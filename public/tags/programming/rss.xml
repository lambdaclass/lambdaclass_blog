<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>LambdaClass Blog - Programming</title>
      <link>https://blog.lambdaclass.com</link>
      <description>Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.</description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://blog.lambdaclass.com/tags/programming/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Thu, 18 Mar 2021 00:00:00 +0000</lastBuildDate>
      <item>
          <title>Modeling complexity with Symbolics.jl and ModelingToolkit.jl</title>
          <pubDate>Thu, 18 Mar 2021 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/modeling-complexity-with-symbolics-jl-and-modelingtoolkit-jl/</link>
          <guid>https://blog.lambdaclass.com/posts/modeling-complexity-with-symbolics-jl-and-modelingtoolkit-jl/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/modeling-complexity-with-symbolics-jl-and-modelingtoolkit-jl/">&lt;h4 id=&quot;an-interview-with-chris-rackauckas&quot;&gt;An interview with Chris Rackauckas&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-sHzrVkhNvHxdiJ2IBmfVPA.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;As we often mentioned on Not a Monad Tutorial, the world is complex, and we increasingly understand where our tools fall short when trying to model this complexity.&lt;&#x2F;p&gt;
&lt;p&gt;We’ve previously interviewed Chris Rackauckas on &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;notamonadtutorial.com&#x2F;scientific-machine-learning-with-julia-the-sciml-ecosystem-b22802951c8a&quot;&gt;SciML&lt;&#x2F;a&gt;; this time he joins us to answer questions regarding new developments in the area of symbolic computation with Julia, its relation to numerical computing, causal vs acausal approaches, how these matters are represented in Symbolics.jl and ModelingToolkit.jl, and how these packages relate to the existing simulation tooling landscape.&lt;&#x2F;p&gt;
&lt;p&gt;These packages compose easily and thus allow modelling larger, more complex systems by reusing parts, as well as helping community efforts. Having these interoperable packages is key to building a modern simulation software stack which can address the aforementioned needs of complex modelling.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h4 id=&quot;what-is-symbolics-jl-what-are-the-motivations-behind-the-creation-of-the-system&quot;&gt;What is Symbolics.jl? What are the motivations behind the creation of the system?&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;JuliaSymbolics&#x2F;Symbolics.jl&quot;&gt;Symbolics.jl&lt;&#x2F;a&gt; is a Computer Algebra System (CAS) in the Julia programming language developed by the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;juliasymbolics.org&#x2F;&quot;&gt;JuliaSymbolics Organization&lt;&#x2F;a&gt;. Think symbolic computation: write down equations and ask the computer to come up with symbolic solutions. It’s a modern CAS, meaning it’s built on a widely used modern programming language (Julia), making use of modern tooling like pervasive parallelism, new algorithms like E-Graphs, integration with machine learning, and more.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-is-modelingtoolkit-jl-what-are-the-needs-it-addresses&quot;&gt;What is ModelingToolkit.jl? What are the needs it addresses?&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;SciML&#x2F;ModelingToolkit.jl&quot;&gt;ModelingToolkit.jl&lt;&#x2F;a&gt; is an equation-based acausal modeling system. It’s similar to systems like Modelica which allow for composing models to quickly generate realistic simulations. This lets you take pre-built models created by other scientists and build complete systems. For example, you can take a high fidelity model of an air conditioning, then make a model of a building, and stick the air conditioning into the building and ask what kind of energy efficiency you get. Then change the building to start designing what’s most efficient.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-does-acausal-modeling-relate-to-tools-like-simulink&quot;&gt;How does acausal modeling relate to tools like Simulink?&lt;&#x2F;h4&gt;
&lt;p&gt;Simulink is a causal modeling tool. You have to know “what causes what” in order to develop the simulation. This can be difficult in our complex world: the heat of the building is read by the thermostat which turns the AC on which then changes the heat of the building. Feedbacks and “algebraic loops” cause issues in causal modeling systems: users have to break the loops or change the model. For this reason &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1909.00484&quot;&gt;experts consider causal modeling as not suitable for complex simulations&lt;&#x2F;a&gt; as they do not compose well. This is the reason acausal tools like Modelica have seen a lot of adoption. Even MATLAB has an acausal tool now, SimScape. Given the advancements in these techniques, I see the next generation of engineers all using acausal tools, with ModelingToolkit.jl being one of the only fully-featured free and open-source acausal systems.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;why-is-symbolic-computation-needed-at-all-what-are-the-advantages-compared-to-numerical-computation-when-is-one-preferred-to-the-other&quot;&gt;Why is symbolic computation needed at all? What are the advantages compared to numerical computation? When is one preferred to the other?&lt;&#x2F;h4&gt;
&lt;p&gt;Are you sure you know enough mathematics to have written the mathematical model in the most numerically-stable form? Even if you know all of the tricks that you’re supposed to do, do you want to do it all by hand? I see the main use of symbolic computation in symbolic-numerics, i.e. using symbolic techniques to improve the models which are then used in numerical methods. For example, in a recent blog post titled &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.stochasticlifestyle.com&#x2F;generalizing-automatic-differentiation-to-automatic-sparsity-uncertainty-stability-and-parallelism&#x2F;&quot;&gt;Generalizing Automatic Differentiation to Automatic Sparsity, Uncertainty, Stability, and Parallelism&lt;&#x2F;a&gt;, I describe how a two-dimensional pendulum simulation without the small angle approximation requires a differential-algebraic equation. The intuitive model of “position moves by velocity, velocity moves by acceleration, and length is constant” is actually an unstable description of the full pendulum. You have to differentiate the “length is constant” equation twice, then substitute other relationships, and then you arrive at an “index-1” DAE which is easier to numerically solve. Even if you know enough of these details to do it, you don’t want to handle that! Symbolic-numeric computation is how we will get to a future where that is all automated.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;wolfram-mathematica-and-sympy-in-python-are-some-of-the-most-popular-choices-when-dealing-with-symbolic-manipulation-nowadays-what-are-the-advantages-symbolics-jl-offers-in-comparison-to-them&quot;&gt;Wolfram Mathematica and SymPy in Python are some of the most popular choices when dealing with symbolic manipulation nowadays. What are the advantages Symbolics.jl offers in comparison to them?&lt;&#x2F;h4&gt;
&lt;p&gt;Symbolics.jl is being built from the ground up for speed, being built from the ground up with parallelism, and last but not least, it’s being built up from a community of tools. There is so much good stuff out there that I think it would be unreasonable to silo one’s organization off and do everything from scratch. Julia has many great initiatives like &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.computeralgebra.de&#x2F;sfb&#x2F;&quot;&gt;OSCAR.jl&lt;&#x2F;a&gt; which are building fast implementations of the mathematical guts. We are using the fact that Julia is a high performance language to both develop high level interfaces and ensure that all of these tools can be used with minimal overhead, mental and computational. So while you might know nothing about Galois fields, there might be a fancy algorithm underneath the hood when you call factorize(x² + 2x + 1) that does it efficiently and scales to large systems.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-is-modelingtoolkit-jl-related-to-symbolics-jl-what-role-does-julia-s-composability-play-in-the-relationship-between-the-two-packages&quot;&gt;How is ModelingToolkit.jl related to Symbolics.jl? What role does Julia’s composability play in the relationship between the two packages?&lt;&#x2F;h4&gt;
&lt;p&gt;Acausal modeling requires symbolic transformations of equations. In that pendulum example, “differentiate the equation twice and substitute”, what kind of tool provides features like differentiation and high performance equation rewriting (i.e. substitution)? A CAS! So ModelingToolkit.jl let’s someone say “this is an ODE”, where it’s equations are described by Symbolics.jl expressions. There are then functions that do things like “transform this to index-1 form” and “analytically discover which equations are redundant and delete them”, and those transformations are written using the tools of Symbolics.jl. This means that as the CAS grows more powerful, so will ModelingToolkit.jl and its environment.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-does-modelingtoolkit-jl-compare-to-other-modeling-frameworks-such-as-modelica-and-simulink-how-easily-would-a-person-with-some-background-on-these-frameworks-adapt-to-modelingtoolkit-jl&quot;&gt;How does ModelingToolkit.jl compare to other modeling frameworks such as Modelica and Simulink? How easily would a person with some background on these frameworks adapt to ModelingToolkit.jl?&lt;&#x2F;h4&gt;
&lt;p&gt;ModelingToolkit.jl’s focus at this point has mainly been on flexibility and speed. In terms of flexibility, ModelingToolkit.jl is the only one which has a hackable compiler that allows composing transformations. All of the symbolic enhancements that are allowed in the Modelica and Simulink compilers are those that are built-in. While it sounds like that’s all that most users need, what that really does is stifle innovation. There are people working in these fields that need a common framework to build off of. Many of these researchers are now in Julia. So for example, could we add an analysis pass that automatically tells you whether you can distinguish between parameters with the data you have? Yes, anyone could extend the ModelingToolkit.jl system with a pass that does that, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;alexeyovchinnikov&#x2F;SIAN-Julia&quot;&gt;and we’re already talking with authors of Julia libraries about doing this&lt;&#x2F;a&gt;. There is so much going on in this space that it’s hard to express, but expect tons of unique transformations to be allowed on your models. “Make a model that doesn’t solve in other systems solve here” is not just a dream.&lt;&#x2F;p&gt;
&lt;p&gt;And then there’s speed. We haven’t done complete and comprehensive benchmarking against all of the systems yet, but we have seen &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2103.05244&quot;&gt;some good performance against some Modelica compilers&lt;&#x2F;a&gt;, indicating we’re doing really well. One NASA user of ModelingToolkit.jl said &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;tQpqsmwlfY0&quot;&gt;a 15 minute Simulink simulation took 50ms in ModelingToolkit.jl&lt;&#x2F;a&gt;. A user mentioned at the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;FMVOUvWNlLE&quot;&gt;AAS&#x2F;AIAA Space Flight Mechanics meeting that every case against a Fortran package with a MATLAB interface, they saw at least an order of magnitude acceleration by moving to ModelingToolkit.jl&lt;&#x2F;a&gt;. In a very early version of ModelingToolkit.jl, we did a demo with Pfizer where we &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;juliacomputing.com&#x2F;case-studies&#x2F;pfizer&#x2F;&quot;&gt;demonstrated a 175x acceleration over their original C-based simulations&lt;&#x2F;a&gt;. Part of all of this is just due to the solvers, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;benchmarks.sciml.ai&#x2F;html&#x2F;MultiLanguage&#x2F;wrapper_packages.html&quot;&gt;which benchmark really well in a cross-language way&lt;&#x2F;a&gt;. Another good chunk is due to the feature sets of the solvers, and ModelingToolkit.jl automatically enabling some of the best choices of combinations. This is explored a bit in a talk at JuliaCon 2020 titled &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=UNkXNZZ3hSw&quot;&gt;Auto-Optimization and Parallelism in DifferentialEquations.jl&lt;&#x2F;a&gt;, which was the video that announced the release of ModelingToolkit.jl as a new front end to the solvers for further improving speed.&lt;&#x2F;p&gt;
&lt;p&gt;That said, we have focused so far on the details. We want the biggest hardest models with the users who have the most demands. These other tools have put a lot more time into user interface, specifically graphical user interfaces (GUIs). Modelica and Simulink has a lot of tooling for drag-and-drop model building. Also, they have libraries of premade libraries. But, this will change very soon. Keep your eyes peeled for some announcements.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-are-the-main-challenges-to-solve-in-order-to-build-such-a-high-level-modeling-library&quot;&gt;What are the main challenges to solve in order to build such a high level modeling library?&lt;&#x2F;h4&gt;
&lt;p&gt;You want to make the modeling language be expressive enough so that every detail you can mathematically specialize on and optimize for is there, but you want to make it easy for users to actually use. Striking that balance is difficult. ModelingToolkit.jl has around 4 years in various prototype forms going through and breaking designs until we found one that could actually solve the problem to the level we hoped.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-is-julia-code-generated-from-symbolic-expressions&quot;&gt;How is Julia code generated from symbolic expressions?&lt;&#x2F;h4&gt;
&lt;p&gt;The symbolic expressions use the same exact pieces under different symantics. For example, square roots in the model are &lt;code&gt;sqrt&lt;&#x2F;code&gt; in Symbolics.jl and &lt;code&gt;sqrt&lt;&#x2F;code&gt; in Julia. This means all we have to do is take the symbolic expression and write it into a Julia function, and invoke the compiler. Invoking compilation on the fly as part of a symbolic language is an interesting challenge though, something that a tool like SymPy skips but which reduces speed by orders of magnitude. The specific details of this are pretty esoteric so I will spare you, but to make this all work we created a new hook into the Julia compiler called &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;SciML&#x2F;RuntimeGeneratedFunctions.jl&quot;&gt;RuntimeGeneratedFunctions&lt;&#x2F;a&gt; which allow for staged compilation that composes with garbage collection, making generated code safe.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-are-the-mechanisms-that-allow-easy-model-composition-with-modelingtoolkit-jl&quot;&gt;What are the mechanisms that allow easy model composition with ModelingToolkit.jl?&lt;&#x2F;h4&gt;
&lt;p&gt;It’s the acasual modeling. You can develop pieces in isolation and just declare relationships between the components. For example, build a model of a power generator, and a model of a computer chip. Now you want to connect these two completely different models? Physically, a wire would connect them and then Kirchoff’s laws would have to hold, i.e. the voltages would have to be equal at the connection points and the currents would sum to zero. So in ModelingToolkit.jl that’s what you’d do: you’d say “current from generator + current to chip = 0” and “voltage at generator = voltage at chip” and bingo you’re there. Now this might produce some redundant variables and equations, but it’s okay: the symbolic preprocessing system eliminates all of this and simplifies down to the most efficient problem to simulate. Then at the end, you can ask “give me the timeseries of the voltage at the chip” and it will give you it, regardless if it was actually in the simulation of not, because it has the information to reconstruct these values.&lt;&#x2F;p&gt;
&lt;p&gt;ModelingToolkit.jl goes one step further. There are &lt;code&gt;connect&lt;&#x2F;code&gt; statements which let you define a common behavior. For example, a &lt;code&gt;Pin&lt;&#x2F;code&gt; in an electrical circuit always has a voltage and a current, and those laws from above are how “connections” physically work. So at this higher level you can say “connect the pin of the generator to the pin of the circuit”, and it generates all of the physical relationships associated with that statement. There are many prebuilt systems which are coming very soon (likely to be completed before these responses are public!), so heat flow, enthalpy relationships, etc. are all simple &lt;code&gt;connect&lt;&#x2F;code&gt; statements. The connection mechanism is extendable too, so if you have a common meaning in say pharmacological models which differs, you can create a new variable type and make connections automatically enforce the laws you want. Connect the heart to the kidney means blood flow is conserved but oxygen is not. This makes it easy to specialize the systems to each of the specific scientific domains.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-are-the-advantages-of-symbolic-preprocessing-of-models&quot;&gt;What are the advantages of symbolic preprocessing of models?&lt;&#x2F;h4&gt;
&lt;p&gt;From the previous statement, note that simple modeling requires the ability to build things in isolation, and then just say “a=b”. Numerically simulating with “a=b” is rather difficult though, numerical methods really want to not solve equations exactly. But if the current at one side is 10^(-8) higher than the other, you lose conservation of current, and you can have the power of the system steadily rising until it spirals out of control and the simulation crashes. This is actually a very common behavior in causal modeling systems. But if you eliminate the variable “b” and replace it with “a” in every place where it shows up, and then if the user asks for “b” you give them “a”, now you’ve symbolically enforced equality and you will never have a numerical issue due to that effect. So not only does it make the set of equations you have to solve smaller (making the solving process faster), but it also makes the numerical solving a lot more stable and more likely to succeed.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;who-are-modelingtoolkit-jl-and-symbolics-jl-aimed-to-beyond-academia-do-you-consider-people-in-the-industry-might-find-them-useful&quot;&gt;Who are ModelingToolkit.jl and Symbolics.jl aimed to? Beyond academia, do you consider people in the industry might find them useful?&lt;&#x2F;h4&gt;
&lt;p&gt;Symbolics.jl is more academically focused. People doing symbolic computer algebra are everywhere, but I tend to see more in academia. Physicists, computational biologists, etc. Because Symbolics.jl allows for translating back and forth between Julia code and symbolic code automatically, we’re seeing computer scientists even adopt it as a nice and easy way to analyze code.&lt;&#x2F;p&gt;
&lt;p&gt;ModelingToolkit.jl on the other hand is more focused towards engineers and modelers. Mechanical engineers, robotics experts, building designers, synthetic biologists. These people are found commonly in both academia and industry. We’re getting a lot of praise from industry users of ModelingToolkit.jl already, so it’s likely to find a nice foothold there.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-many-people-are-involved-in-the-projects-what-are-their-backgrounds&quot;&gt;How many people are involved in the projects? What are their backgrounds?&lt;&#x2F;h4&gt;
&lt;p&gt;There are far too many involved, so I’m just going to give a shoutout to the top few. Yingbo Ma is a super star, still an undergrad but a major contributor to both SciML (the differential equation solvers and ModelingToolkit.jl) and JuliaSymbolics. Shashi Gowda is a PhD student at MIT who has been driving a lot of the internals of JuliaSymbolics. Then there have been many contributions by NASA folks, high schoolers, professors in math departments and biology departments, pandemic researchers, etc. It’s still very early on in the project but the community around it is already great.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-are-the-next-steps-for-each-project&quot;&gt;What are the next steps for each project?&lt;&#x2F;h4&gt;
&lt;p&gt;We’re going to have a major announcement very soon, so stay tuned.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Scientific Machine Learning with Julia: the SciML ecosystem</title>
          <pubDate>Fri, 13 Nov 2020 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/scientific-machine-learning-with-julia-the-sciml-ecosystem/</link>
          <guid>https://blog.lambdaclass.com/posts/scientific-machine-learning-with-julia-the-sciml-ecosystem/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/scientific-machine-learning-with-julia-the-sciml-ecosystem/">&lt;h4 id=&quot;interview-with-chris-rackauckas&quot;&gt;Interview with Chris Rackauckas&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-zBLCNU10DE1qv5PG4wdwbg.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We live in a complex world. For those scientists who dare to immerse themselves in that complexity and generate a deeper understanding of it, it is very common to have to deal with differential equation models that are not possible to solve without the use of a computer.&lt;&#x2F;p&gt;
&lt;p&gt;A lot of time is usually be spent in coding the particular differential equation for each problem. Julia SciML works to create and maintain tools that improve this process— from the creation of a framework that allows to automate the pipeline to create and solve problem-specific differential equations with a high level syntax, to introducing machine learning methods to infer unknown components of the model, and many other functionalities.&lt;&#x2F;p&gt;
&lt;p&gt;We interviewed the creator of SciML, Chris Rackauckas, to get to know a little more about his work.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-bCCWEZqP_ORcTiLPPV13rw.png&quot; alt=&quot;&quot; &#x2F;&gt;Source: DifferentialEquations.jl documentation&lt;&#x2F;p&gt;
&lt;h4 id=&quot;please-tell-us-a-bit-about-yourself-what-is-your-background-what-is-your-current-position&quot;&gt;Please tell us a bit about yourself. What is your background? what is your current position?&lt;&#x2F;h4&gt;
&lt;p&gt;I am an applied mathematics instructor at MIT, the Director of Scientific Research at Pumas-AI, and a senior research analyst at the University of Maryland, School of Pharmacy. My background is numerical differential equations and systems biology, where my PhD was in new methods for efficient solving of stochastic differential equations to model the control of randomness in the developing zebrafish hindbrain.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-is-sciml-why-was-it-born-and-what-s-its-purpose&quot;&gt;What is SciML? Why was it born and what’s its purpose?&lt;&#x2F;h4&gt;
&lt;p&gt;Before the “SciML” organization, there was just DifferentialEquations.jl and JuliaDiffEq, but it grew beyond just a single project. There were methods for symbolically manipulating equations, sparse automatic differentiation, automated model discovery, neural PDE solvers, and even packages in Python and R for using these tools. So the name didn’t fit and we did a reorganization around the central principle: scientific machine learning. Scientific machine learning is a burgeoning field that mixes scientific computing, like differential equation modeling, with machine learning. That is the essence of the organization: many tools for scientific simulation with differential equation solvers, chemical reaction network tools and N-body simulators, but all of them can compose with machine learning.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-YtKzMw7VOvNbOCsOkXwU0A.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;scientific-computing-and-machine-learning-are-often-perceived-as-very-different-areas-what-would-you-say-are-the-strengths-and-weaknesses-of-each-one-and-how-does-sciml-take-advantage-of-them&quot;&gt;Scientific Computing and Machine Learning are often perceived as very different areas. What would you say are the strengths and weaknesses of each one and how does SciML take advantage of them?&lt;&#x2F;h4&gt;
&lt;p&gt;Scientific computing generally requires a lot of prior knowledge about the system. You need to be able to create a “mechanistic model”, which requires knowing the physical laws, the chemicals which react, or other way to mathematically encode each interaction of the system. If you know this, great! Then you have a very predictive model. You might know all of the chemicals which interact but not know the reaction rates, and then 12 data points can turn this into quite a predictive model. So these models are interpretable (since it’s all about the mechanism), data efficient, etc. They are great at extrapolating too: the theory of gravity gives pretty good predictions for what happens on Earth as it does for the solar system as it does for galaxies.&lt;&#x2F;p&gt;
&lt;p&gt;Data-driven modeling, like machine learning, takes a completely opposite approach of being “data first”. You have a non-mechanistic model, and you “train” the model based on the data. This requires a lot of data, but you can do this even when you have no idea what the mechanism is. What’s the mechanism for what movie someone will want to watch next on Netflix given the previous movies they’ve seen? Einstein didn’t have a theory for that! But with big data, you can generate such a model.&lt;&#x2F;p&gt;
&lt;p&gt;Scientific machine learning is about pairing together these two paradigms. Incorporating mechanism into machine learning makes it more interpretable, more data efficient, and better able to predict beyond the training data, all without requiring that you know all of the mechanisms. We’re using this in cases like pharmacometrics, where in the first clinical trial we may not know everything about how the drug works, but we can start with a pretty good guess by using mechanistic models derived for similar drugs, and use the incoming data to train models which transforms the prior model towards the data.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-ihyMT0ujkdDopf3M8eiXUw.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-are-neural-odes-when-is-it-appropiate-to-work-with-one-do-you-fear-that-accuracy-or-interpretability-is-lost-by-introducing-a-neural-network-as-part-of-the-equation-aren-t-there-other-learning-methodologies-suited-for-such-a-thing&quot;&gt;What are Neural ODEs? When is it appropiate to work with one? Do you fear that accuracy or interpretability is lost by introducing a Neural Network as part of the equation? Aren’t there other learning methodologies suited for such a thing?&lt;&#x2F;h4&gt;
&lt;p&gt;Neural Ordinary Differential Equations or Neural ODEs are ordinary differential equations defined by a neural network. Indeed the result is less interpretable than having a mechanistic physical model, but it allows for the model to be learned directly from data. The neural network makes it not just estimating parameters, but estimating functions. As a middle ground, we created the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2001.04385&quot;&gt;universal differential equation&lt;&#x2F;a&gt; which is a partially mechanistic model where the neural networks fill in areas of the model which are unknown or have a lot of uncertainty. In this sense, there is more of a continuum between the data-driven and mechanistic models.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;currently-there-exist-many-differential-equations-solvers-why-do-you-think-this-is-the-case-is-there-a-way-to-choose-the-best-one-for-each-situation&quot;&gt;Currently, there exist many differential equations solvers, why do you think this is the case? Is there a way to choose the best one for each situation?&lt;&#x2F;h4&gt;
&lt;p&gt;We created an automated algorithm chooser in order to mitigate this issue. If you do ‘solve(prob)’ (i.e. don’t specify a solver algorithm), it will choose one for you. Then you can give it hints to go down different branches. As time goes on I think we will keep refining that algorithm and pushing more people towards that.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-are-the-key-reasons-the-sciml-differential-equations-solver-is-so-fast-how-does-it-differ-from-others-how-influential-was-writing-it-in-julia&quot;&gt;What are the key reasons the SciML Differential Equations solver is so fast? How does it differ from others? How influential was writing it in Julia?&lt;&#x2F;h4&gt;
&lt;p&gt;Every differential equation solver specializes on some aspect of the differential equation, giving them different performance aspects. For example, BDF integrators, “the standard” for stiff equations, use values from past steps. This can speed things up if the equation is not too stiff, but if it’s too stiff then you cannot use a high order (known as the Dahlquist barrier) and it slows down. So it’s problem dependent as to how well it can mitigate numerical issues, which means for some problems it’s fast and in others it breaks down. Then, if you have discontinuities which are frequent, like dosing in pharmacometrics simulations, this also requires order reduction and thus makes this particular method slower. DifferentialEquations.jl has about 300 methods when you consider all of the tableaus across not just ODEs but also SDEs, DAEs, and DDEs, and it’s this collection that allows it to be efficient.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;regarding-the-importance-of-being-able-to-quantify-the-uncertainty-of-the-numerical-resolution-when-solving-differential-equations-how-does-sciml-address-this-problem&quot;&gt;Regarding the importance of being able to quantify the uncertainty of the numerical resolution when solving differential equations, how does SciML address this problem?&lt;&#x2F;h4&gt;
&lt;p&gt;DifferentialEquations.jl comes with a module DiffEqUncertainty.jl that gives sampling-based estimates of numerical uncertainty by causing jitter on the order of the error estimates calculated on each step. Normally these error estimates are only used for adapting dt, but this gives a way to get essentially a free estimate of what other possible paths look like. Andrew Stuart’s group at CalTech then has a full publication that describes that this method indeed matches the error distribution of the full solve. So if you run this a hundred times you’ll get a sense of what all of the possible trajectories could’ve been given the error tolerance that you allowed.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-are-multiscalearrays-in-what-ways-do-these-data-structures-help-us-in-simulating-complex-scientific-models&quot;&gt;What are MultiScaleArrays? In what ways do these data structures help us in simulating complex scientific models?&lt;&#x2F;h4&gt;
&lt;p&gt;The differential equation solvers, and actually all of the SciML ecosystem, work on abstract interfaces which allow for the concrete implementation of a type to be radically different from the standard implementation. MultiScaleArrays is a nice example of this where an entire multi-scale model is represented as both a graph structure and an array simultaneously. This lets the user write a model like “for every cell in the lung, do the chemical reactions of a lung cell” to define a model, but have the stiff high-performance ODE solver automatically know how to interact with this object. It’s not even an array: it’s an array of arrays of arrays etc., which acts like an array. In this form it’s very efficient to allows cells to divide and die, and the ODE solver will adapt the size of the solution vector automatically as this changes.&lt;&#x2F;p&gt;
&lt;p&gt;While this was made for the specific case of multi-scale biological modeling in mind, other users have since come up with other great examples. CuArrays are CUDA-accelerated arrays that live on the GPU that can be dropped in as a replacement to the standard array, or ComponentArrays.jl defines an array type similar to MultiScaleArrays which is backed by a real vector, so it’s faster for standard computations but slower for size changes. A lot of new features can thus be directly added and optimized in the ODE solver just by changing the input types!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-crRcFtHznAsYXDCb1uh4oQ.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;are-the-processes-of-solving-differential-equations-and-training-a-neural-networks-similar-how-do-you-put-together-both-frameworks&quot;&gt;Are the processes of solving differential equations and training a Neural Networks similar? How do you put together both frameworks?&lt;&#x2F;h4&gt;
&lt;p&gt;Training a neural network is solving an ODE defined by the gradient of the loss function until zero. Solving that ODE with Euler’s method is gradient descent. So you could use an ODE solver as the algorithm for training a neural ODE, and there is a use case that we’re looking into for that. Differential equations are more ubiquitous than I think most people realize.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;is-gpu-computing-integrated-in-the-sciml-ecosystem-how-important-is-having-this-feature-to-a-scientific-computing-framework-nowadays&quot;&gt;Is GPU computing integrated in the SciML ecosystem? How important is having this feature to a scientific computing framework nowadays?&lt;&#x2F;h4&gt;
&lt;p&gt;Yes, there’s two major ways. If you have “big kernels”, like PDE solving or neural networks integrated into models, you can do those calculations on the GPU. This is what’s known as “within-method parallelism”. One of the more recent techniques that we have is “between-method parallelism”, where we can automatically generate CUDA kernels from your model and parallelize that between trajectories of the solution. This uses some fancy code generation tricks thanks to tools like KernelAbstractions.jl, and allows “small problems” to have an effective way to use GPUs as well.&lt;&#x2F;p&gt;
&lt;p&gt;How important is it? Somewhat. There are problems which are extremely GPU-parallelizable, like neural ODEs and PDEs, and there are problems which are not, like lots of semi-mechanistic universal differential equation models. Whether a GPU is useful is very dependent on what and how you’re trying to model.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;in-which-cases-is-it-worth-to-add-a-bayesian-analysis-to-the-parameter-estimation-for-example-with-the-use-of-diffeqbayes-jl-what-are-its-advantages-over-more-classical-optimization-algorithms&quot;&gt;In which cases is it worth to add a Bayesian analysis to the parameter estimation, for example with the use of DiffEqBayes.jl? What are its advantages over more classical optimization algorithms?&lt;&#x2F;h4&gt;
&lt;p&gt;Bayesian analysis gives you a posterior distribution which has a sense of uncertainty quantification, i.e. it doesn’t just give you the “best parameter” but also a distribution which you can use to understand the error bars on your parameter estimate. In many cases this is a fundamentally interesting quantity. For example, in pharmacology we often want to know the probability that the drug concentration is in the safe zone. To evaluate this, we need a probabilistic fit of the model since only by including the uncertainty of our parameters can we get an accurate guess of the probabilities of the dynamics.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-c8-WwVO2Mlef4QqXP7SvSA.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;are-there-any-relevant-books-or-papers-you-would-like-to-recommend-for-digging-deeper-in-these-topics&quot;&gt;Are there any relevant books or papers you would like to recommend for digging deeper in these topics?&lt;&#x2F;h4&gt;
&lt;p&gt;Books schmooks. You’ll want to go directly to the sources. The only books I really recommend these days are Ernst Hairer’s “Solving Ordinary Differential Equations” I and II tomes: those are a work of art. Also Kloeden’s book on numerical methods for stochastic differential equations. Other than that, dive right into the scientific literature.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-is-next-for-sciml-are-you-currently-working-on-some-other-features-to-add-in-the-near-future&quot;&gt;What is next for SciML? Are you currently working on some other features to add in the near future?&lt;&#x2F;h4&gt;
&lt;p&gt;There’s tons we’re doing! I think a lot of what’s next is the integration of symbolic computing into all of our tools. ModelingToolkit.jl is the centerpiece of that push, and while I gave a talk at JuliaCon 2020 showcasing how it can be used as an automated code optimization tool (and gave a PyData 2020 talk on how you can GPU-accelerate ODE solves in R using it!), it’s so much more than that. It’s sometimes hard to numerically do things correctly, like ensuring positivity in an ODE solution can be difficult. But if you log transformed your model, then by definition your solution will always be positive. Right now this is up to the user, but what if we could automatically change the equations you wrote so that, not only are they more efficient, but they are also mathematically easier to solve and estimate? That’s the scope of ModelingToolkit, and if that interests you then you might want to stay tuned to that and its sister product NeuralSim which is about automated surrogate acceleration for the ModelingToolkit modeling language.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>SymJAX: symbolic CPU&#x2F;GPU&#x2F;TPU programming</title>
          <pubDate>Fri, 18 Sep 2020 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/symjax-symbolic-cpu-gpu-tpu-programming/</link>
          <guid>https://blog.lambdaclass.com/posts/symjax-symbolic-cpu-gpu-tpu-programming/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/symjax-symbolic-cpu-gpu-tpu-programming/">&lt;h4 id=&quot;a-symbolic-programming-version-of-jax&quot;&gt;A symbolic programming version of JAX&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-U2wpT5qoWqSOwrgYtgLJ3w.png&quot; alt=&quot;&quot; &#x2F;&gt;SymJAX’s really cool logo&lt;&#x2F;p&gt;
&lt;p&gt;As we try to have a deeper undestanding of the world we live in, we tend to add more and more complex relationships in the models we use to describe it, so we need to borrow a hand from computers to run them.&lt;&#x2F;p&gt;
&lt;p&gt;Complex relationships often are represented in form of graphs and many learning algorithms require differentiation of some kind.&lt;&#x2F;p&gt;
&lt;p&gt;We also don’t want to lose mathematical interpretability, so having a symbolic programming framework that allows us to represent these complex models in a familiar way, provided with a Theano-like user experience, would be a very interesting tool to have in our pocket.&lt;&#x2F;p&gt;
&lt;p&gt;This is what SymJax has come to offer us. To know more about this, we interviewed &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;RandallBalestriero&quot;&gt;Randall Balestriero&lt;&#x2F;a&gt; the creator and sole contributor of the project so far.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-is-symjax&quot;&gt;What is SymJAX?&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;RandallBalestriero&#x2F;SymJAX&quot;&gt;SymJAX&lt;&#x2F;a&gt; is a &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;networkx.github.io&#x2F;&quot;&gt;NetworkX&lt;&#x2F;a&gt; powered symbolic programming version of &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;jax&quot;&gt;JAX&lt;&#x2F;a&gt; providing a &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Theano&#x2F;Theano&quot;&gt;Theano&lt;&#x2F;a&gt;-like user experience. In addition of simplifying graph input&#x2F;output, variable updates and providing graph utilities such as loading and saving, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;RandallBalestriero&#x2F;SymJAX&quot;&gt;SymJAX&lt;&#x2F;a&gt; features machine learning and deep learning utilities similar to &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Lasagne&#x2F;Lasagne&quot;&gt;Lasagne&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.tensorflow.org&#x2F;&quot;&gt;Tensorflow1&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Illustrative example: Adam optimizer of a dummy loss&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;import symjax&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;import symjax.tensor as T&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;from symjax.nn.optimizers import Adam&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;# we create a persistent variable to be optimized&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;z = T.Variable(3.0, dtype=”float32&amp;quot;, trainable=True)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;# the optimization is about minimizing the following loss&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;loss = T.power(z — 1, 2, name=&amp;#39;loss&amp;#39;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;# this loss is just a node in the graph, nothing is computed yet&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;print(loss) # Op(name=loss, fn=power, shape=(), dtype=float32, scope=&#x2F;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;# we minimize it with Adam, we can omit to assign it to a variable since the&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;# internal updates are automatically collected, 0.1 is the learning rate&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;Adam(loss, 0.1)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;# we create the function (XLA compiled graph) and define what are the inputs&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;# (here none), the outputs and the persistent variable updates (from Adam)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;train = symjax.function(outputs=[loss, z], updates=symjax.get_updates())&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;# for illustrative purposes, we perform 200 steps and reset the graph after 100 steps&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;for i in range(200):&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  if (i + 1) % 100 == 0:&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  # we can use any identifier to select what to reset, (&amp;#39;*&amp;#39; is the default)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  # if we want to only reset the variables create by Adam&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  # (the moving averages etc) one would use (for example)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  # symjax.reset_variables(&#x2F;AdamOptimizer*&amp;#39;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  # in our case let reset all variables&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  symjax.reset_variables()&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  # the output of this function is the current loss and value of z, and when called it also&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  # internally perform the given updates computed from Adam&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  train()&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For additional examples please see: &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;symjax.readthedocs.io&#x2F;en&#x2F;latest&#x2F;auto_examples&#x2F;&quot;&gt;https:&#x2F;&#x2F;symjax.readthedocs.io&#x2F;en&#x2F;latest&#x2F;auto_examples&#x2F;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;the-symjax-documentation-reads-the-number-of-libraries-topping-jax-tensorflow-torch-is-large-and-growing-by-the-day-what-symjax-offers-as-opposed-to-most-is-an-all-in-one-library-with-diverse-functionalities-what-s-the-main-issue-with-having-to-use-multiple-libraries-and-how-does-creating-a-single-library-solve-it&quot;&gt;The SymJAX documentation reads: “The number of libraries topping Jax&#x2F;Tensorflow&#x2F;Torch is large and growing by the day. What SymJAX offers as opposed to most is an all-in-one library with diverse functionalities”. What’s the main issue with having to use multiple libraries and how does creating a single library solve it?&lt;&#x2F;h4&gt;
&lt;p&gt;There is absolutely nothing wrong with having complementary libraries that can be interconnected. In my opinion the current limitation of the mentioned libraries is the absence of inter-compatibility making it difficult to use features from one with another. This is different than say numpy and scipy who both complement each other seamlessly. In SymJAX, the JAX backend allows for any JAX library to be directly imported into SymJAX (as were C&#x2F;CUDA code easily imported into Theano). Second, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.tensorflow.org&#x2F;probability&#x2F;api_docs&#x2F;python&#x2F;tfp&#x2F;experimental&#x2F;substrates&#x2F;jax&quot;&gt;Tensorflow is increasingly leveraging a JAX backend&lt;&#x2F;a&gt;, this development will also allow to easily import those Tensorflow utilities into SymJAX. People interested in using a standard JAX&#x2F;Tensorflow library while benefiting from SymJAX utilities can do so easily. The other way around, any computational graph designed in SymJAX with SymJAX utilities can also be translated back into pure JAX, allowing JAX libraries to benefit from SymJAX. The target end result being that each library newly developed tool would directly benefit all cross-library users.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;the-documentation-states-that-one-of-the-goals-of-symjax-is-to-optimize-processes-how-does-the-library-enable-that-optimization-how-does-it-compare-to-other-technologies&quot;&gt;The documentation states that one of the goals of SymJAX is to optimize processes. How does the library enable that optimization? How does it compare to other technologies?&lt;&#x2F;h4&gt;
&lt;p&gt;There are really two levels of (computational) optimization in SymJAX. First, SymJAX allows to define a computational graph which can be viewed as a computational roadmap based on inputs and operations producing some desired outputs (possibly involving some persistent graph variable updates). This user-defined computational roadmap is obtained without performing any actual computation yet. It is then compiled with XLA producing a sequence of computation kernels generated specifically for the given graph. This step allows to potentially merge multiple low-level operations into a single kernel and demonstrated performances gains for example &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.tensorflow.org&#x2F;xla&#x2F;&quot;&gt;in Tensorflow&lt;&#x2F;a&gt;. This step alone provides SymJAX with similar performances to Jax and XLA-Tensorflow, ceteris paribus.&lt;&#x2F;p&gt;
&lt;p&gt;The second and most important feature of SymJAX is its graph canonicalization. This feature is the same as the one that was employed in the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.deeplearning.net&#x2F;software&#x2F;theano&#x2F;&quot;&gt;now-discontinued Theano library&lt;&#x2F;a&gt;. Graph canonicalization allows generic graph optimization such as replacing the following subgraph:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;log( exp(x) * exp(4 + x) )&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;by the much simpler, yet equivalent subgraph:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;2 * x + 4&amp;#39;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This type of graph simplification can be done on much more complex parts of the graphs such as replacing the sum of two Gaussian distributions by a single Gaussian with different mean and covariance; hence greatly reducing the computational burden of random sampling. This reduced graph is then XLA compiled further optimizing low-level operations. This feature allows for much broader optimization than present in XLA and in most current libraries as it requires &lt;em&gt;a priori&lt;&#x2F;em&gt; knowledge of the computational graph.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;does-symjax-support-all-state-of-art-neural-network-architectures&quot;&gt;Does SymJAX support all state-of-art neural network architectures?&lt;&#x2F;h4&gt;
&lt;p&gt;SymJAX provides out-of-the-box some basic neural network layers implementations. The number of implemented layers increases at each release but can surely not follow the exponentially growing number of neural network flavours being designed by the deep learning community. However, the core of SymJAX provides all the standard operations featuring almost all numpy and scipy functions among many more. This allows anyone to implement their own layers and neural networks (as well as losses or any other bit of a deep learning pipelines) ensuring that any needed architecture can be implemented on-the-go.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-were-the-biggest-challenges-in-allowing-a-broad-hardware-support-gpus-tpus&quot;&gt;What were the biggest challenges in allowing a broad hardware support (GPUs, TPUs)?&lt;&#x2F;h4&gt;
&lt;p&gt;One of the crucial benefit of leveraging JAX as the backend XLA interface is the ability to benefit from their latest hardware support. There was thus nothing additional needed in SymJAX to enable such broad support.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;is-there-support-for-dynamic-computation-graphs-a-la-pytorch-if-not-are-there-any-plans-for-it&quot;&gt;Is there support for dynamic computation graphs à la Pytorch? If not, are there any plans for it?&lt;&#x2F;h4&gt;
&lt;p&gt;The computational graph in itself can be evaluated without XLA compilation allowing one to define a graph, evaluate it, and keep building it while evaluating it again (similar to session.run from Tensorflow 1). This would not give optimal performances but can be useful in some cases and would allow very general dynamic computation graphs. For best performances however the graph needs to be compiled effectively freezing its structure. However, we do allow for one dynamic aspect to persist after compilation: dynamic leading axis length (such as variable batch size). This allows, if needed, to have a compiled graph with the possibility to feed shape varying inputs. For now this is only possible on the leading axis but more general dynamic computation graphs will be considered in the future by allowing only the parts of the graph that will not vary dynamically to be compiled separately allowing for high-performance “hybrid” graphs to be evaluated.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;symjax-pays-homage-to-theano-in-many-aspects-what-s-different-from-theano-and-why-not-improve-theano-to-bring-it-up-to-date-instead-of-creating-a-new-library-from-scratch&quot;&gt;SymJAX pays homage to Theano in many aspects. What’s different from Theano and why not improve Theano to bring it up to date instead of creating a new library from scratch?&lt;&#x2F;h4&gt;
&lt;p&gt;The minimalist version of SymJAX and Theano both make the user define a graph, compile it and then evaluate it. However, SymJAX offers various user-friendly features that greatly simplify its use as opposed to Theano such as&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;much simpler graph construction and monitoring with explicit shape and dtype of each node&lt;&#x2F;li&gt;
&lt;li&gt;lazy (non compiled) partial graph evaluation (a la session.run or pytorch)&lt;&#x2F;li&gt;
&lt;li&gt;the concept of scopes (a la Tensorflow) and node&#x2F;variable&#x2F;placeholder fetching based on their names and scopes&lt;&#x2F;li&gt;
&lt;li&gt;utilities to save, load and reset variables and graphs&lt;&#x2F;li&gt;
&lt;li&gt;various graph analysis tools from networkX that can be used to study the computational graph and provide in-depth structural analysis&lt;&#x2F;li&gt;
&lt;li&gt;side utilities to allow deep learning pipelines to be built&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The option of updating Theano was considered but would have forced to not only implement the above features (requiring some important changes in the Theano design) but would also force us to consistently keep working on the XLA interface&#x2F;compilation and on the support for the latest hardwares including not only new GPU releases but also novel hardwares like TPUs. By instead building upon Jax XLA interface, we directly benefit from the latest XLA support allowing us to focus instead on additional features and graph related utilities.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;theano-is-powerful-but-in-terms-of-popularity-it-lost-the-battle-to-the-more-high-level-tensorflow-what-is-the-user-you-have-in-mind-for-symjax-how-is-it-better-than-the-other-options&quot;&gt;Theano is powerful but in terms of popularity it lost the battle to the more high-level TensorFlow. What is the user you have in mind for SymJAX? How is it better than the other options?&lt;&#x2F;h4&gt;
&lt;p&gt;As per the above points, I believe that Theano lost attraction due to its lack of user-friendly features making it too tedious to build a working pipeline as opposed to Tensorflow (or PyTorch) which allowed for a more flexible set-up thanks to features like automatically gathering trainable variables to be differentiated, automatically resetting all the graph variables without keeping track of them explicitly and so on. In addition Theano suffered from a very slow compilation step and often difficult GPU-support installation.&lt;&#x2F;p&gt;
&lt;p&gt;However, none denies the benefits of Theano in term of its graph simplification abilities and its design. By combining the best of both libraries and incorporating additional JAX abilities, you obtain SymJAX which I believe will attract users from any background. In fact, one of the main effort in SymJAX is to make the symbolic programming paradigm extremely user-friendly allowing anyone to employ it with minimum burden while enjoying all the induced benefits.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-many-people-are-behind-this-project-are-you-looking-for-contributors&quot;&gt;How many people are behind this project? Are you looking for contributors?&lt;&#x2F;h4&gt;
&lt;p&gt;I have been the sole contributor of this project up until recently when a geophysicist colleague stepped in. There has also been a rising interest from the PyMC developer team to see how fit would be SymJAX to replace the Theano backend they employed. This ongoing discussion also allowed for additional contributions to SymJAX. All contributions are welcome and anyone interested in getting involved more actively with this project should feel free to contact me!&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-is-symjax-s-current-status-and-plans-for-the-near-future-how-close-is-the-project-to-its-first-stable-release&quot;&gt;What is SymJAX’s current status and plans for the near future? How close is the project to its first stable release?&lt;&#x2F;h4&gt;
&lt;p&gt;SymJAX has been unstable in its early months as many graph libraries were tested and various new features required drastic changes in the entire pipeline. We now are at a much more stable point where only a few remaining features are being tested and replaced (for example the graph visualization tool, the online data saving and visualization, and the graph canonicalization). But those changes are very localized in the library and do not break any other part of the library when changed. In its current state, SymJAX can already be used actively. In addition, the main remaining task is around documentation, and providing a rich Gallery of examples detailing all the functionalities of SymJAX. Once those changes are done, the first stable release will be published; a rough estimate would put us a few weeks away from it.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;for-our-readers-who-might-want-to-know-more-what-papers-articles-and-courses-do-you-recommend-doing-to-learn-about-symbolic-programming-and-deep-learning&quot;&gt;For our readers who might want to know more, what papers, articles and courses do you recommend doing to learn about symbolic programming and deep learning?&lt;&#x2F;h4&gt;
&lt;p&gt;For a jump-start in deep learning, the Deep Learning book (&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.deeplearningbook.org&#x2F;&quot;&gt;https:&#x2F;&#x2F;www.deeplearningbook.org&#x2F;&lt;&#x2F;a&gt;) is complete and offers all the tricks of the trade for practitioners. For more in-depth understanding of deep networks there are way too many articles to cite so I will only refer to a few iconic ones in two topics that I particularly enjoy:&lt;&#x2F;p&gt;
&lt;p&gt;Orbits, Groups, Invariants and Manifolds&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;yann.lecun.com&#x2F;exdb&#x2F;publis&#x2F;pdf&#x2F;simard-98.pdf&quot;&gt;http:&#x2F;&#x2F;yann.lecun.com&#x2F;exdb&#x2F;publis&#x2F;pdf&#x2F;simard-98.pdf&lt;&#x2F;a&gt; (Transformation Invariance in Pattern Recognition, Tangent Distance and Tangent Propagation)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;1602.07576.pdf&quot;&gt;https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;1602.07576.pdf&lt;&#x2F;a&gt; (Group Equivariant Convolutional Networks)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;1203.1513.pdf&quot;&gt;https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;1203.1513.pdf&lt;&#x2F;a&gt; (Invariant Scattering Convolution Networks)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;ai.stanford.edu&#x2F;~ang&#x2F;papers&#x2F;nips09-MeasuringInvariancesDeepNetworks.pdf&quot;&gt;https:&#x2F;&#x2F;ai.stanford.edu&#x2F;~ang&#x2F;papers&#x2F;nips09-MeasuringInvariancesDeepNetworks.pdf&lt;&#x2F;a&gt; (Measuring Invariances in Deep Networks)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Deep Generative Networks&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;1701.00160.pdf&quot;&gt;https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;1701.00160.pdf&lt;&#x2F;a&gt; (NIPS 2016 Tutorial:Generative Adversarial Networks)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;pure.uva.nl&#x2F;ws&#x2F;files&#x2F;17891313&#x2F;Thesis.pdf&quot;&gt;https:&#x2F;&#x2F;pure.uva.nl&#x2F;ws&#x2F;files&#x2F;17891313&#x2F;Thesis.pdf&lt;&#x2F;a&gt; (Variational inference &amp;amp; deep learning)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;blog.evjang.com&#x2F;2018&#x2F;01&#x2F;nf1.html&quot;&gt;https:&#x2F;&#x2F;blog.evjang.com&#x2F;2018&#x2F;01&#x2F;nf1.html&lt;&#x2F;a&gt; (Normalizing Flows Tutorial)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
      </item>
      <item>
          <title>For the first time, enjoy all the talks of BuzzConf 2020 online and free of charge!</title>
          <pubDate>Sun, 26 Jul 2020 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/for-the-first-time-enjoy-all-the-talks-of-buzzconf-2020-online-and-free-of-charge/</link>
          <guid>https://blog.lambdaclass.com/posts/for-the-first-time-enjoy-all-the-talks-of-buzzconf-2020-online-and-free-of-charge/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/for-the-first-time-enjoy-all-the-talks-of-buzzconf-2020-online-and-free-of-charge/">&lt;h3 id=&quot;come-see-buzzconf-2020-a-software-and-data-science-conference-open-and-online-for-one-and-for-all&quot;&gt;Come see BuzzConf 2020, a software and data science conference, open and online for one and for all!&lt;&#x2F;h3&gt;
&lt;p&gt;The third edition of BuzzConf will be held freely online via Zoom and Youtube live. We’re very proud of our speaker lineup, which covers a wide range of topics that expand the frontiers of our technical knowledge.&lt;&#x2F;p&gt;
&lt;p&gt;We will dive into the topics of functional programming, Julia, Python, data science, machine learning, observability, operating systems and more! We believe Functional Programming and Data Science are two of the most interesting topics in the field which will open many opportunities in the near future, and we want to bring the latest developments in these areas to the global community.&lt;&#x2F;p&gt;
&lt;p&gt;This conference is the result of a combined effort of private and public sectors from Argentina, which aspires to help the development of our country’s technical capabilities while spreading and sharing knowledge with the world.&lt;&#x2F;p&gt;
&lt;p&gt;We thank the generosity of the speakers who agreed to donate their time and we hope you enjoy their talks as much as we will.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-LzNJkTEcILfT_6U8t2baDg.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;mon-july-27-2pm-pdt-6pm-gmt-3-9pm-utc&quot;&gt;Mon, July 27–2pm PDT &#x2F; 6pm GMT-3 &#x2F; 9pm UTC&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;charity-majors-what-got-you-here-won-t-get-you-there-how-your-team-can-become-a-high-performing-team-by-embracing-observability&quot;&gt;Charity Majors — “What got you here won’t get you there: How your team can become a high-performing team by embracing observability”&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;em&gt;To Be Announced&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on Zoom:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;92898927496&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;92898927496&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on YouTube:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;QK6zEFdvXYw&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;youtu.be&#x2F;QK6zEFdvXYw&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-fTWA2R7HUM90oPA7.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;mon-july-27-3pm-pdt-7pm-gmt-3-10pm-utc&quot;&gt;Mon, July 27–3pm PDT &#x2F; 7pm GMT-3 &#x2F; 10pm UTC&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;maria-vanina-martinez-symbolic-reasoning-to-model-sentiment-and-knowledge-diffusion-in-social-networks&quot;&gt;María Vanina Martinez: “Symbolic Reasoning to model Sentiment and Knowledge Diffusion in Social Networks”&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;em&gt;Social media platforms, taken in conjunction, can be seen as complex networks; in this context, understanding how agents react to sentiments expressed by their connections is of great interest. We show how Network Knowledge Bases help represent the integration of multiple social networks, and explore how information flow can be handled via belief revision operators for local (agent-specific) knowledge bases. We report on preliminary experiments on Twitter data showing that different agent types react differently to the same information — this is a first step toward developing symbolic tools to predict how agents behave asinformation flows in their social environment.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on Zoom:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;92898927496&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;92898927496&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on YouTube:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;QK6zEFdvXYw&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;youtu.be&#x2F;QK6zEFdvXYw&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-Urum4vQ0RP0TZub3.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tue-july-28-2pm-pdt-6pm-gmt-3-9pm-utc&quot;&gt;Tue, July 28–2pm PDT &#x2F; 6pm GMT-3 &#x2F; 9pm UTC&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;will-kurt-the-limits-of-probability&quot;&gt;Will Kurt: “The Limits of Probability”&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;em&gt;Probability is an increasingly ubiquitous part of our daily lives, especially as developers, researchers and data scientists. It is easy to mistakenly think this powerful tool is all we need to understand our world. This talk will show how our current environment of global pandemic, political unrest and economic uncertainty forces us to face the limits of probability as a tool for reasoning and understanding. This talk will cover both practical examples of the limitations of probability as well as dive into the philosophical roots of these limitations to show that it cannot be our only means to engage with our world.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on Zoom:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;97859783809&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;97859783809&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on YouTube:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;N75ebGWz2o4&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;youtu.be&#x2F;N75ebGWz2o4&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-a3kX6m-ky8tQK27S.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tue-july-28-3pm-pdt-7pm-gmt-3-10pm-utc&quot;&gt;Tue, July 28–3pm PDT &#x2F; 7pm GMT-3 &#x2F; 10pm UTC&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;lightning-talks&quot;&gt;Lightning Talks&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;Juan Pablo Lorenzo:&lt;&#x2F;strong&gt; “Delete your code: in search of a minimalist approach to software development”&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Gajendra Deshpande:&lt;&#x2F;strong&gt; “Computation Techniques for Encrypted Data using Python”&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on Zoom:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;97859783809&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;97859783809&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on YouTube:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;N75ebGWz2o4&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;youtu.be&#x2F;N75ebGWz2o4&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wed-july-29-2pm-pdt-6pm-gmt-3-9pm-utc&quot;&gt;Wed, July 29–2pm PDT &#x2F; 6pm GMT-3 &#x2F; 9pm UTC&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;aditya-siram-what-fp-can-learn-from-static-introspection&quot;&gt;Aditya Siram: “What FP Can Learn From Static Introspection”&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;em&gt;What if compile time and type level programming in functional programming languages were easy, something you reach for without even thinking about it? What if you could debug type errors with a simple compile time print statement? Write highly flexible systems by being able to introspect into types at compile time? Pre-calculate large portions of your programs for great efficiency? Typed functional programming is a great and fun way to write resilient software, and as type systems have become more and more expressive in recent years, we are able to program sophisticated and useful properties at the type level for even better compile time safety. Just one problem: It is very difficult, requires advanced knowledge of the type system, the syntax is convoluted, the error messages are impenetrable, and it is nearly impossible to debug. This talk will dive into why we should steal static introspection from languages like Nim, and D, state-of-the-art imperative programming languages which can solve all these issues, make type systems much more approachable without losing any expressive power, and offer new design possibilities for functional programs.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on Zoom:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;95139644343&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;95139644343&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on YouTube:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;yGq0KnkqOgI&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;youtu.be&#x2F;yGq0KnkqOgI&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-Koxyxq-wrBx9iGfe.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wed-july-29-3pm-pdt-7pm-gmt-3-10pm-utc&quot;&gt;Wed, July 29–3pm PDT &#x2F; 7pm GMT-3 &#x2F; 10pm UTC&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;sergio-chouhy-deeploying-deep-q-learning-with-pytorch&quot;&gt;Sergio Chouhy: “Deeploying Deep Q Learning with Pytorch”&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;em&gt;Many things are being said about Deep Reinforcement Learning, but sometimes it is really hard to know where to start. In this talk, I will tell you all about the basis of this algorithms and show you how to deploy Deep Q Learning from scratch using Pytorch. I will be also talking about industrial applications for this technology.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on Zoom:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;95139644343&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;95139644343&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on YouTube:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;yGq0KnkqOgI&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;youtu.be&#x2F;yGq0KnkqOgI&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-82lbeMCqONPXiKq1.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;thu-july-30-2pm-pdt-6pm-gmt-3-9pm-utc&quot;&gt;Thu, July 30–2pm PDT &#x2F; 6pm GMT-3 &#x2F; 9pm UTC&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;viral-b-shah-julia-a-language-for-ai-and-much-more&quot;&gt;Viral B. Shah: “Julia — A language for AI and much more”&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;em&gt;The Julia language is now used by over half a million programmers worldwide. Created to solve the two language problem, Julia is demonstrating performance gains of 50x-100x for many data science tasks such as data loading, data processing, graph processing, machine learning and scaling. Robust support for modern deep learning and the ability to do differentiable programming in an intuitive way is quickly leading to Julia becoming the language of choice for AI workloads. My talk will discuss the origin story of Julia, the formation of the Julia community, and all the amazing things happening in the world of Julia.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on Zoom:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;94906592252&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;94906592252&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on YouTube:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;fbKHLdoG7wA&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;youtu.be&#x2F;fbKHLdoG7wA&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0--gyZtKfGpWBIxRoz.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;thu-july-30-3pm-pdt-7pm-gmt-3-10pm-utc&quot;&gt;Thu, July 30–3pm PDT &#x2F; 7pm GMT-3 &#x2F; 10pm UTC&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;chris-rackauckas-sciml-how-language-is-changing-scientific-research&quot;&gt;Chris Rackauckas: “SciML: How Language is Changing Scientific Research”&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;em&gt;Scientific machine learning is a burgeoning field and its taking off in Julia. Why? The purpose of this talk is to dive into that question: how has language accelerated the development of Julia’s SciML ecosystem? The core is composibility through multiple dispatch. We will showcase how this feature is not only what makes standard Julia code as fast as C or Fortran, but also allows Julia to eschew the traditional idea of “machine learning frameworks” and instead have machine learning directly work on the standard functions and libraries of the whole Julia programming language. This language-wide differentiable programming then builds a foundation where existing climate models, helicopter simulations, and efficiency simulators for battery-powered airplanes can be instantly composed with new tools for machine learning, and we will demonstrate how this has changed the way that researchers in Julia do science.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on Zoom:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;94906592252&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;94906592252&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on YouTube:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;fbKHLdoG7wA&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;youtu.be&#x2F;fbKHLdoG7wA&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-2EbV5-0r03R6aPYH.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fri-july-31-2pm-pdt-6pm-gmt-3-9pm-utc&quot;&gt;Fri, July 31–2pm PDT &#x2F; 6pm GMT-3 &#x2F; 9pm UTC&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;pablo-fernandez-machine-learning-in-the-real-world&quot;&gt;Pablo Fernandez: “Machine Learning in The Real World”&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;em&gt;A tour of the last 3 years of my career where I’ve productionized 3 different machine learning projects on kind-of-a-big-company (Despegar). Some of the challenges faced, not only technical but also from a product standpoint, some of the pedagogical work needed to convince others of letting important decisions be made by a machine. Hopefully insights that help you bring your own models to production.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on Zoom:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;92628004626&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;92628004626&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on YouTube:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;t-ebpSHyBEE&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;youtu.be&#x2F;t-ebpSHyBEE&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-7y4gqQ8d8_6veW_j.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fri-july-31-3pm-pdt-7pm-gmt-3-10pm-utc&quot;&gt;Fri, July 31–3pm PDT &#x2F; 7pm GMT-3 &#x2F; 10pm UTC&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;peter-alvaro-what-not-where-why-a-blue-sky-os&quot;&gt;Peter Alvaro: “What not where: why a blue sky OS?”&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;em&gt;A world of distributed, persistent memory is on its way. Our programming models traditionally operate on short-lived data representations tied to ephemeral contexts such as processes or computers. In the limit, however, data lifetime is infinite compared to these transient actors. We discuss the implications for programming models raised by a world of large and potentially persistent distributed memories, including the need for explicit, context-free, invariant data references. We present a novel operating system that uses wisdom from both storage and distributed systems to center the programming model around data as the primary citizen, and reflect on the transformative potential of this change for infrastructure and applications of the future.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on Zoom:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;92628004626&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;92628004626&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on YouTube:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;t-ebpSHyBEE&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;youtu.be&#x2F;t-ebpSHyBEE&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-MOD81ymGRUNUrv7m.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We hope to see you there! There will be time for Q&amp;amp;A with the speakers. &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.eventbrite.com.ar&#x2F;e&#x2F;buzzconf-2020-tickets-111836742708&quot;&gt;Register now&lt;&#x2F;a&gt;!&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>NuShell: the shell where traditional Unix meets  modern development, written in Rust</title>
          <pubDate>Thu, 14 May 2020 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/nushell-the-shell-where-traditional-unix-meets-modern-development-written-in-rust/</link>
          <guid>https://blog.lambdaclass.com/posts/nushell-the-shell-where-traditional-unix-meets-modern-development-written-in-rust/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/nushell-the-shell-where-traditional-unix-meets-modern-development-written-in-rust/">&lt;h4 id=&quot;we-interviewed-its-creators&quot;&gt;We interviewed its creators&lt;&#x2F;h4&gt;
&lt;p&gt;Shells have been around forever and, for better or for worse, haven’t changed much since their inception. Until &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.nushell.sh&#x2F;&quot;&gt;NuShell&lt;&#x2F;a&gt; appeared to reinvent shells and defy our muscle memory. It brought some big changes, which include rethinking how pipelines work, structured input&#x2F;output, and plugins.&lt;&#x2F;p&gt;
&lt;p&gt;We wanted to learn more about NuShell so we interviewed both of its creators: &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;jntrnr&quot;&gt;Jonathan Turner&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;wycats&quot;&gt;Yehuda Katz&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h4 id=&quot;why-create-nushell-is-it-me-or-does-it-have-a-next-level-awk-vibe&quot;&gt;&lt;strong&gt;Why create NuShell? Is it me or does it have a next-level AWK vibe?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;Jonathan Turner&lt;&#x2F;strong&gt; : Sometimes the simplest ideas are the ones that hook you the most :). When Yehuda and I first started discussing how shells could be improved, we settled on the idea of using structured data rather than just text between applications (for example stdin&#x2F;stdout). He had just been experimenting with PowerShell and saw how adding some structure to the data opened up a lot of possibilities.&lt;&#x2F;p&gt;
&lt;p&gt;The basic idea is pretty simple: Nu opens everything into a table you can work with. Files, streams, commands like ls and ps all output this one table format. Then you have a set of commands that work with these tables, to help you get the data you want, change it, view it, etc.&lt;&#x2F;p&gt;
&lt;p&gt;Funny that you mention “awk”. In a way, Nu is a way of saying “what if we didn’t need tools like awk so often?” Since you’re working with structured data, as we add more support for file types, it’s less often you need to reach for “awk”, “jq”, “grep”, and the array of other tools to open and work with common file types.&lt;&#x2F;p&gt;
&lt;p&gt;In a way, it’s taking the original spirit of Unix — where you use pipelines to combine a set of tools — and imagining how that original spirit would work today, with what we know about programming languages and tools. And, being crossplatform, it’s nice to learn this approach and then be able to easily switch operating systems and use the same techniques.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-u77ccTVL0VJ7Cw2xT_7puA.png&quot; alt=&quot;&quot; &#x2F;&gt;NuShell screen capture&lt;&#x2F;p&gt;
&lt;h4 id=&quot;why-use-rust-how-much-experience-did-you-have-beforehand&quot;&gt;&lt;strong&gt;Why use Rust? How much experience did you have beforehand?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;Jonathan&lt;&#x2F;strong&gt; : Yehuda and I have been writing Rust for at least 4 years. He was one of the first people to deploy Rust into production, long before it hit 1.0.&lt;&#x2F;p&gt;
&lt;p&gt;Rust also just made sense. It naturally is crossplatform, it’s easy to optimize, it’s easy to harden against memory and threading issues, and after the initial learning curve it’s also quite a lot of fun to write. When you’re doing things in your free time, having something you’re looking forward to hacking on after work makes it a lot easier to do so day after day.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;did-using-rust-present-a-challenge-in-some-aspect&quot;&gt;&lt;strong&gt;Did using Rust present a challenge in some aspect?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;Yehuda Katz&lt;&#x2F;strong&gt; : Quite the opposite! Rust and its ecosystem has two properties that are a really good fit for what we’re trying to do:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Cross-platform: There is a version of almost every basic crate that works on Windows, macOS, and Linux.&lt;&#x2F;li&gt;
&lt;li&gt;Rigorous: Rust doesn’t really have exceptions. Instead, Rust’s library ecosystem surfaces edge-cases as Results. When writing something like a shell, this saved us from all kinds of problems as we evolved.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Rust also has a great package manager (Cargo), which means that gluing together fast, cross-platform, and rigorous packages from the ecosystem is really easy.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-do-you-go-about-making-software-cross-platform-in-rust-is-it-as-much-work-as-one-would-think&quot;&gt;&lt;strong&gt;How do you go about making software cross-platform in Rust? Is it as much work as one would think?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;Yehuda&lt;&#x2F;strong&gt; : Not really. What you do is look for crates on &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;&quot;&gt;crates.io&lt;&#x2F;a&gt; that support Windows. Most of the time, crates that claim to care about Windows support Windows, as well as other platforms.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Jonathan&lt;&#x2F;strong&gt; : Rust is definitely my preferred tool for crossplatform development these days. Like Yehuda mentions, most crates work across Windows, macOS, and Linux. We’ll also likely explore making Nu work in the browser in the future, which would mean WASM support, and Rust is probably the best language for that as well.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;why-did-you-decide-to-ignore-posix-compliance&quot;&gt;&lt;strong&gt;Why did you decide to ignore POSIX-compliance?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;Yehuda&lt;&#x2F;strong&gt; : This question is a little bit misleading in my opinion. When people say that a shell is “POSIX compliant”, they’re talking about a tiny subset of the syntax and features that people come to rely on in a shell. If you want to run a POSIX shell script in nu, you can just run it with bash or sh. On the other hand, trying to make our syntax perfectly compliant with the POSIX standard would introduce all kinds of weird decades-old cruft and constrain the ergonomics of our syntax.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Jonathan&lt;&#x2F;strong&gt; : When people ask for POSIX-compliance, I think different people mean different things. Generally, I think they mean “don’t break my muscle memory”. That’s fair, it’s annoying to unlearn habits. That said, what it means to be compatible has changed a lot from the original ideas. I saw this tweet the other day which I thought sums it up pretty well:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-gQH1jV4nzbs_WurExrLnEw.png&quot; alt=&quot;&quot; &#x2F;&gt;Source: &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;danluu&#x2F;status&#x2F;1234814736144797697&quot;&gt;Dan Luu&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;where-does-nushell-stand-compared-to-others-like-zsh-or-fish-as-of-today-can-i-set-it-as-my-default-shell&quot;&gt;&lt;strong&gt;Where does NuShell stand compared to others like zsh or fish? As of today, can I set it as my default shell?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;Jonathan&lt;&#x2F;strong&gt; : we’re quickly approaching when you’ll be able to use Nu as your default shell. In fact, some of Nu’s users already use it as their daily driver happily. In 0.13, we added the ability to create your own aliases, which dramatically improves how well Nu works as a shell, as it’s now easy to configure your own set of shortcuts for things you do regularly.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-did-you-decide-on-that-sort-of-hard-division-of-commands-streamers-filters-and-consumers-i-didn-t-see-any-official-names-for-these-concepts-but-i-think-this-conveys-the-idea&quot;&gt;&lt;strong&gt;How did you decide on that sort of “hard” division of commands: streamers, filters, and consumers?&lt;em&gt;I didn’t see any official names for these concepts, but I think this conveys the idea&lt;&#x2F;em&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;Yehuda&lt;&#x2F;strong&gt; : The distinctions arose organically, and make sense. When you think about streams, there are really three parts: the first part, the middle parts, and the last part. The last part is the most special one, because it takes a stream of data and turns it into something you can see, which requires looking at the inbound stream. For example, the outputted table needs to look at some rows to see what headers to use.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;why-make-a-plugin-system-what-are-the-benefits-of-using-json-rpc-for-internal-communication&quot;&gt;&lt;strong&gt;Why make a plugin system? What are the benefits of using JSON-RPC for internal communication?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;Yehuda&lt;&#x2F;strong&gt; : The main difference between plugins and builtins is that built-in commands have access to the shell internals. We wanted to build as many commands as possible on top of a more well-defined interface. This also meant that you could build custom commands in Python, Ruby or JavaScript pretty early in the project.&lt;&#x2F;p&gt;
&lt;p&gt;The benefit of JSON-RPC is that it’s pretty easy to work with JSON-RPC in virtually all programming languages, so it’s possible to build a plugin in any language without major assistance from the nushell team.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;why-would-i-choose-to-make-a-plugin-why-not-just-make-a-binary-that-works-on-all-shells-and-let-the-parsing-of-my-output-to-users-of-nushell&quot;&gt;&lt;strong&gt;Why would I choose to make a plugin? Why not just make a binary that works on all shells and let the parsing of my output to users of NuShell?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;Yehuda&lt;&#x2F;strong&gt; : The major benefit of building a plugin is the ability to work directly with structured data. This means that all of the “good stuff” that nushell gives you out of the box, like sorting and filtering, will just work without your user having to parse string output into a new structured format.&lt;&#x2F;p&gt;
&lt;p&gt;The Nushell plugin API also allows you to specify the types of your arguments, which will give you error messages, syntax highlighting and some amount of context-sensitive completion out of the box. The more information you give Nushell, the more we can give Nushell users useful information as they interact with your command.&lt;&#x2F;p&gt;
&lt;p&gt;Also, the Nushell plugin API is also built for streaming out of the box, so if you use the plugin API in the normal way, you can idiomatically interact with streams of structured data in a way that will scale up to huge amounts of input without “breaking the stream”.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-s-next-for-nushell&quot;&gt;&lt;strong&gt;What’s next for NuShell?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;Jonathan&lt;&#x2F;strong&gt; : Nu, as both a shell and a language, is still very much young and growing. We’re planning on adding functions, a rich auto-completion system, better Jupyter integration for working with data, per-directory environments, and much more. In short, we want it to grow to be the best tool for working with your system, files, and data we can make.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Weld: accelerating numpy, scikit and pandas as much as 100x with Rust and LLVM</title>
          <pubDate>Sat, 21 Sep 2019 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/weld-accelerating-numpy-scikit-and-pandas-as-much-as-100x-with-rust-and-llvm/</link>
          <guid>https://blog.lambdaclass.com/posts/weld-accelerating-numpy-scikit-and-pandas-as-much-as-100x-with-rust-and-llvm/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/weld-accelerating-numpy-scikit-and-pandas-as-much-as-100x-with-rust-and-llvm/">&lt;h3 id=&quot;interview-with-weld-s-main-contributor-accelerating-numpy-scikit-and-pandas-as-much-as-100x-with-rust-and-llvm&quot;&gt;Interview with Weld’s main contributor: accelerating numpy, scikit and pandas as much as 100x with Rust and LLVM&lt;&#x2F;h3&gt;
&lt;p&gt;After working for weeks with Python’s and R’s data science stack I started to ask my self if there could be a common intermediate representation, similar to CUDA, that could be used by many languages. There should be something better than reimplementing and optimizing the same methods in each language. In addition to that, having a common runtime that could optimize the whole program instead of each function separately would be better. After a few days of researching and testing different projects I found &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.weld.rs&#x2F;&quot;&gt;Weld&lt;&#x2F;a&gt; (you can also read its &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;cs.stanford.edu&#x2F;~matei&#x2F;papers&#x2F;2017&#x2F;cidr_weld.pdf&quot;&gt;paper&lt;&#x2F;a&gt;). To my surprise, one of the creators of Weld is &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;matei_zaharia&quot;&gt;Matei Zaharia&lt;&#x2F;a&gt;, who also is the creator of Spark.&lt;&#x2F;p&gt;
&lt;p&gt;That is how I contacted and interviewed &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;shoumik.xyz&#x2F;&quot;&gt;Shoumik Palkar&lt;&#x2F;a&gt;, the main contributor of Weld. Shoumik is a Ph.D. student in the Computer Science department at Stanford University, that is advised by Matei Zaharia.&lt;&#x2F;p&gt;
&lt;p&gt;Weld is far from being production ready but it is promising. If you are interested in the future of data science and in Rust, you will like this interview.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-hqC6KtF-l1RN8uDg99rmow.png&quot; alt=&quot;&quot; &#x2F;&gt;Not a Monad Tutorial new logo!&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;strong&gt;What was the motivation to develop weld and what problem’s does it solve?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The motivation behind Weld is to provide bare-metal performance for applications that rely on existing high-level APIs such as NumPy and Pandas. The main problem it solves is enabling cross-function and cross-library optimizations that other libraries today don’t provide. In particular, many commonly used libraries provide state-of-the-art implementations for algorithms on a per-function basis (e.g., a fast join algorithm implemented in C in Pandas, or a fast matrix multiply in NumPy), but do not provide any facility for enabling optimization across these functions (e.g., preventing unnecessary scans of memory when performing a matrix multiply followed by an aggregation). Weld provides a common runtime that enables libraries to express computations in a common IR; that IR can then be optimized using a compiler optimizer, and can then be JIT’d to parallel native machine code with optimizations such as loop fusion, vectorization, etc. Weld’s IR is natively parallel, so programs expressed in it can always be trivially parallelized.&lt;&#x2F;p&gt;
&lt;p&gt;We also have a new project called split annotations which will integrate with Weld that’s meant to lower the barrier for enabling these optimizations in existing libraries.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Optimizing numpy, pandas and scikit wouldn’t be easier? How faster it is?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Weld provides optimizations across functions in these libraries, whereas optimizing these libraries would only make individual function calls faster. In fact, many of these data libraries are already highly optimized on a per-function basis, but deliver performance below the limits of modern hardware because they do not exploit parallelism or do not make efficient use of the memory hierarchy. For example, many NumPy ndarray functions are already implemented in C, but calling each function requires scanning over each input in entirety. If these arrays do not fit in the CPU caches, most of the execution time can go into loading data from main memory rather than performing computations. Weld can look across individual function calls and perform optimizations such as loop fusion that will keep data in the CPU caches or registers. These kinds of optimizations can improve performance by over an order of magnitude on multi-core systems, because they enable better scaling.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-eheS9p1hxxEPH8Fqo3As8A.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;strong&gt;Prototype integrations of Weld with Spark (top left), NumPy (top right), and TensorFlow (bottom left) show up to 30x improvements over the native framework implementations, with no changes to users’ application code. Cross library optimizations between Pandas and NumPy (bottom right) can improve performance by up to two orders of magnitude.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is Baloo?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Baloo is a library that implements a subset of the Pandas API using Weld. It was developed by Radu Jica, who was a Master’s student in CWI in Amsterdam. The goal of Baloo is to provide the kinds of optimizations described above in Pandas to improve its single-threaded performance, reduce memory usage, and to enable parallelism.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Does Weld&#x2F;Baloo support out-of-core operations (say, like Dask) to handle data that does not fit in memory?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Weld and Baloo currently do not support out-of-core operations, though we’d love open source contributions on this kind of work!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why did you choose Rust and LLVM to implement weld? Was Rust your first choice?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We chose Rust because:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;It has a very minimal runtime (essentially just bounds checks on arrays) and is easy to embed into other languages such as Java and Python&lt;&#x2F;li&gt;
&lt;li&gt;It contains functional programming paradigms such as pattern matching that make writing code such as pattern matching compiler optimizations easier&lt;&#x2F;li&gt;
&lt;li&gt;It has a great community and high quality packages (called “crates” in Rust) that made developing our system easier.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;We chose LLVM because its an open source compiler framework that has wide use and support; we generate LLVM directly instead of C&#x2F;C++ so we don’t need to rely on the existence of a C compiler, and because it improves compilation times (we don’t need to parse C&#x2F;C++ code).&lt;&#x2F;p&gt;
&lt;p&gt;Rust was not the first language in which Weld was implemented; the first implementation was in Scala, which was chosen because of its algebraic data types and powerful pattern matching. This made writing the optimizer, which is the core part of the compiler, very easy. Our original optimizer was based on the design of Catalyst, which is Spark SQL’s extensible optimizer. We moved away from Scala because it was too difficult to embed a JVM-based language into other runtimes and languages.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;If Weld targets CPU and GPUS how does it compare to projects like RAPIDS that implements python data science libraries but for the GPU?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The main way Weld differs from systems such as RAPIDS is that it focuses on optimizing applications across individually written kernels by JIT compiling code rather than providing optimized implementations of individual functions. For example, Weld’s GPU backend would JIT-compile a single CUDA kernel optimized for the end-to-end application on the fly rather than calling existing individual kernels. In addition, Weld’s IR is meant to be hardware independent, allowing it to target GPUs as well as CPUs or custom hardware such as vector accelerators. Of course, Weld overlaps significantly and is influenced by many other projects in the same space, including RAPIDS. Runtimes such as Bohrium (a lazily evaluated NumPy) and Numba (a Python library that enables JIT compilation of numerical code) both share Weld’s high level goals, while optimizers systems such as Spark SQL have directly impacted Weld’s optimizer design.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Does weld have other applications outside data science library optimizations?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;One of the most exciting aspects of Weld’s IR is that it supports data parallelism natively. This means that loops expressed in the Weld IR are always safe to parallelize. This makes Weld an attractive IR for targeting new kinds of hardware. For example, collaborators at NEC have demonstrated that they can use Weld to run Python workloads on a custom high-memory-bandwidth vector accelerator just by adding a new backend to the existing Weld IR. The IR can also be used to implement the physical execution layer in a database, and we plan to add features that will make it possible to compile a subset of Python to Weld code as well.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Are the libraries ready to be used on real-life projects? If not, when can we expect them to be ready?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Many of the examples and benchmarks we’ve tested these libraries on are taken from real workloads, so we’d love it if users tried out the current versions for their own applications, provided feedback, and (best of all) submitted open source patches. That said, we don’t expect everything to work out of the box on real-life applications just yet. Our next few releases over the following couple months are focusing exclusively on usability and robustness of the Python libraries; our goal is to make the libraries good enough for inclusion in real-life projects, and to seamlessly fall back to the non-Weld versions of the libraries in places where support is yet to be added.&lt;&#x2F;p&gt;
&lt;p&gt;As I mentioned on the first answer, one path toward making this easier comes in the form of a related project called split annotations (&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;weld-project&#x2F;split-annotations&quot;&gt;code&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;shoumik.xyz&#x2F;static&#x2F;papers&#x2F;mozart-sosp19final.pdf&quot;&gt;academic paper&lt;&#x2F;a&gt;). Split annotations are a system that allow annotating existing code to define how to split, pipeline, and parallelize it. They provide the optimization that we found was most impactful in Weld (keeping chunks of data in the CPU caches between function calls rather than scanning over the entire dataset), but they are significantly easier to integrate than Weld because they reuse existing library code rather than relying on a compiler IR. This also makes them easier to maintain and debug, which in turn improves their robustness. Libraries without full Weld support can fall back to split annotations when Weld is not supported, which will allow us to incrementally add Weld support based on feedback from users while still enabling some new optimizations.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>There’s more to life than HTTP: VerneMQ a high-performance and distributed MQTT broker</title>
          <pubDate>Wed, 05 Sep 2018 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/theres-more-to-life-than-http-vernemq-an-mqtt-broker/</link>
          <guid>https://blog.lambdaclass.com/posts/theres-more-to-life-than-http-vernemq-an-mqtt-broker/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/theres-more-to-life-than-http-vernemq-an-mqtt-broker/">&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-vHHvudyYcHEpI5d52doOcQ.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;At &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;lambdaclass.com&#x2F;&quot;&gt;LambdaClass&lt;&#x2F;a&gt; and our blog &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;this-is-not-a-monad-tutorial&#x2F;&quot;&gt;This is not a Monad tutorial&lt;&#x2F;a&gt; we are a big fans of exploring new topics, different operating systems, platforms, languages and libraries&#x2F;frameworks. We have been talking in our company about exploring new subjects like protocols.&lt;&#x2F;p&gt;
&lt;p&gt;There is a whole generation of developers that has only worked with HTTP, ReST and JSON. While a partial improvement over previous technologies, it has created a protocol monoculture. There are situations where other protocols are better suited but many of the young bloods don’t even know they exist.&lt;&#x2F;p&gt;
&lt;p&gt;MQTT is the first protocol we want to dive into. For us VerneMQ (&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;vernemq.com&#x2F;&quot;&gt;https:&#x2F;&#x2F;vernemq.com&#x2F;&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;erlio&#x2F;vernemq&quot;&gt;https:&#x2F;&#x2F;github.com&#x2F;erlio&#x2F;vernemq&lt;&#x2F;a&gt;) is one of the best MQTT brokers implementations we know and it is familiar to us since it is implemented in Erlang. The questions were answered by &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;frescosecco&quot;&gt;André Fatton&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;der_graf&quot;&gt;André Graf&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;larshesel&quot;&gt;Lars Hesel Christensen&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;strong&gt;What is MQTT?&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
MQTT was developed by Andy Stanford-Clarke (IBM) and Arlen Nipper (Cirrus Link) in 1999 as a light-weight protocol efficient in terms of bandwidth and resource usage. In fact one of the original use cases was to send telemetry back from oil-pipelines in remote areas where transmitting data is expensive and service windows are far between. The defining feature of MQTT is that it is a dynamic pub&#x2F;sub type paradigm where clients need to actively subscribe to a topic to receive messages published to it, thus decoupling producers and consumers completely. MQTT also supports various quality of service levels as well as persisted sessions and a few other handy things.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is VerneMQ?&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
VerneMQ is an open source (Apache License version 2) MQTT broker supporting the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.oasis-open.org&#x2F;mqtt&#x2F;mqtt&#x2F;v3.1.1&#x2F;mqtt-v3.1.1.html&quot;&gt;MQTT 3.1.1&lt;&#x2F;a&gt; standard as well as &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.oasis-open.org&#x2F;mqtt&#x2F;mqtt&#x2F;v5.0&#x2F;mqtt-v5.0.html&quot;&gt;MQTT 5.0&lt;&#x2F;a&gt; (though, to be fair MQTT 5.0 support has not yet been merged to master at the time of writing, but should be within a few days). Besides being just another MQTT broker, VerneMQ was built from the start to be a distributed MQTT broker with high scalability in mind.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why would somebody use MQTT instead of HTTP 2 or WebSocket?&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
MQTT, HTTP&#x2F;2 and WebSockets all have their strengths and weaknesses. HTTP is a request&#x2F;reply type protocol, while MQTT is a publish&#x2F;subscribe type protocol. So if all you really need is request&#x2F;reply then MQTT might not be the right choice for the use case. But if the messaging patterns are more complex such as fan-in and fan-out and none or a small part is request&#x2F;reply, then MQTT might be an appropriate choice. What MQTT brings to the table is decoupling of the producers and consumers and all the flexibility that comes with that as well as a well defined routing mechanism based on subscriptions with wildcards. In an HTTP or WebSocket context one would have to build a custom routing scheme, which may of course be better suited for the job than something general as MQTT. On the other hand if the desired features are supported by MQTT, then MQTT has a huge advantage in that it is an open (and royalty free) standard and high quality client libraries are available in pretty much any programming language one could imagine.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Does it have an overlap with other protocols like AMQP (implemented by RabbitMQ for example)?&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
Yes, essentially both AMQP (speaking for the 0.9.1 version) and MQTT implement a publish&#x2F;subscribe messaging pattern. Both protocols rely on intermediate queuing&#x2F;store-and-forward techniques to reduce or eliminate message loss in case a client loses the connection to the broker. The main conceptual difference is that in MQTT one client (identified by a ‘unique’ client id), has one TCP connection to the broker and only a single “queue”. As a consequence, even if a client has multiple subscriptions all messages end up in the same queue. In contrast, with AMQP a queue is a resource on the broker and is decoupled from the client, multiple clients can consume the same queue e.g. for load balancing purposes. So a client can create many queues and decide if and when to consume messages. Moreover, a AMQP connection, which is just a TCP connection, is multiplexed via logical channels, enabling the development of highly performant consumers and publishers.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why did you decide to implement another MQTT broker?&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
We stumbled upon the MQTT protocol while working for a customer on a IoT project that heavily used RabbitMQ and AMQP. Although AMQP has been a requirement by the customer we soon figured out that AMQP (and RabbitMQ) might not be the silver bullet for every messaging use case and started to look out for a better IoT protocol. We discovered MQTT and found it a very interesting addition to the other protocols that were widely in use back then and still are today. Especially the small protocol overhead and the focus on small devices (embedded and mobile) instead of big application servers teased us to take the protocol a bit further. Even more so because at that time no scalable and clusterable MQTT broker was around, MQTT was always added as an addition to a ‘main’ protocol like it was done in RabbitMQ or Apache Apollo. We generally disliked the idea of such a ‘multi-protocol’ capability. For example an AMQP broker was traditionally serving a few hundreds to a few thousands of publishers and subscribers with a high message throughput so you build a broker around such scalability and performance requirements. However a traditional MQTT case is the exact opposite, you have ‘a lot’ (a few thousands to a few hundred thousands, to millions) of clients each one only publishing very rarely very small messages. Combining the two protocols in a single software, reusing shared functionality, and still being able to match all the requirements from both worlds seemed like a tough job, too tough for us, and back then no broker known to us did that successfully and we think still no one does today.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Is there anything you dislike about MQTT or that needs an improvement?&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
Sure, while MQTT v3.1.1 is a great protocol, there are a number of limitations. An example is the lack of negative acknowledgements. Take for example a client attempting to publish to a topic where it’s not authorized to do so: the only action allowed according to the spec is to simply disconnect the client with no way telling it why, which is a bit heavy handed. Another example is that there is no way to add meta information to MQTT payloads such as a content type or decoding schemes etc. The only way to deal with this is to decide on an a priori scheme and encode this information into the payloads themselves. A common workaround is to embed the payload into a thin wrapper which contain such information — but it’s always ad-hoc in every system out there.&lt;&#x2F;p&gt;
&lt;p&gt;Fortunately the OASIS consortium has been working with feedback from the community and carefully used these to develop the next version of the MQTT protocol, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.oasis-open.org&#x2F;mqtt&#x2F;mqtt&#x2F;v5.0&#x2F;mqtt-v5.0.html&quot;&gt;MQTT protocol version 5.0&lt;&#x2F;a&gt;. This version basically addresses the issues mentioned above by incorporating them into the protocol, providing a standard way of doing things. We’re really excited about the new protocol version, so we even wrote a bit about it in &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;vernemq.com&#x2F;blog&#x2F;2018&#x2F;06&#x2F;18&#x2F;is-mqttv5-worth-the-trouble.html&quot;&gt;Is MQTT 5 worth the trouble?&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why did you choose Erlang to implement it?&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
We chose Erlang because it was the right tool for the job. Erlang was designed to support highly concurrent and highly available (through fault tolerance) systems which fits exactly for a project like VerneMQ. It was also important that the concurrency model was a first class concept and the units of concurrency can’t block each other if one happens to run for a long time as that would be detrimental when building a low latency system. There are a lot of other features which make Erlang a great tool to work with, the way supervision trees makes writing defensive code unnecessary is an important one as one only writes code to handle only the cases the problem domain requires. This makes the code generally brief and concise. The core of VerneMQ including tests is about 30K lines of Erlang code which we think is quite remarkable.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;After implementing it, do you think you made the right call using Erlang to implement VerneMQ?&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
Yes, absolutely. To build the best possible product Erlang was definitely the right choice. We still think it is one of the best options out there, today there are other interesting options though.To us an obvious one is Elixir, but another, albeit more exotic (we know this might sound ironic coming from a Erlang devs) option would be something like &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.ponylang.org&#x2F;&quot;&gt;Pony&lt;&#x2F;a&gt; which is an extremely interesting language since it eliminates a lot of nasty error classes (deadlocks, data-races, exceptions etc) via the type system and the guys over at &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.wallaroolabs.com&quot;&gt;Wallaroo Labs&lt;&#x2F;a&gt; are building some pretty amazing stuff with it.&lt;&#x2F;p&gt;
&lt;p&gt;We really love Erlang, but we’re also being realistic that if there’s a better technology or the use case doesn’t require or benefit from the featureset we’re completely open to use other tools for the job.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;How do you retain messages and replicate subscription data?&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
Great question! A retained message in MQTT is a message which is stored on the broker using a topic as the key and whenever a client subscribes to that particular topic the broker delivers a copy of the message. Since VerneMQ is a distributed broker we need to replicate retained messages and for this we currently use an implementation of the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.gsd.inesc-id.pt&#x2F;~ler&#x2F;reports&#x2F;srds07.pdf&quot;&gt;Plumtree&lt;&#x2F;a&gt; protocol which was initially implemented for the now defunct Basho Technologies’ distributed database &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;basho&#x2F;riak&quot;&gt;Riak&lt;&#x2F;a&gt;. Later this implementation was factored out into its own repository and we maintain our own &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;erlio&#x2F;plumtree&quot;&gt;fork&lt;&#x2F;a&gt; with a bunch of tweaks. Note, that the replication mechanism in VerneMQ is eventually consistent as this is much easier to scale as no distributed locking is required.&lt;&#x2F;p&gt;
&lt;p&gt;Besides the retained messages VerneMQ also needs to distribute client session state such as subscription information so each VerneMQ node is able to route the published messages across the cluster.&lt;&#x2F;p&gt;
&lt;p&gt;This is all currently handled using Plumtree and Plumtree is doing a great job of it. That said, Plumtree uses relatively many resources when syncing nodes (it uses &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Merkle_tree&quot;&gt;Merkle trees&lt;&#x2F;a&gt; under the hood) and using plain dotted vector clocks means that deleting things require cluster wide synchronization as it is not possible to distinguish between something which was deleted and something which is just missing. To address this we’re working on implementing a new replication mechanism called &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;haslab.uminho.pt&#x2F;tome&#x2F;files&#x2F;global_logical_clocks.pdf&quot;&gt;Server Wide Clocks&lt;&#x2F;a&gt; which combines vector clocks per key-value pair with a node-clock for each participating node, making it possible to establish a global history and thus discard events observed by all members. This makes deletions a special case of the general history trimming process. Furthermore replications with SWC is cheaper than in Plumtree as no Merkle trees are needed and there’s a much smaller overhead per key-value pair on the wire while replicating the state.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What load can VerneMQ manage? Do you have a concrete example (number of nodes, number of connections per node, throughput, latency, etc)?&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
This is a difficult question we can’t give a straight answer for. The main reason for this is that the scenarios, use cases, and deployment environments are very different. E.g. we know people deploying a VerneMQ cluster on a couple of Raspberry PIs, and others deploying a large cluster on Kubernetes. Unfortunately many vendors started to publish benchmarks that are hard if not impossible to reproduce, mainly for marketing purposes. While we don’t exclude doing this in the future, we’d prefer a more scientific approach. For now, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;vernemq.com&#x2F;blog&#x2F;2016&#x2F;08&#x2F;26&#x2F;loadtesting-mqtt-brokers.html%29&quot;&gt;we develop and publish benchmarking tools&lt;&#x2F;a&gt;, so everyone can run a benchmark scenario matching their own use case and see how VerneMQ and also other brokers perform. Moreover those benchmarking tools will simplify the reproducibility once we publish any sort of benchmarks.&lt;&#x2F;p&gt;
&lt;p&gt;That said, we saw several interesting setups on the road of course. Some were more successful than others. E.g. someone deployed a VerneMQ cluster of 80 nodes over multiple sites and managed to connect around 5 millions clients. Obviously they run into multiple problems with such a setup, and required our assistance to design a better architecture. Right now we’re helping a customer to scale a MQTT application to 10+ millions concurrent clients, we’ll see how this ends, but we’re quite confident that we come up with a good VerneMQ setup for this case.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;How do you test VerneMQ?&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
About 25% of the code is test code — of course this doesn’t mean much, but we believe our test suites are pretty thorough. Of course they can always be better, and we routinely add new tests whenever a bug is discovered or a new feature is added. Almost all of our tests are written as Common Test suites as it’s a really fantastic framework which makes it easy to do both unit and integration tests. We do have a few tests written as EUnit tests but almost all new tests are written using Common Test. We’re great fans of property based testing, but so far we haven’t invested enough into making a proper property based test suite. It’s something we’d love to do at some point, though.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What was the most challenging part of VerneMQ to design and build?&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
In Joe Armstrong’s saying “Make it work, make it beautiful, make it fast” the initial “Make it work” wasn’t too challenging, most of the engineering problems were already solved and it was about combining multiple approaches. We borrowed a lot from the way Basho was building and packaging the Riak database as well as the previously mentioned Plumtree. Moreover the initial topic trie routing algorithm was fully taken from the RabbitMQ MQTT plugin. Also the early decision to use LevelDB for disk persistence simplified a lot in the beginning. So it wouldn’t be fair to say that that part was very challenging, especially at the beginning, where we just wanted it to work. Moreover the ‘supposed-to-be-challenging’-part was already solved by Erlang and its distributed nature. However, back then it was challenging to stay focussed on what VerneMQ should become and not adding every possible feature in a half-baked way. So we focussed on a solid plugin system instead of providing everything out of the box right from day one. In retrospective the engineering of the plugin system was actually quite challenging.&lt;&#x2F;p&gt;
&lt;p&gt;These days the implementation of the SWC challenges us as the distributed algorithm is quite complex and we couldn’t just use an existing library for that. Moreover the implementation and integration of the MQTT 5 further challenges also our plugin system.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What’s ahead for VerneMQ?&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
First of all we’re going to get the MQTT 5 support merged into the master branch, and then work with the community and our uses to squash the inevitable bugs and make it better. Parallel to that we’re working on getting the improved replication mechanism (SWC) in place which will be available in VerneMQ 2.0, but may also be made available in the 1.x series as an opt-in feature. Besides this we’re working on improving the entire experience around containerization (Kubernetes, etc), clustering, discoverability and the tooling around that. So lots of interesting stuff going on.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What do you recommend to do or read (books, courses, RFCs, codebases, exercises) for young devs that want to start working with distributed systems?&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
This is a really good question but also a really hard one to give a good answer to. When we studied computer science most of the results on distributed systems made so many crazy assumptions that they were more or less unusable to build actual systems from. So for a practitioner it was a disappointing experience, but it did give us a good understanding of what the challenges of distributed computing are. When starting out from scratch with distributed computing this is probably a good place to start: Learning about the basics such as the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fallacies_of_distributed_computing&quot;&gt;Fallacies of distributed computing&lt;&#x2F;a&gt; and some of the impossibility results such as the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;CAP_theorem&quot;&gt;CAP theorem&lt;&#x2F;a&gt;. To really learn about and understand distributed systems it’s important to work and play with them and for this we of course recommend either Erlang or Elixir as they come with distribution built in so there’s a very low barrier to getting started. Also the actor model of Erlang forces one to start thinking about message passing and building protocols which is really what distributed systems are all about.&lt;&#x2F;p&gt;
&lt;p&gt;To learn anything the best advice usually is to make sure to play and have fun. So go have fun!&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>How to pretend you have social skills</title>
          <pubDate>Tue, 14 Aug 2018 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/how-to-pretend-you-have-social-skills/</link>
          <guid>https://blog.lambdaclass.com/posts/how-to-pretend-you-have-social-skills/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/how-to-pretend-you-have-social-skills/">&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-Zn-cHY_cpFVxmhkIAwhYzw.png&quot; alt=&quot;&quot; &#x2F;&gt;A software company from another dimension&lt;&#x2F;p&gt;
&lt;p&gt;This time I decided to do something uncommon. I have asked Martina Cantaro, a psychologist that works for our company &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;lambdaclass.com&#x2F;&quot;&gt;Lambdaclass,&lt;&#x2F;a&gt; to write about the work she is doing training young developers. I hope you find it useful.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;My role at Lambda is to help young developers train their social skills to perform their best. Soft skills are not secondary to technical knowledge — they are what makes knowledge shine by making it useful to the human beings with and for which we work. A lot of good technical developers tend to underestimate the need of social&#x2F;soft skills.&lt;&#x2F;p&gt;
&lt;p&gt;First of all let’s define what social skills are. According to wikipedia social skills involve:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Coordination — Adjusting actions in relation to others’ actions&lt;&#x2F;li&gt;
&lt;li&gt;Mentoring — Teaching and helping others how to do something (e.g. a study partner).&lt;&#x2F;li&gt;
&lt;li&gt;Negotiation — Discussion aimed at reaching an agreement.&lt;&#x2F;li&gt;
&lt;li&gt;Persuasion — The action or fact of persuading someone or of being persuaded to do or believe something.&lt;&#x2F;li&gt;
&lt;li&gt;Service Orientation — Actively looking for ways to evolve compassionately and grow psycho-socially with people.&lt;&#x2F;li&gt;
&lt;li&gt;Social Perceptiveness — Being aware of others’ reactions and able to respond in an understanding manner.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Since many people have asked me how to develop soft skills and which are the most common problems, I thought I’d share a few vignettes of what I do at Lambda. I hope you find them as interesting as I do.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Don’t kill the dog&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Two programmers had received a message from the client via Slack. The message seemed pretty straightforward. It said: “Feature X isn’t working”. Next, the tech lead of the client listed a series of detailed steps to solve this problem. This client was pretty new so we needed some help to understand how to solve it since the issue was related to business rules we didn’t know. The diligent programmers followed the steps carefully and once they were done reported back to the client: “There! It’s done”; and went on to fulfill the tasks that were awaiting them in Github.&lt;&#x2F;p&gt;
&lt;p&gt;A few hours later, the programmers were shocked to hear that the client was not happy at all. “Feature X still isn’t working!” the client demanded. “But we followed the instructions you sent to the letter!”, the programmers cried out. They repeated this defense to me when we talked about the issue a few days later in our weekly workshop.&lt;&#x2F;p&gt;
&lt;p&gt;Well, I said, and paused, trying to come up with a metaphor that would put things into perspective for them. Then I saw Simon, our office dog. “If I take Simon to the vet because he has a stomach ache, and I tell the vet to please anestesize him, cut him open, swap his liver with his bladder and stitch him up, the vet will promptly stop me and tell me we need to find an alternative solution. Alternatively, if she does exactly as I said, and Simon dies, I will know I need to find a better vet”.&lt;&#x2F;p&gt;
&lt;p&gt;The client described a problem to you. The fact that they helpfully provided you with a path to a solution doesn’t mean that they just wanted you to blindly follow the steps and call it a day. The primary goal is always fixing the problem.&lt;&#x2F;p&gt;
&lt;p&gt;The takeaway here is: &lt;strong&gt;your job is to find solutions to problems&lt;&#x2F;strong&gt;. Test your solutions. Make sure you provided a solution for the client’s problem. Their suggestions may help but it’s not their job to spell out the solution for you. Otherwise it would be program-by-numbers! Always remember your goal. Test what you just did to see if you met that goal. If the provided solution didn’t work, try another one. If you don’t have permission to modify something, report back: the client needs to know it couldn’t be fixed by you and why.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;The truth in your heart&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I was coaching programmers before an interview with a client. One of the topics we expected would come up was their opinion on different programming languages and tools. We didn’t know the interviewer’s style, so the interview could be more structured or more like a casual conversation on programming. I began with some basic, open-ended questions, like “what programming language do you prefer and why?”.&lt;&#x2F;p&gt;
&lt;p&gt;There are two types of wrong answers to this question. I call one the “dogmatic” answer and the other the “judgement day” answer.&lt;&#x2F;p&gt;
&lt;p&gt;The Dogmatic knows exactly how to answer that question because there’s only one possible answer. There is only one language to conquer all languages, and it is usually the one they happen to use. This language has every feature that matters, and none of its disadvantages are really that important. It can do almost anything. Most problems can and should be solved using this language. And all naysayers are stupid.&lt;&#x2F;p&gt;
&lt;p&gt;On the other hand, we have the Judgement Day answer. One programmer just couldn’t make up his mind. He’s a very centered person, who likes to be precise and think through issues before taking a stance. Great qualities for a critical thinker, but in an interview setting his hesitation could be taken the wrong way. He hummed and hawed and only after pressuring him a bit he came up with “Haskell”. Very well, I said, why do you prefer it? He quickly made two or three very valid points and also mentioned its downsides — he had clearly thought about the pros and cons of the language before — and then paused and said candidly: “but I’m not sure Haskell is really my favorite programming language”. Well, I told him, when Judgement Day comes, you better think it through 100%. There are many pros and cons to each language and entire books could be written about why each one is better than the others. But for now, we’ll settle for a 90% accurate answer. Because the question is not really about that.&lt;&#x2F;p&gt;
&lt;p&gt;I mean, sure, the interviewer does want to know which programming language you prefer. But what they truly want to find out, if they are decent interviewers, is the analysis behind your choice. Why did you choose that language? Are you aware of its downsides? Do you know which situations it’s best for? So there’s not one correct answer. Haskell would have been as good an answer as Erlang, as long as you are able to justify it.&lt;&#x2F;p&gt;
&lt;p&gt;I find this happens often with less experienced devs. Their hearts are too pure. They are eager to search their souls and hand you their deepest truth. Also, they are not sure what exactly is being evaluated by these interview questions.&lt;&#x2F;p&gt;
&lt;p&gt;Of course, if the company works with Erlang and you fervently praise Cobol, the interviewer might think you won’t be a good match. So, to sum up, as long as your answer is 1) relevant to them and 2) well justified, you’ll be forgiven for not plunging your hand into your chest, pulling out your heart and finding out what programming language is written in there.&lt;&#x2F;p&gt;
&lt;p&gt;So, young developers. of the world, don’t fret. If you feel paralyzed when an interviewer asks you how you see yourself in five years, remember she doesn’t want you to read the future, she wants to learn about your motivation and goals. The same thing goes for your favorite programming language. However also have in mind that the person that is interviewing you might lack social skills too! You can’t entirely control the output of the interview.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-tb0bOX6gqdjieBZE.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Communication&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Most of the programmers at Lambda speak English as a second language — their first one being Spanish. Since communication between the programmers and the (often English-speaking) client is key to perform well, we devised a series of exercises to improve their communication skills.&lt;&#x2F;p&gt;
&lt;p&gt;In order for a client-programmer conversation about code to be effective, both have to have a similar representation of the code on their minds. Code is an abstract structure, and both have to build that structure in their heads in order to discuss it. It is also important to be able to clearly articulate and understand the transformations we want to make to that structure — often in a non-native language.&lt;&#x2F;p&gt;
&lt;p&gt;So we began with this exercise:&lt;&#x2F;p&gt;
&lt;p&gt;I built a series of increasingly complex structures using common office objects and photographed them. Then I scattered the elements on the table and instructed one person to look at the photograph of the structure and give out verbal instructions to another person to replicate the structure in the photograph.&lt;&#x2F;p&gt;
&lt;p&gt;This proved to be more challenging than it seemed. Trial and error were very frequent. I encouraged them to give out more and more precise instructions: “Rotate the spoon? How many degrees, in which direction?”. Ideally, sentences would be self-explanatory and steps should be followed without trial and error.&lt;&#x2F;p&gt;
&lt;p&gt;I then instructed the executor of the instructions to proceed as if they were deactivating a bomb — to make a move if they were absolutely certain the movement was going to be accurate. If not, they should ask for clarification&lt;&#x2F;p&gt;
&lt;p&gt;By the third or fourth iteration, their sentences had become longer and better structured, and their language more precise. The executor was also more alert and made sure they understood instructions perfectly.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Technical problems and people problems: know the difference&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Sometimes personal issues are disguised as technical ones. For example, a worker repeatedly pointing out minor mistakes to a colleague in front of third-parties might not be motivated by a desire to improve the quality of work but to make the other feel uncomfortable.&lt;&#x2F;p&gt;
&lt;p&gt;When we first learned to identify these sorts of situations, one case popped up. Some programmers were working for a client in cooperation with another service company. The tech lead of this company had been on the project since the beginning and was not keen on having newcomers on it. He frequently withheld information the programmers needed to complete their tasks and was bent on chastising them for their mistakes on the general chat.&lt;&#x2F;p&gt;
&lt;p&gt;The situation was so bad that there was legitimate concern that this was an attempt to push our programmers out of the project, so the situation had to be handled with great care so as to not make matters worse.&lt;&#x2F;p&gt;
&lt;p&gt;So on one occasion where the chastising was particularly bad and unwarranted, our project manager intervened. He answered on the same chat channel that work was being carried out according to the plan and there was no basis for the criticisms being made, effectively standing between the angry tech lead and the programmers with a sword and shiny armor, ready to defend them against attacks.&lt;&#x2F;p&gt;
&lt;p&gt;One of our less experienced programmers, however, felt bad about the situation and wanted to placate Angry Tech Lead. He didn’t know what he had done wrong, but he wanted to make the situation OK.&lt;&#x2F;p&gt;
&lt;p&gt;So, following the epic defense of the project manager, he wrote an apology on the same channel. This opened a flank for the angry tech lead to continue his attack, rendering the project manager’s defense useless.&lt;&#x2F;p&gt;
&lt;p&gt;We analyzed this dynamic later. Here, the hierarchical structure of the company dictated that if your higher up was deflecting the attack, there was no need to take the hit. In fact, taking the hit could justify subsequent attacks by Angry Tech Lead.&lt;&#x2F;p&gt;
&lt;p&gt;Two lessons were drawn from this: first, to trust the higher-ups’ handling of the situation (or at least talk to them first) because they are probably protecting you. Secondly, we dissected the situation and distinguished constructive criticism from destructive criticism. Constructive criticism is given in a spirit of cooperation, with respect and it provides information on how to correct the mistake or avoid it in the future. It is also often dosed so that it doesn’t overwhelm the recipient, unless the matter is urgent. When it is about a task, it focuses on the problem and not the person. But in this case there was little cooperation since information was being withheld, criticism flowed like a cascade and there was no focus on how to accomplish the task more efficiently.&lt;&#x2F;p&gt;
&lt;p&gt;What at first had seemed to them a technical problem now revealed itself as a people’s problem. This took us a little further into understanding the complex relationship between both realms.&lt;&#x2F;p&gt;
&lt;p&gt;Like captain Spock, we combine the worlds of logical thinking with the human dimension, which may seem irrational when analyzed through the cold prisma of mathematical rationality but has its own logic and meaning. And we need to develop skills in both areas, because, ultimately, we are humans working for other humans — code is just our tool.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Interview with Brad Chamberlain about a productive parallel programming language called Chapel</title>
          <pubDate>Mon, 12 Feb 2018 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/interview-with-brad-chamberlain-about-chapel-a-productive-parallel-programming-language/</link>
          <guid>https://blog.lambdaclass.com/posts/interview-with-brad-chamberlain-about-chapel-a-productive-parallel-programming-language/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/interview-with-brad-chamberlain-about-chapel-a-productive-parallel-programming-language/">&lt;p&gt;As you might know, I am a big fan of concurrency, parallelism and distribution but I know almost nothing about high performance computing (HPC) so I decided to get out from my comfort area. This time I’ve interviewed Brad Chamberlain about &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;chapel-lang&#x2F;chapel&quot;&gt;Chapel&lt;&#x2F;a&gt;, a productive parallel programming language.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-Vbk8JH0pBz1gSHSbxV799A.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What problems does Chapel solve? Who is the ideal user of Chapel?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Chapel supports scalable parallel programming in a portable way: programs developed on a user’s multicore laptop can be run on commodity clusters, the cloud, and supercomputers from &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.cray.com&#x2F;&quot;&gt;Cray&lt;&#x2F;a&gt; or other vendors. Chapel is also designed to vastly improve the productivity of performance-oriented programming, whether serial or parallel. As such, it supports programs with Python-like clarity while retaining the performance of lower-level approaches to programming like C, C++, Fortran, MPI, and OpenMP (the &lt;em&gt;de facto&lt;&#x2F;em&gt; standards for high-performance parallel programming).&lt;&#x2F;p&gt;
&lt;p&gt;Ideal Chapel users include Python programmers who are interested in parallel or performance-oriented programming as well as parallel programmers who are fed up with conventional approaches.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Were there any other previous languages that tried to solve the same issue?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Definitely. There’s a long list of failed attempts at developing scalable parallel programming languages, and skeptics like to remind you of them all the time: “If all of these languages have failed, how will you ever succeed?” In designing Chapel, we spent a lot of time reviewing other parallel languages to learn from their mistakes. Historically, I’d say that most parallel languages have failed for one of two reasons: Many were too high-level, limiting what an expert programmer could explicitly control while requiring a lot from their compilers. Others were lower-level, but as a result didn’t provide sufficient appeal over existing approaches like MPI.&lt;&#x2F;p&gt;
&lt;p&gt;Our response to this tension was to design a language using what we refer to as a &lt;em&gt;multiresolution&lt;&#x2F;em&gt; &lt;em&gt;philosophy&lt;&#x2F;em&gt; : Chapel supports higher-level features like parallel loops and distributed arrays for productivity and ease-of-use. Yet, it also supports lower-level features that give programmers more explicit control over the system. Notably, the high-level features are implemented in terms of the lower-level features within Chapel itself. This provides programmers with the ability to extend the language by creating their own abstractions. For example, an advanced Chapel user can implement new work-scheduling policies for their parallel loops, or new distributions or memory layouts for their arrays.&lt;&#x2F;p&gt;
&lt;p&gt;In my opinion, many scalable parallel language attempts have also failed to gain traction because they’ve been insufficiently general-purpose. Once programmers have a capability, they tend to be reluctant to give it up. This lack of generality often stems from the fact that most efforts have been undertaken by academic groups who need to pick their battles in order to publish papers and graduate students. With Chapel, we’ve created a language whose capabilities exceed C or Fortran with MPI and OpenMP, yet in a language that strives to be as attractive to read and write as Python.&lt;&#x2F;p&gt;
&lt;p&gt;It’s obviously very difficult for any new programming language to succeed, yet that’s no reason to avoid pursuing them — particularly when existing languages have major capability gaps. In our case, we believe that parallelism and locality are first-class programming concerns — not just in High-Performance Computing (HPC) where they make or break a program’s ability to scale well, but also in mainstream programming now that multicore processors and accelerators are pervasive. That said, parallelism and locality have traditionally been afterthoughts in language design. So rather than being paralyzed by the challenges of language adoption, we’re striving to fill that gap. And happily, users seem to be excited by our efforts.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;In some ways, don’t OpenMP, MPI, and CUDA solve the same problem?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;OpenMP, MPI, and CUDA are the &lt;em&gt;de facto&lt;&#x2F;em&gt; standards for HPC programmers today when targeting multicore processors, distributed memory systems, and (NVIDIA) GPUs, respectively. In that sense, Chapel is targeting a similar problem space as they are. However, they’re not considered very productive approaches and are great illustrations of my claim that parallelism and locality are traditionally afterthoughts in language design: they’re implemented using pragmas, libraries, and language extensions rather than first-class syntax and semantics. As a result, they feel like they’re “tacked on” rather than a core part of the language. This hurts not just their ease-of-use but also their ability to be optimized by compilers.&lt;&#x2F;p&gt;
&lt;p&gt;These approaches also tend to be very specific to a given type of parallelism in the system architecture: If you’ve written an OpenMP program and now want to run it at scale on a cluster or a Cray, you’ll have to rewrite it in something like MPI, which requires learning a completely different set of features and abstractions. In contrast, Chapel is designed to support parallel programming across these diverse types of parallel hardware with a single, unified set of features for expressing parallelism and locality.&lt;&#x2F;p&gt;
&lt;p&gt;To their immense credit, OpenMP, CUDA, and (especially) MPI have been responsible for the vast majority of scientific advances in high-performance computing over the past several decades. And if you program in these notations and are happy with them, Chapel may not be for you. Yet, just as early computational results were obtained using assembly language before giving way to more modern and portable approaches like Fortran, C, C++, Java, and eventually Python, we think parallel computing is overdue for a similar leap in evolution: from lower-level, detail-oriented approaches to higher-level ones that improve productivity and portability. As such, Chapel strives to empower the millions of desktop-only programmers to use distributed parallel computers for the first time, while also making existing parallel programmers even more effective.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What does Chapel do differently &#x2F; better?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;A characteristic shared by most general-purpose approaches to scalable parallel programming — including MPI, SHMEM, UPC, and Fortran 2008’s co-arrays — is that they express parallelism using the &lt;em&gt;Single Program, Multiple Data&lt;&#x2F;em&gt; (SPMD) programming model. The basic idea is that the user writes their program with the understanding that when it is run, multiple copies of ‘main()’ will execute simultaneously and cooperatively across a number of processors. This forces parallel programmers to write programs using a &lt;em&gt;local view&lt;&#x2F;em&gt; , in which the code expresses the perspective of a single process out of many: “What subset of the data do I need to allocate? What subset of the iteration space do I need to execute?” While the SPMD approach is sufficient for many computations, it’s also very different from traditional programming where one copy of ‘main()’ executes and all computation proceeds from that point. This requires programmers to think differently, to manage lots of bookkeeping details, and even to launch their programs differently. It also means that in order to get finer-grain parallelism, they need to mix in some other parallel programming model like POSIX threads, OpenMP, or CUDA.&lt;&#x2F;p&gt;
&lt;p&gt;In stark contrast, Chapel supports what we call a &lt;em&gt;global view&lt;&#x2F;em&gt; of programming, in which a single task runs ‘main()’ and then any additional parallelism is created as features that introduce tasks are encountered. Similarly, computation and data are distributed across compute nodes when features that control locality are encountered. This permits scalable parallel programming to be far more intuitive and similar to conventional desktop programming, making it accessible to the millions of developers who might never get around to learning MPI. At the same time, Chapel’s global view also supports SPMD programming for computations or users that require it, so nothing is lost.&lt;&#x2F;p&gt;
&lt;p&gt;As an illustration of Chapel’s advantages, consider the STREAM Triad benchmark which multiplies a vector by a scalar, adds it to a second vector, and assigns it to a third. In Chapel, this can be written in a way that will use all the cores of all the system’s compute nodes as follows:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;use BlockDist, HPCCProblemSize;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;config type elemType = real;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;config const m = computeProblemSize(numArrays=3, elemType),&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;         alpha = 3.0;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;proc main() {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  const ProblemSpace = {1..m} dmapped Block(boundingBox={1..m});&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  var A, B, C: [ProblemSpace] elemType;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  B = 2.0;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  C = 1.0;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  A = B + alpha * C;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In contrast, doing the same thing in C + MPI + OpenMP results in computation like the following, due to the SPMD programming model as well as the lower-level notations (MPI-oriented code is in red, OpenMP in blue):&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-7A817ub0TK9QWgLW.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Performance-wise, how does Chapel compare to languages like C, C++, Go, Rust?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Today, Chapel programs tend to perform competitively with hand-coded C and C++. I’m not aware of any detailed performance comparisons with Go and Rust, though in the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;benchmarksgame.alioth.debian.org&#x2F;&quot;&gt;Computer Language Benchmarks Game&lt;&#x2F;a&gt; (CLBG) we’re currently ranked as being a bit faster than Go and a bit slower than Rust. That said, there are specific CLBG benchmarks where any of these five languages win or lose, and many of the fastest entries take a far more heroic and painstaking approach than the Chapel versions.&lt;&#x2F;p&gt;
&lt;p&gt;Since we care about code clarity, we tend to graph the Computer Language Benchmark Game results on scatter plots showing normalized execution times versus code compactness (as a proxy metric for clarity). In such views, Chapel tends to fall in a very unique position, being competitive in speed with the fastest languages while also nearly as compact as scripting languages. The following two plots illustrate this (the right graph zooms in on the fastest entries for readability):&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-5HKm6tfdrqfXiXWP.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-YHDLOnTtFepJmsUV.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why did you implement Chapel using LLVM?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In all honesty, one of my biggest regrets in the project today is that we didn’t implement Chapel using LLVM from day one. When our project started, LLVM was still in its infancy, and there was no reason to believe that it would become the foundational technology that it is today. As a result, our initial compiler approach (which remains the default today) was to compile Chapel down to C which is then compiled by the back-end C compiler of your choice. This approach treats C as a portable assembly language and has worked reasonably well for us over time. However, it is also unfortunate because the Chapel compiler may have semantic information which is challenging or impossible to convey through C to the back-end compiler.&lt;&#x2F;p&gt;
&lt;p&gt;In contrast, Chapel’s LLVM back-end permits us to translate Chapel directly to LLVM’s Internal Representation (IR), giving us greater semantic control plus the possibility of adding Chapel-specific extensions. Since LLVM is a popular compiler framework, using it lets us leverage developer familiarity, not to mention open-source packages. One such example is Simon Moll’s Region Vectorizer for LLVM, developed at Saarland University. We’ve found that it tends to generate better vector performance for Chapel programs than conventional C back-end compilers. But even more importantly, LLVM gives us a single, portable back-end that saves us the trouble of wrestling with the quirks and bugs that are present across the wide diversity of back-end C compiler versions that we attempt to support today. In 2018, we hope to make LLVM our default back-end for these reasons.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is GASNet? Why do you use it in Chapel?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;GASNet is an open-source library for portable inter-process communication developed by Berkeley Labs &#x2F; UC Berkeley. Its communication primitives include active messages and one-sided puts to (or gets from) the memory of a remote process. The GASNet team maps these calls down to the native Remote Direct Memory Access (RDMA) capabilities of various networks while also supporting fallback implementations over UDP or MPI for portability.&lt;&#x2F;p&gt;
&lt;p&gt;These primitives are precisely what a language like Chapel needs to compile to distributed memory systems: Active messages are the natural way to implement Chapel’s &lt;em&gt;on-clauses&lt;&#x2F;em&gt; which are used to migrate tasks from one compute node to another. Similarly, writing&#x2F;reading a variable back on the originating locale maps naturally to one-sided puts&#x2F;gets since only one process will know when such communications are required. As a result, GASNet gives us a portable way to run Chapel on virtually any distributed system. It’s also one of the best engineered and maintained open-source packages we’ve worked with, and the development team is incredibly responsive to questions and issues.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;How do you manage errors? If a long-running computation in multiple nodes crashes in one node, how do you recover the work done or re-execute it without having to re-run everything?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;For user-level errors within the program itself, Chapel supports the ability to throw and catch errors using a low-overhead approach that was inspired by Swift’s error-handling model. This is a relatively new feature set within Chapel, and it rounds out our core capabilities nicely.&lt;&#x2F;p&gt;
&lt;p&gt;That said, your question seems more oriented toward catastrophic errors that may be outside of the programmer’s control, such as having one of their compute nodes fail. Today, Chapel doesn’t handle such cases gracefully, which arguably reflects our HPC heritage. Runtime libraries and system software for HPC have a long tradition of tearing down jobs when fatal errors occur, and Chapel inherits this behavior to some extent. Resiliency is a growing concern within the HPC community as our system scales grow, and we have some ideas for improving Chapel’s ability to cope with such events. Similar features could also be attractive to users from cloud computing environments who are accustomed to elasticity in their environment. That said, we have not yet had the opportunity to pursue these ideas, so they remain an area of potential future research or collaboration.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Is there any way to trace what a live system is currently doing?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We haven’t developed any Chapel-specific tools for tracing or visualizing Chapel executions in real-time. That said, third-party tools can be used with Chapel as with any other C program. We do have a tool named &lt;em&gt;chplvis,&lt;&#x2F;em&gt; developed by Professor Phil Nelson of Western Washington University, which supports visualizing the communication and tasking events logged by a Chapel program. This permits a user to visually inspect a Chapel program’s execution to find possible sources of overhead, but it is strictly a post-mortem tool at present.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Are you aware of anybody using Chapel in the AI&#x2F;Machine Learning world?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We’ve definitely seen an uptick in interest from AI programmers in recent years as the field has become more prevalent, both in HPC and in general. Our most prominent user in this space at present is Brian Dolan, who is the Chief Scientist and Co-Founder of &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;deep6.ai&#x2F;&quot;&gt;Deep 6 AI&lt;&#x2F;a&gt;, a start-up that is accelerating the matching of medical patients to clinical trials. After being disappointed by programming solutions that didn’t live up to their hype, Brian was drawn to Chapel last summer due to its ability to support programs with Python-like clarity, combined with the promise of supporting performance and scalability like C or Fortran with MPI. Half a year later, he’s become one of our most active and vocal users.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Lasp: a little further down the Erlang rabbithole</title>
          <pubDate>Tue, 09 May 2017 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/lasp-a-little-further-down-the-erlang-rabbithole/</link>
          <guid>https://blog.lambdaclass.com/posts/lasp-a-little-further-down-the-erlang-rabbithole/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/lasp-a-little-further-down-the-erlang-rabbithole/">&lt;p&gt;A few years ago I found &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;lasp-lang.readme.io&#x2F;docs&quot;&gt;Lasp&lt;&#x2F;a&gt;: &lt;em&gt;“a suite of libraries aimed at providing a comprehensive programming system for planetary scale Elixir and Erlang applications”&lt;&#x2F;em&gt;. At this point it should come as no surprise for you to learn that here at Not a Monad Tutorial we are are interested in distributed systems and Erlang. After playing a little bit with Lasp I watched a few talks by its creator: &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;cmeik&quot;&gt;Christopher Meiklejohn&lt;&#x2F;a&gt;. After watching his talk &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=lsKaNDj4TrE&quot;&gt;“Distributed, Eventually Consistent Computations”&lt;&#x2F;a&gt; I decided it was time to interview Christopher.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Discuss and vote at&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;3gvmyl&#x2F;lasp_little_further_down_erlang&quot;&gt; &lt;em&gt;lobsters&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;,&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;programming&#x2F;comments&#x2F;6a620o&#x2F;lasp_a_little_further_down_the_erlang_rabbithole&#x2F;&quot;&gt;&lt;em&gt;reddit&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;and&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14300763&quot;&gt; &lt;em&gt;hn&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-SKlcy2D4QxhBrMdNYNCIHA.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is Lasp?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Originally, Lasp was a programming model designed for deterministic distributed computing with weak synchronization. Lasp’s programming model appears function, in that you write applications that look like functional programs, but under arbitrary distribution, these applications are guaranteed to return the correct result, with minimal coordination, under network anomalies such as network partitions or node failures. Lasp achieves this by building upon the design philosophy of Conflict-free Replicated Data Types, or CRDTs: data structures that are designed to achieve convergence without requiring locking or other synchronization primitives.&lt;&#x2F;p&gt;
&lt;p&gt;During the evaluation phase of Lasp, we were tasked with trying to scale a prototype implementation written in Erlang to 10,000 nodes; we got as far as we could in the allotted time we had, which was 1,024 nodes running on Amazon EC2. In the process of trying to achieve that scale, we had to develop a number of libraries in Erlang to provide supporting infrastructure: new distribution algorithms, optimized implementations of the data types, deployment and operations tooling, etc. So, I’d say at this point Lasp, in the academic sense refers to the original programming model, but Lasp in the industrial sense, refers to the entire suite of libraries that deliver the programming system and programming model at large scale.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What are CRDTs? What problems do CRDT solve?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;CRDTs, or Conflict-free Replicated Data Types, are data types that are designed for use in distributed systems: think regular sequential abstract data types, but with a predefined, deterministic merge function for any two possible values.&lt;&#x2F;p&gt;
&lt;p&gt;One of the big challenges in distributed computing is related to consistency. When a network partition occurs, any system that is managing replicated data must make a choice: do they allow operations to proceed, remaining available-under-partition, or do they prohibit operations to proceed, remaining consistent-under-partition.&lt;br &#x2F;&gt;
Consistent-under-partition systems, or CP systems, provide strong consistency which makes application development easier, whereas available-under-partition systems, or AP systems, allow the developer to both exploit available concurrency in the system for performance, and keep servicing requests when network partitions inevitably occur. Available-under-partition systems are ideal for applications that are geo-distributed, because they allow users to read and write locally to their geographically close replica and don’t incur a synchronization penalty for write operations (which, in some cases can be &amp;gt; 100ms an operation).&lt;&#x2F;p&gt;
&lt;p&gt;However, one of the challenges in using available-under-partition systems is the potential for write conflicts: two writes happen to the same object concurrently at two replicas. When the network ultimately convergences, the different replicas have to come to an agreement over which value wins. When using a database with opaque value registers that you &lt;code&gt;set&lt;&#x2F;code&gt; or &lt;code&gt;get&lt;&#x2F;code&gt; values on, this choice can be arbitrary: either choice may be valid, and systems like Cassandra resort to solving this by using the user provided timestamp to pick a value. Approaches like this, while deterministic, are problematic, however, because arbitrarily picking a value based on time and dropping the other write operation may fail to capture developer intent.&lt;&#x2F;p&gt;
&lt;p&gt;CRDTs say, rather than have opaque registers, why not store actual data types in the database, and then have a conflict resolution policy that is compatible with the semantics of the data type. One example of a trivial CRDT is the grow-only set: if you can never remove elements from the set, it’s always safe to merge copies of a set, that is independently modified, using the set union operation. Similar designs exist for sets where you can add and remove elements arbitrarily, graphs, dictionaries, counters, and booleans.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What other alternatives exists apart from CRDTs to solve the same type of issue?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Operational transformation is an alternative approach, which predates CRDTs, and was used to build both Google Docs and Apache Wave. Operational transformation relies on “transforming” edit operations based on concurrent operations so they achieve the desired effect through the transformation once the document has been modified. There exist a significant number of different algorithms, each which makes a different set of tradeoffs, and there’s no algorithm that’s better than the others in the general case. Its are extremely difficult to implement correctly and to verify, given the number of possible operations and operation interleaving and transformations that must be considered.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Are there any downsides of using CRDTs?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;CRDTs can be very expensive in terms of implementation and state synchronization. Lots of effort has gone into reducing the overhead in state transmission through both operations-based CRDTs (a variant that sends just operations instead of state, with the tradeoff that it requires a stronger property for message delivery from the network) and delta-CRDTs (a variant that minimizes the required state that needs to be transferred by minimizing the change representation.)&lt;&#x2F;p&gt;
&lt;p&gt;One open challenge for both CRDTs, and any system that has to manage a large-amount of replicas of objects that will be concurrently operated on, is actor management. Typically, these systems and data structures must carry metadata sizes O(n) on the number of actors to ever modify an object in the system: in a system with a large amount of mobile devices and high churn, this can be prohibitive in terms of space. Recent approaches to try to address this problem rely on either imposing a structure on the way nodes share information with one another to allow some nodes to subsume the changes of other nodes, or allowing transient nodes to temporarily “borrow” identities of a smaller number of permanent nodes so the identifiers of temporary nodes aren’t carried around in the objects metadata indefinitly.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;lasp-lang.readme.io&#x2F;docs&#x2F;what-is-lasp-pg&quot;&gt;&lt;strong&gt;Lasp process registry&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;? Why create a new process registry if we already got global, pg2, gproc or syn in Erlang?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;About three or so years ago I created Riak PG, a process registry that used the same distribution strategy as Riak (with, a corresponding paper presented at the Erlang Workshop that year.) I created this process registry because I had done an extensive study and writeup about why pg2, proc, and global are not designed properly for&lt;br &#x2F;&gt;
distributed scenarios where partitions can occur and availability is paramount.&lt;&#x2F;p&gt;
&lt;p&gt;Lasp PG is a natural extension of this, where it uses an unstructured overlay with full replication and CRDTs instead of partial replication across a structured overlay network and CRDTs.&lt;&#x2F;p&gt;
&lt;p&gt;While Ericsson is working on scaling the global facility and growing distributed Erlang to support a larger number of nodes, they are focusing on:&lt;&#x2F;p&gt;
&lt;p&gt;a) supporting existing applications developed at Ericsson with distributed Erlang&lt;&#x2F;p&gt;
&lt;p&gt;b) smaller scale of nodes, operating in a LAN configuration (think ~200–500)&lt;&#x2F;p&gt;
&lt;p&gt;Their solution for scaling global shards the information across nodes, and requires availability of the DHT (they are using Kademlia, a structured overlay network) for requests to be serviced.&lt;&#x2F;p&gt;
&lt;p&gt;Lasp (and, therefore, Lasp PG) is focusing on large-scale, wide-area programming: think ~10–100k nodes operating at geo-scale. In this scenario, partitions are common — in fact, mobile clients or IoT devices might disable their antennas to preserve battery. In this scenario, we have to assume that nodes are not aware of every other node in the network, have to route messages through other nodes, and have to be resilient to partitions and have the ability to keep operating. Lasp PG is the first step towards this, and our work that was presented at Erlang Factory, Loquat, is the second step towards this goal.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Do you think that parts of what you created and found while developing Lasp will be ported to more traditional programming languages?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Hopefully, but it’s unclear what components will end up being useful or not. We are mainly focused on quickly prototyping things and performing evaluations, all in Erlang and Elixir, to determine which approaches scale, are easy to program with, etc.&lt;&#x2F;p&gt;
&lt;p&gt;I think that once we get a bit further along in the research, maybe 4 to 5 years, that some of the ideas we’re just coming up with now might be useful and developed enough to make it into the mainstream.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;lasp-lang.readme.io&#x2F;docs&#x2F;overview&quot;&gt;&lt;strong&gt;Partisan&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;? Why did you not use the default distributed Erlang?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Partisan is a membership layer for clustering groups of Erlang nodes. It bypasses distributed Erlang completely, can run in a variety of topologies, will soon support connection multiplexing, and has full support for TLS&#x2F;SSL. Partisan can support clusters of nodes running in star-topologies, random unstructured overlays, and clusters that are fully connected.&lt;&#x2F;p&gt;
&lt;p&gt;Distributed Erlang is a bit too rigid for us: it assumes a fully connected network, which is extremely difficult to scale to large clusters of nodes, and uses a single TCP connection between all processes communicating from one node to another. In order to build a more reliable system that would scale to large clusters of nodessecurely, we needed our own membership layer for state dissemination. Right now, partisan doesn’t support all of the semantics that Erlang provides, but we’re actively working with some developers in the open source community to extend partisan to support normal Erlang message passing across our highly-available framework.&lt;&#x2F;p&gt;
&lt;p&gt;We’ve also started to see some companies using Erlang and Elixir pick up partisan as a tool for helping them build reliable, large-scale, applications that need to do efficient state dissemination which is very nice for an implementation that came out of a research group.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What other programming languages or pieces of software do you keep an eye on?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Right now, what I’m most excited about is Space-Time Insight’s implementation of Microsoft Orleans in Erlang, called &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;SpaceTime-IoT&#x2F;erleans&quot;&gt;Erleans&lt;&#x2F;a&gt;. I think that Orleans take a lot of the complexity out of actor management in Erlang and Elixir and helps developers get straight to building distributed applications without having to focus on the low level details around message routing, actor placement, and actor creation and termination.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What do you recommend reading or doing for those of us that we are trying to learn more about distributed systems?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I think that everyone is building distributed applications nowadays — from your web developer building a rich-web client in JavaScript to mobile developers building the next hit application — we all have to deal with the problems of state, synchronization, offline operation, and maintaining consistency.&lt;&#x2F;p&gt;
&lt;p&gt;That said, from the academic side, I’ll recommend&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.springer.com&#x2F;gp&#x2F;book&#x2F;9783642152597&quot;&gt; “Introduction to Reliable and Secure Distributed Programming”&lt;&#x2F;a&gt; from Cahin, Guerraoui, and Rodrigues. It’s the book that my university teaches with, and the course that I’ve TA’d and contributed content to.&lt;&#x2F;p&gt;
&lt;p&gt;The course is also taught via a MOOC on edX as well, and I’ll be doing&lt;br &#x2F;&gt;
a guest lecture this semester in Part 2 on Lasp and CRDTs.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.edx.org&#x2F;course&#x2F;reliable-distributed-algorithms-part-1-kthx-id2203-1x&quot;&gt;Reliable Distributed Algorithms, Part 1This course gives a comprehensive introduction to the theory and practice of distributed algorithms for designing…www.edx.org&lt;img src=&quot;https:&#x2F;&#x2F;cdn-images-1.medium.com&#x2F;fit&#x2F;c&#x2F;160&#x2F;160&#x2F;0*I3V5Fl71IfPeGbC2.&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.edx.org&#x2F;course&#x2F;reliable-distributed-algorithms-part-2-kthx-id2203-2x&quot;&gt;Reliable Distributed Algorithms, Part 2The course will help students gain an in-depth understanding of distributed algorithms to build reliable and scalable…www.edx.org&lt;img src=&quot;https:&#x2F;&#x2F;cdn-images-1.medium.com&#x2F;fit&#x2F;c&#x2F;160&#x2F;160&#x2F;0*wlK5JSGA0E8nK6Kp.&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>The big old reliable elephant: talking about Postgres with Craig Kerstiens</title>
          <pubDate>Wed, 26 Apr 2017 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/the-big-old-reliable-elephant-talking-about-postgres-with-craig-kerstiens/</link>
          <guid>https://blog.lambdaclass.com/posts/the-big-old-reliable-elephant-talking-about-postgres-with-craig-kerstiens/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/the-big-old-reliable-elephant-talking-about-postgres-with-craig-kerstiens/">&lt;p&gt;In this opportunity I interviewed Craig Kerstiens. Craig works for &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.citusdata.com&#x2F;&quot;&gt;citusdata&lt;&#x2F;a&gt;, a company that helps customers scale databases beyond a single node. Over the last few years, after building systems that used Redis, Cassandra, Riak, Elasticsearch and even Mongo, I rediscovered my love for PostgreSQL. The documentation is excellent, its development pace is astonishing and it is a good old reliable beast. However its feature set can be quite overwhelming. To mention just a few of its special features: you got a big option of index types (B-tree, Hash, GiST, SP-GiST, GIN and BRIN), many &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.craigkerstiens.com&#x2F;2014&#x2F;05&#x2F;07&#x2F;Postgres-datatypes-the-ones-youre-not-using&#x2F;&quot;&gt;data types&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;railsware.com&#x2F;blog&#x2F;&#x2F;2012&#x2F;04&#x2F;23&#x2F;postgresql-most-useful-extensions&#x2F;&quot;&gt;extensions&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;postgresguide.com&#x2F;sql&#x2F;window.html&quot;&gt;window functions&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;postgresguide.com&#x2F;cool&#x2F;ctes.html&quot;&gt;common table expressions&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.craigkerstiens.com&#x2F;2013&#x2F;08&#x2F;05&#x2F;a-look-at-FDWs&#x2F;&quot;&gt;foreign data wrappers&lt;&#x2F;a&gt;. As Craig said in one of this talks “Postgres is the Emacs of databases”. If you have ever used Emacs you know that learning it can take some time due to the number of choices available.&lt;&#x2F;p&gt;
&lt;p&gt;Craig helped me decide what postgres features to use and how, thanks to &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.craigkerstiens.com&#x2F;content&#x2F;&quot;&gt;his blog&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.postgresguide.com&#x2F;&quot;&gt;postgresguide.com&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;postgresweekly.com&#x2F;&quot;&gt;postgresweekly.com&lt;&#x2F;a&gt;. He has been really helpful in sharpening my postgres knife.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Discuss and vote at&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;y0k2h5&#x2F;big_old_reliable_elephant_talking_about&quot;&gt; &lt;em&gt;lobsters&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;,&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;programming&#x2F;comments&#x2F;67owq6&#x2F;the_big_old_reliable_elephant_talking_about&#x2F;&quot;&gt;&lt;em&gt;reddit&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;and&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14203940&quot;&gt; &lt;em&gt;hn&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-xBJtkf59c2V5ncf-Q-1_Eg.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why do you prefer PostgreSQL over other SQL databases?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;It was actually a little ways into my career before I came around to Postgres. I started on Oracle in college. When I found Postgres it was a bit stodgey and just correct. There was nothing wrong with it, but it wasn’t anything to write home about. What was interesting about it was the license which made it very favorable to fork and extend and add any more value. Since that time though it’s really come a long way from a user experience perspective, and really expanding beyond the “SQL” world.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why do you think a lot of developers moved away from SQL databases a few years ago?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;To be right to the point… user experience. SQL is a great language for querying lots of data. The idea that you have to setup your schema ahead of time and define your data model is painful though. Over the longterm is pays off, but there is nothing inherint in SQL that says you can’t model things in documents and have that transformed to relational. The ease and promise of document databases is huge for getting started, but it’s not a perfect long term solution…&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why did many of them return to use SQL databases?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The ability to get up and running quickly is always at odds with long term maintainability. Thats not to say that you should pre-maturely optimize, but SQL has stood a test of time of querying and accessing data and we’re seeing that in a return to systems that re-implement SQL on top of other datastores.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;In which cases wouldn’t you use PostgreSQL?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The only one that really comes to mind is graph databases. Over time PostgreSQL has gained support XML, key value, full text search, document storage, the only thing it hasn’t covered yet really is the graph arena.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is the most misused feature of PostgreSQL or SQL?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Wow, thats a tough one. I’m going to completely side step the question and say that it’s not leveraging Postgres specific features. I see a lot of developers say “I want to be able to migrate away so I’m going to do the most generic bare bones thing possible” Whether that’s not using the array datatype, JSONB, GIN or GiST indexes, at that point why even pick Postgres? The biggest mistake I see is not mis-using a feature, it’s not using it for the idea you might one day migrate.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What are your favorite PostgreSQL extensions?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Obviously I’m biased towards &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;citusdata&#x2F;citus&quot;&gt;Citus&lt;&#x2F;a&gt;. I’ve actually known the Citus team for over 4 years now, before they were an extension to Postgres. At Heroku what Iwould hear and see over and over is people running into this ceiling with Postgres. SQL databases typically work really well on a single node, and there’s this notion that SQL can’t be distributed. Citus actually solves a problem for hundreds of customers I saw outgrowing single node Postgres whether at 100 GB or 1 TB, that makes it trivial to shard out while still maintaining transactional semantics.&lt;&#x2F;p&gt;
&lt;p&gt;Though I have to mention my second favorite: &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.citusdata.com&#x2F;blog&#x2F;2017&#x2F;04&#x2F;04&#x2F;distributed_count_distinct_with_postgresql&#x2F;&quot;&gt;HyperLogLog&lt;&#x2F;a&gt;. This is one I personally have not got to put into production, but is super awesome. It’s essentially a sketch algorithm for probabilistic distincts across really large datasets.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Is there any feature that another database has that you would like PostgreSQL to have?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I think the biggest would be easier onboarding or not having to define your schema ahead of time. ToroDB aims to do some of this for Postgres when coming from Mongo, but a native Postgres experience would be huge here.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What do you recommend reading to understand the implementation of PostgreSQL?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Subscribe to the hackers mailing list.&lt;br &#x2F;&gt;
&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.postgresql.org&#x2F;list&#x2F;pgsql-hackers&#x2F;&quot;&gt;https:&#x2F;&#x2F;www.postgresql.org&#x2F;list&#x2F;pgsql-hackers&#x2F;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The best engineers (even one that don’t actively develop for Postgres subscribe here as it’s just great discussion and development).&lt;&#x2F;p&gt;
&lt;p&gt;And for a lighter read, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;postgresweekly.com&quot;&gt;postgresweekly.com&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What do you recommend reading to get better at SQL and PostgreSQL?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I actually got my foundation in relational algebra. At the time it seemed overly academic like a lot of other CS, when it comes to databases though and in particular SQL it gives you a huge leg up. I’d very much encourage people to spend some time on the academic side of relational algebra, then move to SQL syntax, over the long term it’ll really pay off.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>A Pythonist finds a new home at Clojure land</title>
          <pubDate>Fri, 14 Apr 2017 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/a-pythonist-finds-a-new-home-at-clojure-land/</link>
          <guid>https://blog.lambdaclass.com/posts/a-pythonist-finds-a-new-home-at-clojure-land/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/a-pythonist-finds-a-new-home-at-clojure-land/">&lt;p&gt;Welcome back to another interview of &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;notamonadtutorial.com&#x2F;&quot;&gt;Not a Monad Tutorial&lt;&#x2F;a&gt;. In this opportunity I decided to interview Facundo Olano, a friend, a teammate, and a developer with a &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;facundoolano&quot;&gt;diverse experience&lt;&#x2F;a&gt;. We talked about Python, Node.js, Clojure, Common Lisp and software development in general. Something worth mentioning is that this is not the first time Python and Clojure get mentioned together at Not a Monad Tutorial. &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;notamonadtutorial.com&#x2F;indie-languages-interview-pixie-and-timothy-baldridge-cadbc36418dc&quot;&gt;Timothy Baldridge implemented Pixie&lt;&#x2F;a&gt;, a Lisp language inspired by Clojure, in Python.&lt;&#x2F;p&gt;
&lt;p&gt;Vote and discuss at &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;nz28ef&#x2F;pythonist_finds_new_home_at_clojure_land&quot;&gt;lobsters&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;programming&#x2F;comments&#x2F;65ct5j&#x2F;a_pythonist_finds_a_new_home_at_clojure_land&#x2F;&quot;&gt;reddit&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14114624&quot;&gt;hn&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-4XmtTGqxc82DyQwcpmr9pw.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;A wallpaper I created for my OpenBSD laptop. Lisp, BSD, Erlang, Rust. We live in the best of all possible worlds.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;You are quite in love with Python. Why is that?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Heh, love is a big word, isn’t it? But, yes, I guess for a while I had pretty strong feelings for Python. I still have, to a degree. If you’re going with the love metaphor let’s say I had a series of shitty girlfriends that didn’t treat me all that well and I didn’t even noticed it, then I meet this great woman, this caring and interesting woman that listens to what I have to say and doesn’t, um, force me to wrap everything in class.&lt;&#x2F;p&gt;
&lt;p&gt;Seriously speaking, I learnt to program in college, arguably at an old age, and there they taught me Pascal (because some folks are convinced that’s still the best way to teach good programming manners), then a fair amount of C++, and lots of Java. Everybody was in love with Java over there and they kind of gave you the impression that that was it: this is as good as programming gets, this is what will get you a job and it’s so much better than C++, which I already knew wasn’t pleasant to work with. So I got a job programming Java and I loved it, I read all the books, &lt;em&gt;Refactoring&lt;&#x2F;em&gt; and the Design Patterns stuff. But then I had to quit because I was getting behind in College, I got some free time back and I was curious about Python because some former coworkers and other students talked heavens about it.&lt;&#x2F;p&gt;
&lt;p&gt;I got this book &lt;em&gt;Learning Python&lt;&#x2F;em&gt; and went through it top to bottom one summer. I guess I felt scammed, in a way: how come nobody told me about this? I felt I had been wasting my time writing XMLs and type hierarchies, while there was a simpler way to do about everything: dynamic typing gave me polymorphism for free, the data structures were built-in and had literals, string manipulation was just amazingly easy, you could have standalone functions and pass them like values, a lot of the Java design patterns were reduced to one-liners… I guess one of the take-aways of the experience was that sometimes your peers know better than your teachers (or your bosses).&lt;&#x2F;p&gt;
&lt;p&gt;But besides it feeling better than Java, what’s still unique for me about Python is the set of principles that are best expressed in the &lt;em&gt;Zen of Python&lt;&#x2F;em&gt;. It felt like every bit of the language followed those principles and it encouraged you to do the same with your own code; when in doubt about how to tackle something, the Zen of Python would tell you the right way to go. I still follow most of those ideas when I program, regardless of the language.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Before learning Clojure, your&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;facundoolano.wordpress.com&#x2F;2012&#x2F;01&#x2F;31&#x2F;first-impressions-on-common-lisp&#x2F;&quot;&gt;&lt;strong&gt;first experience with a Lisp&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;was with Common Lisp. From what I have talked with you about learning Common Lisp I could sum up that it was a bittersweet experience. Why didn’t you like Common Lisp?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I got interested in Lisp after reading Paul Graham essays. Then there was that bit of Eric Raymond about the religious experience of &lt;em&gt;getting&lt;&#x2F;em&gt; Lisp. After what I went through with Java and Python I made a point about always looking for chances to learn new languages.&lt;&#x2F;p&gt;
&lt;p&gt;But it just didn’t feel right, in a lot of ways it was the opposite of what I loved about Python: the code was very difficult to read (not because parens or prefix notation, just because it was filled with symbols), the operator set was huge, with really weird names and not dynamic at all, I remember it having like six equality operators for different types. Add to that it’s an old language with a small community and zero chances of getting a job using it, it made no sense to invest much time in it, since it wasn’t fun either. But fortunately there are many Lisps and I already knew right then I’d give a chance to Clojure eventually.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why was the experience with&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;facundoolano.wordpress.com&#x2F;2016&#x2F;03&#x2F;20&#x2F;first-impressions-on-clojure&#x2F;&quot;&gt;&lt;strong&gt;Clojure different&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;? As&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;programming&#x2F;comments&#x2F;65ct5j&#x2F;a_pythonist_finds_a_new_home_at_clojure_land&#x2F;dg97mao&#x2F;&quot;&gt;&lt;strong&gt;stesch said in reddit&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;, Clojure land is in the Java sea. Those are strange waters for a pythonist. What did you like about it?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;For starters, it addresses everything that put me off about Common Lisp. It’s more readable. The operator set is big, but very consistent and polymorphic: all core functions work as expected with every data type. It has a strong focus on immutability and functional programming, which CL hadn’t. But it’s also a very pragmatic language: it doesn’t ask you to learn category theory or to know what a functor is in order to get why you would benefit from it. That’s the approach to functional programming that I like. I’m not saying theory isn’t important, just that I’m the kind of programmer whose interest you won’t catch with theory detached from practice. Also, the community is very active and welcoming, and the fact that it’s a JVM language makes it get a lot of attention, considering it’s a Lisp dialect.&lt;&#x2F;p&gt;
&lt;p&gt;Another thing that made me feel at home about Clojure is that it has a strong philosophy and you can tell its design has been driven by it. The philosophy is not the same as the one in Python, and now I understand that that doesn’t really matter. I want consistently opinionated languages rather than bags of features you can bend to program in ten different ways; &lt;em&gt;what&lt;&#x2F;em&gt; the philosophy is is secondary to the fact that &lt;em&gt;there is&lt;&#x2F;em&gt; a philosophy.&lt;&#x2F;p&gt;
&lt;p&gt;The talks by Rich Hickey are enlightening, and every time I watch one I feel like I improved my understanding of the language, even if the talk isn’t about Clojure itself. Kind of like a Zen of Clojure.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What do you think about the JVM and its community?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I’ve been working to suppress the strong feelings I used to have against Java. I still dislike it as a language and the way of programming it encourages, though. I revisited it a couple of years ago to write some Android apps and nope, still not my cup of tea. Everything just feels convoluted and over engineered, I’d constantly think how much simpler this is in Python or Perl or Ruby or JavaScript. It’s a very programmer-centric view, I’m aware, mostly based in what I enjoy in the day to day, which doesn’t necessarily make sense from a business perspective. There’s a reason why big companies go to Java; I recognize there’s a lot of top of the class software written in it, and it’s fast. I don’t have the background to make a serious assessment of the JVM but I’m pretty sure it’s an amazing piece of software.&lt;&#x2F;p&gt;
&lt;p&gt;The good thing is the JVM can now host other languages, and something as weird as a functional Lisp dialect is fairly close to being popular and you can even get a job with it. That’s a lot to say.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What do you miss from Python?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Sometimes I say, half-joking, that programming is a branch of literature. In that sense I value elegance and succinctness, I think there can be beauty in code, but I also know that beauty is completely subjective and I can’t argue about one style being better than another. I’m not talking about readability, that’s important and it’s more or less measureable; I’m talking about aesthetics. I think Python had that kind of beauty for me, which is harder to get in Clojure. Clojure can be more expressive and it’s more powerful but can easily get ugly if you don’t have a lot of discipline. Again: all subjective stuff.&lt;&#x2F;p&gt;
&lt;p&gt;Truth be told, I don’t think I miss Python all that much, at least not while I’m doing Clojure. JavaScript is a different story, JavaScript is a mess. But still, if you bend it in the right directions, it can be a fairly decent functional language. I noticed that Python can’t, there’s stuff that just doesn’t work that way (lambdas come to mind), and that probably would annoy me nowadays. So I guess I’m not married to any language anymore. That’s a good thing, right?&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Your most known projects in Github are written in JavaScript. Do you like coding in JavaScript?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;JavaScript is Frankenstein. As Douglas Crockford showed in &lt;em&gt;The Good Parts&lt;&#x2F;em&gt; years ago, there’s a lot of awful bits and you &lt;em&gt;have&lt;&#x2F;em&gt; to subset the language. That’s gotten worse, because they keep adding stuff to it (some of it really cool, some of it to make it look like Java), and they can’t remove the old stuff, so it has become one of those things you have to agree upfront on which parts you’re going to use and which parts are banned, kind of like C++.&lt;&#x2F;p&gt;
&lt;p&gt;But, as said, if you pick the right subset it can be good. &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;eslint.org&#x2F;&quot;&gt;eslint&lt;&#x2F;a&gt; helps. If you ban &lt;em&gt;this&lt;&#x2F;em&gt; and &lt;em&gt;new&lt;&#x2F;em&gt; and treat objects like maps, most problems go away. If you’re bold you can even pick a set of eslint rules to force immutability. And then there’s &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;ramdajs.com&quot;&gt;Ramda&lt;&#x2F;a&gt;. That’s the secret sauce; it makes data manipulation a joy, in some spots I even like its functions better than their Clojure counterparts. The async stuff is weird. I still can’t make my mind if Promises are better than callbacks, but I got used to them. It’s a lousy way of hiding concurrency, though.&lt;&#x2F;p&gt;
&lt;p&gt;I have a fair amount of Node.js projects in GitHub, yes. That’s the killer thing about Node.js: NPM, its ecosystem, this philosophy of small unix-y modules. You have an idea, you write up a file and you’re two commands away from publishing it and getting feedback. No other language I’ve tried reduces the boilerplate to share your work that much. That’s a real boost for Open Source and Collaboration. I recognize it has some bad side effects (mixed module quality, left-pad, etc.), but those are much less than the advantages. I remember Python dependency and publishing story being way more cumbersome.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;In the last few months you started using Emacs. What do you think about it?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I’ve been putting off a blog post about that. I know I’m glad that I decided not to learn Emacs at the same time that I was learning Clojure. That could have caused me to drop both things. I think there’s this idea that you can’t learn a Lisp without Emacs, and that may have been true before, but now that there’s &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;shaunlebron.github.io&#x2F;parinfer&#x2F;&quot;&gt;parinfer&lt;&#x2F;a&gt; you can safely hack Lisp on most modern editors. Hardcore lispers may not notice how amazing of a contribution to the community this is, it makes it dramatically easier to get started with Lisp and reachable to people that wouldn’t even consider using something like Emacs.&lt;&#x2F;p&gt;
&lt;p&gt;I pleasantly used Clojure with Sublime and parinfer for almost a year. Then I started reading &lt;em&gt;Coders at work&lt;&#x2F;em&gt; and saw all these amazing hackers mentioning Emacs again and again. It felt like I was missing out on something, so I decided I should give it a try, as a weekend project.&lt;&#x2F;p&gt;
&lt;p&gt;And it was a hell of weekend. The first lesson I learned was that I was a shitty typist, but that got better as the days went by. Fortunately it was a quiet week at work because I could barely get anything done for a while. One interesting note is that I went through this process with JavaScript, so I could make Emacs my daily editor at work. It wasn’t until I felt comfortable with the editor that I tried it with Clojure. And then I realised my Clojure experience wasn’t complete before. It probably goes the other way around: you get the best out of Emacs when you’re doing Lisp.&lt;&#x2F;p&gt;
&lt;p&gt;I’m not sure I’d recommend it to every programmer, though, specially if they work on a single language that already has a killer editor. Learning Emacs is a really fun and enriching experience, but you have to be prepared to spend a lot of time tuning the editor at first and acknowledge the fact that &lt;em&gt;your Emacs config will be the project of your life&lt;&#x2F;em&gt; , as I read somewhere.&lt;&#x2F;p&gt;
&lt;p&gt;I know I love those times when you realise you are doing something repeatedly, that could be done by a command, and you write it (or, better, you find that someone else wrote it already). That’s when it pays off.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Is there any particular Clojure library that you would specially recommend?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jonase&#x2F;kibit&quot;&gt;kibit&lt;&#x2F;a&gt; I find amazing because it’s not only a useful linter (like &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jonase&#x2F;eastwood&#x2F;&quot;&gt;eastwood&lt;&#x2F;a&gt; also is), but it teaches you the standard library as you go, which can be a little bit overwhelming when you are starting out. &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;bhauman&#x2F;lein-figwheel&quot;&gt;Figwheel&lt;&#x2F;a&gt; is another obvious one that made a big difference for me when I started to play with ClojureScript.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;macchiato-framework.github.io&#x2F;&quot;&gt;Macchiato framework&lt;&#x2F;a&gt; is doing a great job of bringing Node.js to ClojureScript.**** I noticed some people don’t take Node.js very seriously, but being Clojure a language that makes such a strong point of leveraging the host platform, the world of possibilities available in NPM can’t be disregarded. There’s another often overlooked fact: you’re much more likely to find a functional programming enthusiast nowadays doing Node.js than in the Java world, so shortening that gap can only bring good to the community.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;candid82&#x2F;joker&quot;&gt;Joker&lt;&#x2F;a&gt; is another great one. It’s a Clojure interpreter written in Go, but what I’ve found incredibly useful is how it works as a linter, which you can easily hook to an editor. It really improved my workflow, early catching typos and bugs while I program.&lt;&#x2F;p&gt;
&lt;p&gt;Finally, in the testing related work I’ve been doing recently I’ve found &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jakemcc&#x2F;lein-test-refresh&quot;&gt;lein-test-refresh&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;weavejester&#x2F;eftest&quot;&gt;eftest&lt;&#x2F;a&gt; to be useful and insightful about how clojure.test and leiningen internals work.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;On your github profile you have many pretty well known open source projects. What motivates you to invest time in them?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I just love programming. I have lots of hobbies, but definitely programming is one of the things that I enjoy the most, what gives me the most pleasure. It’s like an itch: I get this idea or I encounter a need that isn’t addressed by an existing library or maybe I’m just playing to learn a new technology. I can’t help it but sitting down and building something, until is see something working on the screen and the itch goes away. I learned not to be lazy, polishing it a bit and uploading it to GitHub.&lt;&#x2F;p&gt;
&lt;p&gt;Open source is ideal, because you get to work on your own time, you do the stuff you’re interested in and drop the project whenever it bores you. I wish someone would pay me to do that. With a real job it’s harder: sometimes it gets boring, sometimes there’s nothing to do or you depend on someone else to move forward. Most often than not you can’t share your work.&lt;&#x2F;p&gt;
&lt;p&gt;And I always liked this process of conceiving a project, executing it and sharing it with others. Not just in software; the same goes for my fiction writing or when I recorded music as a teenager. When I was in high school I didn’t know how to program but I was obsessed with making games, I spent most of my afternoons fiddling with these game maker programs, RPG Maker and such, sharing my creations with friends. Unfortunately internet access was limited at home and they didn’t teach programming in my school, so it wasn’t until much later that I was able to do serious stuff on my own.&lt;&#x2F;p&gt;
&lt;p&gt;During college I did little projects and games but the languages I knew and skills I had weren’t enough to get me very far at the beginning. There was no GitHub, so it was harder to share and find interesting projects to work on. Later I had to juggle between a full-time job and finishing college. It wasn’t until these last couple of years that I got the freedom to work on whatever I want. And I know in a couple of years I’ll have kids and other stuff going on in my life, so I’m trying to enjoy this programming spring as much as I can.&lt;&#x2F;p&gt;
&lt;p&gt;And then there’s marketing factor. I’m not great at some types of job interviews and my resume may not tell you that much on its own, but I have a portfolio of open source projects that shows I’m a serious coder, a published Android game that proves I can take a personal project to production and a blog that tells you that I reason about my craft and I’m constantly trying to improve it. If you care enough to read it.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What are you working on lately?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I work on a Node.js shop, but the team is full of functional enthusiasts. We can’t convince our boss to let us write a production microservice in Clojure or Elixir, or a user interface in Elm. But the boss doesn’t care that much about our integration tests (as long as there &lt;em&gt;are&lt;&#x2F;em&gt; tests). So when someone complained for the zillionth time about how painful it is to write our API integration tests in JavaScript, I proposed migrating them to Clojure. To my surprise they agreed. So I hacked together this little library to easily do all that we were already doing in our Node.js API tests. And I liked how it turned out, so I’ve &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;facundoolano&#x2F;restpect&quot;&gt;published it in GitHub&lt;&#x2F;a&gt;. Nothing too fancy but it was a good excuse to escape from JavaScript, and it got three of my coworkers learning Clojure, which is great news.&lt;&#x2F;p&gt;
&lt;p&gt;Other than that, I keep slowly growing my &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;facundoolano&#x2F;advenjure&quot;&gt;advenjure engine&lt;&#x2F;a&gt;; just &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;facundoolano.github.io&#x2F;house-taken&quot;&gt;published a full game&lt;&#x2F;a&gt; with it, based on a story by Julio Cortázar. Also been doing some &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;cljsbin-bkhgroqzwe.now.sh&#x2F;&quot;&gt;experiments with Macchiato&lt;&#x2F;a&gt;, to write Clojure web apps that run on Node.js. I have this Machine Learning book I’m about to start, see where that takes me. Node.js microservices still pay my bills. For now, I guess. At some point I hope to be able to get paid for writing Clojure.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>MLFE: ML landing in the Erlang world</title>
          <pubDate>Tue, 15 Nov 2016 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/d-day-invasion-with-mlfe-ml-landing-in-the-erlang-world/</link>
          <guid>https://blog.lambdaclass.com/posts/d-day-invasion-with-mlfe-ml-landing-in-the-erlang-world/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/d-day-invasion-with-mlfe-ml-landing-in-the-erlang-world/">&lt;p&gt;Time has passed since our last interview for &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;notamonadtutorial.com&#x2F;&quot;&gt;This is not a Monad Tutorial&lt;&#x2F;a&gt;. OpenBSD released its 6.0 version after 20 years of continues releases without agile, OpenSSL vulnerabilities keep on breeding, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;blog.bugreplay.com&#x2F;post&#x2F;152579164219&#x2F;pornhubdodgesadblockersusingwebsockets&quot;&gt;Pornhub war against ad blockers continued&lt;&#x2F;a&gt;, the Macbook Pro is not that Pro anymore, a new javascript package manager was released by Facebook and last but not least Brexit and Trump are a reality that will shape the new world order.&lt;&#x2F;p&gt;
&lt;p&gt;Going back to our endogamic tech world, I interviewed &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;noisycode.com&#x2F;&quot;&gt;Jeremy Pierre&lt;&#x2F;a&gt; about &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;j14159&#x2F;mlfe&quot;&gt;MLFE&lt;&#x2F;a&gt; or ML Flavoured Erlang. After learning Haskell and after playing with Elm I became quite a fan of ADTs and Hindley-Milner type systems so that is why I am really exited by MLFE. So I think this is a way to counterbalance my love for Lisp languages. Let’s add a little bit of ML into our coffee. One of the projects I had in my To Do list was to implement an ML like language on top of the Erlang VM&#x2F;BEAM. Instead of recreating the wheel, I hope to see further by standing upon the shoulders of MLFE. The invasion has began!&lt;&#x2F;p&gt;
&lt;p&gt;If you have any more questions please let me know via &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;vw8zb2&#x2F;d_day_invasion_with_mlfe_ml_landing_erlang&quot;&gt;lobsters&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;programming&#x2F;comments&#x2F;5d2ooi&#x2F;dday_invasion_with_mlfe_ml_landing_in_the_erlang&#x2F;&quot;&gt;reddit programming&lt;&#x2F;a&gt; or &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=12958099&quot;&gt;hn&lt;&#x2F;a&gt;. Au revoir.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-VHoeeRQqosE3Woi37aHFeA.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;2016 MLFE&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is MLFE?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;ML Flavoured Erlang is a statically typed and strict (eagerly evaluated) language for the Erlang VM patterned a little bit after parts of both OCaml and Elm. It’s incredibly early in the language’s development but we already have things like sum types and product types (e.g. tuples, records with row polymorphism) and a pretty basic foreign function interface to Erlang proper. Honestly the language is probably in need of renaming almost entirely because it’s impossible to call Erlang code directly outside of the FFI.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why did you create an ML language on top of the Erlang VM&#x2F;BEAM?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I appreciate a lot of the practicalities in the Erlang ecosystem, not least of which are the operational aspects of the VM but wanted something with faster feedback on type issues than Dialyzer currently provides, along with the brevity and expressiveness that come with features like OCaml or Elm’s ADTs. One of the earliest drivers for this was constantly wishing for Scala’s case classes every time I wrote Erlang (my day job involves both).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What are the main problems you find while coding in Erlang and while coding in ML like languages?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I don’t often work directly in ML dialects to be perfectly honest although I keep trying to find reasons to use them. Maybe that’s a subconscious reason behind starting MLFE .&lt;&#x2F;p&gt;
&lt;p&gt;As mentioned above however I do often work in Scala and its less pervasive approach to pattern matching and second class nature of things like actors on the JVM are often sore points for me. Having said that, it would be really great to have something like Scala’s Future or ScalaZ’s Task in an Erlang VM language as well. Maybe we can build something with MLFE to scratch that itch but it’s a little early to say I think.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;How did you implement the type inference algorithm?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I have to give credit (or apologize for implementing it badly?) to Oleg Kiselyov for his incredibly helpful article &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;okmij.org&#x2F;ftp&#x2F;ML&#x2F;generalization.html&quot;&gt;How OCaml type checker works&lt;&#x2F;a&gt;. I relied heavily on this, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.cis.upenn.edu&#x2F;~bcpierce&#x2F;tapl&#x2F;&quot;&gt;Types and Programming Languages&lt;&#x2F;a&gt;, and a bit on &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tomprimozic&#x2F;type-systems&#x2F;tree&#x2F;master&#x2F;algorithm_w&quot;&gt;algorithm_w&lt;&#x2F;a&gt; for the earliest work on the typer.&lt;&#x2F;p&gt;
&lt;p&gt;It started with a very basic translation to Erlang of Oleg Kiselyov’s eager&#x2F;strict inferencer examples and then grew from there. Since the algorithm relies on unification (and hence mutation), MLFE’s inferencer needs reference cells which are currently implemented as Erlang processes. I’d like to move these to something like ETS but will probably wait until trying to rewrite and clean up the typer in MLFE itself.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Do you generate core Erlang code or Erlang code?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The MLFE AST is translated to a Core Erlang AST using the “cerl” module and then compiled to BEAM modules from there.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;How do you type check messages?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In MLFE a receive block types as a &lt;em&gt;receiver&lt;&#x2F;em&gt;. Receivers are polymorphic with two parameters: the kind of messages received and the result type of the contained expression. These two parameters are determined by unifying the types in the patterns and the types in the result portion of the receive’s clauses, e.g.&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;receive with &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; 0 -&amp;gt; :zero&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; | x, is_integer x -&amp;gt; :not_zero&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;All of the above patterns are clearly integers and all of the result portions are atoms so the type (internally) in MLFE would be &lt;code&gt;{t_receiver, t_int, t_atom}&lt;&#x2F;code&gt;. As an aside we can of course use union types if we want more complex messages.&lt;&#x2F;p&gt;
&lt;p&gt;Unifying receivers with enclosing expressions makes &lt;em&gt;those&lt;&#x2F;em&gt; expressions receivers too so if we’re assigning a variable in a let expression, the whole thing becomes a receiver e.g.&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;let my_msg = receive with&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; 0 -&amp;gt; :zero&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; | x, is_integer x -&amp;gt; :not_zero &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;in [my_msg, :in_a_list, :why_not]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The above let expression is a &lt;em&gt;{t_receiver, t_int, {t_list, t_atom}}.&lt;&#x2F;em&gt; If we wrapped that in a function, the whole function is a receiver:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;foo () = let my_msg = receive with &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; 0 -&amp;gt; :zero&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; | x, is_integer x -&amp;gt; :not_zero &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;in [my_msg, :in_a_list, :why_not]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The type of the above is:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;{t_receiver, t_int, {t_arrow, [t_unit], {t_list, t_atom}}}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;That is a function from unit to a list of atoms that internally receives integer messages.&lt;&#x2F;p&gt;
&lt;p&gt;Now when we spawn a process, &lt;em&gt;spawn&lt;&#x2F;em&gt; uses the receiver’s first parameter to constrain the resulting PID to a specific type. If we spawn a function that’s a receiver of integers (resulting in a &lt;em&gt;{t_pid, t_int}&lt;&#x2F;em&gt;), all messages sent must be able to unify with &lt;em&gt;t_int&lt;&#x2F;em&gt; so if we try to send it a float or a string we get a type error at compile time.&lt;&#x2F;p&gt;
&lt;p&gt;If we spawn a function that is &lt;em&gt;not&lt;&#x2F;em&gt; a receiver, we get a &lt;em&gt;{t_pid, undefined}&lt;&#x2F;em&gt;. Since &lt;em&gt;undefined&lt;&#x2F;em&gt; will not unify with any other type, it’s a type error to send that particular process any messages at all.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;One of the biggest issues I have with Erlang is that in some cases it is necessary to write code that has a lot of nested cases. Elixir added the&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;learningelixir.joekain.com&#x2F;learning-elixir-with&#x2F;&quot;&gt;&lt;strong&gt;with&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;special form to deal with this issue. Rust 1.3 added a new&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;2016&#x2F;11&#x2F;10&#x2F;Rust-1.13.html#the--operator&quot;&gt;&lt;strong&gt;? operator&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;that provides syntax sugar that helps to deal with this issue. The RabbitMQ team created&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;blog&#x2F;2011&#x2F;05&#x2F;17&#x2F;can-you-hear-the-drums-erlando&#x2F;&quot;&gt;&lt;strong&gt;Erlando&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;using Erlang’s parse transform (Erlang like macros) that adds syntax extensions to Erlang, with the&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rabbitmq&#x2F;erlando#user-content-lots-of-different-types-of-monads&quot;&gt;&lt;strong&gt;do syntax&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;for monads being the most important one to solve somehow this issue. From what I have seen the mlfe_type.erl of MLFE also&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;j14159&#x2F;mlfe&#x2F;blob&#x2F;master&#x2F;src&#x2F;mlfe_typer.erl#L403-L427&quot;&gt;&lt;strong&gt;has this issue&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Do you plan on adding some construct or syntactic sugar to deal with this type of issue?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;This is certainly a common issue within MLFE’s typer itself. I don’t currently have plans to add any specific error handling sugar since I worry that doing so might push people away from OTP and supervision hierarchies. Having said that, I don’t think it’s at all unreasonable to have a simple error type and handling alternatives in a library. While try&#x2F;catch don’t exist yet in MLFE it could look like something as simple as the following:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;module simple_try&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;export try_f&#x2F;1, try_map&#x2F;2&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;type t &amp;#39;result &amp;#39;error = Ok &amp;#39;result | Error &amp;#39;error&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;-- try to run f, wrapping successes in Ok and failures in Error:&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;try_f f = try&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; Ok (f ())&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;catch &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; err -&amp;gt; Error err&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;-- If t is a success apply the function f to it or maintain a failed result:&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;try_map t f = match t with&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; Ok result -&amp;gt; let runner () = f result in try_f runner&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; | Error e -&amp;gt; t&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I wouldn’t call the above ideal (and we need anonymous functions to make it usable to begin with) but I think it does demonstrate that it’s relatively easy to solve the problem in a few ways without needing first-class constructs.&lt;&#x2F;p&gt;
&lt;p&gt;To be clear, I think Rust’s approach makes a great deal of sense since as far as I’m aware, its Result type is core to the language. My reluctance with doing the same in MLFE is almost entirely due to the conventions and capabilities in place with OTP that I see as beneficial in their own right.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What was the most difficult thing about implementing MLFE?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Wrapping my head around type inference and unification was definitely the most challenging thing so far. I’m still working to understand a lot of the details and I’m barely ready to dig into something like the implementation of an ML module system, especially when it comes to functors. We need parametric modules in order to type bindings to a lot of OTP so there will probably be something pretty simple and restrictive to start but I have a lot of studying and learning to do before I can be even reasonably confident we’ll still have a type system that’s decidable.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Do you have any recommendation for those of us that did not implemented any language yet?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Pick a problem or feature you find interesting and dive in! Start with a simple definitional interpreter to play with things first if you don’t want to learn an existing platform’s AST (Reynolds’ paper is &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;surface.syr.edu&#x2F;cgi&#x2F;viewcontent.cgi?article=1012&amp;amp;context=lcsmith_other&quot;&gt;great&lt;&#x2F;a&gt;) or just write an interpreter! If you wanted to target a particular runtime Core Erlang’s AST is generally pretty easy to get started with and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lfe&#x2F;&quot;&gt;LFE&lt;&#x2F;a&gt; is great to learn from. If you like the JVM then &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;graalvm&quot;&gt;Graal and Truffle&lt;&#x2F;a&gt; look really interesting too.&lt;&#x2F;p&gt;
&lt;p&gt;I haven’t yet taken the time to dig into SICP or &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;cs.brown.edu&#x2F;~sk&#x2F;Publications&#x2F;Books&#x2F;ProgLangs&#x2F;&quot;&gt;PLAI&lt;&#x2F;a&gt; (and I’ve heard Dr Krishnamurthi has been working on a new one) but want to at some point. I understand they’re both really good deep dives.&lt;&#x2F;p&gt;
&lt;p&gt;There are so many great ideas to check out and explore, recent work like Dr Jean Yang’s on &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;projects.csail.mit.edu&#x2F;jeeves&#x2F;&quot;&gt;Jeeves&lt;&#x2F;a&gt; for security policy enforcement; &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.cs.ubc.ca&#x2F;~rxg&#x2F;gtes.pdf&quot;&gt;gradual typing&lt;&#x2F;a&gt; — especially for effects — e.g. from Drs Banados Schwerter, Garcia, and Tanter; 1ML for a new approach to &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;people.mpi-sws.org&#x2F;~rossberg&#x2F;1ml&#x2F;&quot;&gt;first class modules&lt;&#x2F;a&gt; from Dr Andreas Rossberg and so much more we’ve barely dug into (Dr Barbara Liskov’s decades of work!).&lt;&#x2F;p&gt;
&lt;p&gt;We have mountains of great ideas from so many people and are barely scratching the surface, it’s really exciting. I’d enthusiastically recommend anyone with any interest in programming languages to just pick a paper to read or an idea to research and just start following where it leads. Start reading groups!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What other languages do you recommend keeping an eye on?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Rust and Pony both look like they’re doing really interesting stuff and I’m curious as to where &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;purerl&quot;&gt;purerl&lt;&#x2F;a&gt; — an Erlang backend for PureScript — will go too. There seems to be a lot of cool stuff happening on the Scheme side of things that I keep worrying I’m missing out on.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Efene: an Erlang VM language that embraces the Zen of Python</title>
          <pubDate>Fri, 27 Nov 2015 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/efene-an-erlang-vm-language-that-embraces-the-python-zen/</link>
          <guid>https://blog.lambdaclass.com/posts/efene-an-erlang-vm-language-that-embraces-the-python-zen/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/efene-an-erlang-vm-language-that-embraces-the-python-zen/">&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-Y6aaUiw3qoh372nY7WNzJg.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In this ocasion we interviewed &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;marianoguerra&quot;&gt;Mariano Guerra&lt;&#x2F;a&gt;, creator of Efene. &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;efene.org&#x2F;&quot;&gt;Efene&lt;&#x2F;a&gt; is &lt;em&gt;“an alternative syntax for the Erlang Programming Language focusing on simplicity, consistency, ease of use and programmer UX”.&lt;&#x2F;em&gt; After reading the interview with Mariano Guerra, check &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;efene.org&#x2F;quick-efene-introduction-busy-programmer.html&quot;&gt;Efene Quick Introduction for the Busy&#x2F;Lazy Programmer&lt;&#x2F;a&gt; for learning more about Efene.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why did you create efene?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I learn by doing, and a while ago I wanted to learn Erlang, it was the first functional programming language I wanted to learn coming from C, C++, ASM, Java and Python so I was looking for some toy project to learn it.&lt;&#x2F;p&gt;
&lt;p&gt;For a while I couldn’t find a project that was interesting to me and also matched the strengths of Erlang at some point I decided that I would do a small calculator in Erlang, you can see the first commit &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;marianoguerra&#x2F;match&#x2F;commit&#x2F;cc048638b4cc99719ad5c28cea2f9e8163b9661c&quot;&gt;here&lt;&#x2F;a&gt; and the full project &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;marianoguerra&#x2F;match&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;At first I was doing all the eval stuff myself but pretty quickly I added support to compile the expression to an Erlang &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;marianoguerra&#x2F;match&#x2F;commit&#x2F;6c726f641e5d651f6bb46b2ae04202e557ea022b&quot;&gt;module with a function&lt;&#x2F;a&gt;. The next commit added function support and then I realized there was a programming language there, you can read the rest of the commits to see how it morphed into one.&lt;&#x2F;p&gt;
&lt;p&gt;At that point the only other beam language other than Erlang was &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;reia-lang.org&#x2F;&quot;&gt;Reia&lt;&#x2F;a&gt;. I wasn’t planning anything in particular with my powerful calculator&#x2F;language hybrid, but at some point people from Erlang Factory asked me if I wanted to give a talk about my language and of course I said yes, then I got a dose of impostor syndrome, so I started the project from scratch to do a proper programming language and I decided to support every feature that Erlang supports and not much more. At that point the project changed from a toy to an actual programming language.&lt;&#x2F;p&gt;
&lt;p&gt;After &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.erlang-factory.com&#x2F;conference&#x2F;London2010&#x2F;speakers&#x2F;MarianoGuerra&quot;&gt;my talk&lt;&#x2F;a&gt; and some initial excitement things got quiet. I just had got my Engineers degree and had a new job so development stopped for a while, then Elixir appeared and got much more attention, so I thought “OK, someone got it right, I will just stop pushing efene” and some years passed. But then looking into Elixir I saw that the Elixir ideas weren’t exactly the ideas of efene and I decided to rewrite it to try to fill the niche of “just a different syntax for Erlang, reuse as much as possible from the Erlang ecosystem, unified tooling and documentation as the core of the project”. The language has been complete for a while now. I’m just working on documentation, rebar3 plugins andwaiting for some of the surrounding tools to mature to avoid having to redo the documentation (mainly &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rebar&#x2F;rebar3&quot;&gt;rebar3&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=YGuAXS0Cy_8&quot;&gt;cowboy 2&lt;&#x2F;a&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why do you embrace the&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.python.org&#x2F;dev&#x2F;peps&#x2F;pep-0020&#x2F;&quot;&gt;&lt;strong&gt;Zen of Python&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-6_ijRzr0oB6Zckr8GTrq4A.png&quot; alt=&quot;&quot; &#x2F;&gt; Zen of Python&lt;&#x2F;p&gt;
&lt;p&gt;Python was the first language I enjoyed coding in before I coded in C, C++, ASM and Java, but just because it was what I knew or they provided something I needed. With Python it was the first time I said “I’m a Python programmer” and not “I’m a programmer”, also the Python Argentina community helped a lot witht hat.&lt;&#x2F;p&gt;
&lt;p&gt;Python has this attitude of simplicity and community that I like and instead of coming up with an “ad hoc, informally-specified, bug-ridden, slow implementation of half of the python zen” I decided just to copy it.&lt;&#x2F;p&gt;
&lt;p&gt;David Nolen summarized it well the other day:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;swannodette&#x2F;status&#x2F;667694050426945536&quot;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;That’s why efene is a mixture of what I like about the languages, communities and philosophies of Python, Javascript and Erlang, don’t expect a lot of novelty in efene, just a remix of what’s there :).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Could you show to us a short and good example of an efene program?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I can’t think of a particularly short snippet of code that will show you all the interesting bits of efene, mainly because there are no clever parts to efene, the idea is to be regular, simple, explicit and readable.&lt;&#x2F;p&gt;
&lt;p&gt;This means it doesn’t try to win a codegolf competition, or some clever language trick.&lt;&#x2F;p&gt;
&lt;p&gt;But I think you can take a look at this project which is a client for an API that supports REST, Web Sockets, Server Sent Events and COMET and then starts some clients that send some pseudo-random stuff to test the server:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;marianoguerra&#x2F;ioriofn&#x2F;&quot;&gt;marianoguerra&#x2F;ioriofnioriofn - ioriodb client and tests in efenegithub.com&lt;img src=&quot;https:&#x2F;&#x2F;cdn-images-1.medium.com&#x2F;fit&#x2F;c&#x2F;160&#x2F;160&#x2F;0*zv67McG0GOVsOXyh.&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;If your reaction is “I understand this and this is boring”, then I would be happy :), of course knowing some Erlang will help the understanding since efene semantics and patterns are the same as Erlang’s.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Which are the biggest advantages of coding in a language that runs on top of the Erlang VM (BEAM)?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The semantics of the VM are really thought out and really simple to learn.&lt;&#x2F;p&gt;
&lt;p&gt;The stability and scalability of the platform is great and there’s a lot of people that have worked on really hard problems for a long time on top of the Erlang VM, this means you can get really good advice and help from them.&lt;&#x2F;p&gt;
&lt;p&gt;One thing I really like and I don’t think is mentioned that much is the level of runtime introspection and visibility the VM has, and the tooling that is build and can be built around it is great.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What difficulties did you find in implementing efene?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Learning the limits of the parser and what syntax is valid an unambiguous, learning to avoid introducing crazy ideas into the language because syntax and semantics are always tricky and you don’t want to have a “WAT” language.&lt;&#x2F;p&gt;
&lt;p&gt;Also learning about Erlang and its VM while doing it.&lt;&#x2F;p&gt;
&lt;p&gt;But to sum it up, it ended up not being as difficult as I thought it will be, it just requires persistence and some hammock-driven development ;)&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Do you have any recommendation for those of us that did not implemented any language yet?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Learn about lexing and parsing, then build a calculator using S-Expressions (Lisp-like) or reverse-polish syntax (Forth-like).&lt;&#x2F;p&gt;
&lt;p&gt;Start it as an interpreter, copy the semantics from a simple language you already know, coming up with good semantics is hard, don’t try to invent them the first time.&lt;&#x2F;p&gt;
&lt;p&gt;Then ride on top of a language you know, either transpile to that language or compile to bytecode or some intermediate representation.&lt;&#x2F;p&gt;
&lt;p&gt;Try to reuse as much of the tooling from the other language as possible (&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.erlang.org&#x2F;doc&#x2F;apps&#x2F;erts&#x2F;absform.html&quot;&gt;AST from Erlang&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;ast.html&quot;&gt;AST from Python&lt;&#x2F;a&gt; or similar), this will allow you to reuse all the tooling and code built around those representations.&lt;&#x2F;p&gt;
&lt;p&gt;Read about Lisps and Forth. Implement a simple Lisp (Scheme) or Forth.&lt;&#x2F;p&gt;
&lt;p&gt;Once you learn to lex and parse you can think syntax for languages and try to parse them.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is the match expression and why did you introduce it?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;At the core of efene rewrite was the concept of “Everything revolves around 4 main things, pattern matching, functions, guards and data”, pattern matching is done when using the equal sign (=), on the argument list of a function definition and on other Erlang expressions. I wanted to unify the pattern matching under a single syntax and reuse it everywhere, that’s where the “case clauses” came to be.&lt;&#x2F;p&gt;
&lt;p&gt;If you haven’t look at efene yet, the shape of efene expressions is something like:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;&amp;lt;keyword&amp;gt; [&amp;lt;expr-args&amp;gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &amp;lt;case-clauses&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    [else: &amp;lt;body&amp;gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;end&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A case-clause has this shape:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;case &amp;lt;case-args&amp;gt; [when &amp;lt;guards&amp;gt;]: &amp;lt;body&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For example try&#x2F;catch:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;try&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &amp;lt;body&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;catch&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &amp;lt;case-clauses&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    [else: &amp;lt;body&amp;gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;[after &amp;lt;body&amp;gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;end&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Receive:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;receive&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &amp;lt;case-clauses&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    [else: &amp;lt;body&amp;gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;[after &amp;lt;after-expr&amp;gt;: &amp;lt;body&amp;gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;end&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Functions:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;fn [&amp;lt;name&amp;gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &amp;lt;case-clauses&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    [else: &amp;lt;body&amp;gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;end&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You should see a pattern there, since the case keyword was already taken and it’s what Erlang use for what “match” does in efene I had to look for a new keyword.&lt;&#x2F;p&gt;
&lt;p&gt;One thing I like about python is this concept of “executable pseudocode”, I like the fact that if you read Python code aloud it sounds like what it does, so I thought “what am I doing here”, “I’m matching and expression against cases”, in imperative it would be “match A [against] case B, case C, else … end” and that’s how I ended up with match.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why did you introduce a &lt;em&gt;for&lt;&#x2F;em&gt; expression?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The initial idea for efene was to be familiar for people coming from “algol-like” or “mainstream” languages, so they can focus on learning what’s interesting about Erlang which are the semantics and the abstractions and avoid learning a new syntax on the way to epiphany.&lt;&#x2F;p&gt;
&lt;p&gt;Since list comprehensions aren’t available in many of those languages but “for” is, I decided to implement list comprehensions as a more familiar construct but in fact it does the same.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is the arrow operator and why did you add it?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;First a quick introduction for people unfamiliar with efene or the arrow operator.&lt;&#x2F;p&gt;
&lt;p&gt;There’s this thing in Erlang where if you want to apply a sequence of operations to a list you have to create a new binding for each intermediate result:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;MyList = create_list(),&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;MyList1 = op1(MyList),&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;MyList2 = op2(MyList1),&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;MyList3 = op3(MyList2),&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;MyList4 = op4(MyList3).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Then if you want to reorder or remove some of the operations you have to rearrange the names to fit.&lt;&#x2F;p&gt;
&lt;p&gt;The idea of the arrow operator is to help with that, it’s a compile operation, this means that if you write:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;MyList = create_list() -&amp;gt; op1() -&amp;gt; op2() -&amp;gt; op3() -&amp;gt; op4()&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It will compile to:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;MyList = op4(op3(op2(op1(create_list))))&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The thing is that the Erlang libraries don’t have a standard position for the thing you are operating on like in other languages where it tends to be the first argument, inspired by Clojure (&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;clojuredocs.org&#x2F;clojure.core&#x2F;-%3E&quot;&gt;http:&#x2F;&#x2F;clojuredocs.org&#x2F;clojure.core&#x2F;-%3E&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;clojuredocs.org&#x2F;clojure.core&#x2F;-%3E%3E&quot;&gt;http:&#x2F;&#x2F;clojuredocs.org&#x2F;clojure.core&#x2F;-%3E%3E&lt;&#x2F;a&gt;)&lt;br &#x2F;&gt;
I created two variants:&lt;&#x2F;p&gt;
&lt;p&gt;_“- &amp;gt;” _adds the result of evaluating the expression on the left as first argument on the function call on the right&lt;&#x2F;p&gt;
&lt;p&gt;_“- &amp;gt;&amp;gt;” _adds the result of evaluating the expression on the left as last argument on the function call on the right&lt;&#x2F;p&gt;
&lt;p&gt;But thinking about symmetry and other common idiom in Erlang and other functional languages which is higher order functions (passing functions as arguments to other functions) I decided to create the reverse of those but with a more restricted use.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;“ &amp;lt;-”&lt;&#x2F;em&gt; adds the case clauses on the right as an anonymous function as last argument on the function call on the left.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;“ &amp;lt;&amp;lt;-”&lt;&#x2F;em&gt; adds the case clauses on the right as an anonymous function as first argument on the function call on the left.&lt;&#x2F;p&gt;
&lt;p&gt;You can see it says “case clauses” and not “anonymous function”, this is because you don’t have to write the &lt;em&gt;fn&lt;&#x2F;em&gt; keyword, it gives this expression a DSL taste that I like, for example:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;lists.map(Things) &amp;lt;&amp;lt;-&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; case 0: zero&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; case A when A % 2 is 0: even&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; else odd&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;end&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Going back to the restricted uses of the right-to-left arrows it’s because since code reads from left to right, putting something on the right that is just a value doesn’t help readability hence I decided not to support it.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;I just saw that you are creating a new language for the BEAM called interfix. What is it?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;As I said above, efene is a language that doesn’t try to come up with anythingnew. This led me to avoid doing experiments on efene itself, but I still wanted to do those experiments somewhere else.&lt;&#x2F;p&gt;
&lt;p&gt;With time the number of ideas for crazy languages I had grew and condensed to a point I thought I had a nice little language. Then coming back from a conference I had a lot of dead time on airports and no internet so I decided to give it a try.&lt;&#x2F;p&gt;
&lt;p&gt;After I landed, the language was growing and all the ideas I had didn’t seem to have any problems so I kept growing it quite fast and for the last days it’s almost a complete language (in the sense that it can do everything Erlang can do).&lt;&#x2F;p&gt;
&lt;p&gt;At this point I’m finishing adding the remaining features and when everything is there and I know everything fits I will move to cleaning the code and adding some tooling and docs around it for people that want to play with a more “experimental” language.&lt;&#x2F;p&gt;
&lt;p&gt;I say experimental in the sense that it has some crazy ideas in it but not experimental in that it will crash, break backward compatibility or compile the code to wrong bytecode.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;You wrote the&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;marianoguerra.github.io&#x2F;little-riak-core-book&#x2F;&quot;&gt;&lt;strong&gt;Little Riak Core Book&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;and you gave a talk called F&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=eiVqDnA0k0U&quot;&gt;&lt;strong&gt;rom 0 to a working distributed system with riak_core&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;. Could you explain what riak core is and why it can be useful for those of us who implement distributed systems?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Riak Core is the foundation of Riak KV and other Basho projects, it’s the generic and reusable part of a “dynamo style” distributed system, it provides some abstractions and utilities to build multi-node, master-less distributed systems.&lt;&#x2F;p&gt;
&lt;p&gt;In a Riak Core based application you build your system by implemented interfaces to handle the work your application does inside virtual nodes (vnodes) that live inside a ring of vnodes, the work is done by routing commands consistently to those vnodes by hashing a key that you specify.&lt;&#x2F;p&gt;
&lt;p&gt;It also provides ways to run a command in more than one vnode and compare the results, grow or shrink the cluster without downtime, migrate vnodes between physical nodes, authentication&#x2F;authorization and a metadata system to hold information about the cluster and your application in a distributed manner.&lt;&#x2F;p&gt;
&lt;p&gt;This frees you from having to implement all this building blocks so you can focus on what actually makes your application different and building upon a tested and production ready foundation.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;While reading your blog I could see that you have used Scala and Clojure apart from Erlang. What has been your experience with Scala and Clojure? What advantages and disadvantages did you find when comparing Scala, Clojure and Erlang?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The experience with the 3 programming languages has been really good, I’ve built similar systems with those programming languages (a kind of pub&#x2F;sub system with persistence), the reason I moved this backend initially from Scala (lift+akka) to Clojure (immutant) was because the system handled lot of semi-structured data both from the frontend and the backend and I was using a lot of time putting that data into “rigid” types to serialize it to json again&lt;&#x2F;p&gt;
&lt;p&gt;after some operations, and each time the shape of the data evolved on the frontend or the storage I had to go and change those types in a backward compatible manner and it was getting really tiring since the backend was really simple in what it actually did.&lt;&#x2F;p&gt;
&lt;p&gt;So I decided to move to Clojure and it resulted in a huge reduction on code but after the code evolved I saw myself implementing this pub&#x2F;sub like system by hand with low level tools like agents, atoms and promises copying the Erlang “patterns”, at this point some customers were asking about scalability and clustering, so I decided to do a prototype using riak_core and after some coding we tried at a new project and since we could improve it fast and it was working quite nice we decided to adopt it as our default backend.&lt;&#x2F;p&gt;
&lt;p&gt;I’m still using scala for Spark jobs, I use clojure for internal tools and internal frontends with clojurescript but the backend now is Erlang.&lt;&#x2F;p&gt;
&lt;p&gt;I just want to clarify that our backend is quite simple in what it does so moving between languages in the backend is not a big deal, the bulk of what we do is in our frontend code.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>How to earn your Clojure white belt</title>
          <pubDate>Mon, 07 Sep 2015 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/how-to-earn-your-clojure-white-belt/</link>
          <guid>https://blog.lambdaclass.com/posts/how-to-earn-your-clojure-white-belt/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/how-to-earn-your-clojure-white-belt/">&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-uFlthCHz1YbmOvzhdVBrFw.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I tend to think that if I do not know how to implement something then I do not undestand completely how it works. That is why I want to learn so many things: new frameworks, programming languages, garbage collectors, type systems, compilers, editors, operating systems, protocols, kernel development. The road to enlightenment is long and difficult. To make things worse, you need to invest time on keeping up to date with technologies you thought you already knew. I usually feel like Mario in one of those levels where he needs to jump between moving clouds to reach the finish line.&lt;&#x2F;p&gt;
&lt;p&gt;That is why one of the best skills to get is being able to separate the wheat from the chaff. We have finite time and distractions are infinite. If you are going to invest time in learning a new language then you should consider Lisp which is definitely wheat of the best quality. If you don’t know why, then go read &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.paulgraham.com&#x2F;avg.html&quot;&gt;Beating the Averages&lt;&#x2F;a&gt; article. Clojure is a member of the Lisp family. If you have used a Lisp dialect such as &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.schemers.org&#x2F;&quot;&gt;Scheme&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;common-lisp.net&#x2F;&quot;&gt;Common Lisp&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Emacs_Lisp&quot;&gt;Emacs Lisp&lt;&#x2F;a&gt;, or even really alien and amazing creatures such &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.shenlanguage.org&#x2F;&quot;&gt;Shen&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;lfe.io&#x2F;&quot;&gt;LFE&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;racket-lang.org&#x2F;&quot;&gt;Racket&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;pixie-lang&#x2F;pixie&quot;&gt;Pixie&lt;&#x2F;a&gt; you might ask yourself why you should be learning Clojure. This is my opinionated point of view:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The language’s creator: Rich Hickey has a holistic understanding of this era development issues. You should read&#x2F;watch his talks called &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;matthiasn&#x2F;talk-transcripts&#x2F;blob&#x2F;master&#x2F;Hickey_Rich&#x2F;AreWeThereYet.md&quot;&gt;Are We There Yet?&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;matthiasn&#x2F;talk-transcripts&#x2F;blob&#x2F;master&#x2F;Hickey_Rich&#x2F;SimpleMadeEasy.md&quot;&gt;Simple Made Easy&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;ROor6_NGIWU&quot;&gt;The Language of the System&lt;&#x2F;a&gt;. I see Clojure as a step in the right direction for tackling this era’s development issues&lt;&#x2F;li&gt;
&lt;li&gt;Great functional programming support: First class functions, persistent, immutable data structures and lazy &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.braveclojure.com&#x2F;core-functions-in-depth&#x2F;#2__The_Sequence_Abstraction&quot;&gt;sequences&lt;&#x2F;a&gt;. It has great support of polimorphism thanks to &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;clojure-doc.org&#x2F;articles&#x2F;language&#x2F;polymorphism.html&quot;&gt;multimethods and protocols&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Concurrency support from its inception thanks to &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;clojure-doc.org&#x2F;articles&#x2F;language&#x2F;concurrency_and_parallelism.html&quot;&gt;atoms, agents, refs, a software transactional memory &lt;&#x2F;a&gt;system and asynchronous programming using channels a la &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Communicating_sequential_processes&quot;&gt;CSP&lt;&#x2F;a&gt; with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;clojure.com&#x2F;blog&#x2F;2013&#x2F;06&#x2F;28&#x2F;clojure-core-async-channels.html&quot;&gt;core.async&lt;&#x2F;a&gt; library&lt;&#x2F;li&gt;
&lt;li&gt;Batteries included: good core libraries and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=6mTbuzafcII&quot;&gt;transducers&lt;&#x2F;a&gt; support&lt;&#x2F;li&gt;
&lt;li&gt;Clojurescript: Clojure that targets JavaScript with great libraries such as &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;reagent-project&#x2F;reagent&quot;&gt;reagent&lt;&#x2F;a&gt;, an interface to React.js that is really simple and useful. Check David Nolen’s talks called ClojureScript: &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;MTawgp3SKy8&quot;&gt;Lisp’s Revenge&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;-I5ldi2aJTI&quot;&gt;Introduction to ClojureScript&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;JVM’s power (available almost everyhwere, optimized garbage collector, JIT compilation, Java interoperability), but also some issues such as not being able to properly support tail call optimization and awful stacktraces. If you are a Java developer you should check part &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=P76Vbsk_3J0&quot;&gt;I&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=hb3rurFxrZ8&quot;&gt;II&lt;&#x2F;a&gt; from Rich Hickey’s Clojure for Java Programmers talk&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;ready-steady-go&quot;&gt;Ready, steady, go!&lt;&#x2F;h3&gt;
&lt;p&gt;Install &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;leiningen.org&#x2F;#install&quot;&gt;Leiningen&lt;&#x2F;a&gt; and configure your editor of choice.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Emacs with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;clojure-emacs&#x2F;cider&quot;&gt;Cider&lt;&#x2F;a&gt; &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;clojure-emacs&#x2F;clojure-mode&quot;&gt;Clojure mode&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;company-mode.github.io&quot;&gt;Company mode&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Vim with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tpope&#x2F;vim-fireplace&quot;&gt;vim-fireplace&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tpope&#x2F;vim-sexp-mappings-for-regular-people&quot;&gt;im-sexp-mappings-for-regular-people&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tpope&#x2F;vim-salve&quot;&gt;vim-salve&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;luochen1990&#x2F;rainbow&quot;&gt;rainbow&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;lighttable.com&#x2F;&quot;&gt;Light Table&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;sekao.net&#x2F;nightcode&#x2F;&quot;&gt;Nightcode&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Sublime with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;odyssomay&#x2F;paredit&quot;&gt;paredit&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;odyssomay&#x2F;sublime-lispindent&quot;&gt;Lispindent&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.google.com.ar&#x2F;search?q=SublimeREPL&quot;&gt;SublimeREPL&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;cursiveclojure.com&#x2F;&quot;&gt;Cursive&lt;&#x2F;a&gt; (IntelliJ)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;doc.ccw-ide.org&#x2F;documentation.html#install-as-standalone-product&quot;&gt;Counterclockwise&lt;&#x2F;a&gt; (Eclipse)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;good-tools-that-deserve-a-mention&quot;&gt;Good tools that deserve a mention&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;Linter &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jonase&#x2F;eastwood&quot;&gt;Eastwood&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Idiomatic Clojure checker &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jonase&#x2F;kibit&quot;&gt;kibit&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Clojure formatter &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;weavejester&#x2F;cljfmt&quot;&gt;cljfmt&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Check simple issues in your code &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;dakrone&#x2F;lein-bikeshed&quot;&gt;bikeshed&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;love-at-first-sight&quot;&gt;Love at first sight&lt;&#x2F;h3&gt;
&lt;p&gt;First of all get an idea of Clojure syntax and semantics:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;learnxinyminutes.com&#x2F;docs&#x2F;clojure&#x2F;&quot;&gt;Learn X in Y minutes where X=clojure&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;kimh.github.io&#x2F;clojure-by-example&#x2F;&quot;&gt;Clojure by example&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;howistart.org&#x2F;posts&#x2F;clojure&#x2F;1&#x2F;&quot;&gt;How I start Clojure&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.se-radio.net&#x2F;2010&#x2F;03&#x2F;episode-158-rich-hickey-on-clojure&#x2F;&quot;&gt;Listen to Software Engineering Radio’s interview with Rich Hickey&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;If you do not understand something move on. At this stage the only objective is to grasp some basic ideas about Clojure.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;practice-plus-reading-equals-perfection&quot;&gt;Practice plus reading equals perfection&lt;&#x2F;h4&gt;
&lt;ol&gt;
&lt;li&gt;First practice with the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;clojurekoans.com&#x2F;&quot;&gt;Koans&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Then read &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.braveclojure.com&#x2F;&quot;&gt;Clojure for the Brave and True&lt;&#x2F;a&gt;, a simple and short book. If you prefer to watch videos, you can buy the course &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.purelyfunctional.tv&#x2F;intro-to-clojure&quot;&gt;Introduction to Clojure&lt;&#x2F;a&gt; from PurelyFunctionalTV.&lt;&#x2F;li&gt;
&lt;li&gt;Practice again with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.4clojure.com&#x2F;&quot;&gt;4clojure problems&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Follow the road to perfection with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;exercism.io&#x2F;languages&#x2F;clojure&quot;&gt;Clojure exercism&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Finish the practice with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;gigasquid&#x2F;wonderland-clojure-katas&quot;&gt;Wanderland Clojure Katas&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;It is always a good idea to have the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;clojure.org&#x2F;api&#x2F;cheatsheet&quot;&gt;cheatsheet&lt;&#x2F;a&gt; at hand.&lt;&#x2F;p&gt;
&lt;p&gt;Other two good tutorials worth mentioning are &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;aphyr.com&#x2F;tags&#x2F;Clojure-from-the-ground-up&quot;&gt;Clojure from the ground up&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;hitchhikersclojure.com&#x2F;&quot;&gt;Hitchhiker’s Guide to Clojure&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;idiomatic-clojure&quot;&gt;Idiomatic Clojure&lt;&#x2F;h4&gt;
&lt;p&gt;Clojure is not Java, neither Common Lisp or Scheme. You should learn to write idiomatic Clojure. The Joy of Clojure is your best friend to become a native Clojure speaker:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.joyofclojure.com&#x2F;the-book&#x2F;&quot;&gt;About The Joy of ClojureWhen this book was conceived, our first instinct was to create a comprehensive com- parison between Clojure and its…www.joyofclojure.com&lt;img src=&quot;https:&#x2F;&#x2F;cdn-images-1.medium.com&#x2F;fit&#x2F;c&#x2F;160&#x2F;160&#x2F;0*B4upiW5LhjZYt_TK.&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;It is also important to follow table manners or the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;bbatsov&#x2F;clojure-style-guide&quot;&gt;Clojure style guide&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;If you have trouble like me grasping macros, then you should also check out &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;pragprog.com&#x2F;book&#x2F;cjclojure&#x2F;mastering-clojure-macros&quot;&gt;Mastering Clojure Macros&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Oh, if you miss your type checking then now it is a good time that you read about &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;typedclojure.org&#x2F;&quot;&gt;optional type system&lt;&#x2F;a&gt; for Clojure.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;keep-up-to-date&quot;&gt;Keep up to date&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;planet.clojure.in&#x2F;&quot;&gt;Planet Clojure&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.clojuregazette.com&#x2F;&quot;&gt;Clojure Gazette&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;reborg.tumblr.com&#x2F;&quot;&gt;Clojure Weekly&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;Clojure&#x2F;&quot;&gt;Reddit&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;user&#x2F;ClojureTV&quot;&gt;ClojureTV&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;know-the-full-arsenal-at-your-disposal&quot;&gt;Know the full arsenal at your disposal&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.clojure-toolbox.com&#x2F;&quot;&gt;Clojure Toolbox&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;razum2um&#x2F;awesome-clojure&quot;&gt;Awesome Clojure&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;get-help&quot;&gt;Get help&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;groups.google.com&#x2F;forum&#x2F;#!forum&#x2F;clojure&quot;&gt;Google Group&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;IRC: #clojure channel in Freenode server&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;clojurians.slack.com&#x2F;&quot;&gt;Clojurians Slack&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;introduction-to-clojurescript&quot;&gt;Introduction to Clojurescript&lt;&#x2F;h4&gt;
&lt;p&gt;Clojure on the frontend trench:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;clojurescript&#x2F;wiki&#x2F;Quick-Start&quot;&gt;Quickstart&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;clojurescript&#x2F;wiki&#x2F;Differences-from-Clojure&quot;&gt;Differences from Clojure&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;magomimmo&#x2F;modern-cljs&quot;&gt;A series of tutorials on Clojurescript&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h4 id=&quot;building-your-own-lisp&quot;&gt;Building your own Lisp&lt;&#x2F;h4&gt;
&lt;p&gt;Building a Lisp is similar to a road trip with friends and good music but with no particular destination. Make yourself comfortable and enjoy the ride!&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.buildyourownlisp.com&#x2F;&quot;&gt;Build your own Lisp&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikibooks.org&#x2F;wiki&#x2F;Write_Yourself_a_Scheme_in_48_Hours&quot;&gt;Write Yourself a Scheme in 48 hours&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;norvig.com&#x2F;lispy.html&quot;&gt;(How to Write a (Lisp) Interpreter (in Python))&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
      </item>
      <item>
          <title>Interview with Nenad Rakocevic about Red, a Rebol inspired programming language</title>
          <pubDate>Fri, 28 Aug 2015 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/interview-with-nenad-rakocevic-about-red-a-rebol-inspired-programming-language/</link>
          <guid>https://blog.lambdaclass.com/posts/interview-with-nenad-rakocevic-about-red-a-rebol-inspired-programming-language/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/interview-with-nenad-rakocevic-about-red-a-rebol-inspired-programming-language/">&lt;p&gt;After our &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;this-is-not-a-monad-tutorial&#x2F;interview-with-brian-mckenna-about-roy-purescript-haskell-idris-and-dependent-types-63bb1289ea3d&quot;&gt;last interview with Brian McKenna&lt;&#x2F;a&gt; for &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;this-is-not-a-monad-tutorial&quot;&gt;This is not a Monad tutorial&lt;&#x2F;a&gt; we interviewed &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;dockimbel&quot;&gt;Nenad Rakocevic&lt;&#x2F;a&gt;, creator of the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.red-lang.org&#x2F;&quot;&gt;Red&lt;&#x2F;a&gt; programming language.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-C0sMUPxpbBs40YIBX848jQ.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;From my completely subjective point of view Red and Rebol are quite strange creatures! But don’t get me wrong, that doesn’t mean something bad. For example, I am not aware of many high-level languages which features an embedded DSL for general-purpose low-level programming or that have 50 native types. You should check it out, you might find some interesting ideas inside Red development.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Please tell us a little bit about Red’s inception. Why was it created?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-869fRKUVs2sTdVDYrqblMQ.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I started programming micro-computers, an Amiga in my case, in my teens. I have now been programming for more than 30 years. After my early experiences, I was unhappy with existing programming languages and tools. This was mostly because I found them not productive or friendly enough for my taste. So, when I stumbled across the Rebol language, in 1999, it was an eye-opener on what was wrong with so called “modern” computing practice. (Nowadays it’s even worse). Fighting complexity on all software fronts became the logical course of action.&lt;&#x2F;p&gt;
&lt;p&gt;In 2010, Rebol was closed source. I deeply felt that the approach had a lot more to offer but Rebol was barely evolving. This was the trigger for me to start work on an open source relative to Rebol with much higher ambitions and a broader field of usage.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What are the main selling points of Red?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;First fullstack programming solution: combines in one tool, the ability to write high-level code (GUI apps, scripting and DSL) and fast low-level code (writing device drivers, operating systems, native interfacing, etc). Moreover, Red is also a &lt;em&gt;both-sided&lt;&#x2F;em&gt; technology (client &amp;amp; server).&lt;&#x2F;li&gt;
&lt;li&gt;Cross-platform native code compiler: from any platform the toolchain runs on, you can compile to about 15 other platforms, with a simple command-line option (-t Windows, -t Linux, -t Darwin, -t RPi, …).&lt;&#x2F;li&gt;
&lt;li&gt;Extremely lightweight: Red is a 1MB, single-file, no install, no setup, toolchain. It takes typically a few seconds to download and you can immediatly start writing and running code, there’s &lt;em&gt;nothing&lt;&#x2F;em&gt; to setup (it’s just terrible that this is the exception instead of being the norm…).&lt;&#x2F;li&gt;
&lt;li&gt;Batteries-included solution: it comes with a very rich runtime library, despite its tiny size, covering pretty much anything you need for common tasks.&lt;&#x2F;li&gt;
&lt;li&gt;DSL-oriented environment: Red comes with many embedded DSL addressing important needs (like GUI or system-programming). DSL are a very powerful way to reduce complexity arising from frameworks or API, while drastically increasing productivity. Red includes a DSL (called Parse) for constructing DSLs.&lt;&#x2F;li&gt;
&lt;li&gt;Red (like Rebol) is a Lisp derivative, but with a human-friendly syntax (no parenthesis hell). Red is its own data format. All code is treated as data until you evaluate it, code&#x2F;data serialization comes for free. The minimal punctuation makes it easy on the eye.&lt;&#x2F;li&gt;
&lt;li&gt;The underlying philosophy of Red (as was that of Rebol) is to make the simple easy and the difficult possible.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;What made Rebol the main inspiration for Red?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Rebol is one of the most innovative programming language created in the last 20 years. Sadly, it remained under the radar being closed source at a time when open-source languages like Perl, Python and Ruby hit the streets. Rebol’s approach shakes the foundation of what programmers consider “simple” or “efficient” in programming. Typically, API which other languages would call “simple”, look uselessly complicated when you are used to wear Rebol glasses. ;-) Here are a few one-liners as examples (using the Rebol2 REPL):&lt;&#x2F;p&gt;
&lt;p&gt;Create a GUI window with a button printing, on click, Hello in the console:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;view layout [button “Click Me” [print “Hello”]]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Dump the content of a web page in console:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;print read http:&#x2F;&#x2F;rebol.com&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Extract the title of a web page:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;parse read http:&#x2F;&#x2F;rebol.com [thru &amp;lt;title&amp;gt; copy text to &amp;lt;&#x2F;title&amp;gt; (print text)]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Send the list of files in current folder by email:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;send user@domain.com mold read %.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Retrieve records from a MySQL database and print them in console:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;foreach row read&#x2F;custom mysql:&#x2F;&#x2F;root@localhost&#x2F;books [“SELECT * FROM authors”] [print row]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Notice that even if you never looked at Rebol code before, you can nonetheless read it and guess what most of the code is doing.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What are the main differences between Rebol and Red?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Red can be (cross-)compiled to native code, Rebol is only interpreted. Compiled code can run much faster than interpreted code.&lt;&#x2F;li&gt;
&lt;li&gt;Red allows system-programming and fast low-level code, Rebol is stuck at scripting-level.&lt;&#x2F;li&gt;
&lt;li&gt;Red relies on native widgets and native backends for GUI support, Rebol has a custom GUI engine. So Red will make your GUI apps feel more natural and better integrated to the OS user.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Besides that, the languages itself are very similar, somewhere around 95% the same. If you know Rebol, you know Red.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Red covers the whole range of abstraction between low-level and high-level programming by offering Red&#x2F;System as a dialect with C-type semantics and Rebol-type syntax. Was the distinction between Red and Red&#x2F;System present in the original design? What advantages do you gain by using Red&#x2F;System?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Absolutely, Red&#x2F;System was one of the main incentive to build a new programming stack instead of simply duplicating the Rebol implementation. Red&#x2F;System is a statically compiled language targetting native code (like C). Red&#x2F;System serves two main purposes:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;provide an embedded DSL to Red users for fast code support and system programming needs&lt;&#x2F;li&gt;
&lt;li&gt;fill the role of an IR (Intermediate Representation) language for compiled Red code&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;AFAIK, Red is the first high-level language which features such embedded DSL for general-purpose low-level programming.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Who uses Red&#x2F;Rebol?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The Rebol community used to be relatively big in the early 2000, but it shrank a lot as its evolution tailed off. The profile of users was astonishly broad on the skills scale. Many were attracted by its simplicity for simple tasks and its cross-platform GUI engine, but other were more interested by its depth (dynamic binding, easy DSL crafting, strong meta-programming abilities, …).&lt;&#x2F;p&gt;
&lt;p&gt;Since then, only the hardcore fans or companies which have built their software on top of it, continue to use and promote it. Many of those same people now form the early adopters for Red, along with many other people which were interested in Rebol when it launched, but rejected it due to its closed-source nature. Some of them wrote libraries for Red, other small games or even a Windows device driver! :-) As soon as Red is ready for production, we’ll make sure many more people will join them and have fun using Red.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;For which scenarios do you think Red is an appropriate language?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Red is a general-purpose programming solution which should be good enough for &lt;em&gt;any&lt;&#x2F;em&gt; programming task. In practice, it’s (only) limited by the available frameworks and libraries. So these tasks are a very good match for Red:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;scripting &#x2F; glue code&lt;&#x2F;li&gt;
&lt;li&gt;GUI apps (in upcoming v0.6.0)&lt;&#x2F;li&gt;
&lt;li&gt;Android apps (in v0.6.1)&lt;&#x2F;li&gt;
&lt;li&gt;data processing&lt;&#x2F;li&gt;
&lt;li&gt;grammar parsers &#x2F; DSL creation&lt;&#x2F;li&gt;
&lt;li&gt;system programming&lt;&#x2F;li&gt;
&lt;li&gt;device drivers&lt;&#x2F;li&gt;
&lt;li&gt;IoT devices programming (runinng on Intel or ARM cpu)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Once we reach 1.0 (next year), Red will also be very good for:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;webapps programming&lt;&#x2F;li&gt;
&lt;li&gt;servers creation&lt;&#x2F;li&gt;
&lt;li&gt;2D games&lt;&#x2F;li&gt;
&lt;li&gt;robotics&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Rebol and Red offer a great variety of built in types with practical applications. Some would argue that it is better to offer a small core of language features. What is your take on that?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Rebol and Red offer about 50 datatypes in a runtime of about 500KB. Among them, two-thirds have a specific literal form (like money, email, url, time, date, colors,…) which gives you, out of the box, a rich set of literals you can use for building embedded DSL.&lt;&#x2F;p&gt;
&lt;p&gt;Another big gain is that most of the features you need for daily work are already there, as first-class citizens, perfectly integrated with the rest, working exactly the same on every supported platform. This is a productivity boost and makes learning&#x2F;using the language much more pleasant (no need to make “imports” for any simple task). Such languages are pragmatic and aiming at reducing the costs of software building.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is a sky-high view of how Red is implemented? Are all the components (parsers, code generators, garbage collectors, etc) hand-written? What dependencies does Red have?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Excepting for a good part of the unit tests, which are generated by script, everything else is hand-written. We are bootstrapping Red using Rebol, so the toolchain (compilers, linker, builders) is written in Rebol2. Rebol offers a parsing DSL which is very effective, adding to that its deep metaprogramming abilities, there is simply no need to use any other tool for building such toolchain. Red scripts can be interpreted from the REPL or compiled to native code, using Red&#x2F;System as intermediary target. The runtime library is built in a mix of Red and Red&#x2F;System code.&lt;&#x2F;p&gt;
&lt;p&gt;Red executables are typically around 0.5MB and have no dependencies.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;How complete is Red as of Mid-2015?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;There’s already a lot implemented, so I’ll describe rather what’s missing. Right now, we are completing the cross-platform GUI support with a first backend for Windows. Android, Linux and OS X backends will follow. The I&#x2F;O is currently limited to simple file operations and HTTP client support only. Modular compilation, full garbage collector and concurrency support are the main features missing before reaching 1.0. We aim at launching the 1.0 release in 2016.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Where do you see Red in the future?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Red has the potential to seduce many developers (especially indie-developers who have the freedom of choice) who are frustrated by existing tools (even the so-called “simple” ones). I expect Red to be wide-spread in a couple of years, helping programmers achieving many different tasks while having fun doing it and making their life easier. Red will expand with many strong DSL for various domains, offering nice replacements for existing libraries direct usage. For example, we’ll push it in robotic and AI fields.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What are the most important lessons learned from the development of Red?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Open-source is a superior way to build quality software (just confirmed that fact with Red project).&lt;&#x2F;li&gt;
&lt;li&gt;Working “in the open” is not always a good thing, sometimes you need to isolate yourself from the outside “noise” to execute complex tasks (mostly design tasks). Being able to do so is increasingly difficult as the project growths up.&lt;&#x2F;li&gt;
&lt;li&gt;Having to deal with a growing community of users consumes a &lt;em&gt;lot&lt;&#x2F;em&gt; of time. Finding people to deal with the community for you is critical.&lt;&#x2F;li&gt;
&lt;li&gt;Designing good syntactic rules is &lt;em&gt;way&lt;&#x2F;em&gt; more difficult than designing good semantics. That’s a part overlooked by many language designers, which end up with great semantics but terrible syntaxes.&lt;&#x2F;li&gt;
&lt;li&gt;Writing a native code compiler for a statically typed language is really not difficult, most programmers with a minimal CS background could do it, they’re just not aware they can.&lt;&#x2F;li&gt;
&lt;li&gt;Premature optimization can (often) bite you in the back. Knowing when you’re optimizing prematurely is a bit of a black art.&lt;&#x2F;li&gt;
&lt;li&gt;Every big software project should be started by a team of at least 2 highly tuned, equally skilled developers. Working alone on big projects is insane, and not a guarantee of best results.&lt;&#x2F;li&gt;
&lt;li&gt;If you work on an open-source project that is attractive enough and gather enough followers, you can live from user’s donations (I did so for 2 years, covering all my basic life expenses). I never thought that would be possible when I started, nor did I counted on it. I guess I’m just lucky that Red has an amazing community.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;What reading material do you recommend for implementing your first programming language?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;You can have a good overview of all the required parts in a book like this &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.goodreads.com&#x2F;book&#x2F;show&#x2F;112256.Modern_Programming_Languages&quot;&gt;Modern Programming Languages: A Practical Introduction&lt;&#x2F;a&gt;. If you want to go in-depth and dive into more abstract concerns, the “Dragon book” is still the reference.&lt;&#x2F;p&gt;
&lt;p&gt;But the most useful way is to study several small languages implementation, that will give you the best insights about how to achieve it yourself. For example, Red 0.1.0 release is just a 24KB zip archive, but features already a working compiler&#x2F;linker for Red&#x2F;System with many features already (including FFI). Get it from here: &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;red&#x2F;red&#x2F;releases&#x2F;tag&#x2F;v0.1.0&quot;&gt;https:&#x2F;&#x2F;github.com&#x2F;red&#x2F;red&#x2F;releases&#x2F;tag&#x2F;v0.1.0&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What other languages or technologies are you keeping an eye?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Go: it’s the language with the fastest growth in the last years, understanding why, could be a key to help Red growing faster too. Go’s concurrency model also seems attractive to users, so worth studying.&lt;&#x2F;li&gt;
&lt;li&gt;Lua: trying to understand where it’s heading and how it grows.&lt;&#x2F;li&gt;
&lt;li&gt;Python3.x: trying to understand where it’s heading, not sure I understand its strategy though.&lt;&#x2F;li&gt;
&lt;li&gt;Webassembly: the foundation for the future of web programming.&lt;&#x2F;li&gt;
&lt;li&gt;MagicLeap: the future of HCI!&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
      </item>
      <item>
          <title>Interview with Brian McKenna about Roy, Purescript, Haskell, Idris and dependent types</title>
          <pubDate>Wed, 26 Aug 2015 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/interview-with-brian-mckenna-about-roy-purescript-haskell-idris-and-dependent-types/</link>
          <guid>https://blog.lambdaclass.com/posts/interview-with-brian-mckenna-about-roy-purescript-haskell-idris-and-dependent-types/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/interview-with-brian-mckenna-about-roy-purescript-haskell-idris-and-dependent-types/">&lt;p&gt;As promised in our &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;this-is-not-a-monad-tutorial&#x2F;eric-merritt-erlang-and-distributed-systems-expert-gives-his-views-on-beam-languages-hindley-a09b15f53a2f&quot;&gt;last interview&lt;&#x2F;a&gt; for &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;this-is-not-a-monad-tutorial&quot;&gt;This is not a Monad tutorial&lt;&#x2F;a&gt; we interviewed &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;puffnfresh&quot;&gt;Brian McKenna&lt;&#x2F;a&gt;, creator of the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;roy.brianmckenna.org&#x2F;&quot;&gt;Roy&lt;&#x2F;a&gt; programming language. In this interview Brian talks about Roy, its implementation, how it compares with Purescript, and also about dependent types and other interesting technologies like Morte and Unison. I highly recommend that you check &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;brianmckenna.org&#x2F;blog&#x2F;&quot;&gt;Brian’s blog&lt;&#x2F;a&gt; after you finish reading this interview.&lt;&#x2F;p&gt;
&lt;p&gt;In the following weeks we will be talking with the creators of &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.red-lang.org&#x2F;&quot;&gt;Red programming language&lt;&#x2F;a&gt;, Robert Virding — Erlang co-inventor and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;lfe.io&#x2F;&quot;&gt;Lisp Flavored Erlang&lt;&#x2F;a&gt; creator — and with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;mirage.io&#x2F;&quot;&gt;MirageOS unikernel&lt;&#x2F;a&gt; dev team.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-vYf7TCGE19Gni5ssKXQaHA.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What are Roy’s main features?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Roy featured things common to languages which are well suited to typed&lt;br &#x2F;&gt;
functional programming:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Types and type inference (with row polymorphism)&lt;&#x2F;li&gt;
&lt;li&gt;Algebraic data types and pattern matching&lt;&#x2F;li&gt;
&lt;li&gt;Monadic syntax&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Why did you create it?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I created Roy after doing years of JavaScript work. I learned Haskell&lt;br &#x2F;&gt;
and it made a huge amount of sense to me. Functional programming with&lt;br &#x2F;&gt;
types seemed like the ideal way for me to work on software and so I&lt;br &#x2F;&gt;
wanted to bring it to web programming.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;I am tempted to say that Roy has some big similarities with&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.purescript.org&#x2F;&quot;&gt;&lt;strong&gt;Purescript&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;. What are the main differences between the two languages?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Roy was first!&lt;&#x2F;p&gt;
&lt;p&gt;PureScript had almost the exact same goals as Roy but had a much&lt;br &#x2F;&gt;
better implementation. Quoting the PureScript wiki:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Roy is probably the most similar language on the list, and was a&lt;br &#x2F;&gt;
large influence on the development of PureScript.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;I stopped working on Roy once PureScript got around equal in&lt;br &#x2F;&gt;
functionality. PureScript’s implementation means it’s a lot easier to&lt;br &#x2F;&gt;
work on and has much fewer bugs.&lt;&#x2F;p&gt;
&lt;p&gt;Originally the PureScript FFI started off being very different (i.e.&lt;br &#x2F;&gt;
it used inline JS instead of an externs file) but recently changed to&lt;br &#x2F;&gt;
being similar to the original design Roy had. That was probably the&lt;br &#x2F;&gt;
biggest difference the projects had.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;You implemented the lexer and the parser. Did you do so to learn&#x2F;play or because you thought that the available tools were not good enough?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I implemented a whitespace sensitive lexer which was passed into the&lt;br &#x2F;&gt;
Jison parser generator. It was the same approach which CoffeeScript&lt;br &#x2F;&gt;
took.&lt;&#x2F;p&gt;
&lt;p&gt;A custom lexer was necessary because the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;this-is-not-a-monad-tutorial&#x2F;interview-with-brian-mckenna-about-roy-purescript-haskell-idris-and-dependent-types-63bb1289ea3d&quot;&gt;Jison&lt;&#x2F;a&gt; lexer generator was not&lt;br &#x2F;&gt;
capable of stateful scanning of whitespace.&lt;&#x2F;p&gt;
&lt;p&gt;I prefer working with parser combinators such as Parsec and Trifecta.&lt;br &#x2F;&gt;
They’re easier to work with and allow you to write reusable&lt;br &#x2F;&gt;
abstractions.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why did you use a whitespace sensitive grammar a la Python&#x2F;Haskell in Roy?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Just to look like Haskell. I hate thinking about syntax — I copy&lt;br &#x2F;&gt;
things as much as I can. I’m also annoyed that we’re still writing&lt;br &#x2F;&gt;
programs using text. They’re trees, not lists of characters!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why is it useful to have monadic sugar in a language that has unrestricted side effects?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Roy was not designed to allow side-effects, but you could do anything&lt;br &#x2F;&gt;
with the FFI and so it was possible.&lt;&#x2F;p&gt;
&lt;p&gt;Scala has (pretty limited) monadic sugar and also unrestricted&lt;br &#x2F;&gt;
side-effects. People use monadic sugar for things as straight-forward&lt;br &#x2F;&gt;
as Option:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;for {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  name &amp;lt;- maybeFirstName&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  user &amp;lt;- lookup(name)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  avatar &amp;lt;- getAvatar(user)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;} yield avatar&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which can be easier to type than:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;maybeFirstName.flatMap { name =&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  lookup(name).flatMap { user =&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    getAvatar(user)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It doesn’t have anything to do with side-effects.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;From what we could read in the Damas-Hindley-Milner type inference algorithm source comments it is based on Robert Smallshire’s Python code. Do you have any recommendation for those who want to implement it?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I recommend reading “Generalizing Hindley-Milner Type Inference&lt;br &#x2F;&gt;
Algorithms” which turns the algorithm into explicit separate&lt;br &#x2F;&gt;
constraint collection and constraint solving problems, which is a bit&lt;br &#x2F;&gt;
easier to work with than plain Algorithm W. It’s then possible to do&lt;br &#x2F;&gt;
tree annotation via the cofree comonad, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;brianmckenna.org&#x2F;blog&#x2F;type_annotation_cofree&quot;&gt;which gives a pretty nice&lt;&#x2F;a&gt;&lt;br &#x2F;&gt;
&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;brianmckenna.org&#x2F;blog&#x2F;type_annotation_cofree&quot;&gt;implementation&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What reading material do you recommend for implementing your first programming language?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Source code of other languages are great resources. I think the&lt;br &#x2F;&gt;
PureScript and Idris compilers are somewhat easy to play around with.&lt;&#x2F;p&gt;
&lt;p&gt;Hackage has a lot of code to look at, such as reference&lt;br &#x2F;&gt;
implementations of Algorithm W:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;hackage.haskell.org&#x2F;packages&#x2F;&quot;&gt;https:&#x2F;&#x2F;hackage.haskell.org&#x2F;packages&#x2F;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What would you recommend us to read to learn about different type systems?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.cis.upenn.edu&#x2F;~bcpierce&#x2F;tapl&#x2F;&quot;&gt;Types and Programming Languages&lt;&#x2F;a&gt; by Benjamin Pierce is a brilliant&lt;br &#x2F;&gt;
resource for understanding both. It’s surprised me by being a very&lt;br &#x2F;&gt;
good introduction to types and having pretty good reference&lt;br &#x2F;&gt;
implementations in OCaml for each of the discussed type-systems. Very&lt;br &#x2F;&gt;
highly recommended.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Have you tried&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;elm-lang.org&#x2F;&quot;&gt;&lt;strong&gt;Elm&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;? What do you think of&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Functional_reactive_programming&quot;&gt;&lt;strong&gt;FRP&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I think Functional Reactive Programming could be generalised a bit to&lt;br &#x2F;&gt;
just general stream combinator libraries and we could make it as&lt;br &#x2F;&gt;
simple as libraries such as pipes, machines and scalaz-stream. I’d&lt;br &#x2F;&gt;
like to implement one of those libraries in PureScript and try to&lt;br &#x2F;&gt;
write combinators to fill in the gaps for developing user interfaces&lt;br &#x2F;&gt;
to see how close we get to current FRP libraries.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;You recently gave a talk about&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.idris-lang.org&#x2F;&quot;&gt;&lt;strong&gt;Idris&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;, a language with&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dependent_type&quot;&gt;&lt;strong&gt;dependent types&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;. Could you explain what are dependent types?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In non-dependently typed languages we have a way of making values&lt;br &#x2F;&gt;
depend upon other values: functions! In dependent typed languages we&lt;br &#x2F;&gt;
have those functions, but also functions which can return types.&lt;&#x2F;p&gt;
&lt;p&gt;Haskell has two completely separate languages: the language of values&lt;br &#x2F;&gt;
and the language of types. Recent versions of GHC give a way of&lt;br &#x2F;&gt;
promoting certain values up to types, but if you want to write a&lt;br &#x2F;&gt;
function over those values, you’ll have to write a version at the&lt;br &#x2F;&gt;
value level and separately at the type level.&lt;&#x2F;p&gt;
&lt;p&gt;Dependent-types remove the separation. If you write a function, you&lt;br &#x2F;&gt;
can reuse it for terms at any level.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What are the practical benefits of using a language with dependent types?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Since you can use values in your types, you can specify a lot more.&lt;br &#x2F;&gt;
For example, I can specify that list reversal is an involution, i.e.&lt;br &#x2F;&gt;
reversing twice is the same as not reversing at all:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;reverseInvolution : (xs : List a) -&amp;gt; reverse (reverse xs) = r&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;No need for tests — if I implement a value for that type, I have a&lt;br &#x2F;&gt;
proof for all possible values.&lt;&#x2F;p&gt;
&lt;p&gt;Or we can specify that a sort function will generate a list where each&lt;br &#x2F;&gt;
element is smaller than the next. The implementation of sort will only&lt;br &#x2F;&gt;
compile if we prove that to be true.&lt;&#x2F;p&gt;
&lt;p&gt;We can also do things like metaprogramming, since we know more about&lt;br &#x2F;&gt;
the values which are passed in, we can compute fancy types for things&lt;br &#x2F;&gt;
such as literals.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;From what we have read from your blog you have learnt Coq and Agda. What can code monkeys like us learn from programming languages like Coq and Agda?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I know a tiny amount of Coq and Agda. They teach people what types are&lt;br &#x2F;&gt;
capable of and how they can be used to interactively prove programs&lt;br &#x2F;&gt;
correct. It’ll also show the potential of typed metaprogramming, for&lt;br &#x2F;&gt;
example allowing the type of printf to depend upon the input string or&lt;br &#x2F;&gt;
how it’s possible to write your own statically checked literal&lt;br &#x2F;&gt;
strings.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Have you checked&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;goto.ucsd.edu&#x2F;~rjhala&#x2F;liquid&#x2F;haskell&#x2F;blog&#x2F;about&#x2F;&quot;&gt;&lt;strong&gt;LiquidHaskell&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;? What do you think about and refinement types?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I think refinement types are interesting. It’s very exciting to just&lt;br &#x2F;&gt;
be able to add on annotations to existing programs and let proof&lt;br &#x2F;&gt;
searching do the rest but I’d prefer dependent types to be a research&lt;br &#x2F;&gt;
area for a couple of reasons:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;LiquidHaskell can do some dependent looking things but doesn’t have&lt;br &#x2F;&gt;
full pi-types so can’t do as much as real dependent types&lt;&#x2F;li&gt;
&lt;li&gt;We’re relying on an SMT solver to come up with a reasoning for why&lt;br &#x2F;&gt;
something is true, dependent types allow you to create and manipulate&lt;br &#x2F;&gt;
your own justifications — this might be solvable just via tooling,&lt;br &#x2F;&gt;
though&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;What other languages or technologies are you keeping an eye on that we should check?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Morte&lt;&#x2F;strong&gt; by Gabriel Gonzalez is a brilliant way of talking about&lt;br &#x2F;&gt;
distributable programs. I want to work on Morte to create a database&lt;br &#x2F;&gt;
of super-optimised code, where package management is about functions,&lt;br &#x2F;&gt;
not libraries. Morte has a pretty good introduction &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;morte-1.2.1&#x2F;docs&#x2F;Morte-Tutorial.html&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Paul Chiusano’s &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;unisonweb.org&#x2F;&quot;&gt;&lt;strong&gt;Unison&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; is an attempt at removing the “list of&lt;br &#x2F;&gt;
characters” problem from programming. It’s also trying to create a&lt;br &#x2F;&gt;
better UX for functional programming.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
      </item>
      <item>
          <title>Erlang and distributed systems expert gives his views on BEAM languages, Hindley–Milner…</title>
          <pubDate>Sat, 08 Aug 2015 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/eric-merritt-erlang-and-distributed-systems-expert-gives-his-views-on-beam-languages-hindley/</link>
          <guid>https://blog.lambdaclass.com/posts/eric-merritt-erlang-and-distributed-systems-expert-gives-his-views-on-beam-languages-hindley/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/eric-merritt-erlang-and-distributed-systems-expert-gives-his-views-on-beam-languages-hindley/">&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-Bvd7l2Q-OmEhkVC2qcclJA.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;eric-merritt-erlang-and-distributed-systems-expert-gives-his-views-on-beam-languages-hindley-milner-type-systems-and-new-technologies&quot;&gt;Eric Merritt, Erlang and distributed systems expert, gives his views on BEAM languages, Hindley–Milner type systems and new technologies&lt;&#x2F;h3&gt;
&lt;p&gt;In this case, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;this-is-not-a-monad-tutorial&quot;&gt;This is not a Monad tutorial&lt;&#x2F;a&gt; interviewed &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;ericbmerritt&quot;&gt;Eric Merritt&lt;&#x2F;a&gt;, author of &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.manning.com&#x2F;logan&#x2F;&quot;&gt;Erlang and OTP in Action&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;joxa.org&#x2F;&quot;&gt;Joxa&lt;&#x2F;a&gt; (a small semantically clean, functional lisp running on the Erlang VM), &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;erlware&#x2F;relx&quot;&gt;relx&lt;&#x2F;a&gt; (best release creation tool in Erlang).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-XCrgX6wctMhx0GLjNQS9nw.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In the following weeks we will be talking with Robert Virding — Erlang co-inventor and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;lfe.io&#x2F;&quot;&gt;Lisp Flavored Erlang&lt;&#x2F;a&gt; creator — , &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;puffnfresh&quot;&gt;Brian McKenna&lt;&#x2F;a&gt; —&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;puffnfresh&#x2F;roy&quot;&gt;Roy&lt;&#x2F;a&gt; language creator— and with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;mirage.io&#x2F;&quot;&gt;MirageOS unikernel&lt;&#x2F;a&gt; dev team. Stay tuned!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;In the Functional Geekery podcast you stated that the Erlang VM (BEAM) is brilliant. What did it get right that other VMs did not?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.functionalgeekery.com&#x2F;episode-20-eric-b-merritt&#x2F;&quot;&gt; Functional Geekery Episode 20 - Eric B. MerrittIn this episode I talk with Eric Merritt. We talk about his background in Erlang, static typing and using OCaml, as…www.functionalgeekery.com&lt;img src=&quot;https:&#x2F;&#x2F;cdn-images-1.medium.com&#x2F;fit&#x2F;c&#x2F;160&#x2F;160&#x2F;0*ssE1kmVx69o3l2qd.&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;BEAM is the only reasonably popular VM that took the language model, in this case Actors, and leveraged that model to make the platform itself more efficient. I find that brilliant. The two major examples of that approach in BEAM are how the Garbage Collector works with the runtime and how IO works.&lt;&#x2F;p&gt;
&lt;p&gt;In many systems, Java included, the Garbage Collector (GC) must examine the entire heap in order to collect all the garbage. There are optimizations to this, like using Generations in a Generational GC, but those optimizations are still just optimizations for walking the entire heap. BEAM takes a different approach, leveraging the actor model on which it is based. That approach basically has the following tenets:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;If a process hasn’t been run, it doesn’t need to be collected&lt;&#x2F;li&gt;
&lt;li&gt;If a process has run, but ended before the next GC run, it doesn’t need&lt;br &#x2F;&gt;
to be collected&lt;&#x2F;li&gt;
&lt;li&gt;If, in the end, the process does need to be collected, only that&lt;br &#x2F;&gt;
single process needs to be stopped while collection occurs&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Those three tenets are one of the primary reasons that Erlang can be a soft-real time system &lt;em&gt;[&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;jlouisramblings.blogspot.com.ar&#x2F;2013&#x2F;01&#x2F;how-erlang-does-scheduling.html&quot;&gt;Elang has a preemptive scheduler that also plays big a part for this&lt;&#x2F;a&gt; &lt;em&gt;]&lt;&#x2F;em&gt;. The fact that the model subsets the work that the GC has to do allows that work to remain small and manageable. Its an impressive achievement.&lt;&#x2F;p&gt;
&lt;p&gt;Another big win for the BEAM and its approach to leveraging Erlang’s Actor model is that it leverages low level, efficient, non-blocking asyncronous IO primitives from the operating system to do IO, but presents a comfortable blocking interface to the language layer. Developers using the platform can use a very human understandable synchronous IO primitives while gaining all the advantages of asyncronous IO. This too, is an impressive achievement. I just gave a talk on this topic for the Seattle Scalability Meetup:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Apart from the Erlang VM (BEAM), what do you think about Erlang as a language?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I think it’s not a bad language. It has the benefit of being both very declarative and very simple. That is a big win in distributed systems where complexity composes and quickly becomes unmanagable. I tend to prefer languages with an algebraic type system and a type inferencing and reasonable meta programming capabilities. Erlang has neither and that’s unfortunate. That said, I have implemented a large number of very reliable systems in Erlang and wouldn’t hesitate to do so again.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;You implemented Joxa, a Lisp for the Erlang VM. Why did you do it?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;For a while there I was working on a problem that was best solved via a suite of DSLs. The platform we built for that was based on Erlang and BEAM, but Erlang doesn’t really lend itself to DSLs. So I decided to write Joxa to facilitate DSL development on the BEAM. It just so happens that creating DSLs for problems is a generally good idea and that makes Joxa a decent general purpose language.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is your opinion about LFE (Lisp Flavored Erlang)?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Joxa took a very different direction than LFE, even though LFE predated it by quite some time. When I ran into the problem that caused Joxa to be created, I investigated it rather deeply to see if it would solve the problem. I ran into a few issues while I was investigating it. In general, I found the implementation very hard to follow. It’s not a bad implementation, it’s just so different from the way I think about languages that it confounded me. That made it difficult for me to expand it.&lt;&#x2F;p&gt;
&lt;p&gt;I was also looking for something with simple semantics that I could build other languages on. LFE is, quite literally, Lisp Flavored Erlang. It is Erlang with S-expression based syntax. That’s not a problem unless you are looking for something with much lower level syntax to build upon. Finally, and this really is a nitpick, Macros are interpreted by LFE and that interpreter is very limited. The rest of the language is interpreted by BEAM. Having to remember if something was going to be run inside the macro interpreter or inside of the normal runtime bothered me a lot.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;And what do you think about Elixir?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I think Elixir has brought a lot of people to the Erlang world that wouldn’t have otherwise come over. That is a very good thing and a powerful contribution to the Erlang eco-system. However, I am not a big fan of Elixir itself. I find the macro system to be a bit inconsistent and I really dislike that Elixir tries to hide immutability. That does make it slightly easier for beginners, but it’s a leaky abstraction. The immutability eventually bleeds through and then you have to think about it. It also introduces additional complexity within bindings in Elixir Macros among other things. It doesn’t help that I have never been a fan of Ruby syntax and Elixir borrows heavily from that sphere.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What do you think about laziness in programming languages? In which cases do you think it is useful, if any?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I love lazyness in concept. I think the idea that computation only occurs when it’s needed is right in line with the trend that has been occurring in functional programming for many decades. The problem that I have with lazyness is more pragmatic. It is very easy to create space leaks and, as of this writing, good tools to detect and debug those space leaks don’t yet exist. That makes me very hesitant to use a language that is lazy by default in production. The Haskell guys are working hard to resolve this, and I think they will, but they haven’t yet.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why do you like Hindley–Milner type system? [the type system used in the ML family (Standard ML, Caml, OCaml, F#) and Haskell]&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-TKFIhHLhfGTz5uMBn6NfkQ.png&quot; alt=&quot;&quot; &#x2F;&gt; Image stolen from &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;learnyousomeerlang.com&#x2F;&quot;&gt;http:&#x2F;&#x2F;learnyousomeerlang.com&#x2F;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Essentially, it’s because I am lazy. Much like resource management, contract management is a slow, manual painful process. By contract management, I mean verifying that the form of data a function recieves is the form of data that it expects. A Hindley-Milner style type system allows me to offload that tedious work to the compiler. Computers are essentially better at that kind of tedious work than humans.&lt;&#x2F;p&gt;
&lt;p&gt;A type system like this is just an evolution of our ongoing effort to offload work to the computer. Originally, we wrote in machine code, then we moved up to Assembly, which was one step higher. Not long after we started using higher level languages like Fortran, Cobol and Lisp. A bit later on we started offloading resource management to the computer as well in the form of GC. An algebraic type system is just a continuation of that. With this type system we are offloading contract checking to the computer. Just like with resource management the contract checking must happen, its just that many languages force the human to do it when the compiler can do it much more effectively.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Do you think that it would be possible to create a language with a Hindley Milner type system for the Erlang VM without affecting the power of Erlang semantics?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Not only do I think its possible, I have been planning to do it for a while now, time being the limiting factor. The main problem you will run into is the mismatch between the untyped bits of the Erlang native system and the typed bits of the new language. Dialyzer attempts to solve this through Success Typing, but there may be a better way. Something like what &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;roy.brianmckenna.org&#x2F;&quot;&gt;Roy&lt;&#x2F;a&gt; [programming languages that tries to meld JavaScript semantics with some features common in static functional languages] is doing in its type system or &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;core.typed&quot;&gt;Clojure’s core.typed&lt;&#x2F;a&gt;. I am not sure, but it’s a fun and solvable problem.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Do you think it would be worthwhile adding algebraic data types to the Erlang VM? Or is using records (Erlang, Joxa) and tagged maps (Elixir) enough for all practical purposes?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Type systems have very little to do with the VM and very much to do with the language. That is, it’s usually a compile time thing rather than a runtime thing. It might actually be useful to add, simply so that BEAM can take advantage of the type annotations to run more optimized versions of the code, but it’s not especially helpful to the efforts to run a well typed language on top of the VM.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;In the past we had to create a few clients and console applications. Python and Ruby were great for building them quickly. However not being able to easily generate standalone binaries for each OS and architecture is a shortcoming of those languages. We are testing Nim and Go since they have good cross compilation and library support. Have you tried them? Could OCaml be a good alternative?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I have not tried either Nim or Go unfortunately. I have used Python extensively and Ruby as well, though to a lesser extent. I have also used OCaml extensively for these types of work and I find that I like OCaml the best. I like it for all the reasons I talked about above. That said, it is very different from other shell programming approaches and takes a bit of getting used to. I should also note that the vast majority of my work with OCaml has been in conjunction with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;janestreet.github.io&#x2F;&quot;&gt;Jane Street Capital’s Core and Async libraries&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What other languages or technologies are you keeping an eye on that we should check?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I haven’t seen any new languages pop up recently that have grabbed my interest. On technologies, I think that microkernels are very, very interesting. Things like &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;osv.io&#x2F;&quot;&gt;OSv&lt;&#x2F;a&gt; for the JVM based languages, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;mirage.io&#x2F;&quot;&gt;Mirage&lt;&#x2F;a&gt; for OCaml and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;rumpkernel.org&#x2F;&quot;&gt;BSD Rump Kernels&lt;&#x2F;a&gt; for the rest. I think those are going to become the fundamental building block of &lt;strong&gt;system orchestration&lt;&#x2F;strong&gt; in the very near future. The other thing to keep an eye on is the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;nixos.org&#x2F;nix&#x2F;&quot;&gt;Nix Package manager&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;nixos.org&#x2F;&quot;&gt;NixOS&lt;&#x2F;a&gt;, and technologies like Atlas from Hashicorp. It’s not going to be too much longer before we declaratively describe out systems as well as our code. I am looking forward to that.&lt;&#x2F;p&gt;
</description>
      </item>
    </channel>
</rss>
