<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>LambdaClass Blog - JavaScript</title>
      <link>https://blog.lambdaclass.com</link>
      <description>Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.</description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://blog.lambdaclass.com/tags/javascript/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Wed, 26 Aug 2015 00:00:00 +0000</lastBuildDate>
      <item>
          <title>Interview with Brian McKenna about Roy, Purescript, Haskell, Idris and dependent types</title>
          <pubDate>Wed, 26 Aug 2015 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/interview-with-brian-mckenna-about-roy-purescript-haskell-idris-and-dependent-types/</link>
          <guid>https://blog.lambdaclass.com/posts/interview-with-brian-mckenna-about-roy-purescript-haskell-idris-and-dependent-types/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/interview-with-brian-mckenna-about-roy-purescript-haskell-idris-and-dependent-types/">&lt;p&gt;As promised in our &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;this-is-not-a-monad-tutorial&#x2F;eric-merritt-erlang-and-distributed-systems-expert-gives-his-views-on-beam-languages-hindley-a09b15f53a2f&quot;&gt;last interview&lt;&#x2F;a&gt; for &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;this-is-not-a-monad-tutorial&quot;&gt;This is not a Monad tutorial&lt;&#x2F;a&gt; we interviewed &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;puffnfresh&quot;&gt;Brian McKenna&lt;&#x2F;a&gt;, creator of the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;roy.brianmckenna.org&#x2F;&quot;&gt;Roy&lt;&#x2F;a&gt; programming language. In this interview Brian talks about Roy, its implementation, how it compares with Purescript, and also about dependent types and other interesting technologies like Morte and Unison. I highly recommend that you check &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;brianmckenna.org&#x2F;blog&#x2F;&quot;&gt;Brian’s blog&lt;&#x2F;a&gt; after you finish reading this interview.&lt;&#x2F;p&gt;
&lt;p&gt;In the following weeks we will be talking with the creators of &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.red-lang.org&#x2F;&quot;&gt;Red programming language&lt;&#x2F;a&gt;, Robert Virding — Erlang co-inventor and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;lfe.io&#x2F;&quot;&gt;Lisp Flavored Erlang&lt;&#x2F;a&gt; creator — and with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;mirage.io&#x2F;&quot;&gt;MirageOS unikernel&lt;&#x2F;a&gt; dev team.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-vYf7TCGE19Gni5ssKXQaHA.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What are Roy’s main features?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Roy featured things common to languages which are well suited to typed&lt;br &#x2F;&gt;
functional programming:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Types and type inference (with row polymorphism)&lt;&#x2F;li&gt;
&lt;li&gt;Algebraic data types and pattern matching&lt;&#x2F;li&gt;
&lt;li&gt;Monadic syntax&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Why did you create it?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I created Roy after doing years of JavaScript work. I learned Haskell&lt;br &#x2F;&gt;
and it made a huge amount of sense to me. Functional programming with&lt;br &#x2F;&gt;
types seemed like the ideal way for me to work on software and so I&lt;br &#x2F;&gt;
wanted to bring it to web programming.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;I am tempted to say that Roy has some big similarities with&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.purescript.org&#x2F;&quot;&gt;&lt;strong&gt;Purescript&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;. What are the main differences between the two languages?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Roy was first!&lt;&#x2F;p&gt;
&lt;p&gt;PureScript had almost the exact same goals as Roy but had a much&lt;br &#x2F;&gt;
better implementation. Quoting the PureScript wiki:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Roy is probably the most similar language on the list, and was a&lt;br &#x2F;&gt;
large influence on the development of PureScript.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;I stopped working on Roy once PureScript got around equal in&lt;br &#x2F;&gt;
functionality. PureScript’s implementation means it’s a lot easier to&lt;br &#x2F;&gt;
work on and has much fewer bugs.&lt;&#x2F;p&gt;
&lt;p&gt;Originally the PureScript FFI started off being very different (i.e.&lt;br &#x2F;&gt;
it used inline JS instead of an externs file) but recently changed to&lt;br &#x2F;&gt;
being similar to the original design Roy had. That was probably the&lt;br &#x2F;&gt;
biggest difference the projects had.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;You implemented the lexer and the parser. Did you do so to learn&#x2F;play or because you thought that the available tools were not good enough?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I implemented a whitespace sensitive lexer which was passed into the&lt;br &#x2F;&gt;
Jison parser generator. It was the same approach which CoffeeScript&lt;br &#x2F;&gt;
took.&lt;&#x2F;p&gt;
&lt;p&gt;A custom lexer was necessary because the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;this-is-not-a-monad-tutorial&#x2F;interview-with-brian-mckenna-about-roy-purescript-haskell-idris-and-dependent-types-63bb1289ea3d&quot;&gt;Jison&lt;&#x2F;a&gt; lexer generator was not&lt;br &#x2F;&gt;
capable of stateful scanning of whitespace.&lt;&#x2F;p&gt;
&lt;p&gt;I prefer working with parser combinators such as Parsec and Trifecta.&lt;br &#x2F;&gt;
They’re easier to work with and allow you to write reusable&lt;br &#x2F;&gt;
abstractions.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why did you use a whitespace sensitive grammar a la Python&#x2F;Haskell in Roy?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Just to look like Haskell. I hate thinking about syntax — I copy&lt;br &#x2F;&gt;
things as much as I can. I’m also annoyed that we’re still writing&lt;br &#x2F;&gt;
programs using text. They’re trees, not lists of characters!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why is it useful to have monadic sugar in a language that has unrestricted side effects?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Roy was not designed to allow side-effects, but you could do anything&lt;br &#x2F;&gt;
with the FFI and so it was possible.&lt;&#x2F;p&gt;
&lt;p&gt;Scala has (pretty limited) monadic sugar and also unrestricted&lt;br &#x2F;&gt;
side-effects. People use monadic sugar for things as straight-forward&lt;br &#x2F;&gt;
as Option:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;for {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  name &amp;lt;- maybeFirstName&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  user &amp;lt;- lookup(name)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  avatar &amp;lt;- getAvatar(user)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;} yield avatar&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which can be easier to type than:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;maybeFirstName.flatMap { name =&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  lookup(name).flatMap { user =&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    getAvatar(user)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It doesn’t have anything to do with side-effects.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;From what we could read in the Damas-Hindley-Milner type inference algorithm source comments it is based on Robert Smallshire’s Python code. Do you have any recommendation for those who want to implement it?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I recommend reading “Generalizing Hindley-Milner Type Inference&lt;br &#x2F;&gt;
Algorithms” which turns the algorithm into explicit separate&lt;br &#x2F;&gt;
constraint collection and constraint solving problems, which is a bit&lt;br &#x2F;&gt;
easier to work with than plain Algorithm W. It’s then possible to do&lt;br &#x2F;&gt;
tree annotation via the cofree comonad, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;brianmckenna.org&#x2F;blog&#x2F;type_annotation_cofree&quot;&gt;which gives a pretty nice&lt;&#x2F;a&gt;&lt;br &#x2F;&gt;
&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;brianmckenna.org&#x2F;blog&#x2F;type_annotation_cofree&quot;&gt;implementation&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What reading material do you recommend for implementing your first programming language?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Source code of other languages are great resources. I think the&lt;br &#x2F;&gt;
PureScript and Idris compilers are somewhat easy to play around with.&lt;&#x2F;p&gt;
&lt;p&gt;Hackage has a lot of code to look at, such as reference&lt;br &#x2F;&gt;
implementations of Algorithm W:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;hackage.haskell.org&#x2F;packages&#x2F;&quot;&gt;https:&#x2F;&#x2F;hackage.haskell.org&#x2F;packages&#x2F;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What would you recommend us to read to learn about different type systems?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.cis.upenn.edu&#x2F;~bcpierce&#x2F;tapl&#x2F;&quot;&gt;Types and Programming Languages&lt;&#x2F;a&gt; by Benjamin Pierce is a brilliant&lt;br &#x2F;&gt;
resource for understanding both. It’s surprised me by being a very&lt;br &#x2F;&gt;
good introduction to types and having pretty good reference&lt;br &#x2F;&gt;
implementations in OCaml for each of the discussed type-systems. Very&lt;br &#x2F;&gt;
highly recommended.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Have you tried&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;elm-lang.org&#x2F;&quot;&gt;&lt;strong&gt;Elm&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;? What do you think of&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Functional_reactive_programming&quot;&gt;&lt;strong&gt;FRP&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I think Functional Reactive Programming could be generalised a bit to&lt;br &#x2F;&gt;
just general stream combinator libraries and we could make it as&lt;br &#x2F;&gt;
simple as libraries such as pipes, machines and scalaz-stream. I’d&lt;br &#x2F;&gt;
like to implement one of those libraries in PureScript and try to&lt;br &#x2F;&gt;
write combinators to fill in the gaps for developing user interfaces&lt;br &#x2F;&gt;
to see how close we get to current FRP libraries.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;You recently gave a talk about&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.idris-lang.org&#x2F;&quot;&gt;&lt;strong&gt;Idris&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;, a language with&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dependent_type&quot;&gt;&lt;strong&gt;dependent types&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;. Could you explain what are dependent types?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In non-dependently typed languages we have a way of making values&lt;br &#x2F;&gt;
depend upon other values: functions! In dependent typed languages we&lt;br &#x2F;&gt;
have those functions, but also functions which can return types.&lt;&#x2F;p&gt;
&lt;p&gt;Haskell has two completely separate languages: the language of values&lt;br &#x2F;&gt;
and the language of types. Recent versions of GHC give a way of&lt;br &#x2F;&gt;
promoting certain values up to types, but if you want to write a&lt;br &#x2F;&gt;
function over those values, you’ll have to write a version at the&lt;br &#x2F;&gt;
value level and separately at the type level.&lt;&#x2F;p&gt;
&lt;p&gt;Dependent-types remove the separation. If you write a function, you&lt;br &#x2F;&gt;
can reuse it for terms at any level.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What are the practical benefits of using a language with dependent types?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Since you can use values in your types, you can specify a lot more.&lt;br &#x2F;&gt;
For example, I can specify that list reversal is an involution, i.e.&lt;br &#x2F;&gt;
reversing twice is the same as not reversing at all:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;reverseInvolution : (xs : List a) -&amp;gt; reverse (reverse xs) = r&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;No need for tests — if I implement a value for that type, I have a&lt;br &#x2F;&gt;
proof for all possible values.&lt;&#x2F;p&gt;
&lt;p&gt;Or we can specify that a sort function will generate a list where each&lt;br &#x2F;&gt;
element is smaller than the next. The implementation of sort will only&lt;br &#x2F;&gt;
compile if we prove that to be true.&lt;&#x2F;p&gt;
&lt;p&gt;We can also do things like metaprogramming, since we know more about&lt;br &#x2F;&gt;
the values which are passed in, we can compute fancy types for things&lt;br &#x2F;&gt;
such as literals.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;From what we have read from your blog you have learnt Coq and Agda. What can code monkeys like us learn from programming languages like Coq and Agda?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I know a tiny amount of Coq and Agda. They teach people what types are&lt;br &#x2F;&gt;
capable of and how they can be used to interactively prove programs&lt;br &#x2F;&gt;
correct. It’ll also show the potential of typed metaprogramming, for&lt;br &#x2F;&gt;
example allowing the type of printf to depend upon the input string or&lt;br &#x2F;&gt;
how it’s possible to write your own statically checked literal&lt;br &#x2F;&gt;
strings.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Have you checked&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;goto.ucsd.edu&#x2F;~rjhala&#x2F;liquid&#x2F;haskell&#x2F;blog&#x2F;about&#x2F;&quot;&gt;&lt;strong&gt;LiquidHaskell&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;? What do you think about and refinement types?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I think refinement types are interesting. It’s very exciting to just&lt;br &#x2F;&gt;
be able to add on annotations to existing programs and let proof&lt;br &#x2F;&gt;
searching do the rest but I’d prefer dependent types to be a research&lt;br &#x2F;&gt;
area for a couple of reasons:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;LiquidHaskell can do some dependent looking things but doesn’t have&lt;br &#x2F;&gt;
full pi-types so can’t do as much as real dependent types&lt;&#x2F;li&gt;
&lt;li&gt;We’re relying on an SMT solver to come up with a reasoning for why&lt;br &#x2F;&gt;
something is true, dependent types allow you to create and manipulate&lt;br &#x2F;&gt;
your own justifications — this might be solvable just via tooling,&lt;br &#x2F;&gt;
though&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;What other languages or technologies are you keeping an eye on that we should check?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Morte&lt;&#x2F;strong&gt; by Gabriel Gonzalez is a brilliant way of talking about&lt;br &#x2F;&gt;
distributable programs. I want to work on Morte to create a database&lt;br &#x2F;&gt;
of super-optimised code, where package management is about functions,&lt;br &#x2F;&gt;
not libraries. Morte has a pretty good introduction &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;morte-1.2.1&#x2F;docs&#x2F;Morte-Tutorial.html&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Paul Chiusano’s &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;unisonweb.org&#x2F;&quot;&gt;&lt;strong&gt;Unison&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; is an attempt at removing the “list of&lt;br &#x2F;&gt;
characters” problem from programming. It’s also trying to create a&lt;br &#x2F;&gt;
better UX for functional programming.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
      </item>
    </channel>
</rss>
