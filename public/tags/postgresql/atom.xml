<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>LambdaClass Blog - Postgresql</title>
    <subtitle>Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.</subtitle>
    <link rel="self" type="application/atom+xml" href="https://blog.lambdaclass.com/tags/postgresql/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2017-11-14T00:00:00+00:00</updated>
    <id>https://blog.lambdaclass.com/tags/postgresql/atom.xml</id>
    <entry xml:lang="en">
        <title>Holiday Ping: how we implemented our first open source app with Erlang and Clojurescript</title>
        <published>2017-11-14T00:00:00+00:00</published>
        <updated>2017-11-14T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com/posts/holiday-ping-how-we-implemented-our-first-open-source-app-with-erlang-and-clojurescript/"/>
        <id>https://blog.lambdaclass.com/posts/holiday-ping-how-we-implemented-our-first-open-source-app-with-erlang-and-clojurescript/</id>
        
        <content type="html" xml:base="https://blog.lambdaclass.com/posts/holiday-ping-how-we-implemented-our-first-open-source-app-with-erlang-and-clojurescript/">&lt;p&gt;After almost ten years of working as a developer for different companies, two years ago I started my own company &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;&quot;&gt;LambdaClass&lt;&#x2F;a&gt;. I did so because I wanted to have more freedom in choosing the type of projects and team I work with.&lt;&#x2F;p&gt;
&lt;p&gt;That is why today it is a very special day for me. We take a break from regular interviews and celebrate the release of our first open source application: &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;holidayping.lambdaclass.com&#x2F;&quot;&gt;Holiday Ping&lt;&#x2F;a&gt;. Facundo Olano is the main developer of the application. The application was written in two of the best programming languages we know (Clojure and Erlang) and our favorite database (PostgreSQL). This post was written by him and tells his journey and lessons learned with the backend side. A similar post on the frontend will be forthcoming. If you find any issue or want to help check &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;holiday_ping&quot;&gt;github&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Discuss and vote at&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;mgefw9&#x2F;holiday_ping_how_we_implemented_our_first&quot;&gt; &lt;em&gt;lobsters&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;,&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;programming&#x2F;comments&#x2F;7cweat&#x2F;holiday_ping_how_we_implemented_our_first_open&#x2F;&quot;&gt;&lt;em&gt;reddit&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;and&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=15695955&quot;&gt; &lt;em&gt;hn&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-9ngymzWNwkPMhZ9u7uZ_XA.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;background&quot;&gt;&lt;strong&gt;Background&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;Earlier this year I joined LambdaClass, a Buenos Aires-based software consultant founded a while ago by some colleagues and schoolmates. LambdaClass has a special interest in distributed systems, and while it’s not exclusively an Erlang shop, most of its projects are implemented in &lt;em&gt;BEAM&lt;&#x2F;em&gt; languages.&lt;&#x2F;p&gt;
&lt;p&gt;Although I have a recent background in microservices and functional languages (mainly Clojure), I needed some time to ramp up and gain experience with the OTP platform and its underlying philosophy. I started working on some of the LambdaClass projects right away, but there are aspects of the learning process, specially those related with architecture and design, that are best experienced in greenfield projects. The company also has the goal of a strong open source presence, thus the decision to spend part of my time on public side projects.&lt;&#x2F;p&gt;
&lt;p&gt;We considered a couple of mid sized projects and implemented one of them (which arguably looked smaller in scope than ended up being). The purpose of this document is to share our experience, put some of our discussions into words so we wrap our understanding of them, and make conclusions that can help us in future projects.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-project&quot;&gt;The Project&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;holidayping.lambdaclass.com&quot;&gt;HolidayPing&lt;&#x2F;a&gt; is a small web application that sends holiday reminders through different services like email and slack. It’s mainly aimed at consultants and freelancers used to work with clients abroad. It’s free of charge and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;holiday_ping&quot;&gt;open source&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;spin-off-projects&quot;&gt;Spin-off projects&lt;&#x2F;h3&gt;
&lt;p&gt;As part of the HolidayPing effort, we have started to design and implement some open source tools that solve a couple of problems that we identify as recurring: &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;throttle&quot;&gt;throttle&lt;&#x2F;a&gt;, to perform access control over resources such as API endpoints, and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;reconnections&quot;&gt;reconnections&lt;&#x2F;a&gt;, to initiate and maintain connections to external services in an OTP idiomatic way.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-backend&quot;&gt;The Backend&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;language-erlang-vs-elixir&quot;&gt;Language: Erlang vs. Elixir&lt;&#x2F;h4&gt;
&lt;p&gt;The first decision was the programming language: Erlang or Elixir. We use both at LambdaClass, so I’d eventually have to learn them both, the question was which was more effective to learn first, considering both goals of being productive and properly understanding the Erlang platform in the long run.&lt;&#x2F;p&gt;
&lt;p&gt;Elixir would have probably been easier, considering my previous background and that it has a syntax closer to other modern languages. But learning it first carried the risk of just scratching the surface of OTP: using the language like &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=ChUB5Oj2Jj4&quot;&gt;it’s the new Ruby&lt;&#x2F;a&gt;, and hiding what’s going on underneath. It does seem like it’s simpler to get a good understanding of the “OTP way” by starting with Erlang, especially since &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;learnyousomeerlang.com&#x2F;&quot;&gt;there’s literature that guides you through the process&lt;&#x2F;a&gt;. Then, switching to Elixir would mostly consist of getting familiar with a new syntax and a few language features.&lt;&#x2F;p&gt;
&lt;p&gt;We understand that as Elixir is gaining popularity and more Elixir code is being written, a deeper understanding of Erlang and OTP will become a valuable asset for the company. In addition, many robust and useful libraries are written in Erlang and being able to dive in the code is important.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;learning-erlang&quot;&gt;Learning Erlang&lt;&#x2F;h4&gt;
&lt;p&gt;A quick note on my impressions of the language: I found it to be very expressive, mostly because of pattern matching; coming from Clojure, I didn’t have issues to grasp Erlang’s functional aspects; contrary to a lot of people, I don’t mind the syntax, I actually like it a lot with the exception of some notable quirks (one comes to mind: binary literals, while very powerful, are very inconvenient as a string replacement). As my coworkers kept telling me and I later confirmed: OTP is the big deal, and not the language itself.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;application-and-supervisor-structure&quot;&gt;Application and supervisor structure&lt;&#x2F;h4&gt;
&lt;p&gt;At a high level, the application can be divided into the following components&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;A RESTful API, mostly for CRUD operations.&lt;&#x2F;li&gt;
&lt;li&gt;A Process that periodically checks whether reminders should be sent (e.g.: today is a holiday in Bob’s country, and Bob asked to send reminders through slack and email channels).&lt;&#x2F;li&gt;
&lt;li&gt;Worker processes that send the reminders.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;rest-api&quot;&gt;Rest API&lt;&#x2F;h3&gt;
&lt;p&gt;The CRUD API didn’t require much thinking, at least from the OTP point of view. It’s implemented with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;ninenines.eu&#x2F;docs&#x2F;en&#x2F;cowboy&#x2F;2.0&#x2F;guide&#x2F;rest_handlers&#x2F;&quot;&gt;Cowboy rest handlers&lt;&#x2F;a&gt;, and I’ll just note that the library does a great job at forcing you to define a well behaved REST server without too much code.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;reminder-checker&quot;&gt;Reminder checker&lt;&#x2F;h4&gt;
&lt;p&gt;The processes involved in the reminders were more interesting, and obviously more important since the value of the application depends on them working properly (&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;jlouisramblings.blogspot.com.ar&#x2F;2010&#x2F;11&#x2F;on-erlang-state-and-crashes.html&quot;&gt;this is the “error kernel” of the app&lt;&#x2F;a&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;The process that checks whether holidays should be sent (remind_checker) is a gen_server that uses timer:send_interval to periodically query the database, asking what reminders should be sent. It then triggers worker creation with the necessary data to send the reminders.&lt;&#x2F;p&gt;
&lt;p&gt;How often the checker runs and what information is passed to workers are things that changed as the model and its implementation got more sophisticated, but the general idea was to always isolate the decision to send a reminder from the act of sending it, so a failure in a specific channel wouldn’t affect other channels, other users, or the checker process.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;reminder-router&quot;&gt;Reminder router&lt;&#x2F;h4&gt;
&lt;p&gt;The reminders are sent by gen_server processes called reminder routers, which are children of a supervisor under a simple_one_for_one strategy. Different channel modules implement the specifics to send the message on each service (email, slack, webhook).&lt;&#x2F;p&gt;
&lt;h4 id=&quot;why-not-gen-event&quot;&gt;Why not gen_event?&lt;&#x2F;h4&gt;
&lt;p&gt;While first studying OTP behaviors, my coworkers suggested I defer reading about gen_event, since it wasn’t used much in practice. When I started to work on HolidayPing, though, which is almost entirely about setting up and triggering events, it sounded like gen_event would be something to consider. And indeed a superficial overview confirmed that; quoting the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.erlang-in-anger.com&#x2F;&quot;&gt;Erlang in Anger book&lt;&#x2F;a&gt;: &lt;em&gt;a gen_event will act as an event hub for callbacks, or as a way to deal with notifications of some sort&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;So I went back to my coworkers: how come we aren’t using gen_event for this? It turns out that this behavior &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.afronski.pl&#x2F;2015&#x2F;11&#x2F;02&#x2F;what-is-wrong-with-gen-event.html&quot;&gt;doesn’t provide much of the benefits&lt;&#x2F;a&gt; one would expect for such an event hub. In terms of what was discussed at the beginning of this section, gen_event does not provide isolation between events, so a slow or crashing event would affect the rest.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;why-not-worker-pools&quot;&gt;Why not worker pools?&lt;&#x2F;h4&gt;
&lt;p&gt;At a certain point in the development, each router was sending the reminders for all the channels of a user on a given holiday. We wanted to further separate processing to have isolated channel requests (e.g. we don’t to bypass email sending if there was a crash requesting Slack).&lt;&#x2F;p&gt;
&lt;p&gt;The obvious option was to add a second simple_one_for_one supervisor with a new gen_server, but we briefly considered a worker pool instead. In other language ecosystems, where threads are expensive, a pool is an usual option. In Erlang, though, the story is different: processes are cheap and there’s no reason upfront to force a limit on the amount of processes being created (with some exceptions, such as maintaining a pool of connections to a database). And if you hit a point where there’s so much work to do that the amount of concurrent processes becomes too expensive, you most likely will need something fancier than a pool to overcome it (i.e. the pool manager will become a bottleneck or the queue will grow faster than workers can process it).&lt;&#x2F;p&gt;
&lt;p&gt;Admittedly, our situation is atypical in the sense that a potential overload wouldn’t come from requests constantly arriving, but a burst of reminders that need to be sent when the checker runs (currently every 15 minutes). We could easily alleviate this load by spreading the reminders through the time we have between one checker run and the next. Then again, it would be a useless optimization to do this upfront.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;avoiding-throttling-issues&quot;&gt;Avoiding throttling issues&lt;&#x2F;h4&gt;
&lt;p&gt;Which brings me to an issue that we didn’t notice until I was writing these lines, and that’s &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;holiday_ping&#x2F;issues&#x2F;34&quot;&gt;still open&lt;&#x2F;a&gt;. While we don’t have reasons to expect that our system won’t be able to handle sending all reminders at once, it’s likely that the third party services we hit will enforce throttling limits on us.&lt;&#x2F;p&gt;
&lt;p&gt;Let’s say that hopefully a thousand developers from Argentina find our project useful, and all of them set up a Slack channel, with the default reminder settings. If that’s the case, on Christmas morning at about 9:00am the reminder checker will attempt to send a thousand requests to Slack, more or less at the same time. Slack will likely reject those requests (and their retries next time the checker runs).&lt;&#x2F;p&gt;
&lt;p&gt;One way to reduce the chance of this happening, would be the same as mentioned in previous section: spread the reminder sending across the available time between one run and the next. Of course, with enough users the limit could be hit anyway and we’d have to resort to finer grained queuing or throttling mechanisms.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;database&quot;&gt;Database&lt;&#x2F;h3&gt;
&lt;p&gt;The database pick was simple: &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;@jlouis666&#x2F;how-to-build-stable-systems-6fe9dcf32fc4&quot;&gt;&lt;em&gt;PostgreSQL is the default database&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;For me it had been years either &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;facundoolano.wordpress.com&#x2F;2012&#x2F;03&#x2F;11&#x2F;django-db-optimization-for-pedestrians&#x2F;&quot;&gt;hiding the database behind an ORM&lt;&#x2F;a&gt;, or using schema-less stores like MongoDB. Although the lazy developer inside of me grumbled a bit at having to define the schemas upfront, I eventually came to remember how amazingly flexible and powerful PostgreSQL can be, to the point where I found myself pushing stuff (e.g. time arithmetics) to the database level because it was just easier to work with than the available Erlang libraries. We even &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;holiday_ping&#x2F;issues&#x2F;179&quot;&gt;want to explore&lt;&#x2F;a&gt; domain integrity constraints to implement the long-postponed input validations on the backend.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;handle-the-configuration-differences-between-channels&quot;&gt;Handle the configuration differences between channels&lt;&#x2F;h4&gt;
&lt;p&gt;Our model had a spot that was hard to fit in the database schema: the user creates channels that can be of different types (Slack, email, webhook), each with different configuration parameters. The email channel takes a list of email addresses, webhook takes a single url, Slack takes an hook url, a list of channels and users, an emoji, etc.&lt;&#x2F;p&gt;
&lt;p&gt;We care about those differences only in each end of the application: when we validate the user input, and when we execute the type-specific logic to send a reminder; everywhere else, we want to treat the channels equally, regardless of the configuration. We tried several PostgreSQL features to save the channel configuration.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;inheritance&quot;&gt;Inheritance&lt;&#x2F;h4&gt;
&lt;p&gt;This use case seemed like a good fit for &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;9.6&#x2F;static&#x2F;ddl-inherit.html&quot;&gt;table inheritance&lt;&#x2F;a&gt;: we wrote a base channel table with all the common fields (user, name, type) and separate tables inheriting from it adding the type-specific configuration. But we soon found out that inheritance features are &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;9.6&#x2F;static&#x2F;ddl-inherit.html#DDL-INHERIT-CAVEATS&quot;&gt;very limited&lt;&#x2F;a&gt; and don’t provide the features that would justify the choice: unique constraints aren’t enforced across children, you can’t get children’s data when querying the parent, etc.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;plain-tables&quot;&gt;Plain tables&lt;&#x2F;h4&gt;
&lt;p&gt;Given that inheritance didn’t provide much operational value, using separate tables for configuration and managing them manually made more sense. This is the way to go in the long run, since we want to benefit from type validations and constraints, but compared with a schemaless storage, it would induce a lot of overhead in the early stages of development, considering the channel types and the model in general were far from being stable.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;hstore&quot;&gt;hstore&lt;&#x2F;h4&gt;
&lt;p&gt;We started looking at unstructured PostgreSQL data types. &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;static&#x2F;hstore.html&quot;&gt;hstore&lt;&#x2F;a&gt; is a key&#x2F;value type, but it doesn’t have arrays (e.g. more than one value per key). We needed this for channel options, so hstore didn’t do the trick.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;jsonb&quot;&gt;jsonb&lt;&#x2F;h4&gt;
&lt;p&gt;So we turned again to &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;9.5&#x2F;static&#x2F;datatype-json.html&quot;&gt;JSON&lt;&#x2F;a&gt;. jsonb fields let us store arbitrary configuration inside the channel table, and treat it like an opaque value except on the spot where we actually use that configuration to send a reminder. Arguably this is the most convenient option only because we never got to the point of thoroughly validating channel input in the backend. When we get there, it will make sense to define properly structured tables first.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;rest-api-1&quot;&gt;Rest API&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;identifiers&quot;&gt;Identifiers&lt;&#x2F;h4&gt;
&lt;p&gt;We’ve spent some time discussing ways of identifying our resources across the project. This is a relevant discussion since it applies to most of our projects; we may as well settle with one design and be consistent from now on.&lt;&#x2F;p&gt;
&lt;p&gt;As we see it, the most flexible method is to use:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;A serial ID, just for PostgreSQL. Every table has it, you use it for foreign keys and joins. You don’t want to expose it in the API, since it’s implementation dependent, and something that may not be reusable should you want to switch databases (or add an extra one).&lt;&#x2F;li&gt;
&lt;li&gt;A separate ID to uniquely identify the resource: a UUID that will never change and can be reused across databases.&lt;&#x2F;li&gt;
&lt;li&gt;When it makes sense, a “model” ID for the resource (a user email, an unique name, etc.). You may use it as an identifier in the user facing API (i.e. in the REST uris or the UI routes), to make it user friendly. But you shouldn’t rely on it for internal storage and correlation: even if you start out with an “email won’t change” assumption, business rules like that do change and there’s no benefit in relying too heavily on them for your implementation.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The last one is something we didn’t get entirely right, and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;holiday_ping&#x2F;issues&#x2F;113&quot;&gt;there’s still work to do&lt;&#x2F;a&gt;. Our current implementation has model IDs (user email, channel name, holiday date), but no external UUIDs, so some use cases like changing a channel name are not supported.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;authentication-and-authorization&quot;&gt;Authentication and authorization&lt;&#x2F;h4&gt;
&lt;p&gt;To manage authorization of the API, we went with Bearer tokens based on previous experience. What’s convenient about token authorization, as opposed to, say, requiring Basic Auth on every request, is that it allows us to decouple the authentication from the authorization: if we want to support a new authentication method (which we did when we added GitHub login), we just add a new auth endpoint that returns an access token; authorization on the rest of the API remains untouched.&lt;&#x2F;p&gt;
&lt;p&gt;Regarding the token format, I initially went with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;jwt.io&#x2F;&quot;&gt;JWT&lt;&#x2F;a&gt; without giving it much thought, because that’s what I’ve seen most commonly used to authorize web apps accessing a REST backend. My coworkers, who haven’t heard about it before, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;holiday_ping&#x2F;issues&#x2F;20&quot;&gt;were suspicious&lt;&#x2F;a&gt;, which I understand, because it totally sounds like:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-LmkSEubDQc5xYFKb.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;And we’re &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;@jlouis666&#x2F;two-technologies-which-are-bad-for-you-160311ad6b24#13fd&quot;&gt;not very fond of JSON&lt;&#x2F;a&gt;. So I digged up a little bit more to make sure the decision made sense. There are &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;cryto.net&#x2F;~joepie91&#x2F;blog&#x2F;2016&#x2F;06&#x2F;13&#x2F;stop-using-jwt-for-sessions&#x2F;&quot;&gt;several&lt;&#x2F;a&gt; &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;kev.inburke.com&#x2F;kevin&#x2F;things-to-use-instead-of-jwt&#x2F;&quot;&gt;articles&lt;&#x2F;a&gt; expressing concerns about using JWT, although most of them don’t apply to our use case. Assuming we want to stick to Bearer tokens, the alternative to JWT would be to &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;auth0.com&#x2F;blog&#x2F;ten-things-you-should-know-about-tokens-and-cookies&#x2F;#token-oauth&quot;&gt;just store a random string in the database&lt;&#x2F;a&gt;, associated with the user, and check that value on every request. A quick comparison between the two options:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;JWT lets you identify the user without the need to hit the database on every request: the server decodes the token with the same secret it used to generate it, and checks the claims. To be fair, at least in our use case, there’s no evidence that going to the database on each request would be a problem.&lt;&#x2F;li&gt;
&lt;li&gt;JWT is stateless, which seems to be more inline with REST principles: there’s no session, the client sends the token on each request which is enough to identify it.&lt;&#x2F;li&gt;
&lt;li&gt;Database stored tokens require a bit of extra effort: we need to manage expiration ourselves, delete old tokens and make sure we pick a secure enough method to generate them. On the other hand, blacklisting compromised tokens is easier than with JWT, since we can just flag them in the database (although this is &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;7030694&#x2F;why-do-access-tokens-expire&#x2F;7035926#7035926&quot;&gt;less of an issue&lt;&#x2F;a&gt; using a short expiration).&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;In conclusion, JWT is easier (although &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.infoq.com&#x2F;presentations&#x2F;Simple-Made-Easy&quot;&gt;it may not be simpler&lt;&#x2F;a&gt;) than database stored tokens. Either option can work, and I don’t see a strong enough reason to drop JWT having that already working.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;nested-resources&quot;&gt;Nested resources&lt;&#x2F;h4&gt;
&lt;p&gt;This is one of the things that we debated but didn’t get to a definite answer. We have these restful resources:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&#x2F;api&#x2F;channels&#x2F;:name&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&#x2F;api&#x2F;channels&#x2F;:name&#x2F;holidays&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&#x2F;api&#x2F;channels&#x2F;:name&#x2F;reminders&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;And at some point the UI needs to display a summary view that lists channels including their holiday and reminder information.&lt;&#x2F;p&gt;
&lt;p&gt;What do we do? We obviously don’t want to force the UI to collect the data by making two extra requests per channel in the list. We don’t want to have an API tailor-made for this specific client, either. And don’t say GraphQL, because this is nowhere near big enough to call for that. View saw two acceptable solutions:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Use a generic query parameter like &lt;code&gt;?children=true&lt;&#x2F;code&gt; to indicate that all the children resources should be included in the response. The problem is that this is an all-or-nothing approach: with big enough resources, you may want some of the children and not all. I’ve seen APIs suffer from that, coming up with weird DSLs to recursively pick nested children in the responses (now, &lt;em&gt;that&lt;&#x2F;em&gt; is the case where you’d look at GraphQL nowadays).&lt;&#x2F;li&gt;
&lt;li&gt;Consider the detailed version of the channel (the one that includes its children information) as a separate resource altogether. At first this too felt a bit like forcing the backend to fit a client need (and, to be honest, looking at the URIs &#x2F;api&#x2F;channels and &#x2F;api&#x2F;channels_detail didn’t help); but after some thinking: better to let resources reproduce and keep the interface as dumb as possible (i.e. no magic query parameters).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;We could have gone either way. We chose the separate resource because it was easier to implement.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tests&quot;&gt;Tests&lt;&#x2F;h3&gt;
&lt;p&gt;I think you can’t write serious software without some sort of testing. At some point it’s inefficient to try to make progress without having tests to have your back. But I also think there are situations where being obligated to add tests is counter productive. Apart from the one commandment: &lt;em&gt;thou shalt test thy shit&lt;&#x2F;em&gt; , I don’t like any kind of religiousness about testing. Some types of software benefit a lot from unit tests (testing specific functions, isolated from the rest of the system), some not so much; coverage can be a good indicator, but forcing a specific coverage level sucks; some people work better with TDD, some people work better by adding tests after having some working code; some stuff calls for testing every possible scenario, some for generative testing. Etcetera.&lt;&#x2F;p&gt;
&lt;p&gt;In my experience over the last few years, working on small APIs that mostly deal with connecting to and integrating with external services, there’s little benefit in making pure unit tests. You have to spend a lot of time building mocks to test glue code, and still the most common scenarios can totally fail. If your software deals mostly with integrations, then you need integration tests to have some sort of confidence that your project works and that you don’t break it when you modify it. Because I change it a lot, all the time; that’s something I &lt;em&gt;am&lt;&#x2F;em&gt; religious about: if you aren’t breaking any APIs, you have the time and you know how to put your code in a better shape, then you do it every time you can.&lt;&#x2F;p&gt;
&lt;p&gt;Fortunately my coworkers share the same vision, so for HolidayPing we focused on integration tests that make sure the project works as a whole, with a real database and sending actual reminders. At first with lots of shortcuts to make sure the internal parts were working, but eventually, as development moved forward and the API stabilized, we were able to rewrite the tests so they mostly talk to the external API.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;To be continued…&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>The big old reliable elephant: talking about Postgres with Craig Kerstiens</title>
        <published>2017-04-26T00:00:00+00:00</published>
        <updated>2017-04-26T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com/posts/the-big-old-reliable-elephant-talking-about-postgres-with-craig-kerstiens/"/>
        <id>https://blog.lambdaclass.com/posts/the-big-old-reliable-elephant-talking-about-postgres-with-craig-kerstiens/</id>
        
        <content type="html" xml:base="https://blog.lambdaclass.com/posts/the-big-old-reliable-elephant-talking-about-postgres-with-craig-kerstiens/">&lt;p&gt;In this opportunity I interviewed Craig Kerstiens. Craig works for &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.citusdata.com&#x2F;&quot;&gt;citusdata&lt;&#x2F;a&gt;, a company that helps customers scale databases beyond a single node. Over the last few years, after building systems that used Redis, Cassandra, Riak, Elasticsearch and even Mongo, I rediscovered my love for PostgreSQL. The documentation is excellent, its development pace is astonishing and it is a good old reliable beast. However its feature set can be quite overwhelming. To mention just a few of its special features: you got a big option of index types (B-tree, Hash, GiST, SP-GiST, GIN and BRIN), many &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.craigkerstiens.com&#x2F;2014&#x2F;05&#x2F;07&#x2F;Postgres-datatypes-the-ones-youre-not-using&#x2F;&quot;&gt;data types&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;railsware.com&#x2F;blog&#x2F;&#x2F;2012&#x2F;04&#x2F;23&#x2F;postgresql-most-useful-extensions&#x2F;&quot;&gt;extensions&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;postgresguide.com&#x2F;sql&#x2F;window.html&quot;&gt;window functions&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;postgresguide.com&#x2F;cool&#x2F;ctes.html&quot;&gt;common table expressions&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.craigkerstiens.com&#x2F;2013&#x2F;08&#x2F;05&#x2F;a-look-at-FDWs&#x2F;&quot;&gt;foreign data wrappers&lt;&#x2F;a&gt;. As Craig said in one of this talks “Postgres is the Emacs of databases”. If you have ever used Emacs you know that learning it can take some time due to the number of choices available.&lt;&#x2F;p&gt;
&lt;p&gt;Craig helped me decide what postgres features to use and how, thanks to &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.craigkerstiens.com&#x2F;content&#x2F;&quot;&gt;his blog&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.postgresguide.com&#x2F;&quot;&gt;postgresguide.com&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;postgresweekly.com&#x2F;&quot;&gt;postgresweekly.com&lt;&#x2F;a&gt;. He has been really helpful in sharpening my postgres knife.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Discuss and vote at&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;y0k2h5&#x2F;big_old_reliable_elephant_talking_about&quot;&gt; &lt;em&gt;lobsters&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;,&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;programming&#x2F;comments&#x2F;67owq6&#x2F;the_big_old_reliable_elephant_talking_about&#x2F;&quot;&gt;&lt;em&gt;reddit&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;and&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14203940&quot;&gt; &lt;em&gt;hn&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-xBJtkf59c2V5ncf-Q-1_Eg.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why do you prefer PostgreSQL over other SQL databases?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;It was actually a little ways into my career before I came around to Postgres. I started on Oracle in college. When I found Postgres it was a bit stodgey and just correct. There was nothing wrong with it, but it wasn’t anything to write home about. What was interesting about it was the license which made it very favorable to fork and extend and add any more value. Since that time though it’s really come a long way from a user experience perspective, and really expanding beyond the “SQL” world.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why do you think a lot of developers moved away from SQL databases a few years ago?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;To be right to the point… user experience. SQL is a great language for querying lots of data. The idea that you have to setup your schema ahead of time and define your data model is painful though. Over the longterm is pays off, but there is nothing inherint in SQL that says you can’t model things in documents and have that transformed to relational. The ease and promise of document databases is huge for getting started, but it’s not a perfect long term solution…&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why did many of them return to use SQL databases?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The ability to get up and running quickly is always at odds with long term maintainability. Thats not to say that you should pre-maturely optimize, but SQL has stood a test of time of querying and accessing data and we’re seeing that in a return to systems that re-implement SQL on top of other datastores.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;In which cases wouldn’t you use PostgreSQL?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The only one that really comes to mind is graph databases. Over time PostgreSQL has gained support XML, key value, full text search, document storage, the only thing it hasn’t covered yet really is the graph arena.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is the most misused feature of PostgreSQL or SQL?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Wow, thats a tough one. I’m going to completely side step the question and say that it’s not leveraging Postgres specific features. I see a lot of developers say “I want to be able to migrate away so I’m going to do the most generic bare bones thing possible” Whether that’s not using the array datatype, JSONB, GIN or GiST indexes, at that point why even pick Postgres? The biggest mistake I see is not mis-using a feature, it’s not using it for the idea you might one day migrate.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What are your favorite PostgreSQL extensions?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Obviously I’m biased towards &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;citusdata&#x2F;citus&quot;&gt;Citus&lt;&#x2F;a&gt;. I’ve actually known the Citus team for over 4 years now, before they were an extension to Postgres. At Heroku what Iwould hear and see over and over is people running into this ceiling with Postgres. SQL databases typically work really well on a single node, and there’s this notion that SQL can’t be distributed. Citus actually solves a problem for hundreds of customers I saw outgrowing single node Postgres whether at 100 GB or 1 TB, that makes it trivial to shard out while still maintaining transactional semantics.&lt;&#x2F;p&gt;
&lt;p&gt;Though I have to mention my second favorite: &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.citusdata.com&#x2F;blog&#x2F;2017&#x2F;04&#x2F;04&#x2F;distributed_count_distinct_with_postgresql&#x2F;&quot;&gt;HyperLogLog&lt;&#x2F;a&gt;. This is one I personally have not got to put into production, but is super awesome. It’s essentially a sketch algorithm for probabilistic distincts across really large datasets.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Is there any feature that another database has that you would like PostgreSQL to have?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I think the biggest would be easier onboarding or not having to define your schema ahead of time. ToroDB aims to do some of this for Postgres when coming from Mongo, but a native Postgres experience would be huge here.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What do you recommend reading to understand the implementation of PostgreSQL?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Subscribe to the hackers mailing list.&lt;br &#x2F;&gt;
&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.postgresql.org&#x2F;list&#x2F;pgsql-hackers&#x2F;&quot;&gt;https:&#x2F;&#x2F;www.postgresql.org&#x2F;list&#x2F;pgsql-hackers&#x2F;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The best engineers (even one that don’t actively develop for Postgres subscribe here as it’s just great discussion and development).&lt;&#x2F;p&gt;
&lt;p&gt;And for a lighter read, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;postgresweekly.com&quot;&gt;postgresweekly.com&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What do you recommend reading to get better at SQL and PostgreSQL?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I actually got my foundation in relational algebra. At the time it seemed overly academic like a lot of other CS, when it comes to databases though and in particular SQL it gives you a huge leg up. I’d very much encourage people to spend some time on the academic side of relational algebra, then move to SQL syntax, over the long term it’ll really pay off.&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
