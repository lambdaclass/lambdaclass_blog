<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>LambdaClass Blog - Ocaml</title>
    <subtitle>Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.</subtitle>
    <link rel="self" type="application/atom+xml" href="https://blog.lambdaclass.com/tags/ocaml/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2016-11-15T00:00:00+00:00</updated>
    <id>https://blog.lambdaclass.com/tags/ocaml/atom.xml</id>
    <entry xml:lang="en">
        <title>MLFE: ML landing in the Erlang world</title>
        <published>2016-11-15T00:00:00+00:00</published>
        <updated>2016-11-15T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com/posts/d-day-invasion-with-mlfe-ml-landing-in-the-erlang-world/"/>
        <id>https://blog.lambdaclass.com/posts/d-day-invasion-with-mlfe-ml-landing-in-the-erlang-world/</id>
        
        <content type="html" xml:base="https://blog.lambdaclass.com/posts/d-day-invasion-with-mlfe-ml-landing-in-the-erlang-world/">&lt;p&gt;Time has passed since our last interview for &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;notamonadtutorial.com&#x2F;&quot;&gt;This is not a Monad Tutorial&lt;&#x2F;a&gt;. OpenBSD released its 6.0 version after 20 years of continues releases without agile, OpenSSL vulnerabilities keep on breeding, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;blog.bugreplay.com&#x2F;post&#x2F;152579164219&#x2F;pornhubdodgesadblockersusingwebsockets&quot;&gt;Pornhub war against ad blockers continued&lt;&#x2F;a&gt;, the Macbook Pro is not that Pro anymore, a new javascript package manager was released by Facebook and last but not least Brexit and Trump are a reality that will shape the new world order.&lt;&#x2F;p&gt;
&lt;p&gt;Going back to our endogamic tech world, I interviewed &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;noisycode.com&#x2F;&quot;&gt;Jeremy Pierre&lt;&#x2F;a&gt; about &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;j14159&#x2F;mlfe&quot;&gt;MLFE&lt;&#x2F;a&gt; or ML Flavoured Erlang. After learning Haskell and after playing with Elm I became quite a fan of ADTs and Hindley-Milner type systems so that is why I am really exited by MLFE. So I think this is a way to counterbalance my love for Lisp languages. Let’s add a little bit of ML into our coffee. One of the projects I had in my To Do list was to implement an ML like language on top of the Erlang VM&#x2F;BEAM. Instead of recreating the wheel, I hope to see further by standing upon the shoulders of MLFE. The invasion has began!&lt;&#x2F;p&gt;
&lt;p&gt;If you have any more questions please let me know via &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;vw8zb2&#x2F;d_day_invasion_with_mlfe_ml_landing_erlang&quot;&gt;lobsters&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;programming&#x2F;comments&#x2F;5d2ooi&#x2F;dday_invasion_with_mlfe_ml_landing_in_the_erlang&#x2F;&quot;&gt;reddit programming&lt;&#x2F;a&gt; or &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=12958099&quot;&gt;hn&lt;&#x2F;a&gt;. Au revoir.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-VHoeeRQqosE3Woi37aHFeA.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;2016 MLFE&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is MLFE?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;ML Flavoured Erlang is a statically typed and strict (eagerly evaluated) language for the Erlang VM patterned a little bit after parts of both OCaml and Elm. It’s incredibly early in the language’s development but we already have things like sum types and product types (e.g. tuples, records with row polymorphism) and a pretty basic foreign function interface to Erlang proper. Honestly the language is probably in need of renaming almost entirely because it’s impossible to call Erlang code directly outside of the FFI.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why did you create an ML language on top of the Erlang VM&#x2F;BEAM?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I appreciate a lot of the practicalities in the Erlang ecosystem, not least of which are the operational aspects of the VM but wanted something with faster feedback on type issues than Dialyzer currently provides, along with the brevity and expressiveness that come with features like OCaml or Elm’s ADTs. One of the earliest drivers for this was constantly wishing for Scala’s case classes every time I wrote Erlang (my day job involves both).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What are the main problems you find while coding in Erlang and while coding in ML like languages?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I don’t often work directly in ML dialects to be perfectly honest although I keep trying to find reasons to use them. Maybe that’s a subconscious reason behind starting MLFE .&lt;&#x2F;p&gt;
&lt;p&gt;As mentioned above however I do often work in Scala and its less pervasive approach to pattern matching and second class nature of things like actors on the JVM are often sore points for me. Having said that, it would be really great to have something like Scala’s Future or ScalaZ’s Task in an Erlang VM language as well. Maybe we can build something with MLFE to scratch that itch but it’s a little early to say I think.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;How did you implement the type inference algorithm?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I have to give credit (or apologize for implementing it badly?) to Oleg Kiselyov for his incredibly helpful article &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;okmij.org&#x2F;ftp&#x2F;ML&#x2F;generalization.html&quot;&gt;How OCaml type checker works&lt;&#x2F;a&gt;. I relied heavily on this, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.cis.upenn.edu&#x2F;~bcpierce&#x2F;tapl&#x2F;&quot;&gt;Types and Programming Languages&lt;&#x2F;a&gt;, and a bit on &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tomprimozic&#x2F;type-systems&#x2F;tree&#x2F;master&#x2F;algorithm_w&quot;&gt;algorithm_w&lt;&#x2F;a&gt; for the earliest work on the typer.&lt;&#x2F;p&gt;
&lt;p&gt;It started with a very basic translation to Erlang of Oleg Kiselyov’s eager&#x2F;strict inferencer examples and then grew from there. Since the algorithm relies on unification (and hence mutation), MLFE’s inferencer needs reference cells which are currently implemented as Erlang processes. I’d like to move these to something like ETS but will probably wait until trying to rewrite and clean up the typer in MLFE itself.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Do you generate core Erlang code or Erlang code?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The MLFE AST is translated to a Core Erlang AST using the “cerl” module and then compiled to BEAM modules from there.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;How do you type check messages?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In MLFE a receive block types as a &lt;em&gt;receiver&lt;&#x2F;em&gt;. Receivers are polymorphic with two parameters: the kind of messages received and the result type of the contained expression. These two parameters are determined by unifying the types in the patterns and the types in the result portion of the receive’s clauses, e.g.&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;receive with &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; 0 -&amp;gt; :zero&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; | x, is_integer x -&amp;gt; :not_zero&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;All of the above patterns are clearly integers and all of the result portions are atoms so the type (internally) in MLFE would be &lt;code&gt;{t_receiver, t_int, t_atom}&lt;&#x2F;code&gt;. As an aside we can of course use union types if we want more complex messages.&lt;&#x2F;p&gt;
&lt;p&gt;Unifying receivers with enclosing expressions makes &lt;em&gt;those&lt;&#x2F;em&gt; expressions receivers too so if we’re assigning a variable in a let expression, the whole thing becomes a receiver e.g.&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;let my_msg = receive with&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; 0 -&amp;gt; :zero&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; | x, is_integer x -&amp;gt; :not_zero &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;in [my_msg, :in_a_list, :why_not]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The above let expression is a &lt;em&gt;{t_receiver, t_int, {t_list, t_atom}}.&lt;&#x2F;em&gt; If we wrapped that in a function, the whole function is a receiver:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;foo () = let my_msg = receive with &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; 0 -&amp;gt; :zero&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; | x, is_integer x -&amp;gt; :not_zero &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;in [my_msg, :in_a_list, :why_not]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The type of the above is:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;{t_receiver, t_int, {t_arrow, [t_unit], {t_list, t_atom}}}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;That is a function from unit to a list of atoms that internally receives integer messages.&lt;&#x2F;p&gt;
&lt;p&gt;Now when we spawn a process, &lt;em&gt;spawn&lt;&#x2F;em&gt; uses the receiver’s first parameter to constrain the resulting PID to a specific type. If we spawn a function that’s a receiver of integers (resulting in a &lt;em&gt;{t_pid, t_int}&lt;&#x2F;em&gt;), all messages sent must be able to unify with &lt;em&gt;t_int&lt;&#x2F;em&gt; so if we try to send it a float or a string we get a type error at compile time.&lt;&#x2F;p&gt;
&lt;p&gt;If we spawn a function that is &lt;em&gt;not&lt;&#x2F;em&gt; a receiver, we get a &lt;em&gt;{t_pid, undefined}&lt;&#x2F;em&gt;. Since &lt;em&gt;undefined&lt;&#x2F;em&gt; will not unify with any other type, it’s a type error to send that particular process any messages at all.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;One of the biggest issues I have with Erlang is that in some cases it is necessary to write code that has a lot of nested cases. Elixir added the&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;learningelixir.joekain.com&#x2F;learning-elixir-with&#x2F;&quot;&gt;&lt;strong&gt;with&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;special form to deal with this issue. Rust 1.3 added a new&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;2016&#x2F;11&#x2F;10&#x2F;Rust-1.13.html#the--operator&quot;&gt;&lt;strong&gt;? operator&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;that provides syntax sugar that helps to deal with this issue. The RabbitMQ team created&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;blog&#x2F;2011&#x2F;05&#x2F;17&#x2F;can-you-hear-the-drums-erlando&#x2F;&quot;&gt;&lt;strong&gt;Erlando&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;using Erlang’s parse transform (Erlang like macros) that adds syntax extensions to Erlang, with the&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rabbitmq&#x2F;erlando#user-content-lots-of-different-types-of-monads&quot;&gt;&lt;strong&gt;do syntax&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;for monads being the most important one to solve somehow this issue. From what I have seen the mlfe_type.erl of MLFE also&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;j14159&#x2F;mlfe&#x2F;blob&#x2F;master&#x2F;src&#x2F;mlfe_typer.erl#L403-L427&quot;&gt;&lt;strong&gt;has this issue&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Do you plan on adding some construct or syntactic sugar to deal with this type of issue?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;This is certainly a common issue within MLFE’s typer itself. I don’t currently have plans to add any specific error handling sugar since I worry that doing so might push people away from OTP and supervision hierarchies. Having said that, I don’t think it’s at all unreasonable to have a simple error type and handling alternatives in a library. While try&#x2F;catch don’t exist yet in MLFE it could look like something as simple as the following:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;module simple_try&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;export try_f&#x2F;1, try_map&#x2F;2&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;type t &amp;#39;result &amp;#39;error = Ok &amp;#39;result | Error &amp;#39;error&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;-- try to run f, wrapping successes in Ok and failures in Error:&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;try_f f = try&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; Ok (f ())&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;catch &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; err -&amp;gt; Error err&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;-- If t is a success apply the function f to it or maintain a failed result:&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;try_map t f = match t with&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; Ok result -&amp;gt; let runner () = f result in try_f runner&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; | Error e -&amp;gt; t&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I wouldn’t call the above ideal (and we need anonymous functions to make it usable to begin with) but I think it does demonstrate that it’s relatively easy to solve the problem in a few ways without needing first-class constructs.&lt;&#x2F;p&gt;
&lt;p&gt;To be clear, I think Rust’s approach makes a great deal of sense since as far as I’m aware, its Result type is core to the language. My reluctance with doing the same in MLFE is almost entirely due to the conventions and capabilities in place with OTP that I see as beneficial in their own right.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What was the most difficult thing about implementing MLFE?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Wrapping my head around type inference and unification was definitely the most challenging thing so far. I’m still working to understand a lot of the details and I’m barely ready to dig into something like the implementation of an ML module system, especially when it comes to functors. We need parametric modules in order to type bindings to a lot of OTP so there will probably be something pretty simple and restrictive to start but I have a lot of studying and learning to do before I can be even reasonably confident we’ll still have a type system that’s decidable.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Do you have any recommendation for those of us that did not implemented any language yet?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Pick a problem or feature you find interesting and dive in! Start with a simple definitional interpreter to play with things first if you don’t want to learn an existing platform’s AST (Reynolds’ paper is &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;surface.syr.edu&#x2F;cgi&#x2F;viewcontent.cgi?article=1012&amp;amp;context=lcsmith_other&quot;&gt;great&lt;&#x2F;a&gt;) or just write an interpreter! If you wanted to target a particular runtime Core Erlang’s AST is generally pretty easy to get started with and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lfe&#x2F;&quot;&gt;LFE&lt;&#x2F;a&gt; is great to learn from. If you like the JVM then &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;graalvm&quot;&gt;Graal and Truffle&lt;&#x2F;a&gt; look really interesting too.&lt;&#x2F;p&gt;
&lt;p&gt;I haven’t yet taken the time to dig into SICP or &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;cs.brown.edu&#x2F;~sk&#x2F;Publications&#x2F;Books&#x2F;ProgLangs&#x2F;&quot;&gt;PLAI&lt;&#x2F;a&gt; (and I’ve heard Dr Krishnamurthi has been working on a new one) but want to at some point. I understand they’re both really good deep dives.&lt;&#x2F;p&gt;
&lt;p&gt;There are so many great ideas to check out and explore, recent work like Dr Jean Yang’s on &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;projects.csail.mit.edu&#x2F;jeeves&#x2F;&quot;&gt;Jeeves&lt;&#x2F;a&gt; for security policy enforcement; &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.cs.ubc.ca&#x2F;~rxg&#x2F;gtes.pdf&quot;&gt;gradual typing&lt;&#x2F;a&gt; — especially for effects — e.g. from Drs Banados Schwerter, Garcia, and Tanter; 1ML for a new approach to &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;people.mpi-sws.org&#x2F;~rossberg&#x2F;1ml&#x2F;&quot;&gt;first class modules&lt;&#x2F;a&gt; from Dr Andreas Rossberg and so much more we’ve barely dug into (Dr Barbara Liskov’s decades of work!).&lt;&#x2F;p&gt;
&lt;p&gt;We have mountains of great ideas from so many people and are barely scratching the surface, it’s really exciting. I’d enthusiastically recommend anyone with any interest in programming languages to just pick a paper to read or an idea to research and just start following where it leads. Start reading groups!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What other languages do you recommend keeping an eye on?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Rust and Pony both look like they’re doing really interesting stuff and I’m curious as to where &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;purerl&quot;&gt;purerl&lt;&#x2F;a&gt; — an Erlang backend for PureScript — will go too. There seems to be a lot of cool stuff happening on the Scheme side of things that I keep worrying I’m missing out on.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Interview with Jesper Louis Andersen about Erlang, Haskell, OCaml, Go, Idris, the JVM, software and…</title>
        <published>2015-12-28T00:00:00+00:00</published>
        <updated>2015-12-28T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com/posts/interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and/"/>
        <id>https://blog.lambdaclass.com/posts/interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and/</id>
        
        <content type="html" xml:base="https://blog.lambdaclass.com/posts/interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and/">&lt;h3 id=&quot;interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and-protocol-design-part-i&quot;&gt;Interview with Jesper Louis Andersen about Erlang, Haskell, OCaml, Go, Idris, the JVM, software and protocol design — PART I&lt;&#x2F;h3&gt;
&lt;p&gt;In this occasion we interviewed Jesper Louis Andersen, a type theorist with lot of practical knowledge and experience. His &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;@jlouis666&quot;&gt;blog&lt;&#x2F;a&gt; (you should also check his old &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;jlouisramblings.blogspot.com&#x2F;&quot;&gt;blog&lt;&#x2F;a&gt;, you will find a lot of good things over there) and code (specially things like &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jlouis&#x2F;safetyvalve&quot;&gt;safetyvalve&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jlouis&#x2F;fuse&quot;&gt;fuse&lt;&#x2F;a&gt;) have been a big inspiration to me. That is why I published the interview in two parts: I had too many questions for him. I hope you enjoy reading his answers as much as I did.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-mIrYVuSZtaYe3WJkRwUqwQ.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I published part II of the interview. &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;this-is-not-a-monad-tutorial&#x2F;interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and-5628fe591295&quot;&gt;Check it out!&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;strong&gt;Your reply to the picture that is below was:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;The typical applications I write in Erlang have 3–4 functions above it in the call stack&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Modern comfortable programming language #java:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-Ee-kDajNT561ZgOd.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why is it so? Why this is not the case in most OOP languages?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;It is not really an artifact of OOP-style languages as much as it is an artifact of how we develop software. In biology, it has been observed solutions are usually not rewriting code, but rather patching code. Imagine a world where we are more inclined to build on top of what we already have rather than go down and rewrite older parts. I think each new generation of programmers tend to add a layer on top of what we already have, mostly to put their mark on programming and to simplify and abstract the parts of the lower levels which are in common use while also hiding the rare parts. What you get is the deep call stack. Another similar view would be in geology where you can see older layers and go back in time to older periods. Much of the Java stack has this in it.&lt;&#x2F;p&gt;
&lt;p&gt;Erlang is no different, but from the outset, small-community languages are less susceptible to patching. Especially if it is easy to rewrite code, which means an itch can be scratched by writing something new, rather than building on top of what others did. What brings the call stack down to 3–4 frames, however, are processes. In an Erlang-system a typical web request is served by cooperation of 3–4 processes, each of those having a call stack. Add them all together, and you approach the above size, but in isolation, they are small. An eventual error will result in a crash report with 3 things in it: the backtrace, the state &lt;em&gt;before&lt;&#x2F;em&gt; the process crashed and the incoming message which made it crash. The reason we have the original state is because of functional programming: every data structure is persistent, so we can version it. Usually this is enough to quickly isolate and figure out where the error is and what went wrong.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;You tweeted:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Lets talk agile: The ultimate agile language is one in which you can deliver working code quickly, which is also maintainable. Hence there are only a few agile languages in existence: Haskell, Ocaml and Erlang are 3. Go, Javascript, Python and the rest lacks the necessary abstractions to be regarded as agile. You end up having to recode. However, the &lt;strong&gt;real&lt;&#x2F;strong&gt; solution is to stop doing agile. The idea is bullshit in the first place.”&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Why Haskell, OCaml and Erlang are the only agile languages?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;If the waterfall model risks not building the right product, then agile risks not building the product right. I’m very fond of Erlang creator Mike Williams point: “If you don’t make experiments before starting a project, then your whole project will be an experiment”. My hunch is what a lot of Agile process misses is that you need to experiment before you build.&lt;&#x2F;p&gt;
&lt;p&gt;If we instead ask about prototyping, then we need a programming language with certain traits. The team is usually small, so we need an expressive language, and we need to address the core kernel of the system in isolation, first. We don’t need a lot of interfacing to foreign systems and in general we won’t care too much if the system we build is fast. Also, we usually won’t need to operate the prototype in production, since it is simply a proof of concept.&lt;&#x2F;p&gt;
&lt;p&gt;From a perspective of rapid prototyping and proof-of-concept development, functional languages tend to have an edge over imperative ones. Their higher level and expressivity allows more to be said succinctly, in fewer lines of code. They also tend to describe data structures and algorithms in ways that are clearer, which helps understanding of the problem space.&lt;&#x2F;p&gt;
&lt;p&gt;In turn, since agile values the minimum viable product, moving fast and making experiments, then you need languages in which it is easy to experiment with the unknown ideas many agile projects face. In languages such as Haskell, Erlang and OCaml you can often iterate over far more designs in a limited time window. Thus you can carry out more experiments and this often leads to a better product, even if the final product is not even written in a functional language. In general I feel we value experimentation too little. Build it, throw it away, and rewrite with the new knowledge.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What do you think about Clojure?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Sadly, my experience with Clojure is limited to carrying out a set of Koans in the language, and I have not ever used it for anything serious work. I must admit I don’t find the language especially compelling, and in general I don’t find Lisp-dialects interesting. My language roots are closer to Standard ML, which may be the reason it did not catch my interest when I finally tried toying with Scheme and Common Lisp.&lt;&#x2F;p&gt;
&lt;p&gt;That said, people are doing lots of outright &lt;em&gt;amazing&lt;&#x2F;em&gt; stuff in Clojure. I think the Datomic project is genuinely interesting as a database system. And the work Kyle Kingsbury has done with his “Jepsen” framework and his “Knossos” linearizability checker in Clojure is solid work. I’m also following David Nolen’s work with interest. But I’m pretty sure the language isn’t “for me”.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;You tweeted:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Functional programming semantics are far more important than static typing for removing errors from programs.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Why? Could you elaborate?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I’ve somewhat alluded to this before, but never in more than 140 characters. In an imperative program a function depends on two things: the parameters it is passed and also the current state of the machine store. In a functional language, only the former matters. The consequence of this choice if far reaching:&lt;&#x2F;p&gt;
&lt;p&gt;One, the state space we have to reason about as human beings is far smaller for FP, which makes it harder to make a programming mistake. Two, we can test functions in isolation and be rather confident we have covered the functions execution well. Three, data processing is inductive in nature, recursing over the &lt;em&gt;structure&lt;&#x2F;em&gt; of data rather than manipulating the store from afar. The programming is closer to a proof by induction, which force the programmer to handle corner cases rigorously.&lt;&#x2F;p&gt;
&lt;p&gt;The ease of reasoning also comes into play once you have found a bug. It is often easier to figure out what the program is doing wrong just by taking a close look. It is rare you need to attach a debugger, which you can’t in a concurrent and&#x2F;or distributed system where some parts are outside of your direct control.&lt;&#x2F;p&gt;
&lt;p&gt;When you add typing to the above, you obtain another dimension where your system is (automatically) checked for additional rigor. But I often find people forget how much power there is to be had just by functional programming on its own, with no regard to types. From my own experience, functional programs tend to have an order of magnitude fewer errors than imperative counterpart programs, especially when these are subtle corner-case errors, types or not. Naturally, types + functional programming help even more. But had I the choice between imperative programming with types or functional without, I know what I’d pick without hesitation.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is your opinion regarding dependent types like the one Idris has?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I have not studied Idris very much yet, but I did some work in Agda and Coq, which both employs dependent types, albeit the type theory is subtly different between all of them. I’ve deliberately been pushing it ahead of me for a while, like I also have done with Rust. Mostly because I’d like them to settle down and mature a bit more before I start looking into them. I’d probably start looking around 2017 on both. From a research perspective, Idris is extremely important. We need to explore this area more for real world programs as well, and having a language designed for programs rather than proof-assistance is fairly important. Of course, one would like to see a more mature language, but one has to understand how much is being sunk into Idris to make this happen currently.&lt;&#x2F;p&gt;
&lt;p&gt;I’m not yet entirely convinced we necessarily want to add dependent types to mainstream languages in its full form. Perhaps it turns out we’d rather want a simpler type system in some areas in order to extend it along other dimensions. I’m somewhat interested in the Curry-Howard correspondence between distributed programming and epistemic logic for instance. And it is not a priori clear we even understand what it means to marry dependent types to such a beast. We may have to cut the cake differently in order to understand the type-level interactions.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Don’t you think that OCaml and Go compete for the same space? What has been your experience with the two languages and how do you think they compare?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;If you squint your eyes hard enough, OCaml is an imperative language on top of which you added a lambda calculus. Or it is a lambda calculus with primitive operations for imperative execution. Either way, Go and OCaml are very much alike in the core: both are garbage collected, and natively compiled languages. They tend to provide execution speed in the same ballpark: usually they are in the same order of magnitude when it comes to executing programs.&lt;&#x2F;p&gt;
&lt;p&gt;What sets the two languages apart is the underlying ideology of how to design a programming language. Go is a modest cleanup of the C semantics on top of which you add channels, goroutines and interfaces. OCaml is a programming language in the tradition of Milners Meta-Language (ML), drawing inspiration from several sources including Haskell and Standard ML, among others.&lt;&#x2F;p&gt;
&lt;p&gt;Go usually opts for simplicity and separation of features into a small basis. The language is specifically addressing concerns when programming in the large. This yields programs which are highly coherent because the programmer have relatively few abstraction tools at their disposal. In addition, the interface concept in Go is implicit, which means you have less need to alter other parts of the system. In a large setting with 100s of programmers, altering code someone else “owns” is usually measured in days, whereas local alterations takes hours. So the time lost on lower abstraction can be deceiving.&lt;&#x2F;p&gt;
&lt;p&gt;The simple coherent design of Go also fosters fast compilation with little to no abstraction overhead. It doesn’t matter what abstractions you use, your program will usually compile fast and it will be pretty obvious what the performance behavior of the program is. Fast compilation speed matters in large settings because waiting on the compiler is often wasted time[*]&lt;&#x2F;p&gt;
&lt;p&gt;Russ Cox noted that some abstractions, generics for instance, makes a trade-off between putting the onus on the programmer, the compiler or the execution speed. Leave out generics and the programmer has to work around it. Add generics, and the compiler has to do more work in the compilation phase. Or abstract away generics by a boxing construction, which affects execution speed. Go opts for the first of these.&lt;&#x2F;p&gt;
&lt;p&gt;OCaml contrasts heavily. From an abstraction perspective, it leaves Go in the dust, and supports so much more efficient use of the programmers time. The compiler is also relatively fast and it handles the added abstraction well, though at the current time there is an overhead to the abstraction use. In the notion of Cox, the current version of OCaml (4.02) sacrifices execution speed in some cases. The new FLambda IR in OCaml 4.03, shifts this onus around and puts more into the compiler[0].&lt;&#x2F;p&gt;
&lt;p&gt;Another important dividing factor is the current lack of a proper Multicore support in OCaml, which also means the lack of a proper concurrency runtime built-in by default. In OCaml, you have to rely on a system such as LWT or Async to achieve the same as goroutines do in Go. And the fact there is two, means everyone has to support both for their libraries. The situation is far from perfect.&lt;&#x2F;p&gt;
&lt;p&gt;I usually grab OCaml for problems which have certain traits. Symbolic manipulation is one thing at which OCaml excels because it has proper algebraic datatypes. Thus, I would never write a compiler or proof assistant in something else. Programs generating programs is another area in which OCaml excels. Finally, problems which have embarrassingly parallel structure can easily be handled by just spawning more OS processes in OCaml, and the cogen of OCaml is quite efficient.&lt;&#x2F;p&gt;
&lt;p&gt;I usually write Go for simple brute-force programs where the interactions are not very complex and there is a simple channel network inside the program. I avoid it for anything with complex interactions, because the simplicity of the language often gets in the way. But some problems have the virtue of being simple by construction, which makes Go a really good language.&lt;&#x2F;p&gt;
&lt;p&gt;Personally, I prefer the OCaml ideology. Add abstractions to the language, build a powerful module system, with functors, in which you can program in the large by β-reducing modules into one another. And use the compiler and computer as a sacrifice to pay for this additional abstraction. Those programs are easier to maintain, and easier to recombine.&lt;&#x2F;p&gt;
&lt;p&gt;Go and OCaml are best used for the programs where there is a part of the program which is heavily CPU-bound and you are not memory bound. The vast majority of the programs I write have little to no need to run on a tight CPU-schedule and there I usually just write them in Erlang. If you are bound by memory, you often end up in situations where the gain of dropping to OCaml or Go is small. And if you are bound by outside interaction, disk or network, there is almost no gain.&lt;&#x2F;p&gt;
&lt;p&gt;[*] Fast compilation and linking speed are two major reasons I like Erlang too.&lt;&#x2F;p&gt;
&lt;p&gt;[0] A worthwhile aside: The MLton Standard ML compiler takes this to an extreme by compiling &lt;em&gt;all&lt;&#x2F;em&gt; of the program in one fell swoop. Thus, it is able to perform whole-program analysis and optimization with perfect knowledge of the program. This makes a lot of the abstractions free, but the price is long compilation times.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;In a great post where you explained the drawbacks of JSON and REST HTTP APIS you also wrote:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;“We need to go back to our roots and start building protocols again. This change will never come from a large company. It has to rely on an open tinkerer culture. We need well-defined protocols and multiple implementations of these. Protocol design is quickly becoming a lost art. Rather, people are satiated with “APIs” to the point where they can’t recover.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;We need de-centralization. The internet is built on the idea of end-to-end interaction between machines. The current state is more of a client&#x2F;server infrastructure in which few central entities drive the status quo.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;We need distribution. If we rely on big players, we tie ourselves to their solutions. This will be a bane going forward as we build infrastructure around vendors only interesting in lock-in.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;And finally, we need education. A lot of the current “protocol design” is so bad compared to what can be found in old RFCs. If you want to implement something new, you need to study the past a lot before you build it. If you reject an old idea, you need to explain why. If you reinvent an old idea, you need to know you reinvented it and what happened historically for that idea not to catch on.”&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Could you give us some recommendations of RFC, books, articles to read and exercises to do learn how to design protocols?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Good protocol design is an art form. The goal is produce protocols which are simple to implement, are hard to implement wrong and have future extensibility. Take the TCP protocol for instance. You can implement it in hardware as a simple stop-and-go protocol, ignoring everything about sliding windows. This is a correct and valid implementation of the protocol, though it will be slow. Once that works, you can add layers on top which makes the protocol faster. In addition to the RFCs for TCP, James E. White’s RFCs, 707 and 708, are dear to my heart. They were written in 1976, and they handle a lot of problems we still have to this day: how will distributed machines communicate.&lt;&#x2F;p&gt;
&lt;p&gt;The BitTorrent protocol deserves mention as well. It defines how clients communicate, but it gives relatively few rules about how a client is supposed to implement their behavior. Once you set forth and start implementing the protocol however, you find there is only one true way of doing each part. So that could be left out of the specification. Instead, a minimal viable protocol is given, and the details can be altered as you go along. But also note how the original BT protocol used a Bit-array of 64 bits in the handshake rendezvous in order to negotiate what additional features were supported. This was later replaced with a fully extensible system because it proved to be inadequate. Whenever you see such patches of the protocol design, think about how it could have been avoided in the first place.&lt;&#x2F;p&gt;
&lt;p&gt;Another incredibly well-designed protocol is the 9p protocol from Plan9. And it is generic enough it can be adapted to a lot of other situations as well. It implements many good ideas, like out-of-order messaging, proper multiplexing of messages on one channel, requests initiated from both ends of the connection, and so on.&lt;&#x2F;p&gt;
&lt;p&gt;The general advice is to cut out any part which nominates how the peer should behave itself internally. You need to maximize the freedom of the implementer and only establish the basis for communication. Cut cut cut. Leave out everything which will not destroy the coherency and internal consistency of the protocol. Layer the protocol and push things into separate layers. A layered protocol is much easier to reason about formally, and you better be doing so though either Model Checking or quickchecking the protocol internals.&lt;&#x2F;p&gt;
&lt;p&gt;One should read the critiques of HTTP&#x2F;2.0 and how we got there from HTTP&#x2F;1.1. The protocol suffers from some rushed work, sadly. Read some of the simpler alternative approaches. As an example the PUSH message from Server to Client in HTTP&#x2F;2.0 grows out of White’s observation in RFC707: both peers in a protocol needs to be able to initiate communication. But HTTP is skewed, like most RPC, since all communication is initiated from the client toward the server.&lt;&#x2F;p&gt;
&lt;p&gt;A good approach is that of Roy T. Fielding — define what constraints you need, and then squeeze hard until the minimal protocol comes out. That is, start by defining a large framing of what you need your protocol to do and then create a protocol with those properties. TCP is defined by its constraints of being a stream protocol, connection oriented and without data loss. ZeroMQ is a message channel, connection oriented, without data loss. UDP are message oriented, datagram oriented, with loss. SCTP is …, and so on.&lt;&#x2F;p&gt;
&lt;p&gt;Protocols are far better than APIs because they invite multiple competing implementations of the same thing. They debug themselves over time by virtue of non-interaction between peers. And they open up the design space, rather than closing it down. In a distributed world, we should not be slaves to API designs by large mega-corporations, but be masters of the protocols.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Erlang and distributed systems expert gives his views on BEAM languages, Hindley–Milner…</title>
        <published>2015-08-08T00:00:00+00:00</published>
        <updated>2015-08-08T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com/posts/eric-merritt-erlang-and-distributed-systems-expert-gives-his-views-on-beam-languages-hindley/"/>
        <id>https://blog.lambdaclass.com/posts/eric-merritt-erlang-and-distributed-systems-expert-gives-his-views-on-beam-languages-hindley/</id>
        
        <content type="html" xml:base="https://blog.lambdaclass.com/posts/eric-merritt-erlang-and-distributed-systems-expert-gives-his-views-on-beam-languages-hindley/">&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-Bvd7l2Q-OmEhkVC2qcclJA.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;eric-merritt-erlang-and-distributed-systems-expert-gives-his-views-on-beam-languages-hindley-milner-type-systems-and-new-technologies&quot;&gt;Eric Merritt, Erlang and distributed systems expert, gives his views on BEAM languages, Hindley–Milner type systems and new technologies&lt;&#x2F;h3&gt;
&lt;p&gt;In this case, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;this-is-not-a-monad-tutorial&quot;&gt;This is not a Monad tutorial&lt;&#x2F;a&gt; interviewed &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;ericbmerritt&quot;&gt;Eric Merritt&lt;&#x2F;a&gt;, author of &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.manning.com&#x2F;logan&#x2F;&quot;&gt;Erlang and OTP in Action&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;joxa.org&#x2F;&quot;&gt;Joxa&lt;&#x2F;a&gt; (a small semantically clean, functional lisp running on the Erlang VM), &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;erlware&#x2F;relx&quot;&gt;relx&lt;&#x2F;a&gt; (best release creation tool in Erlang).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-XCrgX6wctMhx0GLjNQS9nw.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In the following weeks we will be talking with Robert Virding — Erlang co-inventor and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;lfe.io&#x2F;&quot;&gt;Lisp Flavored Erlang&lt;&#x2F;a&gt; creator — , &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;puffnfresh&quot;&gt;Brian McKenna&lt;&#x2F;a&gt; —&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;puffnfresh&#x2F;roy&quot;&gt;Roy&lt;&#x2F;a&gt; language creator— and with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;mirage.io&#x2F;&quot;&gt;MirageOS unikernel&lt;&#x2F;a&gt; dev team. Stay tuned!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;In the Functional Geekery podcast you stated that the Erlang VM (BEAM) is brilliant. What did it get right that other VMs did not?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.functionalgeekery.com&#x2F;episode-20-eric-b-merritt&#x2F;&quot;&gt; Functional Geekery Episode 20 - Eric B. MerrittIn this episode I talk with Eric Merritt. We talk about his background in Erlang, static typing and using OCaml, as…www.functionalgeekery.com&lt;img src=&quot;https:&#x2F;&#x2F;cdn-images-1.medium.com&#x2F;fit&#x2F;c&#x2F;160&#x2F;160&#x2F;0*ssE1kmVx69o3l2qd.&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;BEAM is the only reasonably popular VM that took the language model, in this case Actors, and leveraged that model to make the platform itself more efficient. I find that brilliant. The two major examples of that approach in BEAM are how the Garbage Collector works with the runtime and how IO works.&lt;&#x2F;p&gt;
&lt;p&gt;In many systems, Java included, the Garbage Collector (GC) must examine the entire heap in order to collect all the garbage. There are optimizations to this, like using Generations in a Generational GC, but those optimizations are still just optimizations for walking the entire heap. BEAM takes a different approach, leveraging the actor model on which it is based. That approach basically has the following tenets:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;If a process hasn’t been run, it doesn’t need to be collected&lt;&#x2F;li&gt;
&lt;li&gt;If a process has run, but ended before the next GC run, it doesn’t need&lt;br &#x2F;&gt;
to be collected&lt;&#x2F;li&gt;
&lt;li&gt;If, in the end, the process does need to be collected, only that&lt;br &#x2F;&gt;
single process needs to be stopped while collection occurs&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Those three tenets are one of the primary reasons that Erlang can be a soft-real time system &lt;em&gt;[&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;jlouisramblings.blogspot.com.ar&#x2F;2013&#x2F;01&#x2F;how-erlang-does-scheduling.html&quot;&gt;Elang has a preemptive scheduler that also plays big a part for this&lt;&#x2F;a&gt; &lt;em&gt;]&lt;&#x2F;em&gt;. The fact that the model subsets the work that the GC has to do allows that work to remain small and manageable. Its an impressive achievement.&lt;&#x2F;p&gt;
&lt;p&gt;Another big win for the BEAM and its approach to leveraging Erlang’s Actor model is that it leverages low level, efficient, non-blocking asyncronous IO primitives from the operating system to do IO, but presents a comfortable blocking interface to the language layer. Developers using the platform can use a very human understandable synchronous IO primitives while gaining all the advantages of asyncronous IO. This too, is an impressive achievement. I just gave a talk on this topic for the Seattle Scalability Meetup:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Apart from the Erlang VM (BEAM), what do you think about Erlang as a language?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I think it’s not a bad language. It has the benefit of being both very declarative and very simple. That is a big win in distributed systems where complexity composes and quickly becomes unmanagable. I tend to prefer languages with an algebraic type system and a type inferencing and reasonable meta programming capabilities. Erlang has neither and that’s unfortunate. That said, I have implemented a large number of very reliable systems in Erlang and wouldn’t hesitate to do so again.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;You implemented Joxa, a Lisp for the Erlang VM. Why did you do it?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;For a while there I was working on a problem that was best solved via a suite of DSLs. The platform we built for that was based on Erlang and BEAM, but Erlang doesn’t really lend itself to DSLs. So I decided to write Joxa to facilitate DSL development on the BEAM. It just so happens that creating DSLs for problems is a generally good idea and that makes Joxa a decent general purpose language.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is your opinion about LFE (Lisp Flavored Erlang)?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Joxa took a very different direction than LFE, even though LFE predated it by quite some time. When I ran into the problem that caused Joxa to be created, I investigated it rather deeply to see if it would solve the problem. I ran into a few issues while I was investigating it. In general, I found the implementation very hard to follow. It’s not a bad implementation, it’s just so different from the way I think about languages that it confounded me. That made it difficult for me to expand it.&lt;&#x2F;p&gt;
&lt;p&gt;I was also looking for something with simple semantics that I could build other languages on. LFE is, quite literally, Lisp Flavored Erlang. It is Erlang with S-expression based syntax. That’s not a problem unless you are looking for something with much lower level syntax to build upon. Finally, and this really is a nitpick, Macros are interpreted by LFE and that interpreter is very limited. The rest of the language is interpreted by BEAM. Having to remember if something was going to be run inside the macro interpreter or inside of the normal runtime bothered me a lot.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;And what do you think about Elixir?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I think Elixir has brought a lot of people to the Erlang world that wouldn’t have otherwise come over. That is a very good thing and a powerful contribution to the Erlang eco-system. However, I am not a big fan of Elixir itself. I find the macro system to be a bit inconsistent and I really dislike that Elixir tries to hide immutability. That does make it slightly easier for beginners, but it’s a leaky abstraction. The immutability eventually bleeds through and then you have to think about it. It also introduces additional complexity within bindings in Elixir Macros among other things. It doesn’t help that I have never been a fan of Ruby syntax and Elixir borrows heavily from that sphere.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What do you think about laziness in programming languages? In which cases do you think it is useful, if any?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I love lazyness in concept. I think the idea that computation only occurs when it’s needed is right in line with the trend that has been occurring in functional programming for many decades. The problem that I have with lazyness is more pragmatic. It is very easy to create space leaks and, as of this writing, good tools to detect and debug those space leaks don’t yet exist. That makes me very hesitant to use a language that is lazy by default in production. The Haskell guys are working hard to resolve this, and I think they will, but they haven’t yet.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why do you like Hindley–Milner type system? [the type system used in the ML family (Standard ML, Caml, OCaml, F#) and Haskell]&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-TKFIhHLhfGTz5uMBn6NfkQ.png&quot; alt=&quot;&quot; &#x2F;&gt; Image stolen from &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;learnyousomeerlang.com&#x2F;&quot;&gt;http:&#x2F;&#x2F;learnyousomeerlang.com&#x2F;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Essentially, it’s because I am lazy. Much like resource management, contract management is a slow, manual painful process. By contract management, I mean verifying that the form of data a function recieves is the form of data that it expects. A Hindley-Milner style type system allows me to offload that tedious work to the compiler. Computers are essentially better at that kind of tedious work than humans.&lt;&#x2F;p&gt;
&lt;p&gt;A type system like this is just an evolution of our ongoing effort to offload work to the computer. Originally, we wrote in machine code, then we moved up to Assembly, which was one step higher. Not long after we started using higher level languages like Fortran, Cobol and Lisp. A bit later on we started offloading resource management to the computer as well in the form of GC. An algebraic type system is just a continuation of that. With this type system we are offloading contract checking to the computer. Just like with resource management the contract checking must happen, its just that many languages force the human to do it when the compiler can do it much more effectively.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Do you think that it would be possible to create a language with a Hindley Milner type system for the Erlang VM without affecting the power of Erlang semantics?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Not only do I think its possible, I have been planning to do it for a while now, time being the limiting factor. The main problem you will run into is the mismatch between the untyped bits of the Erlang native system and the typed bits of the new language. Dialyzer attempts to solve this through Success Typing, but there may be a better way. Something like what &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;roy.brianmckenna.org&#x2F;&quot;&gt;Roy&lt;&#x2F;a&gt; [programming languages that tries to meld JavaScript semantics with some features common in static functional languages] is doing in its type system or &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;core.typed&quot;&gt;Clojure’s core.typed&lt;&#x2F;a&gt;. I am not sure, but it’s a fun and solvable problem.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Do you think it would be worthwhile adding algebraic data types to the Erlang VM? Or is using records (Erlang, Joxa) and tagged maps (Elixir) enough for all practical purposes?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Type systems have very little to do with the VM and very much to do with the language. That is, it’s usually a compile time thing rather than a runtime thing. It might actually be useful to add, simply so that BEAM can take advantage of the type annotations to run more optimized versions of the code, but it’s not especially helpful to the efforts to run a well typed language on top of the VM.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;In the past we had to create a few clients and console applications. Python and Ruby were great for building them quickly. However not being able to easily generate standalone binaries for each OS and architecture is a shortcoming of those languages. We are testing Nim and Go since they have good cross compilation and library support. Have you tried them? Could OCaml be a good alternative?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I have not tried either Nim or Go unfortunately. I have used Python extensively and Ruby as well, though to a lesser extent. I have also used OCaml extensively for these types of work and I find that I like OCaml the best. I like it for all the reasons I talked about above. That said, it is very different from other shell programming approaches and takes a bit of getting used to. I should also note that the vast majority of my work with OCaml has been in conjunction with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;janestreet.github.io&#x2F;&quot;&gt;Jane Street Capital’s Core and Async libraries&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What other languages or technologies are you keeping an eye on that we should check?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I haven’t seen any new languages pop up recently that have grabbed my interest. On technologies, I think that microkernels are very, very interesting. Things like &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;osv.io&#x2F;&quot;&gt;OSv&lt;&#x2F;a&gt; for the JVM based languages, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;mirage.io&#x2F;&quot;&gt;Mirage&lt;&#x2F;a&gt; for OCaml and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;rumpkernel.org&#x2F;&quot;&gt;BSD Rump Kernels&lt;&#x2F;a&gt; for the rest. I think those are going to become the fundamental building block of &lt;strong&gt;system orchestration&lt;&#x2F;strong&gt; in the very near future. The other thing to keep an eye on is the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;nixos.org&#x2F;nix&#x2F;&quot;&gt;Nix Package manager&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;nixos.org&#x2F;&quot;&gt;NixOS&lt;&#x2F;a&gt;, and technologies like Atlas from Hashicorp. It’s not going to be too much longer before we declaratively describe out systems as well as our code. I am looking forward to that.&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
