<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>LambdaClass Blog - Erlang</title>
      <link>https://blog.lambdaclass.com</link>
      <description>Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.</description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://blog.lambdaclass.com/tags/erlang/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Thu, 15 Jul 2021 00:00:00 +0000</lastBuildDate>
      <item>
          <title>BEAM all the things! ClojErl, an implementation of Clojure on the Erlang Virtual Machine</title>
          <pubDate>Thu, 15 Jul 2021 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/clojerl-an-implementation-of-the-clojure-language-that-runs-on-the-beam/</link>
          <guid>https://blog.lambdaclass.com/posts/clojerl-an-implementation-of-the-clojure-language-that-runs-on-the-beam/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/clojerl-an-implementation-of-the-clojure-language-that-runs-on-the-beam/">&lt;h4 id=&quot;an-interview-with-its-creator-juan-facorro&quot;&gt;&lt;strong&gt;An interview with its creator, Juan Facorro.&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Our blog has had a long standing interest in novel uses of the BEAM, or Erlang virtual machine, as shown by the many articles we have published on that topic: we talked to Eric Merritt about &lt;a href=&quot;&#x2F;eric-merritt-erlang-and-distributed-systems-expert-gives-his-views-on-beam-languages-hindley&#x2F;&quot;&gt;languages that run on BEAM&lt;&#x2F;a&gt; from a high-level overview, and went deep on &lt;a href=&quot;&#x2F;an-interview-with-the-creator-of-gleam-an-ml-like-language-for-the-erlang-vm-with-a-compiler&#x2F;&quot;&gt;Gleam&lt;&#x2F;a&gt; (an ML-like language for the Erlang VM with a compiler written in Rust), &lt;a href=&quot;&#x2F;d-day-invasion-with-mlfe-ml-landing-in-the-erlang-world&#x2F;&quot;&gt;MLFE&lt;&#x2F;a&gt; (which is short for ML-Flavored Erlang), &lt;a href=&quot;&#x2F;efene-an-erlang-vm-language-that-embraces-the-python-zen&#x2F;&quot;&gt;Efene&lt;&#x2F;a&gt; (an alternative syntax for Erlang), &lt;a href=&quot;&#x2F;gaming-with-elixir-discovering-new-lands-in-the-beam-realm&#x2F;&quot;&gt;using Elixir for videogame backends&lt;&#x2F;a&gt;, and &lt;a href=&quot;&#x2F;lasp-a-little-further-down-the-erlang-rabbithole&#x2F;&quot;&gt;Lasp&lt;&#x2F;a&gt; (“a suite of libraries aimed at providing a comprehensive programming system for planetary scale Elixir and Erlang applications”).&lt;&#x2F;p&gt;
&lt;p&gt;We also published a guide to learn &lt;a href=&quot;&#x2F;how-to-earn-your-clojure-white-belt&#x2F;&quot;&gt;Clojure&lt;&#x2F;a&gt; and an &lt;a href=&quot;&#x2F;a-pythonist-finds-a-new-home-at-clojure-land&#x2F;&quot;&gt;interview&lt;&#x2F;a&gt; that might persuade you to get into it if you haven’t already.&lt;&#x2F;p&gt;
&lt;p&gt;So our readers will understand it was inevitable for us to be interested in Juan Facorro’s project, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;clojerl&#x2F;clojerl&quot;&gt;ClojErl&lt;&#x2F;a&gt;. And of course, we interviewed him about it. We hope you enjoy it as much as we did.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h4 id=&quot;tell-us-a-little-about-clojerl-what-is-it-how-did-it-come-about&quot;&gt;&lt;strong&gt;Tell us a little about ClojErl, what is it? How did it come about?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;ClojErl is an implementation of the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;clojure.org&#x2F;&quot;&gt;Clojure&lt;&#x2F;a&gt; language that runs on the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;BEAM_(Erlang_virtual_machine)&quot;&gt;BEAM&lt;&#x2F;a&gt; (the Erlang Virtual Machine).&lt;&#x2F;p&gt;
&lt;p&gt;The project started as a learning and exploratory exercise on language implementation. The idea was born out of the combination of my desire to use Clojure at work, and me starting a new job at &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;inaka.github.io&#x2F;&quot;&gt;Inaka&lt;&#x2F;a&gt; where I learned to use Erlang (and the BEAM) to build systems.&lt;&#x2F;p&gt;
&lt;p&gt;I found that the concurrency model of the BEAM made sense to me, because it provided a framework and some guarantees that made it simple for me to think about concurrency. This has not been the case for me with other concurrency models.&lt;&#x2F;p&gt;
&lt;p&gt;The BEAM was built to solve a practical problem (i.e. high availability communication switches) and solving for concurrency was a big part of the solution, which also included immutable data structures. These two concepts, concurrency and immutability, are also at the core of Clojure’s design principles, so it seemed like a good idea to try to bring this language to the BEAM.&lt;&#x2F;p&gt;
&lt;p&gt;I’m not sure if I thought about it at the time, but the abstractions on which Clojure is built make using the language a pleasure. The example that I always use is the fact that you can use the &lt;strong&gt;count&lt;&#x2F;strong&gt; core function with almost any data structure (it only needs to implement the &lt;strong&gt;ICounted&lt;&#x2F;strong&gt; protocol). Even though it is possible to define a function like this in Erlang, I think the resulting code would not be idiomatic Erlang and it would be hard both to maintain and to extend to new types. This is not the case with Clojure.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-advantages-does-the-actor-model-bring-over-clojure-s-concurrency-model&quot;&gt;&lt;strong&gt;What advantages does the actor model bring over clojure’s concurrency model?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;I don’t think there are absolute advantages of one model over the other.&lt;&#x2F;p&gt;
&lt;p&gt;Because of the way systems are built on the BEAM and the tools it provides (i.e. lightweight processes, monitors and links), it is very suitable for building resilient systems that (when designed right) can recover from failure. This can arguably be done with any language and platform (e.g. Akka on the JVM), but I think it is simpler and easier to do when using the BEAM.&lt;&#x2F;p&gt;
&lt;p&gt;Other things are harder and end up being more complex when using Erlang, but I have wondered if this is something that is more related to the size of the community and the problems it is solving, than the language itself. The amount of Elixir libraries that have been written to do almost anything would suggest that this is very likely the case.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;when-would-clojerl-be-a-better-choice-than-regular-jvm-clojure&quot;&gt;&lt;strong&gt;When would ClojErl be a better choice than regular JVM clojure?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;I would say that whenever you need to build a system that is resilient, degrades gracefully and can recover from failures, and you don’t want to spend time on building the mechanism to achieve this from scratch. Using ClojErl will provide a battle-tested platform where all these things are already included in the VM’s design and how systems are built on it.&lt;&#x2F;p&gt;
&lt;p&gt;This assumes that you don’t need a very purpose-specific library that exists only in Java, or a Clojure library that is a lot of work to port from Clojure(Script) into ClojErl.&lt;&#x2F;p&gt;
&lt;p&gt;It also assumes that there is a library (either in Erlang or maybe other BEAM language) for every one of your needs, which unfortunately is sometimes not the case.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-much-impact-does-losing-java-interop-have-on-the-language-in-everyday-use&quot;&gt;&lt;strong&gt;How much impact does losing Java interop have on the language in everyday use?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;There is no impact as far as I can tell, although I’m biased :).&lt;&#x2F;p&gt;
&lt;p&gt;Anything that would necessitate Java interop is either replaced with Erlang interop or an implementation of the set of protocols through which Clojure interacts with the platform (e.g. &lt;strong&gt;IWriter&lt;&#x2F;strong&gt; and &lt;strong&gt;IReader&lt;&#x2F;strong&gt; for I&#x2F;O).&lt;&#x2F;p&gt;
&lt;h4 id=&quot;there-are-certain-clojure-features-that-are-unsupported-why-is-that&quot;&gt;&lt;strong&gt;There are certain Clojure features that are unsupported. Why is that?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;Clojure JVM is implemented on a platform that allows mutability, which is not the case on the BEAM.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;clojure.org&#x2F;reference&#x2F;transients&quot;&gt;Transient data structures&lt;&#x2F;a&gt; for example, rely on the fact that parts of the underlying representation can be updated in-place. The whole point of their existence is to allow for faster operations without the cost of creating new instances after each modification. This cannot be achieved on the BEAM if we want to use the native immutable data structures.&lt;&#x2F;p&gt;
&lt;p&gt;I have not explored the path of implementing a whole set of data structures through &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;erlang.org&#x2F;doc&#x2F;tutorial&#x2F;nif.html&quot;&gt;NIFs&lt;&#x2F;a&gt; that would maybe make this possible. I’m not convinced this is a good idea though, for a number of reasons. The first one is that it would be a lot of work and we would end up with an implementation that needs to be battle-tested before it can be relied upon. The second is that the cost of calling a NIF is not zero and the result might not even provide significant performance gains. And the third is that it would not be possible to use any of the built-in Erlang functions from the standard library or any of the optimizations for them added to the BEAM.&lt;&#x2F;p&gt;
&lt;p&gt;Another feature that is not implemented for Clojure on the BEAM is &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;clojure.org&#x2F;reference&#x2F;refs&quot;&gt;Refs and Transactions&lt;&#x2F;a&gt;. This feature is heavily dependent on how the JVM works and it is also not something that is very widely used (as far as I know) in the wild.&lt;&#x2F;p&gt;
&lt;p&gt;ClojErl relies only on the numeric types provided by the platform. This means that things such as ratios, big decimals, and flags about unchecked math are not available. The BEAM is not designed to provide good performance around numerical operations, so if that is your use case you are better off using another set of tools for that purpose.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-good-is-the-interoperability-with-erlang-what-about-elixir&quot;&gt;&lt;strong&gt;How good is the interoperability with Erlang? What about Elixir?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;One of the design principles for ClojErl was to make interoperability with the platform as seamless as possible.&lt;&#x2F;p&gt;
&lt;p&gt;A function call to an Erlang function is equivalent to any other Clojure function call: &lt;strong&gt;(module&#x2F;function arg1 arg2 … argN)&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Data structures are not equivalent, Clojure’s are implemented on top of Erlang’s. All Clojure core functions related to data structures (e.g. count, first, map, etc.) work for all of Erlang’s though, since the necessary protocols are implemented for them to work. It is possible to write expressions for literal Erlang data structures by using the &lt;strong&gt;#erl&lt;&#x2F;strong&gt; reader macro before a Clojure literal (e.g. &lt;strong&gt;#erl{:a 1}&lt;&#x2F;strong&gt; would be compiled to a literal Erlang map).&lt;&#x2F;p&gt;
&lt;p&gt;As mentioned before ClojErl currently provides only the numerical data types available on the BEAM: integer (unbound) and float (64 bits).&lt;&#x2F;p&gt;
&lt;p&gt;ClojErl strings are Erlang UTF-8 binaries. It is possible to write literal Erlang strings (i.e. lists of integers) by using the #erl reader macro.&lt;&#x2F;p&gt;
&lt;p&gt;Pattern matching is also available in ClojErl when using any of the special forms where bindings are created (i.e. &lt;strong&gt;fn&lt;&#x2F;strong&gt;* , &lt;strong&gt;let&lt;&#x2F;strong&gt;* , &lt;strong&gt;loop&lt;&#x2F;strong&gt;* and &lt;strong&gt;case&lt;&#x2F;strong&gt;*).&lt;&#x2F;p&gt;
&lt;p&gt;A ClojErl anonymous function can be used as an argument to any of the Erlang BIFs that expect a function, as long as the ClojErl function doesn’t use variadic arity or multiple arities. These two features are specific to Clojure, which means that Erlang code wouldn’t know how to correctly call the function in that case.&lt;&#x2F;p&gt;
&lt;p&gt;The story for Elixir is similar to Erlang’s (or any other language on the BEAM). Any function from an Elixir module can be called from ClojErl. Elixir is a little particular in that all its modules have an implicit “&lt;strong&gt;Elixir.&lt;&#x2F;strong&gt; ” prefix added by the compiler to them. There have been some people recently trying this out with some success (see &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;marcio_lopes&#x2F;status&#x2F;1400256642478903299&quot;&gt;here&lt;&#x2F;a&gt;).&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-was-is-the-most-challenging-part-of-the-project&quot;&gt;&lt;strong&gt;What was&#x2F;is the most challenging part of the project?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;The most challenging part was and still is finding ways to reconcile what the BEAM offers with the semantics of the Clojure language. Sometimes the conclusion is that we can’t support a feature (e.g. transient collections), other times we need to provide something similar but a little more limited than the original (e.g. vars), and yet other times we add something completely new to the language because we want to have interoperability with platform features (e.g. pattern matching).&lt;&#x2F;p&gt;
&lt;p&gt;Another big challenge has been performance. Some features, when implemented on the JVM, do not translate very well to how the BEAM works (e.g. transducers) which results in a much worse performance (i.e. an order of magnitude slower) than what the JVM offers. The release of OTP 24 saw the inclusion of a JIT compiler, preliminary micro-benchmarking using this release showed a lot of improvement in the run time performance of some expressions. There is still quite a lot of work to be done performance wise (both with time and memory usage) on ClojErl.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;are-there-currently-any-interesting-use-cases-for-clojerl&quot;&gt;&lt;strong&gt;Are there currently any interesting use cases for ClojErl?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;If we talk about production environment use cases, the short answer is no. The project is still in beta and there hasn’t been (that I know of) any company or individual that has used ClojErl in a production environment.&lt;&#x2F;p&gt;
&lt;p&gt;But there are some use cases that I have found interesting and fun.&lt;&#x2F;p&gt;
&lt;p&gt;One of them is &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;clojerl&#x2F;doodler&quot;&gt;doodler&lt;&#x2F;a&gt; which is an implementation of a canvas for creating animations inspired in the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;quil.info&#x2F;?example=fireworks&quot;&gt;quil&lt;&#x2F;a&gt; Clojure(Script) project.&lt;&#x2F;p&gt;
&lt;p&gt;Another one is the application behind &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;try.clojerl.online&#x2F;&quot;&gt;try.clojerl.online&lt;&#x2F;a&gt; which is built in ClojErl. I think I spent more time on the JS client-side console than on the code necessary to have a remote running ClojErl REPL.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;is-the-project-open-for-contributions-if-so-how-should-people-get-started&quot;&gt;&lt;strong&gt;Is the project open for contributions? If so, how should people get started?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;Yes, absolutely, 100%!&lt;&#x2F;p&gt;
&lt;p&gt;There are open issues to which I haven’t had time to dedicate myself and anyone that is interested in working on them and any other features or improvements, can reach out through the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;clojerl&#x2F;clojerl&quot;&gt;GitHub repository&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;jfacorro&quot;&gt;Twitter&lt;&#x2F;a&gt; ot the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;erlanger.slack.com&#x2F;archives&#x2F;C7KBUEAMC&quot;&gt;#ClojErl Slack channel&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The fastest way to have a working development environment is by using &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;gitpod.io&#x2F;&quot;&gt;gitpod.io&lt;&#x2F;a&gt;, which provides an online IDE for any public project hosted in the major code repositories (e.g. GitHub). Firing up a new environment is as simple as following &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;gitpod.io&#x2F;#github.com&#x2F;clojerl&#x2F;clojerl&quot;&gt;this link&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;How to navigate code is a little bit more complicated because the documentation around this is lacking. There is some documentation in the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.clojerl.org&#x2F;&quot;&gt;ClojErl.org&lt;&#x2F;a&gt; page and there are also &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;hexdocs.pm&#x2F;clojerl&#x2F;clj_compiler.html&quot;&gt;API docs for the Erlang modules in hex.pm&lt;&#x2F;a&gt;. But they provide a limited view and there are some important things that are not included there, therefore until there is more documentation for developing ClojErl I am available for people to reach out with their questions.&lt;&#x2F;p&gt;
&lt;p&gt;Other areas that need some love are tools for developing. The &lt;strong&gt;rebar3_ClojErl&lt;&#x2F;strong&gt; plugin currently provides pretty good support for compiling, testing, building applications and script; and starting up a REPL. The area that is not so great is the editor support for ClojErl. Syntax highlighting is available and simple to get, but it would be an amazing developer experience if &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;erlang-ls&#x2F;erlang_ls&quot;&gt;&lt;strong&gt;Erlang-ls&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; could also parse ClojErl files and help navigate the code both in Erlang and ClojErl.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;can-i-use-any-library-written-in-erlang-directly-in-clojerl&quot;&gt;Can I use any library written in Erlang directly in ClojErl?&lt;&#x2F;h4&gt;
&lt;p&gt;Yes! ClojErl is “just” an Erlang library, which means you can combine it with any other Erlang library and&#x2F;or application by using &lt;strong&gt;rebar3&lt;&#x2F;strong&gt; and the dedicated &lt;strong&gt;rebar3_ClojErl&lt;&#x2F;strong&gt; plugin.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>LAM: an actor-model VM for WebAssembly and native</title>
          <pubDate>Fri, 26 Feb 2021 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/lam-an-actor-model-vm-for-webassembly-and-native/</link>
          <guid>https://blog.lambdaclass.com/posts/lam-an-actor-model-vm-for-webassembly-and-native/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/lam-an-actor-model-vm-for-webassembly-and-native/">&lt;p&gt;An interview with its creator, Leandro Ostera.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-ZA5-hKa-yYGz8FX-kmZh9g.png&quot; alt=&quot;&quot; &#x2F;&gt;Source: &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;abstractmachines.dev&#x2F;&quot;&gt;https:&#x2F;&#x2F;abstractmachines.dev&#x2F;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Here, at NAMT, we are in love with the Actor Model.&lt;br &#x2F;&gt;
Within this paradigm, the basic units of computation are called actors. There is no shared state between them, instead, they interact via message passing. This has the advantage that actors become trivial to paralellize (in Erlang, an actor is called a &lt;em&gt;process&lt;&#x2F;em&gt;) and errors became easier to handle.&lt;&#x2F;p&gt;
&lt;p&gt;The actor model is a concurrency paradigm created by Carl Hewitt in 1973 with the goal of making the task of writing concurrent programs simpler. It is based on the idea of actors, entities that can only send, receive and process messages. By reducing the amount of shared state it reduces the need of locks for synchronization. There exists several battle-tested implementations of the Actor Model such as Erlang&#x2F;OTP, Akka (Scala&#x2F;Java) and Orleans (C#).&lt;&#x2F;p&gt;
&lt;p&gt;In this interview, we chat with Leandro Ostera, the founder of Abstract Machines. Ostera is working on LAM, The Little Actor Machine, an embeddable virtual machine for the actor model that runs native or compiles to WebAssembly.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;The questions for this interview were thought by Juan Pablo Amoroso, Javier Chatruc &amp;amp; Federico Carrone. Joaquín Centeno and Juan Bono wrote the introduction and edited the article.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;strong&gt;Tell us a bit about your project lab, Abstract Machines. What kind of work do you do?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I started Abstract Machines with a single goal in mind: build tools that would help me think more clearly.&lt;&#x2F;p&gt;
&lt;p&gt;Right now what I do think about the most is writing software. I think typed languages help me think clearly, so I’m building Caramel, an OCaml for the BEAM. I also think that understanding the program that runs your programs is fundamental to thinking clearly about the quality of what you build, so I’m building LAM, an actor-model VM.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;LAM’s tagline is “A Little Actor Machine that runs on Native and WebAssembly”. Could you give us a brief overview of the actor system?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The original name was Leandro’s Abstract Machine. Like Prolog’s WAM was named after Warren, Warren’s Abstract Machine, and the early Erlang VM was JAM after Joe’s Abstract Machine. But Little I think it’s a much better name overall: LAM should be small, tiny even.&lt;&#x2F;p&gt;
&lt;p&gt;The actor system it implements is in spirit very close to Erlang’s take on the actor model — processes with mailboxes, message passing across them, fair scheduling through reduction counting. There’s a few more things in the roadmap, like process linking and monitoring. Overall, if you have worked with Erlang or Elixir before, you should feel right at home with LAM.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is the motivation behind LAM? Why build a BEAM alternative?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;LAM’s mission is to make Actor concurrency available everywhere by providing a specified, lightweight runtime. Think LuaVM meets the Actor Model. I’ve always liked the LuaVM, there’s a certain elegance to it that I find very appealing.&lt;&#x2F;p&gt;
&lt;p&gt;One of the reasons to build an alternative is that the BEAM is rather large, and the implementation is the only real spec. [Erik Stenmans’ Beam Book] or [kvavks Beam Wisdoms] have tried to document it, but without an official effort to produce a JVM style spec (like the one you can get in a bookshelf), it’s unlikely we will have a reliable drop-in alternative any time soon.&lt;&#x2F;p&gt;
&lt;p&gt;So I thought I could instead make a new thing that could learn from both the LuaVM and the BEAM. At 35 instructions, LAM can run an interesting amount of Erlang programs, in fact I’d like most code that runs on the BEAM to be bytecode-translatable to run on LAM. Not all of it tho, and we’ll see what doesn’t make the cut.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;One of LAM’s targets is WebAssembly. Is there any alternative actor system for the web? How do they compare with LAM?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Yes, there are plenty! A most promising one these days is Lunatic, but on the Erlang side of things, there’s the up-and-coming Lumen.&lt;&#x2F;p&gt;
&lt;p&gt;Most of the rest are libraries for building actor applications in other languages, like how Actix lets you use Actors in Rust. Lumen in particular is more of a compiler + runtime that brings Erlang down to LLVM and gives you this single optimized executable.&lt;&#x2F;p&gt;
&lt;p&gt;LAM by contrast is a higher level VM: you feed it bytecode (spawn, send, receive, call, make list, etc), and as it runs it, side-effects happen through FFI&#x2F;Bindings depending on the platform.&lt;&#x2F;p&gt;
&lt;p&gt;Around LAM there’s a tiny compilation toolchain that takes that bytecode, lowers it to something that can be run a little faster, and packs it &lt;em&gt;with the VM&lt;&#x2F;em&gt; in a single binary that is optimized for a specific platform.&lt;&#x2F;p&gt;
&lt;p&gt;Because the VM is tiny, and the FFIs are pluggable, it’s straightforward to compile it to WebAssembly and run your bytecode there.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;The documentation mentions that one of the goals is to support Erlang&#x2F;OTP’s supervision tree structure. Would this allow more reliable&#x2F;resilient web UIs, capable of gracefully recovering from errors?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Absolutely! I expect it to let you build even more natural and flexible UIs. After all the “event” model fits perfectly: when process Button receives message Click, do this&#x2F;that.&lt;&#x2F;p&gt;
&lt;p&gt;The main problem is that preemptive scheduling makes it impossible to guarantee certain processes will have enough time to make stuff like animations run smoothly. But I’m borrowing the idea of dirty schedulers and considering introducing Greedy Processes instead, that can either request upfront how much time they need, or just run to completion. Definitely interesting to experiment with hard-real time scheduling as well.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What are some interesting use cases for LAM?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Off the top of my head, there’s 2. The first one is perhaps why I want it the most these days: fast cli tools. Write ’em in Erlang&#x2F;Elixir&#x2F;Caramel, ships as a single binary.&lt;&#x2F;p&gt;
&lt;p&gt;The second one will have the largest impact on how we build for the BEAM: actually writing full-stack applications in a single BEAM Language.&lt;&#x2F;p&gt;
&lt;p&gt;Write your backend in Elixir and run it on the BEAM, write your frontend in Elixir too but run it on LAM. And it doesn’t have to be a web-based app, it could be an actual native GUI application too.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why write it in Rust? Is the Rust-WASM toolchain mature enough to target WASM reliably with LAM?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I love Rust. It’s a good language and the learning curve has certainly taught me a lot about how to build software. I think the Rust-wasm toolchain is pretty mature these days too.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Besides performance (LAM compiles AOT), what will be the advantages of LAM over the BEAM?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Really the AOT stuff I can’t consider an advantage — I don’t expect LAM to be fundamentally faster than the BEAM, especially after the BeamJIT work. Nor do I expect it to compete in speed with Lumen.&lt;&#x2F;p&gt;
&lt;p&gt;What I see as an advantage is that LAM is being built to have a Specification and to be Embeddable.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;WebAssembly lacks a garbage collector and the BEAM is a GC environment. How does LAM tackle this?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;There is a wasm-gc spec in the works, and some other folks are waiting on it as well (like the OCaml-wasm efforts).&lt;&#x2F;p&gt;
&lt;p&gt;But since WebAssembly isn’t the only LAM target, we’ll have to embed a GC anyway. I expect it to work very closely to the BEAMs (per process collections, ref counted binary strings, etc). I haven’t looked so deeply into this, but I have a chunky book waiting for me (The Garbage Collection Handbook).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Is this a solo project or are you looking for contributors? If you are looking for contributors, how should they get started (first issues, roadmap, etc)?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;So far it is just me, but I’d love to build a friendly and welcoming community around it. At the moment I’ve been focused on getting this vertical slice of the project up and running so it becomes easier to do some horizontal scoping: how far along are we with the specification, or how much of the BEAM bytecode can we support via translation.&lt;&#x2F;p&gt;
&lt;p&gt;There’s tons of work to do starting at the design level. From figuring out how to build the right layers to FFIs across platforms (native, wasi, web), to how to optimize the main emulator loop to crunch the bytecode as fast as possible, to GC and bundling the final binaries, to writing the spec and the manual.&lt;&#x2F;p&gt;
&lt;p&gt;Formalizing the spec is a big topic where I hope I can get some interest from the TLA+ community to guide me into doing justice to both TLA+ and LAM.&lt;&#x2F;p&gt;
&lt;p&gt;LAM could use help across the board, so if you’re reading this please tweet at me (&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;leostera&#x2F;&quot;&gt;@leostera&lt;&#x2F;a&gt;)!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;For our last question, in general, what are your favorite books, articles or resources for programmers?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I think that if you asked me this a year ago I would have regurgitated a bunch of books that I should list here, but that didn’t really further my understanding. There’s a lot of reference material that is just terrible for learning, because its meant to be a compendium of information rather than a pedagogically written introduction to a subject.&lt;&#x2F;p&gt;
&lt;p&gt;For example, Types and Programming Languages by Benjamin Pierce is deemed &lt;em&gt;the ultimate&lt;&#x2F;em&gt; reference for type stuff. But I learned more about the nature of typing by reading The Little Typer. After that it was a lot easier to get into the right headspace to understand what Pierce wanted me to get out of the book.&lt;&#x2F;p&gt;
&lt;p&gt;So if you’re getting into a subject, don’t rush for the ultimate reference, and find something written to teach you &lt;em&gt;the core&lt;&#x2F;em&gt; of the subject. Then the rest becomes a little easier.&lt;&#x2F;p&gt;
&lt;p&gt;Virtual Machines by Iain D. Craig, and Formal Development of a Network-Centric RTOS have been very useful in working with LAM. Hillel Wayne’s Practical TLA+, and Alloy’s Software Abstraction books have been really good to get a better grip on how to specify systems as well. Of course &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;lamport.azurewebsites.net&#x2F;tla&#x2F;book.html&quot;&gt;“Specifying Systems” by Lamport&lt;&#x2F;a&gt; has been a good reference as well.&lt;&#x2F;p&gt;
&lt;p&gt;Some books that have had a massive impact in how I think and communicate have (unsurprisingly) nothing to do with computers. Like Umberto Eco’s “6 Walks in the Fictional Woods” (focused on how to create narratives and rhetoric) or Mandelbrot’s “The (Mis)Behavior of Markets” (a historical account of how fractal geometry describes better the financial markets). Nonetheless, they’ve helped shape the way I think and I’ve come out a better programmer.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-nPPWbd4-7dJavk5P.gif&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>An interview with the creator of Gleam: an ML like language for the Erlang VM with a compiler…</title>
          <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/an-interview-with-the-creator-of-gleam-an-ml-like-language-for-the-erlang-vm-with-a-compiler/</link>
          <guid>https://blog.lambdaclass.com/posts/an-interview-with-the-creator-of-gleam-an-ml-like-language-for-the-erlang-vm-with-a-compiler/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/an-interview-with-the-creator-of-gleam-an-ml-like-language-for-the-erlang-vm-with-a-compiler/">&lt;h3 id=&quot;an-interview-with-the-creator-of-gleam-an-ml-like-language-for-the-erlang-vm-with-a-compiler-written-in-rust&quot;&gt;An interview with the creator of Gleam: an ML like language for the Erlang VM with a compiler written in Rust&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-ivv-xih7D4rulPdRNmSYkg.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I have been writting soft real time systems with Erlang for almost a decade and for that task I think it is the best tool we have around. The concurrency model, the preemptive scheduler, the GC, the profiling tools, the libraries and the community are excellent for the task. Distribution libraries like &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;lasp-lang.readme.io&#x2F;docs&quot;&gt;Lasp&lt;&#x2F;a&gt; or distributed systems frameworks like &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;riak_core_tutorial&quot;&gt;Riak Core&lt;&#x2F;a&gt; are not easily available in other languages. At last, cheap processes, non shared state, supervisors and the let it crash philosophy are great tools when you are writing backends. Instead of trying to catch all the errors at compile time, you accept that it is impossible to catch all the possible problems and you deal with that reality. It is a very different error handling model from what you can find in Haskell or OCaml.&lt;&#x2F;p&gt;
&lt;p&gt;However Erlang language is pretty simple. I always miss sum types when I am coding in Erlang. I miss ML’s type system expressiveness, safety and practicality. That is why I am interested in the development of Gleam, a statically typed functional programming language for the BEAM.&lt;&#x2F;p&gt;
&lt;p&gt;Another interesting thing about Gleam is that its compiler is written in Rust. I think that Rust is a sort of ML + C language. I like C since the developer is at the driver seat driving with manual transmission. I can’t explain very well but I have always seen C as a simple and powerful language but I have always disliked C++. Knowing that I like ML and C you might understand why I find Rust an interesting language.&lt;&#x2F;p&gt;
&lt;p&gt;To sum up we (me and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;JuanBono&quot;&gt;Juan Bono&lt;&#x2F;a&gt;) decided to do this interview with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;louispilfold&quot;&gt;Louis Pilfold&lt;&#x2F;a&gt; not only because of what it is, but also because it is implemented in Rust. Go ahead and check &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lpil&#x2F;gleam&quot;&gt;Gleam’s repo&lt;&#x2F;a&gt;!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-x_OU1YRmBR8037eqsSAfYA.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;strong&gt;Tell us a little about yourself. Have you been working on programming languages for long?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Professionally I’m a web programmer, but over the last 4 years my hobby projects have largely been compilers in one form or another. Two of the most popular ones have been Dogma (an Elixir to angry error message compiler) and exfmt (an Elixir to slightly prettier Elixir formatter). For the last year I’ve been focusing on Gleam, which is an ML inspired statically typed language for the Erlang ecosystem.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What was the first programming language you learned?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The first language I attempted to learn was C, though with no experience and nothing but a few youtube videos I didn’t make much progress. After that I discovered an online version of MIT’s introduction to computer science and worked my way through that, so Python was the first program I successfully learnt. After finishing the course I discovered Ruby, which became my day-to-day language and my introduction to the world of web dev and professional programming, and then Haskell, which really shaped how I think about solving problems with code.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why do you think that the ML languages are a good fit for the BEAM VM?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Both families share the same lambda calculus core, and once you’ve discarded the various bells and whistles of the individual languages (such as processes, type classes, module functors, etc) they all have strikingly similar semantics. Given these shared semantics I think we can take the much loved type systems of ML languages and the proven value of the BEAM VM to create a language that has the best of both, or at least lots of fun :)&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;How does Gleam compare to the other ML-like initiatives targeting the Erlang VM? (Alpaca, Elchemy, etc). What are the main differences and what motivated you to create Gleam?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I think Gleam has a subtly different outlook to the other projects, it is more focused on using the learnings of ML to enhance the BEAM rather than creating an actual ML language. This thinking has resulted in some design differences such as simple interop in both directions, no auto-currying, no effects system, curly brace based syntax, and an Erlang style module system.&lt;&#x2F;p&gt;
&lt;p&gt;I’m very glad that there are multiple projects working in this area. If Gleam fails and one of the other projects manages to build a healthy community then I’ll still be happy, I just want at one to succeed so I can use it in the real world.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Do you compile Gleam directly to BEAM bytecode?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The Gleam compiler has had a few full rewrites. The previous version compiled to BEAM bytecode via Core Erlang, which is an intermediate representation with the Erlang compiler, but the current version compiles to regular Erlang source code that has been pretty-printed. This has a few nice advantages such as providing an escape hatch for people who no longer wish to use Gleam, and enabling Erlang&#x2F;Elixir&#x2F;etc projects to use libraries written in Gleam without having to install the Gleam compiler.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What kind of type system Gleam uses? (Hindley-Milner?)&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Gleam uses a Hindley-Milner type system with a fairly standard implementation of Algorithm W. One slightly unusual addition is that row types are used to represent both records (which are Erlang maps) and modules, making them polymorphic in a way that I believe fits the way we use maps and modules in Erlang&#x2F;Elixir.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Does the static typing provide any run-time guarantees beyond the compilation checks?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;At runtime all types have been erased and there are no run-time checks. This is nice for performance and makes calling Gleam from Erlang easier, but it means there’s no way of automatically handling an incorrect type annotation when calling Erlang from Gleam.&lt;&#x2F;p&gt;
&lt;p&gt;If you have an unruly or unreliable Erlang function that you wish to call from Gleam the standard library provides a module for handling dynamically typed data that can be used to handle the return values safely at runtime.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;How does the type system interact with message passing and distribution? How do you handle the message passing features of erlang? Have you given any thought on protocol specification as type checking?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Currently we don’t have a good solution for typed message passing and such, and development is currently focused on building the more run-of-the-mill parts of the language. Rather than introduce a flawed stop-gap solution that will later need to be replaced I’ve opted not to have first class support for the BEAM’s low level concurrency primitives, so these will have to be used via Erlang FFI.&lt;&#x2F;p&gt;
&lt;p&gt;On the other hand OTP behaviours such as gen_server can be implemented using Gleam’s first class module system, which is enough to start writing OTP applications using Gleam today.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why did you choose Rust for implementing the Gleam compiler? (instead of choosing erlang&#x2F;elixir, etc)&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Gleam started as a few little experiments in Elixir but fairly quickly shifted over to Erlang. In December 2018 I realised I was going to have to refactor the type inference module in a fairly major fashion in order to correct a mistake in the design. The typer was easily the most complex part of the compiler and had accrued a lot of technical debt as I learnt and iterated on the language so I wasn’t feel very confident about the refactoring, especially without a static type system to guide me.&lt;&#x2F;p&gt;
&lt;p&gt;I decided that a full rewrite of the compiler would give me a chance to produce a better application without the mistakes of the first version, and using a statically typed language would enable me to refactor more easily in future. I picked Rust, and after roughly 3 months I had a new compiler with roughly the same features, fewer bugs, and less tech debt. It’s also considerably faster.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Is Rust a good language for implementing programming languages?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Yes, I think so. The type system is sophisticated and robust enough to take refactorings that would have bested me in the Erlang version and complete them with relatively little stress and fewer bugs. The tooling, documentation, and libraries are delightful, and the community is exceptionally friendly and helpful.&lt;&#x2F;p&gt;
&lt;p&gt;As a nice little bonus the performance of Rust has improved the user experience somewhat; Compilation is faster and there’s no longer a noticeable lag caused by the Erlang virtual machine booting and loading the various modules.&lt;&#x2F;p&gt;
&lt;p&gt;However it’s certainly not a perfect language for compiler implementation. Rust’s linear type system means it doesn’t need a garbage collector, but it can be a very frustrating experience learning how to write code that type checks, and the resulting code can be quite verbose. I speculate that if I had opted to use OCaml instead the type inference code would be under half the size it currently is.&lt;&#x2F;p&gt;
&lt;p&gt;I’m quite sure that someone with more Rust experience could make a lot of my code more concise and remove unnecessary memory allocations, but what we have today performs well and isn’t too difficult to modify. Overall I’m very happy with the decision to use Rust.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What kind of features do you plan to add to Gleam in the future (if any)? Were you inspired by a specific language?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The two main features I’ve been asked about are typed message passing (as you have enquired about above!) and some form of ad-hoc polymorphism like Haskell’s type classes. I don’t think that type classes are a good fit for Gleam, though perhaps something like OCaml’s proposed implicit module system could be worth exploring. Either way it will be a long time before we can start to design and experiment here, there’s plenty to do beforehand.&lt;&#x2F;p&gt;
&lt;p&gt;I’d like to enhance how atoms are represented at type level. Currently we can say “this value is an atom”, but that’s about it. It would be more useful if we could say “this value is the atom ‘ok’ or the atom ‘error’”, or “this function can takes the atom ‘up’ or the atom ‘down’, but no other atom”. This could also be extended to create polymorphic enum variants too, though I’m unsure whether it makes sense to have those as well as Gleam’s existing pre-declared enums.&lt;&#x2F;p&gt;
&lt;p&gt;It could be fun to have some alternative backends for the compiler so that we can compile to Javascript or a native binary, allowing Gleam to be used for cloud functions, command line tools, and other applications to which BEAM is less suited.&lt;&#x2F;p&gt;
&lt;p&gt;A much more mundane feature I’m interested in is record punning, as found in Javascript or Haskell. It would be nice to be able to write this&lt;&#x2F;p&gt;
&lt;p&gt;let {name, score} = player&lt;&#x2F;p&gt;
&lt;p&gt;Instead of&lt;&#x2F;p&gt;
&lt;p&gt;let {name = name, score = score} = player&lt;&#x2F;p&gt;
&lt;p&gt;However that syntax has already been taken by tuples, so something would need to change for us to have this feature.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What recommendations would you give to someone who wants to start writing their first programming language?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Write lots of code in your language before writing the compiler! Solve lots of simple problems and compile it in your mind so that you can work out how all the different features would interplay and how it might work under the hood. Writing a compiler takes a lot of time so the more experimentation and learning you can do to build confidence in your language design the better. Changing syntax when you have one file of fake code takes seconds, while with a compiler it may take many hours. Worse still, changing the semantics of your language in your compiler could take days or weeks. It pays to get the design right first.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Holiday Ping: how we implemented our first open source app with Erlang and Clojurescript</title>
          <pubDate>Tue, 14 Nov 2017 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/holiday-ping-how-we-implemented-our-first-open-source-app-with-erlang-and-clojurescript/</link>
          <guid>https://blog.lambdaclass.com/posts/holiday-ping-how-we-implemented-our-first-open-source-app-with-erlang-and-clojurescript/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/holiday-ping-how-we-implemented-our-first-open-source-app-with-erlang-and-clojurescript/">&lt;p&gt;After almost ten years of working as a developer for different companies, two years ago I started my own company &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;&quot;&gt;LambdaClass&lt;&#x2F;a&gt;. I did so because I wanted to have more freedom in choosing the type of projects and team I work with.&lt;&#x2F;p&gt;
&lt;p&gt;That is why today it is a very special day for me. We take a break from regular interviews and celebrate the release of our first open source application: &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;holidayping.lambdaclass.com&#x2F;&quot;&gt;Holiday Ping&lt;&#x2F;a&gt;. Facundo Olano is the main developer of the application. The application was written in two of the best programming languages we know (Clojure and Erlang) and our favorite database (PostgreSQL). This post was written by him and tells his journey and lessons learned with the backend side. A similar post on the frontend will be forthcoming. If you find any issue or want to help check &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;holiday_ping&quot;&gt;github&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Discuss and vote at&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;mgefw9&#x2F;holiday_ping_how_we_implemented_our_first&quot;&gt; &lt;em&gt;lobsters&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;,&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;programming&#x2F;comments&#x2F;7cweat&#x2F;holiday_ping_how_we_implemented_our_first_open&#x2F;&quot;&gt;&lt;em&gt;reddit&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;and&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=15695955&quot;&gt; &lt;em&gt;hn&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-9ngymzWNwkPMhZ9u7uZ_XA.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;background&quot;&gt;&lt;strong&gt;Background&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;Earlier this year I joined LambdaClass, a Buenos Aires-based software consultant founded a while ago by some colleagues and schoolmates. LambdaClass has a special interest in distributed systems, and while it’s not exclusively an Erlang shop, most of its projects are implemented in &lt;em&gt;BEAM&lt;&#x2F;em&gt; languages.&lt;&#x2F;p&gt;
&lt;p&gt;Although I have a recent background in microservices and functional languages (mainly Clojure), I needed some time to ramp up and gain experience with the OTP platform and its underlying philosophy. I started working on some of the LambdaClass projects right away, but there are aspects of the learning process, specially those related with architecture and design, that are best experienced in greenfield projects. The company also has the goal of a strong open source presence, thus the decision to spend part of my time on public side projects.&lt;&#x2F;p&gt;
&lt;p&gt;We considered a couple of mid sized projects and implemented one of them (which arguably looked smaller in scope than ended up being). The purpose of this document is to share our experience, put some of our discussions into words so we wrap our understanding of them, and make conclusions that can help us in future projects.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-project&quot;&gt;The Project&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;holidayping.lambdaclass.com&quot;&gt;HolidayPing&lt;&#x2F;a&gt; is a small web application that sends holiday reminders through different services like email and slack. It’s mainly aimed at consultants and freelancers used to work with clients abroad. It’s free of charge and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;holiday_ping&quot;&gt;open source&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;spin-off-projects&quot;&gt;Spin-off projects&lt;&#x2F;h3&gt;
&lt;p&gt;As part of the HolidayPing effort, we have started to design and implement some open source tools that solve a couple of problems that we identify as recurring: &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;throttle&quot;&gt;throttle&lt;&#x2F;a&gt;, to perform access control over resources such as API endpoints, and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;reconnections&quot;&gt;reconnections&lt;&#x2F;a&gt;, to initiate and maintain connections to external services in an OTP idiomatic way.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-backend&quot;&gt;The Backend&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;language-erlang-vs-elixir&quot;&gt;Language: Erlang vs. Elixir&lt;&#x2F;h4&gt;
&lt;p&gt;The first decision was the programming language: Erlang or Elixir. We use both at LambdaClass, so I’d eventually have to learn them both, the question was which was more effective to learn first, considering both goals of being productive and properly understanding the Erlang platform in the long run.&lt;&#x2F;p&gt;
&lt;p&gt;Elixir would have probably been easier, considering my previous background and that it has a syntax closer to other modern languages. But learning it first carried the risk of just scratching the surface of OTP: using the language like &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=ChUB5Oj2Jj4&quot;&gt;it’s the new Ruby&lt;&#x2F;a&gt;, and hiding what’s going on underneath. It does seem like it’s simpler to get a good understanding of the “OTP way” by starting with Erlang, especially since &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;learnyousomeerlang.com&#x2F;&quot;&gt;there’s literature that guides you through the process&lt;&#x2F;a&gt;. Then, switching to Elixir would mostly consist of getting familiar with a new syntax and a few language features.&lt;&#x2F;p&gt;
&lt;p&gt;We understand that as Elixir is gaining popularity and more Elixir code is being written, a deeper understanding of Erlang and OTP will become a valuable asset for the company. In addition, many robust and useful libraries are written in Erlang and being able to dive in the code is important.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;learning-erlang&quot;&gt;Learning Erlang&lt;&#x2F;h4&gt;
&lt;p&gt;A quick note on my impressions of the language: I found it to be very expressive, mostly because of pattern matching; coming from Clojure, I didn’t have issues to grasp Erlang’s functional aspects; contrary to a lot of people, I don’t mind the syntax, I actually like it a lot with the exception of some notable quirks (one comes to mind: binary literals, while very powerful, are very inconvenient as a string replacement). As my coworkers kept telling me and I later confirmed: OTP is the big deal, and not the language itself.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;application-and-supervisor-structure&quot;&gt;Application and supervisor structure&lt;&#x2F;h4&gt;
&lt;p&gt;At a high level, the application can be divided into the following components&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;A RESTful API, mostly for CRUD operations.&lt;&#x2F;li&gt;
&lt;li&gt;A Process that periodically checks whether reminders should be sent (e.g.: today is a holiday in Bob’s country, and Bob asked to send reminders through slack and email channels).&lt;&#x2F;li&gt;
&lt;li&gt;Worker processes that send the reminders.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;rest-api&quot;&gt;Rest API&lt;&#x2F;h3&gt;
&lt;p&gt;The CRUD API didn’t require much thinking, at least from the OTP point of view. It’s implemented with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;ninenines.eu&#x2F;docs&#x2F;en&#x2F;cowboy&#x2F;2.0&#x2F;guide&#x2F;rest_handlers&#x2F;&quot;&gt;Cowboy rest handlers&lt;&#x2F;a&gt;, and I’ll just note that the library does a great job at forcing you to define a well behaved REST server without too much code.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;reminder-checker&quot;&gt;Reminder checker&lt;&#x2F;h4&gt;
&lt;p&gt;The processes involved in the reminders were more interesting, and obviously more important since the value of the application depends on them working properly (&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;jlouisramblings.blogspot.com.ar&#x2F;2010&#x2F;11&#x2F;on-erlang-state-and-crashes.html&quot;&gt;this is the “error kernel” of the app&lt;&#x2F;a&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;The process that checks whether holidays should be sent (remind_checker) is a gen_server that uses timer:send_interval to periodically query the database, asking what reminders should be sent. It then triggers worker creation with the necessary data to send the reminders.&lt;&#x2F;p&gt;
&lt;p&gt;How often the checker runs and what information is passed to workers are things that changed as the model and its implementation got more sophisticated, but the general idea was to always isolate the decision to send a reminder from the act of sending it, so a failure in a specific channel wouldn’t affect other channels, other users, or the checker process.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;reminder-router&quot;&gt;Reminder router&lt;&#x2F;h4&gt;
&lt;p&gt;The reminders are sent by gen_server processes called reminder routers, which are children of a supervisor under a simple_one_for_one strategy. Different channel modules implement the specifics to send the message on each service (email, slack, webhook).&lt;&#x2F;p&gt;
&lt;h4 id=&quot;why-not-gen-event&quot;&gt;Why not gen_event?&lt;&#x2F;h4&gt;
&lt;p&gt;While first studying OTP behaviors, my coworkers suggested I defer reading about gen_event, since it wasn’t used much in practice. When I started to work on HolidayPing, though, which is almost entirely about setting up and triggering events, it sounded like gen_event would be something to consider. And indeed a superficial overview confirmed that; quoting the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.erlang-in-anger.com&#x2F;&quot;&gt;Erlang in Anger book&lt;&#x2F;a&gt;: &lt;em&gt;a gen_event will act as an event hub for callbacks, or as a way to deal with notifications of some sort&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;So I went back to my coworkers: how come we aren’t using gen_event for this? It turns out that this behavior &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.afronski.pl&#x2F;2015&#x2F;11&#x2F;02&#x2F;what-is-wrong-with-gen-event.html&quot;&gt;doesn’t provide much of the benefits&lt;&#x2F;a&gt; one would expect for such an event hub. In terms of what was discussed at the beginning of this section, gen_event does not provide isolation between events, so a slow or crashing event would affect the rest.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;why-not-worker-pools&quot;&gt;Why not worker pools?&lt;&#x2F;h4&gt;
&lt;p&gt;At a certain point in the development, each router was sending the reminders for all the channels of a user on a given holiday. We wanted to further separate processing to have isolated channel requests (e.g. we don’t to bypass email sending if there was a crash requesting Slack).&lt;&#x2F;p&gt;
&lt;p&gt;The obvious option was to add a second simple_one_for_one supervisor with a new gen_server, but we briefly considered a worker pool instead. In other language ecosystems, where threads are expensive, a pool is an usual option. In Erlang, though, the story is different: processes are cheap and there’s no reason upfront to force a limit on the amount of processes being created (with some exceptions, such as maintaining a pool of connections to a database). And if you hit a point where there’s so much work to do that the amount of concurrent processes becomes too expensive, you most likely will need something fancier than a pool to overcome it (i.e. the pool manager will become a bottleneck or the queue will grow faster than workers can process it).&lt;&#x2F;p&gt;
&lt;p&gt;Admittedly, our situation is atypical in the sense that a potential overload wouldn’t come from requests constantly arriving, but a burst of reminders that need to be sent when the checker runs (currently every 15 minutes). We could easily alleviate this load by spreading the reminders through the time we have between one checker run and the next. Then again, it would be a useless optimization to do this upfront.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;avoiding-throttling-issues&quot;&gt;Avoiding throttling issues&lt;&#x2F;h4&gt;
&lt;p&gt;Which brings me to an issue that we didn’t notice until I was writing these lines, and that’s &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;holiday_ping&#x2F;issues&#x2F;34&quot;&gt;still open&lt;&#x2F;a&gt;. While we don’t have reasons to expect that our system won’t be able to handle sending all reminders at once, it’s likely that the third party services we hit will enforce throttling limits on us.&lt;&#x2F;p&gt;
&lt;p&gt;Let’s say that hopefully a thousand developers from Argentina find our project useful, and all of them set up a Slack channel, with the default reminder settings. If that’s the case, on Christmas morning at about 9:00am the reminder checker will attempt to send a thousand requests to Slack, more or less at the same time. Slack will likely reject those requests (and their retries next time the checker runs).&lt;&#x2F;p&gt;
&lt;p&gt;One way to reduce the chance of this happening, would be the same as mentioned in previous section: spread the reminder sending across the available time between one run and the next. Of course, with enough users the limit could be hit anyway and we’d have to resort to finer grained queuing or throttling mechanisms.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;database&quot;&gt;Database&lt;&#x2F;h3&gt;
&lt;p&gt;The database pick was simple: &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;@jlouis666&#x2F;how-to-build-stable-systems-6fe9dcf32fc4&quot;&gt;&lt;em&gt;PostgreSQL is the default database&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;For me it had been years either &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;facundoolano.wordpress.com&#x2F;2012&#x2F;03&#x2F;11&#x2F;django-db-optimization-for-pedestrians&#x2F;&quot;&gt;hiding the database behind an ORM&lt;&#x2F;a&gt;, or using schema-less stores like MongoDB. Although the lazy developer inside of me grumbled a bit at having to define the schemas upfront, I eventually came to remember how amazingly flexible and powerful PostgreSQL can be, to the point where I found myself pushing stuff (e.g. time arithmetics) to the database level because it was just easier to work with than the available Erlang libraries. We even &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;holiday_ping&#x2F;issues&#x2F;179&quot;&gt;want to explore&lt;&#x2F;a&gt; domain integrity constraints to implement the long-postponed input validations on the backend.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;handle-the-configuration-differences-between-channels&quot;&gt;Handle the configuration differences between channels&lt;&#x2F;h4&gt;
&lt;p&gt;Our model had a spot that was hard to fit in the database schema: the user creates channels that can be of different types (Slack, email, webhook), each with different configuration parameters. The email channel takes a list of email addresses, webhook takes a single url, Slack takes an hook url, a list of channels and users, an emoji, etc.&lt;&#x2F;p&gt;
&lt;p&gt;We care about those differences only in each end of the application: when we validate the user input, and when we execute the type-specific logic to send a reminder; everywhere else, we want to treat the channels equally, regardless of the configuration. We tried several PostgreSQL features to save the channel configuration.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;inheritance&quot;&gt;Inheritance&lt;&#x2F;h4&gt;
&lt;p&gt;This use case seemed like a good fit for &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;9.6&#x2F;static&#x2F;ddl-inherit.html&quot;&gt;table inheritance&lt;&#x2F;a&gt;: we wrote a base channel table with all the common fields (user, name, type) and separate tables inheriting from it adding the type-specific configuration. But we soon found out that inheritance features are &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;9.6&#x2F;static&#x2F;ddl-inherit.html#DDL-INHERIT-CAVEATS&quot;&gt;very limited&lt;&#x2F;a&gt; and don’t provide the features that would justify the choice: unique constraints aren’t enforced across children, you can’t get children’s data when querying the parent, etc.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;plain-tables&quot;&gt;Plain tables&lt;&#x2F;h4&gt;
&lt;p&gt;Given that inheritance didn’t provide much operational value, using separate tables for configuration and managing them manually made more sense. This is the way to go in the long run, since we want to benefit from type validations and constraints, but compared with a schemaless storage, it would induce a lot of overhead in the early stages of development, considering the channel types and the model in general were far from being stable.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;hstore&quot;&gt;hstore&lt;&#x2F;h4&gt;
&lt;p&gt;We started looking at unstructured PostgreSQL data types. &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;static&#x2F;hstore.html&quot;&gt;hstore&lt;&#x2F;a&gt; is a key&#x2F;value type, but it doesn’t have arrays (e.g. more than one value per key). We needed this for channel options, so hstore didn’t do the trick.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;jsonb&quot;&gt;jsonb&lt;&#x2F;h4&gt;
&lt;p&gt;So we turned again to &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;9.5&#x2F;static&#x2F;datatype-json.html&quot;&gt;JSON&lt;&#x2F;a&gt;. jsonb fields let us store arbitrary configuration inside the channel table, and treat it like an opaque value except on the spot where we actually use that configuration to send a reminder. Arguably this is the most convenient option only because we never got to the point of thoroughly validating channel input in the backend. When we get there, it will make sense to define properly structured tables first.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;rest-api-1&quot;&gt;Rest API&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;identifiers&quot;&gt;Identifiers&lt;&#x2F;h4&gt;
&lt;p&gt;We’ve spent some time discussing ways of identifying our resources across the project. This is a relevant discussion since it applies to most of our projects; we may as well settle with one design and be consistent from now on.&lt;&#x2F;p&gt;
&lt;p&gt;As we see it, the most flexible method is to use:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;A serial ID, just for PostgreSQL. Every table has it, you use it for foreign keys and joins. You don’t want to expose it in the API, since it’s implementation dependent, and something that may not be reusable should you want to switch databases (or add an extra one).&lt;&#x2F;li&gt;
&lt;li&gt;A separate ID to uniquely identify the resource: a UUID that will never change and can be reused across databases.&lt;&#x2F;li&gt;
&lt;li&gt;When it makes sense, a “model” ID for the resource (a user email, an unique name, etc.). You may use it as an identifier in the user facing API (i.e. in the REST uris or the UI routes), to make it user friendly. But you shouldn’t rely on it for internal storage and correlation: even if you start out with an “email won’t change” assumption, business rules like that do change and there’s no benefit in relying too heavily on them for your implementation.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The last one is something we didn’t get entirely right, and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;holiday_ping&#x2F;issues&#x2F;113&quot;&gt;there’s still work to do&lt;&#x2F;a&gt;. Our current implementation has model IDs (user email, channel name, holiday date), but no external UUIDs, so some use cases like changing a channel name are not supported.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;authentication-and-authorization&quot;&gt;Authentication and authorization&lt;&#x2F;h4&gt;
&lt;p&gt;To manage authorization of the API, we went with Bearer tokens based on previous experience. What’s convenient about token authorization, as opposed to, say, requiring Basic Auth on every request, is that it allows us to decouple the authentication from the authorization: if we want to support a new authentication method (which we did when we added GitHub login), we just add a new auth endpoint that returns an access token; authorization on the rest of the API remains untouched.&lt;&#x2F;p&gt;
&lt;p&gt;Regarding the token format, I initially went with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;jwt.io&#x2F;&quot;&gt;JWT&lt;&#x2F;a&gt; without giving it much thought, because that’s what I’ve seen most commonly used to authorize web apps accessing a REST backend. My coworkers, who haven’t heard about it before, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;holiday_ping&#x2F;issues&#x2F;20&quot;&gt;were suspicious&lt;&#x2F;a&gt;, which I understand, because it totally sounds like:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-LmkSEubDQc5xYFKb.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;And we’re &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;@jlouis666&#x2F;two-technologies-which-are-bad-for-you-160311ad6b24#13fd&quot;&gt;not very fond of JSON&lt;&#x2F;a&gt;. So I digged up a little bit more to make sure the decision made sense. There are &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;cryto.net&#x2F;~joepie91&#x2F;blog&#x2F;2016&#x2F;06&#x2F;13&#x2F;stop-using-jwt-for-sessions&#x2F;&quot;&gt;several&lt;&#x2F;a&gt; &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;kev.inburke.com&#x2F;kevin&#x2F;things-to-use-instead-of-jwt&#x2F;&quot;&gt;articles&lt;&#x2F;a&gt; expressing concerns about using JWT, although most of them don’t apply to our use case. Assuming we want to stick to Bearer tokens, the alternative to JWT would be to &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;auth0.com&#x2F;blog&#x2F;ten-things-you-should-know-about-tokens-and-cookies&#x2F;#token-oauth&quot;&gt;just store a random string in the database&lt;&#x2F;a&gt;, associated with the user, and check that value on every request. A quick comparison between the two options:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;JWT lets you identify the user without the need to hit the database on every request: the server decodes the token with the same secret it used to generate it, and checks the claims. To be fair, at least in our use case, there’s no evidence that going to the database on each request would be a problem.&lt;&#x2F;li&gt;
&lt;li&gt;JWT is stateless, which seems to be more inline with REST principles: there’s no session, the client sends the token on each request which is enough to identify it.&lt;&#x2F;li&gt;
&lt;li&gt;Database stored tokens require a bit of extra effort: we need to manage expiration ourselves, delete old tokens and make sure we pick a secure enough method to generate them. On the other hand, blacklisting compromised tokens is easier than with JWT, since we can just flag them in the database (although this is &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;7030694&#x2F;why-do-access-tokens-expire&#x2F;7035926#7035926&quot;&gt;less of an issue&lt;&#x2F;a&gt; using a short expiration).&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;In conclusion, JWT is easier (although &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.infoq.com&#x2F;presentations&#x2F;Simple-Made-Easy&quot;&gt;it may not be simpler&lt;&#x2F;a&gt;) than database stored tokens. Either option can work, and I don’t see a strong enough reason to drop JWT having that already working.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;nested-resources&quot;&gt;Nested resources&lt;&#x2F;h4&gt;
&lt;p&gt;This is one of the things that we debated but didn’t get to a definite answer. We have these restful resources:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&#x2F;api&#x2F;channels&#x2F;:name&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&#x2F;api&#x2F;channels&#x2F;:name&#x2F;holidays&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&#x2F;api&#x2F;channels&#x2F;:name&#x2F;reminders&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;And at some point the UI needs to display a summary view that lists channels including their holiday and reminder information.&lt;&#x2F;p&gt;
&lt;p&gt;What do we do? We obviously don’t want to force the UI to collect the data by making two extra requests per channel in the list. We don’t want to have an API tailor-made for this specific client, either. And don’t say GraphQL, because this is nowhere near big enough to call for that. View saw two acceptable solutions:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Use a generic query parameter like &lt;code&gt;?children=true&lt;&#x2F;code&gt; to indicate that all the children resources should be included in the response. The problem is that this is an all-or-nothing approach: with big enough resources, you may want some of the children and not all. I’ve seen APIs suffer from that, coming up with weird DSLs to recursively pick nested children in the responses (now, &lt;em&gt;that&lt;&#x2F;em&gt; is the case where you’d look at GraphQL nowadays).&lt;&#x2F;li&gt;
&lt;li&gt;Consider the detailed version of the channel (the one that includes its children information) as a separate resource altogether. At first this too felt a bit like forcing the backend to fit a client need (and, to be honest, looking at the URIs &#x2F;api&#x2F;channels and &#x2F;api&#x2F;channels_detail didn’t help); but after some thinking: better to let resources reproduce and keep the interface as dumb as possible (i.e. no magic query parameters).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;We could have gone either way. We chose the separate resource because it was easier to implement.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tests&quot;&gt;Tests&lt;&#x2F;h3&gt;
&lt;p&gt;I think you can’t write serious software without some sort of testing. At some point it’s inefficient to try to make progress without having tests to have your back. But I also think there are situations where being obligated to add tests is counter productive. Apart from the one commandment: &lt;em&gt;thou shalt test thy shit&lt;&#x2F;em&gt; , I don’t like any kind of religiousness about testing. Some types of software benefit a lot from unit tests (testing specific functions, isolated from the rest of the system), some not so much; coverage can be a good indicator, but forcing a specific coverage level sucks; some people work better with TDD, some people work better by adding tests after having some working code; some stuff calls for testing every possible scenario, some for generative testing. Etcetera.&lt;&#x2F;p&gt;
&lt;p&gt;In my experience over the last few years, working on small APIs that mostly deal with connecting to and integrating with external services, there’s little benefit in making pure unit tests. You have to spend a lot of time building mocks to test glue code, and still the most common scenarios can totally fail. If your software deals mostly with integrations, then you need integration tests to have some sort of confidence that your project works and that you don’t break it when you modify it. Because I change it a lot, all the time; that’s something I &lt;em&gt;am&lt;&#x2F;em&gt; religious about: if you aren’t breaking any APIs, you have the time and you know how to put your code in a better shape, then you do it every time you can.&lt;&#x2F;p&gt;
&lt;p&gt;Fortunately my coworkers share the same vision, so for HolidayPing we focused on integration tests that make sure the project works as a whole, with a real database and sending actual reminders. At first with lots of shortcuts to make sure the internal parts were working, but eventually, as development moved forward and the API stabilized, we were able to rewrite the tests so they mostly talk to the external API.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;To be continued…&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Lasp: a little further down the Erlang rabbithole</title>
          <pubDate>Tue, 09 May 2017 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/lasp-a-little-further-down-the-erlang-rabbithole/</link>
          <guid>https://blog.lambdaclass.com/posts/lasp-a-little-further-down-the-erlang-rabbithole/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/lasp-a-little-further-down-the-erlang-rabbithole/">&lt;p&gt;A few years ago I found &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;lasp-lang.readme.io&#x2F;docs&quot;&gt;Lasp&lt;&#x2F;a&gt;: &lt;em&gt;“a suite of libraries aimed at providing a comprehensive programming system for planetary scale Elixir and Erlang applications”&lt;&#x2F;em&gt;. At this point it should come as no surprise for you to learn that here at Not a Monad Tutorial we are are interested in distributed systems and Erlang. After playing a little bit with Lasp I watched a few talks by its creator: &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;cmeik&quot;&gt;Christopher Meiklejohn&lt;&#x2F;a&gt;. After watching his talk &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=lsKaNDj4TrE&quot;&gt;“Distributed, Eventually Consistent Computations”&lt;&#x2F;a&gt; I decided it was time to interview Christopher.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Discuss and vote at&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;3gvmyl&#x2F;lasp_little_further_down_erlang&quot;&gt; &lt;em&gt;lobsters&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;,&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;programming&#x2F;comments&#x2F;6a620o&#x2F;lasp_a_little_further_down_the_erlang_rabbithole&#x2F;&quot;&gt;&lt;em&gt;reddit&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;and&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14300763&quot;&gt; &lt;em&gt;hn&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-SKlcy2D4QxhBrMdNYNCIHA.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is Lasp?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Originally, Lasp was a programming model designed for deterministic distributed computing with weak synchronization. Lasp’s programming model appears function, in that you write applications that look like functional programs, but under arbitrary distribution, these applications are guaranteed to return the correct result, with minimal coordination, under network anomalies such as network partitions or node failures. Lasp achieves this by building upon the design philosophy of Conflict-free Replicated Data Types, or CRDTs: data structures that are designed to achieve convergence without requiring locking or other synchronization primitives.&lt;&#x2F;p&gt;
&lt;p&gt;During the evaluation phase of Lasp, we were tasked with trying to scale a prototype implementation written in Erlang to 10,000 nodes; we got as far as we could in the allotted time we had, which was 1,024 nodes running on Amazon EC2. In the process of trying to achieve that scale, we had to develop a number of libraries in Erlang to provide supporting infrastructure: new distribution algorithms, optimized implementations of the data types, deployment and operations tooling, etc. So, I’d say at this point Lasp, in the academic sense refers to the original programming model, but Lasp in the industrial sense, refers to the entire suite of libraries that deliver the programming system and programming model at large scale.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What are CRDTs? What problems do CRDT solve?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;CRDTs, or Conflict-free Replicated Data Types, are data types that are designed for use in distributed systems: think regular sequential abstract data types, but with a predefined, deterministic merge function for any two possible values.&lt;&#x2F;p&gt;
&lt;p&gt;One of the big challenges in distributed computing is related to consistency. When a network partition occurs, any system that is managing replicated data must make a choice: do they allow operations to proceed, remaining available-under-partition, or do they prohibit operations to proceed, remaining consistent-under-partition.&lt;br &#x2F;&gt;
Consistent-under-partition systems, or CP systems, provide strong consistency which makes application development easier, whereas available-under-partition systems, or AP systems, allow the developer to both exploit available concurrency in the system for performance, and keep servicing requests when network partitions inevitably occur. Available-under-partition systems are ideal for applications that are geo-distributed, because they allow users to read and write locally to their geographically close replica and don’t incur a synchronization penalty for write operations (which, in some cases can be &amp;gt; 100ms an operation).&lt;&#x2F;p&gt;
&lt;p&gt;However, one of the challenges in using available-under-partition systems is the potential for write conflicts: two writes happen to the same object concurrently at two replicas. When the network ultimately convergences, the different replicas have to come to an agreement over which value wins. When using a database with opaque value registers that you &lt;code&gt;set&lt;&#x2F;code&gt; or &lt;code&gt;get&lt;&#x2F;code&gt; values on, this choice can be arbitrary: either choice may be valid, and systems like Cassandra resort to solving this by using the user provided timestamp to pick a value. Approaches like this, while deterministic, are problematic, however, because arbitrarily picking a value based on time and dropping the other write operation may fail to capture developer intent.&lt;&#x2F;p&gt;
&lt;p&gt;CRDTs say, rather than have opaque registers, why not store actual data types in the database, and then have a conflict resolution policy that is compatible with the semantics of the data type. One example of a trivial CRDT is the grow-only set: if you can never remove elements from the set, it’s always safe to merge copies of a set, that is independently modified, using the set union operation. Similar designs exist for sets where you can add and remove elements arbitrarily, graphs, dictionaries, counters, and booleans.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What other alternatives exists apart from CRDTs to solve the same type of issue?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Operational transformation is an alternative approach, which predates CRDTs, and was used to build both Google Docs and Apache Wave. Operational transformation relies on “transforming” edit operations based on concurrent operations so they achieve the desired effect through the transformation once the document has been modified. There exist a significant number of different algorithms, each which makes a different set of tradeoffs, and there’s no algorithm that’s better than the others in the general case. Its are extremely difficult to implement correctly and to verify, given the number of possible operations and operation interleaving and transformations that must be considered.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Are there any downsides of using CRDTs?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;CRDTs can be very expensive in terms of implementation and state synchronization. Lots of effort has gone into reducing the overhead in state transmission through both operations-based CRDTs (a variant that sends just operations instead of state, with the tradeoff that it requires a stronger property for message delivery from the network) and delta-CRDTs (a variant that minimizes the required state that needs to be transferred by minimizing the change representation.)&lt;&#x2F;p&gt;
&lt;p&gt;One open challenge for both CRDTs, and any system that has to manage a large-amount of replicas of objects that will be concurrently operated on, is actor management. Typically, these systems and data structures must carry metadata sizes O(n) on the number of actors to ever modify an object in the system: in a system with a large amount of mobile devices and high churn, this can be prohibitive in terms of space. Recent approaches to try to address this problem rely on either imposing a structure on the way nodes share information with one another to allow some nodes to subsume the changes of other nodes, or allowing transient nodes to temporarily “borrow” identities of a smaller number of permanent nodes so the identifiers of temporary nodes aren’t carried around in the objects metadata indefinitly.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;lasp-lang.readme.io&#x2F;docs&#x2F;what-is-lasp-pg&quot;&gt;&lt;strong&gt;Lasp process registry&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;? Why create a new process registry if we already got global, pg2, gproc or syn in Erlang?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;About three or so years ago I created Riak PG, a process registry that used the same distribution strategy as Riak (with, a corresponding paper presented at the Erlang Workshop that year.) I created this process registry because I had done an extensive study and writeup about why pg2, proc, and global are not designed properly for&lt;br &#x2F;&gt;
distributed scenarios where partitions can occur and availability is paramount.&lt;&#x2F;p&gt;
&lt;p&gt;Lasp PG is a natural extension of this, where it uses an unstructured overlay with full replication and CRDTs instead of partial replication across a structured overlay network and CRDTs.&lt;&#x2F;p&gt;
&lt;p&gt;While Ericsson is working on scaling the global facility and growing distributed Erlang to support a larger number of nodes, they are focusing on:&lt;&#x2F;p&gt;
&lt;p&gt;a) supporting existing applications developed at Ericsson with distributed Erlang&lt;&#x2F;p&gt;
&lt;p&gt;b) smaller scale of nodes, operating in a LAN configuration (think ~200–500)&lt;&#x2F;p&gt;
&lt;p&gt;Their solution for scaling global shards the information across nodes, and requires availability of the DHT (they are using Kademlia, a structured overlay network) for requests to be serviced.&lt;&#x2F;p&gt;
&lt;p&gt;Lasp (and, therefore, Lasp PG) is focusing on large-scale, wide-area programming: think ~10–100k nodes operating at geo-scale. In this scenario, partitions are common — in fact, mobile clients or IoT devices might disable their antennas to preserve battery. In this scenario, we have to assume that nodes are not aware of every other node in the network, have to route messages through other nodes, and have to be resilient to partitions and have the ability to keep operating. Lasp PG is the first step towards this, and our work that was presented at Erlang Factory, Loquat, is the second step towards this goal.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Do you think that parts of what you created and found while developing Lasp will be ported to more traditional programming languages?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Hopefully, but it’s unclear what components will end up being useful or not. We are mainly focused on quickly prototyping things and performing evaluations, all in Erlang and Elixir, to determine which approaches scale, are easy to program with, etc.&lt;&#x2F;p&gt;
&lt;p&gt;I think that once we get a bit further along in the research, maybe 4 to 5 years, that some of the ideas we’re just coming up with now might be useful and developed enough to make it into the mainstream.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;lasp-lang.readme.io&#x2F;docs&#x2F;overview&quot;&gt;&lt;strong&gt;Partisan&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;? Why did you not use the default distributed Erlang?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Partisan is a membership layer for clustering groups of Erlang nodes. It bypasses distributed Erlang completely, can run in a variety of topologies, will soon support connection multiplexing, and has full support for TLS&#x2F;SSL. Partisan can support clusters of nodes running in star-topologies, random unstructured overlays, and clusters that are fully connected.&lt;&#x2F;p&gt;
&lt;p&gt;Distributed Erlang is a bit too rigid for us: it assumes a fully connected network, which is extremely difficult to scale to large clusters of nodes, and uses a single TCP connection between all processes communicating from one node to another. In order to build a more reliable system that would scale to large clusters of nodessecurely, we needed our own membership layer for state dissemination. Right now, partisan doesn’t support all of the semantics that Erlang provides, but we’re actively working with some developers in the open source community to extend partisan to support normal Erlang message passing across our highly-available framework.&lt;&#x2F;p&gt;
&lt;p&gt;We’ve also started to see some companies using Erlang and Elixir pick up partisan as a tool for helping them build reliable, large-scale, applications that need to do efficient state dissemination which is very nice for an implementation that came out of a research group.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What other programming languages or pieces of software do you keep an eye on?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Right now, what I’m most excited about is Space-Time Insight’s implementation of Microsoft Orleans in Erlang, called &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;SpaceTime-IoT&#x2F;erleans&quot;&gt;Erleans&lt;&#x2F;a&gt;. I think that Orleans take a lot of the complexity out of actor management in Erlang and Elixir and helps developers get straight to building distributed applications without having to focus on the low level details around message routing, actor placement, and actor creation and termination.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What do you recommend reading or doing for those of us that we are trying to learn more about distributed systems?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I think that everyone is building distributed applications nowadays — from your web developer building a rich-web client in JavaScript to mobile developers building the next hit application — we all have to deal with the problems of state, synchronization, offline operation, and maintaining consistency.&lt;&#x2F;p&gt;
&lt;p&gt;That said, from the academic side, I’ll recommend&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.springer.com&#x2F;gp&#x2F;book&#x2F;9783642152597&quot;&gt; “Introduction to Reliable and Secure Distributed Programming”&lt;&#x2F;a&gt; from Cahin, Guerraoui, and Rodrigues. It’s the book that my university teaches with, and the course that I’ve TA’d and contributed content to.&lt;&#x2F;p&gt;
&lt;p&gt;The course is also taught via a MOOC on edX as well, and I’ll be doing&lt;br &#x2F;&gt;
a guest lecture this semester in Part 2 on Lasp and CRDTs.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.edx.org&#x2F;course&#x2F;reliable-distributed-algorithms-part-1-kthx-id2203-1x&quot;&gt;Reliable Distributed Algorithms, Part 1This course gives a comprehensive introduction to the theory and practice of distributed algorithms for designing…www.edx.org&lt;img src=&quot;https:&#x2F;&#x2F;cdn-images-1.medium.com&#x2F;fit&#x2F;c&#x2F;160&#x2F;160&#x2F;0*I3V5Fl71IfPeGbC2.&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.edx.org&#x2F;course&#x2F;reliable-distributed-algorithms-part-2-kthx-id2203-2x&quot;&gt;Reliable Distributed Algorithms, Part 2The course will help students gain an in-depth understanding of distributed algorithms to build reliable and scalable…www.edx.org&lt;img src=&quot;https:&#x2F;&#x2F;cdn-images-1.medium.com&#x2F;fit&#x2F;c&#x2F;160&#x2F;160&#x2F;0*wlK5JSGA0E8nK6Kp.&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Gaming with Elixir: discovering new lands in the BEAM realm</title>
          <pubDate>Thu, 20 Apr 2017 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/gaming-with-elixir-discovering-new-lands-in-the-beam-realm/</link>
          <guid>https://blog.lambdaclass.com/posts/gaming-with-elixir-discovering-new-lands-in-the-beam-realm/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/gaming-with-elixir-discovering-new-lands-in-the-beam-realm/">&lt;p&gt;In this opportunity I interviewed somebody I don’t normally interview: a client, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;chrisjimison&#x2F;&quot;&gt;Chris Jimison&lt;&#x2F;a&gt;, CTO of Merigo. One of my clients. After working for almost a year with Merigo, I appreciate and understand the differences between using a BEAM language to develop a typical REST JSON system and using it to develop a videogame backend. I am not aware of many companies using Elixir to develop backends. I have only watch a talk by Jamie Winsor called “&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;_i6n-eWiVn4&quot;&gt;Building And Releasing A Massively Multiplayer Online Game”&lt;&#x2F;a&gt;. I hope to be able to interview Jamie in the following weeks.&lt;&#x2F;p&gt;
&lt;p&gt;To sum up I did this interview because I wanted to share my experience of using Elixir for developing a different kind of beast. I am also writting a post about what I like and dislike about Elixir after developing in Erlang for quite a few years.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Discuss and vote at&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;f1wxuc&#x2F;gaming_with_elixir_discovering_new_lands&quot;&gt; &lt;em&gt;lobsters&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;,&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;programming&#x2F;comments&#x2F;66hnpk&#x2F;gaming_with_elixir_discovering_new_lands_in_the&#x2F;&quot;&gt;&lt;em&gt;reddit&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;and&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14156379&quot;&gt; &lt;em&gt;hn&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-3HjK0CX5813XXtDwfKIhWw.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Could you describe your experience in the software industry?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I started in the software industry about 15 years ago. My career has been focused in the game development industry, specializing in networking problems. This includes games that have a peer-to-peer deterministic game play model, all the way to big MMORPG titles. In the last 7 years I have been working on mobile titles where the game networking requirements are more of a hybrid of REST and MMORPG-style technologies. Some companies I have worked for in the past include EA, Sony R&amp;amp;D, NGMOCO and DeNA.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;merigo.co&#x2F;&quot;&gt;&lt;strong&gt;Merigo&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;About 3 and a half years ago my cofounders and I decided we wanted to start our own company to help game developers be more successful in the market. One of the big issues that has come around in the last 4–5 years is single player games just don’t make that much money in the market place (outside of the occasional indie hit). As mobile game developers move into the “Online Gaming” space, the costs of creating these applications are increasing exponentially. When the iPhone 3G first launched (this was the first model that had the App Store) many game teams consisted of one or two engineers — a “large” game having 3–5 engineers. We are now seeing team sizes of anywhere between 10–20 and have even heard of some titles consisting of over 30 engineers. This means costs of titles are skyrocketing and the need to “fail fast” is more critical. “Fail fast” gets to the heart of game development. A game designer comes up with an idea they “think” will be fun. However you don’t truly know until you have it in your hands to play. Some ideas work, some don’t. With such a high development cost, many game teams must choose to implement a feature and hope that it works because they don’t have the budget to try a second or third time. Merigo wants teams spending more time “focusing on the fun” and less time worrying about how to make it all work.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is SDE?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The Merigo SDE (Server Development Environment) is a system that allows developers to build out their server logic quickly without having to worry about all the pain of how to scale out and manage their stack. We provide many common game services such as authentication, purchase verification, leaderboards, player persistence, etc. However the SDE is not a bunch of black box REST APIs. The SDE enables developers to write custom “scripts” in Elixir that can be loaded&#x2F;updated at runtime, allowing them to create custom APIs and behaviors needed for their application. Since we have provided the basic framework of how the scripts are managed and when they are called we can now “scale” this logic out across a distributed server cluster. Our main philosophy with the SDE is “servers are cheap, people are expensive”. With the SDE we wanted to provide a system that allows for fast development and rapid iteration with the knowledge that you can always spin up new servers to balance the load, even if your business logic is not optimized for high performance. Each team can then decide where they want to invest their time once the game goes “live.” They can decide where to best invest their time: building new features or optimizing their code to reduce their server costs. Basically turning development into a simple Return on Investment (ROI) equation.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What languages&#x2F;platforms did you consider or try before settling on BEAM&#x2F;Elixir?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Java, Scala, Go and for one crazy day I even debated just writing the whole stack in C++.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What made you choose the Erlang VM (BEAM) instead of the JVM?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I hate writing Java… The real reason we didn’t go with a JVM environment is tuning it is kind of a black art and something I have not done in years (since Java 1.4).&lt;&#x2F;p&gt;
&lt;p&gt;Also, we had the following goals:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;High level of fault tolerance&lt;br &#x2F;&gt;
a. Because game teams write “scripts” we did not want them to be able to bring the node down because they wrote bad code&lt;br &#x2F;&gt;
b. If the game server goes down this is VERY bad for game developers. Users will get mad quickly and just download a different game with a very slim chance they may come back&lt;br &#x2F;&gt;
c. User Acquisition (UA) is expensive. To “buy” a user (this is done via Ads or Promotions, etc) you can spend up to $30 per person, and if your game server is crashed that money is gone.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;2. Easy to scale horizontally&lt;&#x2F;p&gt;
&lt;p&gt;3. Easy to upgrade servers with hot patches without taking the system down&lt;&#x2F;p&gt;
&lt;p&gt;With those three goals BEAM is one of the best tools for the job.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Lua is a language that is pretty common in the game development community. The Erlang VM has a Lua based language called Luerl. Why did you choose to implement Playground in Elixir instead of Luerl?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We actually started with Luerl in early 2014 as our scripting language. The problem with Luerl at the time (I have not reviewed it in some years) was its basic architecture didn’t fit our needs. Luerl is designed for you to pass it a bunch of data, process that data in Lua, then get the results back. However if you don’t know what the Lua code will be doing you need to pass in ALL possible data in one big map (and this was pre-Erlang maps so it was a custom struct the Luerl lib created). This meant we had to spend a lot of time modifying the actual Luerl package to extend its basic APIs so the game logic could “ask” our Erlang code for needed data, etc. Around mid&#x2F;late 2014 Elixir had matured and we felt that the language was easy enough that most folks could pick up the basic syntax without a lot of work. In the end we are really happy that we moved off Luerl. Now our System &amp;lt;-&amp;gt; scripting environment has a near zero overhead (we don’t have to serialize&#x2F;deserialize struct, etc). In fact we liked Elixir so much we ended up porting all of our Erlang system to it and now we are pretty much an Elixir shop.&lt;&#x2F;p&gt;
&lt;p&gt;Also Elixir made it easy to “Walk” the code AST where we can check it for operations we don’t allow. For example, when a team writes Elixir business logic we don’t allow them to use OTP, or even spawn processes, etc.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is the biggest difference between implementing a backend for a video game and a HTTP REST JSON api?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;It all boils down to two things: latency and state.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;State&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
Games are very state-full, and if you had to send all the data needed to finish a REST-based transaction your JSON would be HUGE both upstream and downstream. Games also tend to react to events that the user did not generate so bi-directional communication is a very strong requirement. For example: If player 1 attacks player 2, player 2 will need to be notified of this event and different actions may be triggered if player 2 is online or not. Also, this state may need to be presented to other players, so in the last example player 3 may see that players 1 and 2 are in combat so he&#x2F;she may jump in and help player 2.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Latency&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
For a typically ecommerce site a 500ms latency may be completely unnoticeable. However, in a game, 500 ms could be the difference between winning and losing. So we are constantly concerned with latency. This includes things like time spent serializing&#x2F;deserializing your communications, how much data you are sending up and down the wire, how long you spent accessing the DB, etc, etc.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What are the main difference between implementing actual games and game development tools?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;It is the same as developing any tools&#x2F;lib vs a product that goes directly to consumers. With tools you need to think about not just what the tool does but also you have to think about how others will use it. Does it have the flexibility to work in N different use cases, etc. With a game you know exactly how your product should behave and can quickly tell when things work or they don’t. With a tool it may work great with the designed use case, but some other creative engineer decided to repurpose it in a completely different way. As a tools&#x2F;lib developer your challenge is to have the flexibility to support both.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What was your experience using&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;basho&#x2F;riak_core&quot;&gt;&lt;strong&gt;Riak Core&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;? What did you like and what did you not?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Riak Core is a very cool library but really you have to look at it from two angles.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Do I buy into the whole Consistency Hashing thing?&lt;&#x2F;li&gt;
&lt;li&gt;Do I want to implement my own solution for this?&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;About two years ago we said yes to the first question, however getting Riak Core to work in an elixir environment was just too painful so we rolled our own solution. It worked well and was actually a bit faster than Riak Core, however it was not nearly as robust and did not handle node failures and handoffs well. Recently the Phoenix and Basho got a Hex package that actually works in Elixir and we jumped at the chance to try it out. After some evaluation we decided that the little bit of performance gains we got from our system was outweighed by the expanded functionality that Riak Core provided.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Liked&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Very robust software that handles a lot of error cases for us.&lt;&#x2F;li&gt;
&lt;li&gt;Built in gossip protocol&lt;&#x2F;li&gt;
&lt;li&gt;Handles data handoffs when new nodes are brought online&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Dislike&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Dependencies that don’t work because Basho bases all their libs&#x2F;tools on Erlang R15&lt;&#x2F;li&gt;
&lt;li&gt;Very heavy weight&lt;&#x2F;li&gt;
&lt;li&gt;Difficult to track down errors deep in the system code&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Is there anything you miss from implementing actual videogames?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Working on videogames is a truly unique experience. Not only are you working with very smart engineers, you also get to work closely with Artists, Game Designers, Musicians, and sometimes even Actors. That is a very fun and exciting environment to be in.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>MLFE: ML landing in the Erlang world</title>
          <pubDate>Tue, 15 Nov 2016 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/d-day-invasion-with-mlfe-ml-landing-in-the-erlang-world/</link>
          <guid>https://blog.lambdaclass.com/posts/d-day-invasion-with-mlfe-ml-landing-in-the-erlang-world/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/d-day-invasion-with-mlfe-ml-landing-in-the-erlang-world/">&lt;p&gt;Time has passed since our last interview for &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;notamonadtutorial.com&#x2F;&quot;&gt;This is not a Monad Tutorial&lt;&#x2F;a&gt;. OpenBSD released its 6.0 version after 20 years of continues releases without agile, OpenSSL vulnerabilities keep on breeding, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;blog.bugreplay.com&#x2F;post&#x2F;152579164219&#x2F;pornhubdodgesadblockersusingwebsockets&quot;&gt;Pornhub war against ad blockers continued&lt;&#x2F;a&gt;, the Macbook Pro is not that Pro anymore, a new javascript package manager was released by Facebook and last but not least Brexit and Trump are a reality that will shape the new world order.&lt;&#x2F;p&gt;
&lt;p&gt;Going back to our endogamic tech world, I interviewed &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;noisycode.com&#x2F;&quot;&gt;Jeremy Pierre&lt;&#x2F;a&gt; about &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;j14159&#x2F;mlfe&quot;&gt;MLFE&lt;&#x2F;a&gt; or ML Flavoured Erlang. After learning Haskell and after playing with Elm I became quite a fan of ADTs and Hindley-Milner type systems so that is why I am really exited by MLFE. So I think this is a way to counterbalance my love for Lisp languages. Let’s add a little bit of ML into our coffee. One of the projects I had in my To Do list was to implement an ML like language on top of the Erlang VM&#x2F;BEAM. Instead of recreating the wheel, I hope to see further by standing upon the shoulders of MLFE. The invasion has began!&lt;&#x2F;p&gt;
&lt;p&gt;If you have any more questions please let me know via &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;vw8zb2&#x2F;d_day_invasion_with_mlfe_ml_landing_erlang&quot;&gt;lobsters&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;programming&#x2F;comments&#x2F;5d2ooi&#x2F;dday_invasion_with_mlfe_ml_landing_in_the_erlang&#x2F;&quot;&gt;reddit programming&lt;&#x2F;a&gt; or &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=12958099&quot;&gt;hn&lt;&#x2F;a&gt;. Au revoir.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-VHoeeRQqosE3Woi37aHFeA.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;2016 MLFE&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is MLFE?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;ML Flavoured Erlang is a statically typed and strict (eagerly evaluated) language for the Erlang VM patterned a little bit after parts of both OCaml and Elm. It’s incredibly early in the language’s development but we already have things like sum types and product types (e.g. tuples, records with row polymorphism) and a pretty basic foreign function interface to Erlang proper. Honestly the language is probably in need of renaming almost entirely because it’s impossible to call Erlang code directly outside of the FFI.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why did you create an ML language on top of the Erlang VM&#x2F;BEAM?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I appreciate a lot of the practicalities in the Erlang ecosystem, not least of which are the operational aspects of the VM but wanted something with faster feedback on type issues than Dialyzer currently provides, along with the brevity and expressiveness that come with features like OCaml or Elm’s ADTs. One of the earliest drivers for this was constantly wishing for Scala’s case classes every time I wrote Erlang (my day job involves both).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What are the main problems you find while coding in Erlang and while coding in ML like languages?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I don’t often work directly in ML dialects to be perfectly honest although I keep trying to find reasons to use them. Maybe that’s a subconscious reason behind starting MLFE .&lt;&#x2F;p&gt;
&lt;p&gt;As mentioned above however I do often work in Scala and its less pervasive approach to pattern matching and second class nature of things like actors on the JVM are often sore points for me. Having said that, it would be really great to have something like Scala’s Future or ScalaZ’s Task in an Erlang VM language as well. Maybe we can build something with MLFE to scratch that itch but it’s a little early to say I think.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;How did you implement the type inference algorithm?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I have to give credit (or apologize for implementing it badly?) to Oleg Kiselyov for his incredibly helpful article &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;okmij.org&#x2F;ftp&#x2F;ML&#x2F;generalization.html&quot;&gt;How OCaml type checker works&lt;&#x2F;a&gt;. I relied heavily on this, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.cis.upenn.edu&#x2F;~bcpierce&#x2F;tapl&#x2F;&quot;&gt;Types and Programming Languages&lt;&#x2F;a&gt;, and a bit on &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tomprimozic&#x2F;type-systems&#x2F;tree&#x2F;master&#x2F;algorithm_w&quot;&gt;algorithm_w&lt;&#x2F;a&gt; for the earliest work on the typer.&lt;&#x2F;p&gt;
&lt;p&gt;It started with a very basic translation to Erlang of Oleg Kiselyov’s eager&#x2F;strict inferencer examples and then grew from there. Since the algorithm relies on unification (and hence mutation), MLFE’s inferencer needs reference cells which are currently implemented as Erlang processes. I’d like to move these to something like ETS but will probably wait until trying to rewrite and clean up the typer in MLFE itself.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Do you generate core Erlang code or Erlang code?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The MLFE AST is translated to a Core Erlang AST using the “cerl” module and then compiled to BEAM modules from there.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;How do you type check messages?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In MLFE a receive block types as a &lt;em&gt;receiver&lt;&#x2F;em&gt;. Receivers are polymorphic with two parameters: the kind of messages received and the result type of the contained expression. These two parameters are determined by unifying the types in the patterns and the types in the result portion of the receive’s clauses, e.g.&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;receive with &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; 0 -&amp;gt; :zero&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; | x, is_integer x -&amp;gt; :not_zero&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;All of the above patterns are clearly integers and all of the result portions are atoms so the type (internally) in MLFE would be &lt;code&gt;{t_receiver, t_int, t_atom}&lt;&#x2F;code&gt;. As an aside we can of course use union types if we want more complex messages.&lt;&#x2F;p&gt;
&lt;p&gt;Unifying receivers with enclosing expressions makes &lt;em&gt;those&lt;&#x2F;em&gt; expressions receivers too so if we’re assigning a variable in a let expression, the whole thing becomes a receiver e.g.&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;let my_msg = receive with&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; 0 -&amp;gt; :zero&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; | x, is_integer x -&amp;gt; :not_zero &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;in [my_msg, :in_a_list, :why_not]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The above let expression is a &lt;em&gt;{t_receiver, t_int, {t_list, t_atom}}.&lt;&#x2F;em&gt; If we wrapped that in a function, the whole function is a receiver:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;foo () = let my_msg = receive with &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; 0 -&amp;gt; :zero&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; | x, is_integer x -&amp;gt; :not_zero &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;in [my_msg, :in_a_list, :why_not]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The type of the above is:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;{t_receiver, t_int, {t_arrow, [t_unit], {t_list, t_atom}}}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;That is a function from unit to a list of atoms that internally receives integer messages.&lt;&#x2F;p&gt;
&lt;p&gt;Now when we spawn a process, &lt;em&gt;spawn&lt;&#x2F;em&gt; uses the receiver’s first parameter to constrain the resulting PID to a specific type. If we spawn a function that’s a receiver of integers (resulting in a &lt;em&gt;{t_pid, t_int}&lt;&#x2F;em&gt;), all messages sent must be able to unify with &lt;em&gt;t_int&lt;&#x2F;em&gt; so if we try to send it a float or a string we get a type error at compile time.&lt;&#x2F;p&gt;
&lt;p&gt;If we spawn a function that is &lt;em&gt;not&lt;&#x2F;em&gt; a receiver, we get a &lt;em&gt;{t_pid, undefined}&lt;&#x2F;em&gt;. Since &lt;em&gt;undefined&lt;&#x2F;em&gt; will not unify with any other type, it’s a type error to send that particular process any messages at all.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;One of the biggest issues I have with Erlang is that in some cases it is necessary to write code that has a lot of nested cases. Elixir added the&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;learningelixir.joekain.com&#x2F;learning-elixir-with&#x2F;&quot;&gt;&lt;strong&gt;with&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;special form to deal with this issue. Rust 1.3 added a new&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;2016&#x2F;11&#x2F;10&#x2F;Rust-1.13.html#the--operator&quot;&gt;&lt;strong&gt;? operator&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;that provides syntax sugar that helps to deal with this issue. The RabbitMQ team created&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;blog&#x2F;2011&#x2F;05&#x2F;17&#x2F;can-you-hear-the-drums-erlando&#x2F;&quot;&gt;&lt;strong&gt;Erlando&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;using Erlang’s parse transform (Erlang like macros) that adds syntax extensions to Erlang, with the&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rabbitmq&#x2F;erlando#user-content-lots-of-different-types-of-monads&quot;&gt;&lt;strong&gt;do syntax&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;for monads being the most important one to solve somehow this issue. From what I have seen the mlfe_type.erl of MLFE also&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;j14159&#x2F;mlfe&#x2F;blob&#x2F;master&#x2F;src&#x2F;mlfe_typer.erl#L403-L427&quot;&gt;&lt;strong&gt;has this issue&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Do you plan on adding some construct or syntactic sugar to deal with this type of issue?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;This is certainly a common issue within MLFE’s typer itself. I don’t currently have plans to add any specific error handling sugar since I worry that doing so might push people away from OTP and supervision hierarchies. Having said that, I don’t think it’s at all unreasonable to have a simple error type and handling alternatives in a library. While try&#x2F;catch don’t exist yet in MLFE it could look like something as simple as the following:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;module simple_try&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;export try_f&#x2F;1, try_map&#x2F;2&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;type t &amp;#39;result &amp;#39;error = Ok &amp;#39;result | Error &amp;#39;error&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;-- try to run f, wrapping successes in Ok and failures in Error:&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;try_f f = try&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; Ok (f ())&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;catch &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; err -&amp;gt; Error err&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;-- If t is a success apply the function f to it or maintain a failed result:&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;try_map t f = match t with&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; Ok result -&amp;gt; let runner () = f result in try_f runner&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; | Error e -&amp;gt; t&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I wouldn’t call the above ideal (and we need anonymous functions to make it usable to begin with) but I think it does demonstrate that it’s relatively easy to solve the problem in a few ways without needing first-class constructs.&lt;&#x2F;p&gt;
&lt;p&gt;To be clear, I think Rust’s approach makes a great deal of sense since as far as I’m aware, its Result type is core to the language. My reluctance with doing the same in MLFE is almost entirely due to the conventions and capabilities in place with OTP that I see as beneficial in their own right.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What was the most difficult thing about implementing MLFE?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Wrapping my head around type inference and unification was definitely the most challenging thing so far. I’m still working to understand a lot of the details and I’m barely ready to dig into something like the implementation of an ML module system, especially when it comes to functors. We need parametric modules in order to type bindings to a lot of OTP so there will probably be something pretty simple and restrictive to start but I have a lot of studying and learning to do before I can be even reasonably confident we’ll still have a type system that’s decidable.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Do you have any recommendation for those of us that did not implemented any language yet?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Pick a problem or feature you find interesting and dive in! Start with a simple definitional interpreter to play with things first if you don’t want to learn an existing platform’s AST (Reynolds’ paper is &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;surface.syr.edu&#x2F;cgi&#x2F;viewcontent.cgi?article=1012&amp;amp;context=lcsmith_other&quot;&gt;great&lt;&#x2F;a&gt;) or just write an interpreter! If you wanted to target a particular runtime Core Erlang’s AST is generally pretty easy to get started with and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lfe&#x2F;&quot;&gt;LFE&lt;&#x2F;a&gt; is great to learn from. If you like the JVM then &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;graalvm&quot;&gt;Graal and Truffle&lt;&#x2F;a&gt; look really interesting too.&lt;&#x2F;p&gt;
&lt;p&gt;I haven’t yet taken the time to dig into SICP or &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;cs.brown.edu&#x2F;~sk&#x2F;Publications&#x2F;Books&#x2F;ProgLangs&#x2F;&quot;&gt;PLAI&lt;&#x2F;a&gt; (and I’ve heard Dr Krishnamurthi has been working on a new one) but want to at some point. I understand they’re both really good deep dives.&lt;&#x2F;p&gt;
&lt;p&gt;There are so many great ideas to check out and explore, recent work like Dr Jean Yang’s on &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;projects.csail.mit.edu&#x2F;jeeves&#x2F;&quot;&gt;Jeeves&lt;&#x2F;a&gt; for security policy enforcement; &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.cs.ubc.ca&#x2F;~rxg&#x2F;gtes.pdf&quot;&gt;gradual typing&lt;&#x2F;a&gt; — especially for effects — e.g. from Drs Banados Schwerter, Garcia, and Tanter; 1ML for a new approach to &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;people.mpi-sws.org&#x2F;~rossberg&#x2F;1ml&#x2F;&quot;&gt;first class modules&lt;&#x2F;a&gt; from Dr Andreas Rossberg and so much more we’ve barely dug into (Dr Barbara Liskov’s decades of work!).&lt;&#x2F;p&gt;
&lt;p&gt;We have mountains of great ideas from so many people and are barely scratching the surface, it’s really exciting. I’d enthusiastically recommend anyone with any interest in programming languages to just pick a paper to read or an idea to research and just start following where it leads. Start reading groups!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What other languages do you recommend keeping an eye on?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Rust and Pony both look like they’re doing really interesting stuff and I’m curious as to where &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;purerl&quot;&gt;purerl&lt;&#x2F;a&gt; — an Erlang backend for PureScript — will go too. There seems to be a lot of cool stuff happening on the Scheme side of things that I keep worrying I’m missing out on.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Interview with Robert Virding, creator of Lisp Flavored Erlang, an alien technology masterpiece</title>
          <pubDate>Mon, 29 Feb 2016 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/interview-with-robert-virding-creator-lisp-flavored-erlang-an-alien-technology-masterpiece/</link>
          <guid>https://blog.lambdaclass.com/posts/interview-with-robert-virding-creator-lisp-flavored-erlang-an-alien-technology-masterpiece/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/interview-with-robert-virding-creator-lisp-flavored-erlang-an-alien-technology-masterpiece/">&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-0_N8_5MqdROjW5duRb6Dpw.png&quot; alt=&quot;&quot; &#x2F;&gt;As you might know zombies, skeletons and momies are good friends of aliens&lt;&#x2F;p&gt;
&lt;p&gt;This time I interviewed &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;rvirding&quot;&gt;Robert Virding&lt;&#x2F;a&gt;, co-creator of Erlang and creator of &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;lfe.io&#x2F;&quot;&gt;Lisp Flavored Erlang&lt;&#x2F;a&gt; (LFE). I am an Erlang developer and Lisp fan — if you are learning Clojure check out my post &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;this-is-not-a-monad-tutorial&#x2F;how-to-earn-your-clojure-white-belt-7e7db68a71e5#.dtmcog9gk&quot;&gt;How to earn your Clojure white belt&lt;&#x2F;a&gt; — so logically I am very excited about LFE.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;strong&gt;Why did you create LFE?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I discovered and learnt Lisp long before we started working with Erlang, and have always loved it. But I also like the Erlang language (I don’t have problems with the syntax :-)) and how it can build systems. My goal was to make a lisp which was a “real” lisp which builds systems in the Erlang way. Hence LFE.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is the LFE philosophy?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;LFE is a proper lisp based on the features and limitations of the Erlang VM, which coexists seamlessly with vanilla Erlang and OTP and runs on the standard Erlang VM.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;In your talk called&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=afLRmoSOnHA&quot;&gt;&lt;strong&gt;“About Language Design”&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;you said:&lt;br &#x2F;&gt;
&lt;em&gt;“&lt;&#x2F;em&gt; &lt;em&gt;People complain about the Erlang libraries and once thing they complain very rightly about the Elang libraries is they’re inconsistent, the naming conventions is inconsistent, the argument ordering is inconsistent, everything is inconsistent about them and that is correct. They are right and people complain about that.”&lt;&#x2F;em&gt;&lt;br &#x2F;&gt;
At some point, will you create a new standard library in LFE?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I would like to but there are some deep problems trying to do that. Basically you can’t really change any library module that is used by OTP without the effect propagating and going viral in OTP. Adding new libraries yes, modifying old modules not really. Elixir got around this by having their special module aliases which map onto module name ‘Elixir.XXX’ but then you end up with 2 module naming conventions. I preferred to keep the same names.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rvirding&#x2F;lfe&#x2F;blob&#x2F;dev-macro&#x2F;src&#x2F;cl.lfe&quot;&gt;&lt;strong&gt;Common Lisp macros and functions&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;have been added to&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rvirding&#x2F;lfe&#x2F;blob&#x2F;dev-macro&#x2F;src&#x2F;cl.lfe&quot;&gt;&lt;strong&gt;LFE&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;.&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lfex&#x2F;clj&#x2F;issues&#x2F;18&quot;&gt;&lt;strong&gt;Clojure macros and functions&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;are also available as a separate library. LFE follows more traditional LISPs like Common Lisp, Scheme or more modern Lisps like Clojure?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;LFE more has the feel of CL and Scheme, especially CL as it is a lisp-2 not a lisp-1 like Scheme. Clojure is definitely interesting but I felt that the way it does concurrency doesn’t really map well onto Erlang and the style of building systems feels different. Clojure feels more like language with concurrency while Erlang feels more like a operating system with a language.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rvirding&#x2F;flavors&quot;&gt;&lt;strong&gt;LFE Flavors&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;and the&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;oubiwann&#x2F;los&quot;&gt;&lt;strong&gt;LFE Object System&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;? Aren’t they pretty similar?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Flavors is an object system on the Lisp Machine. I did LFE Flavors out of pure fun and curiosity. A long time ago (about 30 yrs) I did an implementation of Flavors for another lisp system, Portable Standard Lisp, and I was curious to see what it would be like to do one for LFE. It worked quite well for the central parts but there is a lot of Lisp machine specifics which can’t be transferred. CLOS is based on Flavors and you can see the heritage.&lt;&#x2F;p&gt;
&lt;p&gt;My plan with LFE Flavors is not to bake it in as part of LFE but have it as a supported compatible plugin. I like to keep the core simple. I also have plans to implements more general structs which will allow more control over data structures and access to them. It would subsume records and elixir structs amongst other things.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;A few months ago you&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;groups.google.com&#x2F;d&#x2F;topic&#x2F;lisp-flavoured-erlang&#x2F;l_Te7ZHkm9M&#x2F;discussion&quot;&gt;&lt;strong&gt;sent an email&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;titled “New macro handling and compiled macros”. How does the macro system work in LFE, what are you changing and why?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Currently macros work by defining them locally in each file where they are used. If you need to share macros then you define them in include files. The new macro handling will allow macros to be exported from modules in much the same way as functions and you would call them in the same way. So for a module foo you call functions with (foo:function …) and macros with (foo:macro …) making the interface much more consistent generic. Most uses of include files will disappear.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What do you think about Elixir?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Ambivalent! I don’t speak Ruby at all, so much of the syntax feels very strange and foreign. It also manages to push some of my programming buttons, for example having multiple ways of representing the same thing and adding syntax for special cases; both which I feel are just wrong. I am jealous of their ability to clean up some of the OTP modules by writing their own interfaces and having a way to avoid overlapping module names. I wonder about some of the complexity but that is just because I have a thing about simplicity.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Have you incorporated any idea from it into LFE?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I have not taken any ideas directly from Elixir though we do share some features, for example having multiple modules in one file (which I am not sure I like but it can be practical).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;I have seen&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;blog.lfe.io&#x2F;design&#x2F;2015&#x2F;07&#x2F;11&#x2F;1720-towards-multi-methods-in-lfe&#x2F;&quot;&gt;&lt;strong&gt;multimethods&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;and&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lfex&#x2F;los&#x2F;issues&#x2F;8&quot;&gt;&lt;strong&gt;protocols&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;mentioned a few times by the LFE community. What do you think about Clojure multimethods and protocols?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;One difficulty doing something like this in Erlang is that Erlang modules must be compiled as one unit, it is impossible to add, or remove, functions afterwards without recompiling the whole module. This makes it very difficult to have methods which are to be in one module in different places. Which lessens the usefulness of multimethods. IMAO.&lt;&#x2F;p&gt;
&lt;p&gt;Flavors gets around this by compiling each component flavor separately and building a object flavor from all its mixin when the first instance is created. This allows us to create the components separately as long as all are done before their first time they are used. After that they cannot be modified.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Do you think adding something like&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;26317325&#x2F;can-someone-explain-clojure-transducers-to-me-in-simple-terms&quot;&gt;&lt;strong&gt;transducers&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;to LFE would be a good idea?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;They probably would be, but they are not really the way I think. I find I tend to be very explicit in which data types I use; for me this is as fundamental as choosing which algorithm to use. This means that having polymorphic transformation functions becomes less interesting for me.&lt;&#x2F;p&gt;
&lt;p&gt;I know that many people prefer working in this way and I see no problems in adding them to the set of standard LFE libraries. They just won’t be integrated into LFE at the lowest level. You will be able to choose.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;I have seen some discussions about Dialyzer in LFE’s mailing list and there is a dialyzer branch in the&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rvirding&#x2F;lfe&#x2F;tree&#x2F;dev-dialyzer&quot;&gt;&lt;strong&gt;LFE repository&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;. How well does LFE support&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;erlang.org&#x2F;doc&#x2F;man&#x2F;dialyzer.html&quot;&gt;&lt;strong&gt;Dialyzer&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Supporting dialyzer is a little tricky as the official interface to dialyzer is very restricted: you either pass in erlang files, or you pass in beam files containing the Erlang AST of the code (compiling with the debug_info option). This does not work with LFE as the LFE compiler generates Core erlang, a language used internally in the compiler.&lt;&#x2F;p&gt;
&lt;p&gt;However, by being a bit cunning I have generated some alternate dialyzer interface modules which can load in the Core erlang forms directly. It works but it is really only an experiment; a better solution would be to do a proper fix of the dialyzer interface but this is not that simple as the current interface is not very cleanly coded. It is actually quite ironic as dialyzer uses Core erlang internally.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What do you think about&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.sbcl.org&#x2F;manual&#x2F;#Handling-of-Types&quot;&gt;&lt;strong&gt;Steel Bank Common Lisp Type system&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;,&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;ts-guide&#x2F;index.html&quot;&gt;&lt;strong&gt;Typed Racket&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;or&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;core.typed&quot;&gt;&lt;strong&gt;Clojure’s core.typed&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;and&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.shenlanguage.org&#x2F;learn-shen&#x2F;types&#x2F;types.html&quot;&gt;&lt;strong&gt;Shen Types&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I have never tried these so I can’t say. Generally I am very dynamically typed. :-)&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is the roadmap for LFE v1.0?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;So far the roadmap has been a little “I just want to add this one last feature and then I’ll release 1.0”. Anyway, my plan now is that when the new macro handling works and is properly integrated then the system will feel well rounded and I will release 1.0.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h4 id=&quot;did-you-like-it-follow-me-on-twitter-unbalancedparen&quot;&gt;Did you like it? F&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;unbalancedparen&quot;&gt;ollow me on Twitter — @unbalancedparen&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;Oh and I recommend that you read this email from Robert about LFE titled &lt;em&gt;“A bit of philosophy and some design principles”&lt;&#x2F;em&gt; :&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;There was a bit of discussion on the IRC about the CL module and where LFE gets its impulses from, that it doesn’t try to stand on its feet. There are things in it from scheme and CL but most of it is based on Erlang and the features it provides and the type of systems you build using it.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;The base of LFE rests directly on what the underlying Erlang VM provides and this determines what LFE can do and how it works. It is based on language features like modules, pattern matching, immutable data and how functions work. This is what defines LFE. I don’t think that LFE tries as hard as Elixir to hide this background.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;This, for example, is why LFE is a lisp-2 not a lisp-1 as it is a better fit for how Erlang handles functions. On top of this there is a set of convenience macros which were originally more scheme inspired but became more CL inspired when LFE became a lisp-2. They are just a better fit. Of course this doesn’t make LFE a scheme or a CL as there are many things in both scheme and CL which LFE can’t do because of the underlying Erlang VM like mutable data and the handling of nil&#x2F;() and symbols with values, plists and function bindings [*].&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;An alternative would have been more inspired by clojure which shares some properties with Erlang. However they are fundamentally different in many ways so it would mainly have been using clojure’s naming conventions. Also clojure’s concurrency model is very different from Erlang&#x2F;LFE so its way of building systems is also very different. You get the feeling, at least I do, that it is based on a central thread of execution where we you can run things in parallel, but there is this central thread. This is very un-Erlangy as Erlang&#x2F;LFE systems typically don’t have a central thread.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;This gets us, finally, to the CL module. It is just a library containing many of the standard CL library functions which gives you the possibility of writing in a CL style. Not everything can be included, for example the nXXXX functions which mutate data, and some features don’t mesh well with Erlang&#x2F;LFE. For example equating nil&#x2F;() and predicates which in Erlang&#x2F;LFE return true&#x2F;false while in CL are truthy and return nil&#x2F;() and anything else [**]. It is in no way a fundamental part of LFE and is just an add-on. If anyone feels inclined to do a similar module for clojure then I will definitely consider including it. Again it would just be an add-on. These could easily be included in the base release.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Packages like flavors, which I did because they are interesting and I think fun, should probably not be part of the base. This wou|d also apply to things like LFE CLOS (if anyone decided to do it) and LFE clojure-like protocols. They are interesting and useful in themselves but not things I would consider part of the LFE base. A set of these should probably kept in a standard place to make them easily accessible for everyone. I would like to keep the base relatively simple, clean and “basic”, a “lean, mean, fighting machine” if you will. It is all too easy to add things, even sensible and useful things, and end up with a bloated mess. I really want to avoid this, hence keeping the base simple and clean.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
</description>
      </item>
      <item>
          <title>Interview with Jesper Louis Andersen about Erlang, Haskell, OCaml, Go, Idris, the JVM, software and…</title>
          <pubDate>Tue, 29 Dec 2015 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and-60901251608c356716f2f92e/</link>
          <guid>https://blog.lambdaclass.com/posts/interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and-60901251608c356716f2f92e/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and-60901251608c356716f2f92e/">&lt;h3 id=&quot;interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and-protocol-design-part-ii&quot;&gt;Interview with Jesper Louis Andersen about Erlang, Haskell, OCaml, Go, Idris, the JVM, software and protocol design — PART II&lt;&#x2F;h3&gt;
&lt;p&gt;This is part II of the interview with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;jlouis666&quot;&gt;Jesper Louis Andersen&lt;&#x2F;a&gt;. You can read &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;this-is-not-a-monad-tutorial&#x2F;interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and-b0de06440fbd#.4gidstolk&quot;&gt;part I here.&lt;&#x2F;a&gt; This part of the interview is mostly about Erlang, one of my favorite languages. If you want to learn Erlang, take a look at &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;spawnedshelter.com&#x2F;&quot;&gt;Spawned Shelter&lt;&#x2F;a&gt;, a website I made for Erlang newcomers.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-DCzEYU60hk2pO7WCJj3GoQ.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What are the advantages of the Erlang VM over the JVM and vice versa?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;From a perspective of history, the choice of building the BEAM VM for Erlang was the correct one. Massive concurrency was less on the radar for many people, and Ericsson needed a platform which they controlled. Furthermore, the BEAM can exploit it is executing functional languages only: the GC needs no generation forward set for instance.&lt;&#x2F;p&gt;
&lt;p&gt;The roll-your-own-design decision has proven to be very valuable, even though compared to the JVM, the OTP team is far smaller. My guess is that for every hour sunk into BEAM, there is at least 15–20 hours of work in the JVM. In turn, there are things which you cannot do efficiently on the BEAM. It is still (2015) bytecode interpreted and has no JIT, which means raw execution of computationally intensive tasks is about 10–20 times slower than typical well-written Java. Projects such as Quasar&#x2F;Pulsar and Akka promises Erlang-style concurrency on the JVM, but they are recently developed whereas the BEAM has been in production for many years.&lt;&#x2F;p&gt;
&lt;p&gt;The key differing design criteria comes from the design space originating in Bjarne Däcker’s thesis. Most notably the soft real-time constraints and the need for seamless hardware interaction, but also the need for running very large software systems in which feature interaction is complex. It turns out in such a world that the major problems are rarely raw execution speed, but rather how parts of the system operate as a coherent whole. Many of the problems in the design space requires a different approach than sheer execution brute force, especially in a multicore world. Had fast execution been important, it would have been addressed a long time ago. But it turns out every major release of BEAM provides a far more important set of new features. There is a lot of power in having a large industrial company backing the system, as the new features tend to be operational&#x2F;industrial in nature.&lt;&#x2F;p&gt;
&lt;p&gt;The key difference in implementation is that the BEAM is built from the ground up as a resource sharing system, much like in an operating system. In an OS, two processes A and B are isolated and gets a fair share of the resources. If B is badly written, this has considerably less impact on A. Suppose for instance B has bad GC productivity and allocates a lot. Then the GC of B has to run far more often and B has to pay: either in lower throughput, or worse latency. At the same time, A will keep on running, without B having any bad impact on its operation. The BEAM isolates resources in such a way that a B application cannot directly impact an A application from a resource standpoint.&lt;&#x2F;p&gt;
&lt;p&gt;The contrast are systems where one large shared heap is used. They hedge both A and B on the same GC heap, hoping it is fast enough to power through. But clearly, a badly written B can affect a well written A far more. It matters in very-large-scale development since you cannot hope every part of the system is perfectly written.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;If the Erlang VM uses asynchronous I&#x2F;O&lt;&#x2F;strong&gt; &lt;strong&gt;how does it do to present a normal api to the developer? Why aren’t callbacks needed like in Node.js?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Node.js uses a cooperative scheduling algorithm as seen in old operating systems such as MacOS 9, Windows 95 running legacy 16-bit code, MS-DOS and so on. The method, in which the program explicitly yields the CPU for the next task, has a number of advantages: it is easy to adapt existing languages and systems to the method. It is highly efficient in throughput. And it allows you to “pack” lots of work into a single process.&lt;&#x2F;p&gt;
&lt;p&gt;The weakness of the cooperative model is its fragility in server settings. If one of the tasks in the task queue monopolizes the CPU, hangs or blocks, then the impact is worse throughput, higher latency, or a deadlocked server. The fragility has to be avoided in large-scale systems, so the Erlang runtime is built preemptively. The normal code is “instrumented” such that any call which may block automatically puts that process to sleep, and switches in the next one on the CPU. Furthermore, Erlang being functional, any process must loop by calling functions. An internal funcall counter measures “reductions” and once 2000 of these has been used, the process is forced off the CPU and the next one is switched in. The process is entirely automatic and follows the modern idea of time-sharing in operating systems: AmigaOS, UNIX, Windows NT+, and so on.&lt;&#x2F;p&gt;
&lt;p&gt;Note that in Erlang there is &lt;em&gt;no way&lt;&#x2F;em&gt; to call blocking operations at all, since they are all handled by the runtime. This means the model is coherent and I can use any library I like without fear of it doing something bad. As an example, BEAM uses its own PCRE Regex library which cooperatively yields expensive NFA traversals. It also breaks up expensive crypto-computations, long-running GCs, and costly term serializations. It even includes a blocking monitor built-in so you can get notified if a monopolization has happened. Calls to foreign code written in C is harder though, since you have to take its blocking behavior into account.&lt;&#x2F;p&gt;
&lt;p&gt;You can get much of the same in any other language by using an appropriate framework. However, this breeds fragmentation: library code in one framework is not usable in another framework without adaptation. And code written for no framework has to be inspected for eventual blocking behavior. In turn, code is colored in different colors, and you can’t mix them.&lt;&#x2F;p&gt;
&lt;p&gt;A far better approach is seen in Quasar&#x2F;Pulsar: take existing bytecode and rewrite it by instrumentation, much like in Erlang. You can insert forced preemptions into loops, and protect any potentially blocking call by a lightweight fiber switch. If you add your own I&#x2F;O manager underneath, you almost have a full implementation of the Erlang model. But it takes a serious amount of work to get the lower parts to run fast in this model, since you have to reimplement all of the Erlang VM inside Java.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;In practical term what do you gain from using a VM like the Erlang VM that has a preemptive scheduler?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Preemption is an exchange in which you sacrifice explicit control for gains in productivity. First, you don’t have to adapt existing code to your model, which saves time. In languages without proper abstraction barriers, calling the wrong function at the wrong time can block a scheduler. Second, in a post-DevOps world where you run your own systems, productivity is directly tied to the maintenance overhead of existing systems. The lower fragility of the model means you have more time to actually write new code rather than fix old problems. You can afford to let bad behavior live for longer in the system since its impact simply gracefully degrades the system a bit.&lt;&#x2F;p&gt;
&lt;p&gt;Most importantly however, you don’t have to worry about every nook and cranny of the code. Rarely run code can be written slightly less performance-oriented since its cost is automatically amortized over the whole of the program by the scheduler. And even in the critical paths, the smearing operation of the scheduler helps a lot to alleviate spikes. Long running background jobs can simply be started without much worry.&lt;&#x2F;p&gt;
&lt;p&gt;Another gain is had from the observation “N starts out small and then grows” which is to say that over time, a piece of software gets to handle gradually more and more data. Without a preemptive scheduler, this growth very often ends up having a considerable latency or throughput impact. Erlang systems errs on the side of maintaining good low-latency for slightly worse throughput in these situations. As load increases on a system, this is often the desirable behavior as it is less likely to affect other systems directly. The system simply degrades gracefully rather than abruptly.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;You wrote:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;In Haskell, Type Classes are often the abstraction way to go. In ML, the key is to use modules.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Don’t you miss type classes or ML modules in Erlang?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I do miss them a lot, but they both rely on efficient type worlds in order to function. Adding them to an untyped language like Erlang is going to be rather hard. A far more reasonable way to go at Erlang programs is to look inside the Elixir and Clojure communities. Clojure’s “procotols” would be a good addition I think, and it fits the Erlang design space far more. Another good place for inspiration is Scheme48’s implementation of modules, which took inspiration from Standard ML’s functors among other things. Scheme48 being a R5RS (&lt;em&gt;Revised^5 Report on the Algorithmic Language Scheme&lt;&#x2F;em&gt;) implementation also shares lots of its design space with Erlang.&lt;&#x2F;p&gt;
&lt;p&gt;It is often said a Haskell type class construction can be implemented with an ML module. The correspondence to Erlang would be to use a process. Processes forces code to modularize and isolate, since the communication can only be done through exchange of messages. Granted, it happens at runtime, but used correctly it yields emergent behaviors in the source code: the same module is executed by many isolated processes at runtime, and their interaction defines the behavior of the program. The literature on swarm intelligence provide more information in this area.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Is it possible to implement a rich static type system and also have message passing at the same time?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Yes it is! Most such systems introduces some kind of “box” which can be typed as in a “box containing type X”. The box is often a single-message mailbox, or a channel. The type system doesn’t even need to be rich for this to work out, as Go shows. It works because the box threads a type with it, so when you put things into the box or extract things from the box, you can statically reason about the type of the extracted&#x2F;inserted value.&lt;&#x2F;p&gt;
&lt;p&gt;Haskell has several highly interesting communication models which enjoy rich typing. There is also John Reppy’s ConcurrentML, which takes communication a step further: not only are channels first class values which can be manipulated, &lt;em&gt;events&lt;&#x2F;em&gt; are first class. CML has an algebra for manipulating events, and combining them. Once you call &lt;em&gt;sync&lt;&#x2F;em&gt; on the event, then the scenario plays out. It is akin being able to have &lt;em&gt;receive&lt;&#x2F;em&gt; -clauses as values which you can join: &lt;em&gt;sync join(Recv1, Recv2)&lt;&#x2F;em&gt;. The most mind-altering operation in Reppy’s calculus is the &lt;em&gt;withNack&lt;&#x2F;em&gt; which is an event firing if &lt;em&gt;another&lt;&#x2F;em&gt; event is picked. It is often used for cancellation situations.&lt;&#x2F;p&gt;
&lt;p&gt;Most of these models assume a non-distributed setting though. They assume that communication cannot fail, and that code cannot be upgraded as it is running. CMLs event resolution in a distributed setting is likely to run into the CAP theorem for instance. Most type systems assume total static knowledge&#x2F;control, something you rarely have in a distributed system. Hence you have to verify interactions between distributed agents, which somewhat defeats the holistic aspect of static typing.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What do you think about monads in erlang? Are they useful? Have you tried out&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rabbitmq&#x2F;erlando&quot;&gt;&lt;strong&gt;erlando&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I do use a monad construction in Erlang from time to time, when the code is going to flow better with a monad, but I rarely use tools such as erlando when doing so. The packages assumes a monad is a module whereas I often use a record for my monad work. To me, monads have always been a tool best used in special cases, and to understand formal logics. Personally, I much prefer the hybrid approaches of OCaml and Erlang, where the languages are imperative rather than the approach of Haskell and purity above all. The latter “forces” monads upon you in ways I don’t always appreciate.&lt;&#x2F;p&gt;
&lt;p&gt;The monad story in Erlang is somewhat weaker than I would like it to be. In Haskell, it is nice because the compiler can use the types to implicitly infer what monad is to be used and then use that monad. A lot of the power comes from the ability to interweave the monadic bind into your code. A Haskell weakness is when you have monad transformer stacks where your code has to change whenever you reorder to stack, but perhaps the work on Free’er monads by Kiselyov can amend this weakness. I feel the productivity is slightly less so in e.g., OCaml (4.02), which needs explicit reference to the monad in order to use it. In Erlang, simple monads are easy to comprehend. But once you raise a complex system out of abstraction, you really need a proper type system to guide you, which you don’t get in Erlang. In turn, Erlang code tends to be less abstraction heavy.&lt;&#x2F;p&gt;
&lt;p&gt;I don’t necessarily think it is a bad idea to have code which uses relatively few abstractions. My own code style, even in OCaml and Haskell, tend to rely on simple principles rather than high levels of abstraction. If you introduce many abstractions, you are also introducing the need for readers to have that knowledge. It is possible to go overboard here, and end up with code which only a few people in the world can read and understand. It might be very efficient and very elegant, but you won’t get many programmers looking at the code. Hence, I tend to use a couple of abstractions when they really help the code, but I refrain from using them in most other situations, preferring to rewrite code through simpler means.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What do you think about Idris Erlang?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Sam Elliot wrote a thesis on this subject[0], and I take that it is this work you are asking about. Among the contributions is a proof-of-concept Erlang-backend for Idris. It allows you to take Idris modules and compile them as Erlang modules. A proper backend would definitely need more work, and it should target Erlang’s Core rather than concatenating strings together to form an Erlang program. Yet, one has to remember what the goals of a thesis are, which is to say it is not about producing production quality backends for languages. But the thesis also explores another path which was perhaps a bit overlooked: how do we type message communication?&lt;&#x2F;p&gt;
&lt;p&gt;Looking at the Erlang message model, and squinting your eyes a lot, you get what is essentially IP&#x2F;UDP communication of messages, of arbitrary size. If you know a Process ID, you know it’s “IP” and you have a capability to send that PID a message. You also have the property that message loss might occur but it is very unlikely unless something is going seriously wrong. Since the risk of failure is low, you can usually handle it by restarting from a known good state, rather than implementing complex recovery schemes.&lt;&#x2F;p&gt;
&lt;p&gt;This model is extremely flexible and you can build almost any kind of messaging on top of it. But on the other hand, generality weakens the meta-theoretic properties of any protocol: we can’t say anything about the well-formedness of messages.&lt;&#x2F;p&gt;
&lt;p&gt;What Elliot points out in his thesis is the notion of constraining our communication to certain limited patterns. By giving up the general messaging, we can suddenly define a typed world in which we understand what is going on. In turn, we can prove well-typed patterns enjoy desirable properties. With enough work, we may be able to capture essentially all the healthy patterns of communication, while rejecting the bad ones. If this could lead to removal of subtle concurrency&#x2F;distribution mistakes, we have come a long way.&lt;&#x2F;p&gt;
&lt;p&gt;Another thesis I have to mention in passing is Simon Fowlers on monitoring communication patterns in Erlang&#x2F;OTP[1]. Fowler explores the idea of monitoring messaging at runtime through an altered &lt;em&gt;gen_server&lt;&#x2F;em&gt; construct. One of his major observations is that many Erlang message patterns are not captured by a typical two-party session type, let alone a multi-party session type. In particular multi-party session types doesn’t allow for the dynamic introduction of new members nor for the termination of members while the session is ongoing. Fowler proposes several interesting solutions and paths in his thesis on how to adapt the system to handle these problems.&lt;&#x2F;p&gt;
&lt;p&gt;All in all, these observations seem to suggest we need some more research work in the area to understand the full interplay between a language such a Idris, and a highly concurrent ecosystem such as the Erlang BEAM VM. It would seem Erlang is a more generic fabric on top of which we could &lt;em&gt;patch in&lt;&#x2F;em&gt; restrictions which improves the quality of our systems through automatic fault removal. In any case, typing concurrent&#x2F;distributed programming in a very general communication model such as Erlang seems to be very hard.&lt;&#x2F;p&gt;
&lt;p&gt;We also need to explore messaging patterns in Erlang which are typeable in some type system. Usually such patterns have additional desirable structure embedded in them because the type system enforces rigidity. By researching in this area, one may hope to improve the understanding of why certain patterns are used, or not.&lt;&#x2F;p&gt;
&lt;p&gt;[0] &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;lenary.co.uk&#x2F;publications&#x2F;dissertation&#x2F;&quot;&gt;http:&#x2F;&#x2F;lenary.co.uk&#x2F;publications&#x2F;dissertation&#x2F;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;[1] &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;simonjf.com&#x2F;writing&#x2F;msc-thesis.pdf&quot;&gt;http:&#x2F;&#x2F;simonjf.com&#x2F;writing&#x2F;msc-thesis.pdf&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Since it is very common to use a pool of gen servers in Erlang: Wouldn’t it be a good idea for Erlang&#x2F;OTP to have a default gen_pool implementation?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Erlangs tenet is “provide tools, not solutions”. That is, provide the tooling for building a pool, but don’t provide a pool. The reason has to do with the fact pools are not alike. Over the last 10 years I’ve come across perhaps 5 different pool implementations and the key observation is they are all &lt;em&gt;valid&lt;&#x2F;em&gt; such implementations. How to hand out resources from the pool differ: some do round-robin proxying. Some queue requests and hand them out in FIFO order. Some uses LIFO order. Some are distributed Job-Idle Queue implementations, whereas some can only run on a single machine. Some provide automatic health checks and reconnections. Some block the caller when there is no work, others errors, and some queues the caller for a while, before erroring.&lt;&#x2F;p&gt;
&lt;p&gt;The other observation is how such pools handle failure, reclaim stale resources, handle errors in the pool implementation itself etc. Again, it is not clear what &lt;em&gt;the&lt;&#x2F;em&gt; implementation should be, and what would be the correct operation. It is mostly a function of context in which the pool is used.&lt;&#x2F;p&gt;
&lt;p&gt;My experience is that this problem space requires either chaos monkeys, concuerror or QuickCheck+PULSE to remove faults, and it is hard to get entirely right. But such tools require a specification of “correct operation”, and there are several such specifications.&lt;&#x2F;p&gt;
&lt;p&gt;Had Erlang&#x2F;OTP provided a default gen_pool implementation, then people would use it even if it doesn’t fit their problem space. This tend to create subtle hard-to-find faults.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Interview with Jesper Louis Andersen about Erlang, Haskell, OCaml, Go, Idris, the JVM, software and…</title>
          <pubDate>Mon, 28 Dec 2015 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and/</link>
          <guid>https://blog.lambdaclass.com/posts/interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and/">&lt;h3 id=&quot;interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and-protocol-design-part-i&quot;&gt;Interview with Jesper Louis Andersen about Erlang, Haskell, OCaml, Go, Idris, the JVM, software and protocol design — PART I&lt;&#x2F;h3&gt;
&lt;p&gt;In this occasion we interviewed Jesper Louis Andersen, a type theorist with lot of practical knowledge and experience. His &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;@jlouis666&quot;&gt;blog&lt;&#x2F;a&gt; (you should also check his old &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;jlouisramblings.blogspot.com&#x2F;&quot;&gt;blog&lt;&#x2F;a&gt;, you will find a lot of good things over there) and code (specially things like &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jlouis&#x2F;safetyvalve&quot;&gt;safetyvalve&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jlouis&#x2F;fuse&quot;&gt;fuse&lt;&#x2F;a&gt;) have been a big inspiration to me. That is why I published the interview in two parts: I had too many questions for him. I hope you enjoy reading his answers as much as I did.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-mIrYVuSZtaYe3WJkRwUqwQ.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I published part II of the interview. &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;this-is-not-a-monad-tutorial&#x2F;interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and-5628fe591295&quot;&gt;Check it out!&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;strong&gt;Your reply to the picture that is below was:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;The typical applications I write in Erlang have 3–4 functions above it in the call stack&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Modern comfortable programming language #java:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-Ee-kDajNT561ZgOd.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why is it so? Why this is not the case in most OOP languages?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;It is not really an artifact of OOP-style languages as much as it is an artifact of how we develop software. In biology, it has been observed solutions are usually not rewriting code, but rather patching code. Imagine a world where we are more inclined to build on top of what we already have rather than go down and rewrite older parts. I think each new generation of programmers tend to add a layer on top of what we already have, mostly to put their mark on programming and to simplify and abstract the parts of the lower levels which are in common use while also hiding the rare parts. What you get is the deep call stack. Another similar view would be in geology where you can see older layers and go back in time to older periods. Much of the Java stack has this in it.&lt;&#x2F;p&gt;
&lt;p&gt;Erlang is no different, but from the outset, small-community languages are less susceptible to patching. Especially if it is easy to rewrite code, which means an itch can be scratched by writing something new, rather than building on top of what others did. What brings the call stack down to 3–4 frames, however, are processes. In an Erlang-system a typical web request is served by cooperation of 3–4 processes, each of those having a call stack. Add them all together, and you approach the above size, but in isolation, they are small. An eventual error will result in a crash report with 3 things in it: the backtrace, the state &lt;em&gt;before&lt;&#x2F;em&gt; the process crashed and the incoming message which made it crash. The reason we have the original state is because of functional programming: every data structure is persistent, so we can version it. Usually this is enough to quickly isolate and figure out where the error is and what went wrong.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;You tweeted:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Lets talk agile: The ultimate agile language is one in which you can deliver working code quickly, which is also maintainable. Hence there are only a few agile languages in existence: Haskell, Ocaml and Erlang are 3. Go, Javascript, Python and the rest lacks the necessary abstractions to be regarded as agile. You end up having to recode. However, the &lt;strong&gt;real&lt;&#x2F;strong&gt; solution is to stop doing agile. The idea is bullshit in the first place.”&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Why Haskell, OCaml and Erlang are the only agile languages?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;If the waterfall model risks not building the right product, then agile risks not building the product right. I’m very fond of Erlang creator Mike Williams point: “If you don’t make experiments before starting a project, then your whole project will be an experiment”. My hunch is what a lot of Agile process misses is that you need to experiment before you build.&lt;&#x2F;p&gt;
&lt;p&gt;If we instead ask about prototyping, then we need a programming language with certain traits. The team is usually small, so we need an expressive language, and we need to address the core kernel of the system in isolation, first. We don’t need a lot of interfacing to foreign systems and in general we won’t care too much if the system we build is fast. Also, we usually won’t need to operate the prototype in production, since it is simply a proof of concept.&lt;&#x2F;p&gt;
&lt;p&gt;From a perspective of rapid prototyping and proof-of-concept development, functional languages tend to have an edge over imperative ones. Their higher level and expressivity allows more to be said succinctly, in fewer lines of code. They also tend to describe data structures and algorithms in ways that are clearer, which helps understanding of the problem space.&lt;&#x2F;p&gt;
&lt;p&gt;In turn, since agile values the minimum viable product, moving fast and making experiments, then you need languages in which it is easy to experiment with the unknown ideas many agile projects face. In languages such as Haskell, Erlang and OCaml you can often iterate over far more designs in a limited time window. Thus you can carry out more experiments and this often leads to a better product, even if the final product is not even written in a functional language. In general I feel we value experimentation too little. Build it, throw it away, and rewrite with the new knowledge.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What do you think about Clojure?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Sadly, my experience with Clojure is limited to carrying out a set of Koans in the language, and I have not ever used it for anything serious work. I must admit I don’t find the language especially compelling, and in general I don’t find Lisp-dialects interesting. My language roots are closer to Standard ML, which may be the reason it did not catch my interest when I finally tried toying with Scheme and Common Lisp.&lt;&#x2F;p&gt;
&lt;p&gt;That said, people are doing lots of outright &lt;em&gt;amazing&lt;&#x2F;em&gt; stuff in Clojure. I think the Datomic project is genuinely interesting as a database system. And the work Kyle Kingsbury has done with his “Jepsen” framework and his “Knossos” linearizability checker in Clojure is solid work. I’m also following David Nolen’s work with interest. But I’m pretty sure the language isn’t “for me”.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;You tweeted:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Functional programming semantics are far more important than static typing for removing errors from programs.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Why? Could you elaborate?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I’ve somewhat alluded to this before, but never in more than 140 characters. In an imperative program a function depends on two things: the parameters it is passed and also the current state of the machine store. In a functional language, only the former matters. The consequence of this choice if far reaching:&lt;&#x2F;p&gt;
&lt;p&gt;One, the state space we have to reason about as human beings is far smaller for FP, which makes it harder to make a programming mistake. Two, we can test functions in isolation and be rather confident we have covered the functions execution well. Three, data processing is inductive in nature, recursing over the &lt;em&gt;structure&lt;&#x2F;em&gt; of data rather than manipulating the store from afar. The programming is closer to a proof by induction, which force the programmer to handle corner cases rigorously.&lt;&#x2F;p&gt;
&lt;p&gt;The ease of reasoning also comes into play once you have found a bug. It is often easier to figure out what the program is doing wrong just by taking a close look. It is rare you need to attach a debugger, which you can’t in a concurrent and&#x2F;or distributed system where some parts are outside of your direct control.&lt;&#x2F;p&gt;
&lt;p&gt;When you add typing to the above, you obtain another dimension where your system is (automatically) checked for additional rigor. But I often find people forget how much power there is to be had just by functional programming on its own, with no regard to types. From my own experience, functional programs tend to have an order of magnitude fewer errors than imperative counterpart programs, especially when these are subtle corner-case errors, types or not. Naturally, types + functional programming help even more. But had I the choice between imperative programming with types or functional without, I know what I’d pick without hesitation.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is your opinion regarding dependent types like the one Idris has?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I have not studied Idris very much yet, but I did some work in Agda and Coq, which both employs dependent types, albeit the type theory is subtly different between all of them. I’ve deliberately been pushing it ahead of me for a while, like I also have done with Rust. Mostly because I’d like them to settle down and mature a bit more before I start looking into them. I’d probably start looking around 2017 on both. From a research perspective, Idris is extremely important. We need to explore this area more for real world programs as well, and having a language designed for programs rather than proof-assistance is fairly important. Of course, one would like to see a more mature language, but one has to understand how much is being sunk into Idris to make this happen currently.&lt;&#x2F;p&gt;
&lt;p&gt;I’m not yet entirely convinced we necessarily want to add dependent types to mainstream languages in its full form. Perhaps it turns out we’d rather want a simpler type system in some areas in order to extend it along other dimensions. I’m somewhat interested in the Curry-Howard correspondence between distributed programming and epistemic logic for instance. And it is not a priori clear we even understand what it means to marry dependent types to such a beast. We may have to cut the cake differently in order to understand the type-level interactions.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Don’t you think that OCaml and Go compete for the same space? What has been your experience with the two languages and how do you think they compare?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;If you squint your eyes hard enough, OCaml is an imperative language on top of which you added a lambda calculus. Or it is a lambda calculus with primitive operations for imperative execution. Either way, Go and OCaml are very much alike in the core: both are garbage collected, and natively compiled languages. They tend to provide execution speed in the same ballpark: usually they are in the same order of magnitude when it comes to executing programs.&lt;&#x2F;p&gt;
&lt;p&gt;What sets the two languages apart is the underlying ideology of how to design a programming language. Go is a modest cleanup of the C semantics on top of which you add channels, goroutines and interfaces. OCaml is a programming language in the tradition of Milners Meta-Language (ML), drawing inspiration from several sources including Haskell and Standard ML, among others.&lt;&#x2F;p&gt;
&lt;p&gt;Go usually opts for simplicity and separation of features into a small basis. The language is specifically addressing concerns when programming in the large. This yields programs which are highly coherent because the programmer have relatively few abstraction tools at their disposal. In addition, the interface concept in Go is implicit, which means you have less need to alter other parts of the system. In a large setting with 100s of programmers, altering code someone else “owns” is usually measured in days, whereas local alterations takes hours. So the time lost on lower abstraction can be deceiving.&lt;&#x2F;p&gt;
&lt;p&gt;The simple coherent design of Go also fosters fast compilation with little to no abstraction overhead. It doesn’t matter what abstractions you use, your program will usually compile fast and it will be pretty obvious what the performance behavior of the program is. Fast compilation speed matters in large settings because waiting on the compiler is often wasted time[*]&lt;&#x2F;p&gt;
&lt;p&gt;Russ Cox noted that some abstractions, generics for instance, makes a trade-off between putting the onus on the programmer, the compiler or the execution speed. Leave out generics and the programmer has to work around it. Add generics, and the compiler has to do more work in the compilation phase. Or abstract away generics by a boxing construction, which affects execution speed. Go opts for the first of these.&lt;&#x2F;p&gt;
&lt;p&gt;OCaml contrasts heavily. From an abstraction perspective, it leaves Go in the dust, and supports so much more efficient use of the programmers time. The compiler is also relatively fast and it handles the added abstraction well, though at the current time there is an overhead to the abstraction use. In the notion of Cox, the current version of OCaml (4.02) sacrifices execution speed in some cases. The new FLambda IR in OCaml 4.03, shifts this onus around and puts more into the compiler[0].&lt;&#x2F;p&gt;
&lt;p&gt;Another important dividing factor is the current lack of a proper Multicore support in OCaml, which also means the lack of a proper concurrency runtime built-in by default. In OCaml, you have to rely on a system such as LWT or Async to achieve the same as goroutines do in Go. And the fact there is two, means everyone has to support both for their libraries. The situation is far from perfect.&lt;&#x2F;p&gt;
&lt;p&gt;I usually grab OCaml for problems which have certain traits. Symbolic manipulation is one thing at which OCaml excels because it has proper algebraic datatypes. Thus, I would never write a compiler or proof assistant in something else. Programs generating programs is another area in which OCaml excels. Finally, problems which have embarrassingly parallel structure can easily be handled by just spawning more OS processes in OCaml, and the cogen of OCaml is quite efficient.&lt;&#x2F;p&gt;
&lt;p&gt;I usually write Go for simple brute-force programs where the interactions are not very complex and there is a simple channel network inside the program. I avoid it for anything with complex interactions, because the simplicity of the language often gets in the way. But some problems have the virtue of being simple by construction, which makes Go a really good language.&lt;&#x2F;p&gt;
&lt;p&gt;Personally, I prefer the OCaml ideology. Add abstractions to the language, build a powerful module system, with functors, in which you can program in the large by β-reducing modules into one another. And use the compiler and computer as a sacrifice to pay for this additional abstraction. Those programs are easier to maintain, and easier to recombine.&lt;&#x2F;p&gt;
&lt;p&gt;Go and OCaml are best used for the programs where there is a part of the program which is heavily CPU-bound and you are not memory bound. The vast majority of the programs I write have little to no need to run on a tight CPU-schedule and there I usually just write them in Erlang. If you are bound by memory, you often end up in situations where the gain of dropping to OCaml or Go is small. And if you are bound by outside interaction, disk or network, there is almost no gain.&lt;&#x2F;p&gt;
&lt;p&gt;[*] Fast compilation and linking speed are two major reasons I like Erlang too.&lt;&#x2F;p&gt;
&lt;p&gt;[0] A worthwhile aside: The MLton Standard ML compiler takes this to an extreme by compiling &lt;em&gt;all&lt;&#x2F;em&gt; of the program in one fell swoop. Thus, it is able to perform whole-program analysis and optimization with perfect knowledge of the program. This makes a lot of the abstractions free, but the price is long compilation times.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;In a great post where you explained the drawbacks of JSON and REST HTTP APIS you also wrote:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;“We need to go back to our roots and start building protocols again. This change will never come from a large company. It has to rely on an open tinkerer culture. We need well-defined protocols and multiple implementations of these. Protocol design is quickly becoming a lost art. Rather, people are satiated with “APIs” to the point where they can’t recover.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;We need de-centralization. The internet is built on the idea of end-to-end interaction between machines. The current state is more of a client&#x2F;server infrastructure in which few central entities drive the status quo.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;We need distribution. If we rely on big players, we tie ourselves to their solutions. This will be a bane going forward as we build infrastructure around vendors only interesting in lock-in.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;And finally, we need education. A lot of the current “protocol design” is so bad compared to what can be found in old RFCs. If you want to implement something new, you need to study the past a lot before you build it. If you reject an old idea, you need to explain why. If you reinvent an old idea, you need to know you reinvented it and what happened historically for that idea not to catch on.”&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Could you give us some recommendations of RFC, books, articles to read and exercises to do learn how to design protocols?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Good protocol design is an art form. The goal is produce protocols which are simple to implement, are hard to implement wrong and have future extensibility. Take the TCP protocol for instance. You can implement it in hardware as a simple stop-and-go protocol, ignoring everything about sliding windows. This is a correct and valid implementation of the protocol, though it will be slow. Once that works, you can add layers on top which makes the protocol faster. In addition to the RFCs for TCP, James E. White’s RFCs, 707 and 708, are dear to my heart. They were written in 1976, and they handle a lot of problems we still have to this day: how will distributed machines communicate.&lt;&#x2F;p&gt;
&lt;p&gt;The BitTorrent protocol deserves mention as well. It defines how clients communicate, but it gives relatively few rules about how a client is supposed to implement their behavior. Once you set forth and start implementing the protocol however, you find there is only one true way of doing each part. So that could be left out of the specification. Instead, a minimal viable protocol is given, and the details can be altered as you go along. But also note how the original BT protocol used a Bit-array of 64 bits in the handshake rendezvous in order to negotiate what additional features were supported. This was later replaced with a fully extensible system because it proved to be inadequate. Whenever you see such patches of the protocol design, think about how it could have been avoided in the first place.&lt;&#x2F;p&gt;
&lt;p&gt;Another incredibly well-designed protocol is the 9p protocol from Plan9. And it is generic enough it can be adapted to a lot of other situations as well. It implements many good ideas, like out-of-order messaging, proper multiplexing of messages on one channel, requests initiated from both ends of the connection, and so on.&lt;&#x2F;p&gt;
&lt;p&gt;The general advice is to cut out any part which nominates how the peer should behave itself internally. You need to maximize the freedom of the implementer and only establish the basis for communication. Cut cut cut. Leave out everything which will not destroy the coherency and internal consistency of the protocol. Layer the protocol and push things into separate layers. A layered protocol is much easier to reason about formally, and you better be doing so though either Model Checking or quickchecking the protocol internals.&lt;&#x2F;p&gt;
&lt;p&gt;One should read the critiques of HTTP&#x2F;2.0 and how we got there from HTTP&#x2F;1.1. The protocol suffers from some rushed work, sadly. Read some of the simpler alternative approaches. As an example the PUSH message from Server to Client in HTTP&#x2F;2.0 grows out of White’s observation in RFC707: both peers in a protocol needs to be able to initiate communication. But HTTP is skewed, like most RPC, since all communication is initiated from the client toward the server.&lt;&#x2F;p&gt;
&lt;p&gt;A good approach is that of Roy T. Fielding — define what constraints you need, and then squeeze hard until the minimal protocol comes out. That is, start by defining a large framing of what you need your protocol to do and then create a protocol with those properties. TCP is defined by its constraints of being a stream protocol, connection oriented and without data loss. ZeroMQ is a message channel, connection oriented, without data loss. UDP are message oriented, datagram oriented, with loss. SCTP is …, and so on.&lt;&#x2F;p&gt;
&lt;p&gt;Protocols are far better than APIs because they invite multiple competing implementations of the same thing. They debug themselves over time by virtue of non-interaction between peers. And they open up the design space, rather than closing it down. In a distributed world, we should not be slaves to API designs by large mega-corporations, but be masters of the protocols.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Efene: an Erlang VM language that embraces the Zen of Python</title>
          <pubDate>Fri, 27 Nov 2015 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/efene-an-erlang-vm-language-that-embraces-the-python-zen/</link>
          <guid>https://blog.lambdaclass.com/posts/efene-an-erlang-vm-language-that-embraces-the-python-zen/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/efene-an-erlang-vm-language-that-embraces-the-python-zen/">&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-Y6aaUiw3qoh372nY7WNzJg.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In this ocasion we interviewed &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;marianoguerra&quot;&gt;Mariano Guerra&lt;&#x2F;a&gt;, creator of Efene. &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;efene.org&#x2F;&quot;&gt;Efene&lt;&#x2F;a&gt; is &lt;em&gt;“an alternative syntax for the Erlang Programming Language focusing on simplicity, consistency, ease of use and programmer UX”.&lt;&#x2F;em&gt; After reading the interview with Mariano Guerra, check &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;efene.org&#x2F;quick-efene-introduction-busy-programmer.html&quot;&gt;Efene Quick Introduction for the Busy&#x2F;Lazy Programmer&lt;&#x2F;a&gt; for learning more about Efene.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why did you create efene?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I learn by doing, and a while ago I wanted to learn Erlang, it was the first functional programming language I wanted to learn coming from C, C++, ASM, Java and Python so I was looking for some toy project to learn it.&lt;&#x2F;p&gt;
&lt;p&gt;For a while I couldn’t find a project that was interesting to me and also matched the strengths of Erlang at some point I decided that I would do a small calculator in Erlang, you can see the first commit &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;marianoguerra&#x2F;match&#x2F;commit&#x2F;cc048638b4cc99719ad5c28cea2f9e8163b9661c&quot;&gt;here&lt;&#x2F;a&gt; and the full project &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;marianoguerra&#x2F;match&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;At first I was doing all the eval stuff myself but pretty quickly I added support to compile the expression to an Erlang &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;marianoguerra&#x2F;match&#x2F;commit&#x2F;6c726f641e5d651f6bb46b2ae04202e557ea022b&quot;&gt;module with a function&lt;&#x2F;a&gt;. The next commit added function support and then I realized there was a programming language there, you can read the rest of the commits to see how it morphed into one.&lt;&#x2F;p&gt;
&lt;p&gt;At that point the only other beam language other than Erlang was &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;reia-lang.org&#x2F;&quot;&gt;Reia&lt;&#x2F;a&gt;. I wasn’t planning anything in particular with my powerful calculator&#x2F;language hybrid, but at some point people from Erlang Factory asked me if I wanted to give a talk about my language and of course I said yes, then I got a dose of impostor syndrome, so I started the project from scratch to do a proper programming language and I decided to support every feature that Erlang supports and not much more. At that point the project changed from a toy to an actual programming language.&lt;&#x2F;p&gt;
&lt;p&gt;After &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.erlang-factory.com&#x2F;conference&#x2F;London2010&#x2F;speakers&#x2F;MarianoGuerra&quot;&gt;my talk&lt;&#x2F;a&gt; and some initial excitement things got quiet. I just had got my Engineers degree and had a new job so development stopped for a while, then Elixir appeared and got much more attention, so I thought “OK, someone got it right, I will just stop pushing efene” and some years passed. But then looking into Elixir I saw that the Elixir ideas weren’t exactly the ideas of efene and I decided to rewrite it to try to fill the niche of “just a different syntax for Erlang, reuse as much as possible from the Erlang ecosystem, unified tooling and documentation as the core of the project”. The language has been complete for a while now. I’m just working on documentation, rebar3 plugins andwaiting for some of the surrounding tools to mature to avoid having to redo the documentation (mainly &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rebar&#x2F;rebar3&quot;&gt;rebar3&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=YGuAXS0Cy_8&quot;&gt;cowboy 2&lt;&#x2F;a&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why do you embrace the&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.python.org&#x2F;dev&#x2F;peps&#x2F;pep-0020&#x2F;&quot;&gt;&lt;strong&gt;Zen of Python&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-6_ijRzr0oB6Zckr8GTrq4A.png&quot; alt=&quot;&quot; &#x2F;&gt; Zen of Python&lt;&#x2F;p&gt;
&lt;p&gt;Python was the first language I enjoyed coding in before I coded in C, C++, ASM and Java, but just because it was what I knew or they provided something I needed. With Python it was the first time I said “I’m a Python programmer” and not “I’m a programmer”, also the Python Argentina community helped a lot witht hat.&lt;&#x2F;p&gt;
&lt;p&gt;Python has this attitude of simplicity and community that I like and instead of coming up with an “ad hoc, informally-specified, bug-ridden, slow implementation of half of the python zen” I decided just to copy it.&lt;&#x2F;p&gt;
&lt;p&gt;David Nolen summarized it well the other day:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;swannodette&#x2F;status&#x2F;667694050426945536&quot;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;That’s why efene is a mixture of what I like about the languages, communities and philosophies of Python, Javascript and Erlang, don’t expect a lot of novelty in efene, just a remix of what’s there :).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Could you show to us a short and good example of an efene program?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I can’t think of a particularly short snippet of code that will show you all the interesting bits of efene, mainly because there are no clever parts to efene, the idea is to be regular, simple, explicit and readable.&lt;&#x2F;p&gt;
&lt;p&gt;This means it doesn’t try to win a codegolf competition, or some clever language trick.&lt;&#x2F;p&gt;
&lt;p&gt;But I think you can take a look at this project which is a client for an API that supports REST, Web Sockets, Server Sent Events and COMET and then starts some clients that send some pseudo-random stuff to test the server:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;marianoguerra&#x2F;ioriofn&#x2F;&quot;&gt;marianoguerra&#x2F;ioriofnioriofn - ioriodb client and tests in efenegithub.com&lt;img src=&quot;https:&#x2F;&#x2F;cdn-images-1.medium.com&#x2F;fit&#x2F;c&#x2F;160&#x2F;160&#x2F;0*zv67McG0GOVsOXyh.&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;If your reaction is “I understand this and this is boring”, then I would be happy :), of course knowing some Erlang will help the understanding since efene semantics and patterns are the same as Erlang’s.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Which are the biggest advantages of coding in a language that runs on top of the Erlang VM (BEAM)?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The semantics of the VM are really thought out and really simple to learn.&lt;&#x2F;p&gt;
&lt;p&gt;The stability and scalability of the platform is great and there’s a lot of people that have worked on really hard problems for a long time on top of the Erlang VM, this means you can get really good advice and help from them.&lt;&#x2F;p&gt;
&lt;p&gt;One thing I really like and I don’t think is mentioned that much is the level of runtime introspection and visibility the VM has, and the tooling that is build and can be built around it is great.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What difficulties did you find in implementing efene?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Learning the limits of the parser and what syntax is valid an unambiguous, learning to avoid introducing crazy ideas into the language because syntax and semantics are always tricky and you don’t want to have a “WAT” language.&lt;&#x2F;p&gt;
&lt;p&gt;Also learning about Erlang and its VM while doing it.&lt;&#x2F;p&gt;
&lt;p&gt;But to sum it up, it ended up not being as difficult as I thought it will be, it just requires persistence and some hammock-driven development ;)&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Do you have any recommendation for those of us that did not implemented any language yet?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Learn about lexing and parsing, then build a calculator using S-Expressions (Lisp-like) or reverse-polish syntax (Forth-like).&lt;&#x2F;p&gt;
&lt;p&gt;Start it as an interpreter, copy the semantics from a simple language you already know, coming up with good semantics is hard, don’t try to invent them the first time.&lt;&#x2F;p&gt;
&lt;p&gt;Then ride on top of a language you know, either transpile to that language or compile to bytecode or some intermediate representation.&lt;&#x2F;p&gt;
&lt;p&gt;Try to reuse as much of the tooling from the other language as possible (&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.erlang.org&#x2F;doc&#x2F;apps&#x2F;erts&#x2F;absform.html&quot;&gt;AST from Erlang&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;ast.html&quot;&gt;AST from Python&lt;&#x2F;a&gt; or similar), this will allow you to reuse all the tooling and code built around those representations.&lt;&#x2F;p&gt;
&lt;p&gt;Read about Lisps and Forth. Implement a simple Lisp (Scheme) or Forth.&lt;&#x2F;p&gt;
&lt;p&gt;Once you learn to lex and parse you can think syntax for languages and try to parse them.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is the match expression and why did you introduce it?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;At the core of efene rewrite was the concept of “Everything revolves around 4 main things, pattern matching, functions, guards and data”, pattern matching is done when using the equal sign (=), on the argument list of a function definition and on other Erlang expressions. I wanted to unify the pattern matching under a single syntax and reuse it everywhere, that’s where the “case clauses” came to be.&lt;&#x2F;p&gt;
&lt;p&gt;If you haven’t look at efene yet, the shape of efene expressions is something like:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;&amp;lt;keyword&amp;gt; [&amp;lt;expr-args&amp;gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &amp;lt;case-clauses&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    [else: &amp;lt;body&amp;gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;end&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A case-clause has this shape:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;case &amp;lt;case-args&amp;gt; [when &amp;lt;guards&amp;gt;]: &amp;lt;body&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For example try&#x2F;catch:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;try&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &amp;lt;body&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;catch&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &amp;lt;case-clauses&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    [else: &amp;lt;body&amp;gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;[after &amp;lt;body&amp;gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;end&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Receive:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;receive&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &amp;lt;case-clauses&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    [else: &amp;lt;body&amp;gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;[after &amp;lt;after-expr&amp;gt;: &amp;lt;body&amp;gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;end&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Functions:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;fn [&amp;lt;name&amp;gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &amp;lt;case-clauses&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    [else: &amp;lt;body&amp;gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;end&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You should see a pattern there, since the case keyword was already taken and it’s what Erlang use for what “match” does in efene I had to look for a new keyword.&lt;&#x2F;p&gt;
&lt;p&gt;One thing I like about python is this concept of “executable pseudocode”, I like the fact that if you read Python code aloud it sounds like what it does, so I thought “what am I doing here”, “I’m matching and expression against cases”, in imperative it would be “match A [against] case B, case C, else … end” and that’s how I ended up with match.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why did you introduce a &lt;em&gt;for&lt;&#x2F;em&gt; expression?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The initial idea for efene was to be familiar for people coming from “algol-like” or “mainstream” languages, so they can focus on learning what’s interesting about Erlang which are the semantics and the abstractions and avoid learning a new syntax on the way to epiphany.&lt;&#x2F;p&gt;
&lt;p&gt;Since list comprehensions aren’t available in many of those languages but “for” is, I decided to implement list comprehensions as a more familiar construct but in fact it does the same.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is the arrow operator and why did you add it?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;First a quick introduction for people unfamiliar with efene or the arrow operator.&lt;&#x2F;p&gt;
&lt;p&gt;There’s this thing in Erlang where if you want to apply a sequence of operations to a list you have to create a new binding for each intermediate result:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;MyList = create_list(),&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;MyList1 = op1(MyList),&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;MyList2 = op2(MyList1),&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;MyList3 = op3(MyList2),&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;MyList4 = op4(MyList3).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Then if you want to reorder or remove some of the operations you have to rearrange the names to fit.&lt;&#x2F;p&gt;
&lt;p&gt;The idea of the arrow operator is to help with that, it’s a compile operation, this means that if you write:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;MyList = create_list() -&amp;gt; op1() -&amp;gt; op2() -&amp;gt; op3() -&amp;gt; op4()&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It will compile to:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;MyList = op4(op3(op2(op1(create_list))))&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The thing is that the Erlang libraries don’t have a standard position for the thing you are operating on like in other languages where it tends to be the first argument, inspired by Clojure (&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;clojuredocs.org&#x2F;clojure.core&#x2F;-%3E&quot;&gt;http:&#x2F;&#x2F;clojuredocs.org&#x2F;clojure.core&#x2F;-%3E&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;clojuredocs.org&#x2F;clojure.core&#x2F;-%3E%3E&quot;&gt;http:&#x2F;&#x2F;clojuredocs.org&#x2F;clojure.core&#x2F;-%3E%3E&lt;&#x2F;a&gt;)&lt;br &#x2F;&gt;
I created two variants:&lt;&#x2F;p&gt;
&lt;p&gt;_“- &amp;gt;” _adds the result of evaluating the expression on the left as first argument on the function call on the right&lt;&#x2F;p&gt;
&lt;p&gt;_“- &amp;gt;&amp;gt;” _adds the result of evaluating the expression on the left as last argument on the function call on the right&lt;&#x2F;p&gt;
&lt;p&gt;But thinking about symmetry and other common idiom in Erlang and other functional languages which is higher order functions (passing functions as arguments to other functions) I decided to create the reverse of those but with a more restricted use.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;“ &amp;lt;-”&lt;&#x2F;em&gt; adds the case clauses on the right as an anonymous function as last argument on the function call on the left.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;“ &amp;lt;&amp;lt;-”&lt;&#x2F;em&gt; adds the case clauses on the right as an anonymous function as first argument on the function call on the left.&lt;&#x2F;p&gt;
&lt;p&gt;You can see it says “case clauses” and not “anonymous function”, this is because you don’t have to write the &lt;em&gt;fn&lt;&#x2F;em&gt; keyword, it gives this expression a DSL taste that I like, for example:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;lists.map(Things) &amp;lt;&amp;lt;-&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; case 0: zero&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; case A when A % 2 is 0: even&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; else odd&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;end&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Going back to the restricted uses of the right-to-left arrows it’s because since code reads from left to right, putting something on the right that is just a value doesn’t help readability hence I decided not to support it.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;I just saw that you are creating a new language for the BEAM called interfix. What is it?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;As I said above, efene is a language that doesn’t try to come up with anythingnew. This led me to avoid doing experiments on efene itself, but I still wanted to do those experiments somewhere else.&lt;&#x2F;p&gt;
&lt;p&gt;With time the number of ideas for crazy languages I had grew and condensed to a point I thought I had a nice little language. Then coming back from a conference I had a lot of dead time on airports and no internet so I decided to give it a try.&lt;&#x2F;p&gt;
&lt;p&gt;After I landed, the language was growing and all the ideas I had didn’t seem to have any problems so I kept growing it quite fast and for the last days it’s almost a complete language (in the sense that it can do everything Erlang can do).&lt;&#x2F;p&gt;
&lt;p&gt;At this point I’m finishing adding the remaining features and when everything is there and I know everything fits I will move to cleaning the code and adding some tooling and docs around it for people that want to play with a more “experimental” language.&lt;&#x2F;p&gt;
&lt;p&gt;I say experimental in the sense that it has some crazy ideas in it but not experimental in that it will crash, break backward compatibility or compile the code to wrong bytecode.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;You wrote the&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;marianoguerra.github.io&#x2F;little-riak-core-book&#x2F;&quot;&gt;&lt;strong&gt;Little Riak Core Book&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;and you gave a talk called F&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=eiVqDnA0k0U&quot;&gt;&lt;strong&gt;rom 0 to a working distributed system with riak_core&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;. Could you explain what riak core is and why it can be useful for those of us who implement distributed systems?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Riak Core is the foundation of Riak KV and other Basho projects, it’s the generic and reusable part of a “dynamo style” distributed system, it provides some abstractions and utilities to build multi-node, master-less distributed systems.&lt;&#x2F;p&gt;
&lt;p&gt;In a Riak Core based application you build your system by implemented interfaces to handle the work your application does inside virtual nodes (vnodes) that live inside a ring of vnodes, the work is done by routing commands consistently to those vnodes by hashing a key that you specify.&lt;&#x2F;p&gt;
&lt;p&gt;It also provides ways to run a command in more than one vnode and compare the results, grow or shrink the cluster without downtime, migrate vnodes between physical nodes, authentication&#x2F;authorization and a metadata system to hold information about the cluster and your application in a distributed manner.&lt;&#x2F;p&gt;
&lt;p&gt;This frees you from having to implement all this building blocks so you can focus on what actually makes your application different and building upon a tested and production ready foundation.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;While reading your blog I could see that you have used Scala and Clojure apart from Erlang. What has been your experience with Scala and Clojure? What advantages and disadvantages did you find when comparing Scala, Clojure and Erlang?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The experience with the 3 programming languages has been really good, I’ve built similar systems with those programming languages (a kind of pub&#x2F;sub system with persistence), the reason I moved this backend initially from Scala (lift+akka) to Clojure (immutant) was because the system handled lot of semi-structured data both from the frontend and the backend and I was using a lot of time putting that data into “rigid” types to serialize it to json again&lt;&#x2F;p&gt;
&lt;p&gt;after some operations, and each time the shape of the data evolved on the frontend or the storage I had to go and change those types in a backward compatible manner and it was getting really tiring since the backend was really simple in what it actually did.&lt;&#x2F;p&gt;
&lt;p&gt;So I decided to move to Clojure and it resulted in a huge reduction on code but after the code evolved I saw myself implementing this pub&#x2F;sub like system by hand with low level tools like agents, atoms and promises copying the Erlang “patterns”, at this point some customers were asking about scalability and clustering, so I decided to do a prototype using riak_core and after some coding we tried at a new project and since we could improve it fast and it was working quite nice we decided to adopt it as our default backend.&lt;&#x2F;p&gt;
&lt;p&gt;I’m still using scala for Spark jobs, I use clojure for internal tools and internal frontends with clojurescript but the backend now is Erlang.&lt;&#x2F;p&gt;
&lt;p&gt;I just want to clarify that our backend is quite simple in what it does so moving between languages in the backend is not a big deal, the bulk of what we do is in our frontend code.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Erlang and distributed systems expert gives his views on BEAM languages, Hindley–Milner…</title>
          <pubDate>Sat, 08 Aug 2015 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/eric-merritt-erlang-and-distributed-systems-expert-gives-his-views-on-beam-languages-hindley/</link>
          <guid>https://blog.lambdaclass.com/posts/eric-merritt-erlang-and-distributed-systems-expert-gives-his-views-on-beam-languages-hindley/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/eric-merritt-erlang-and-distributed-systems-expert-gives-his-views-on-beam-languages-hindley/">&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-Bvd7l2Q-OmEhkVC2qcclJA.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;eric-merritt-erlang-and-distributed-systems-expert-gives-his-views-on-beam-languages-hindley-milner-type-systems-and-new-technologies&quot;&gt;Eric Merritt, Erlang and distributed systems expert, gives his views on BEAM languages, Hindley–Milner type systems and new technologies&lt;&#x2F;h3&gt;
&lt;p&gt;In this case, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;this-is-not-a-monad-tutorial&quot;&gt;This is not a Monad tutorial&lt;&#x2F;a&gt; interviewed &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;ericbmerritt&quot;&gt;Eric Merritt&lt;&#x2F;a&gt;, author of &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.manning.com&#x2F;logan&#x2F;&quot;&gt;Erlang and OTP in Action&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;joxa.org&#x2F;&quot;&gt;Joxa&lt;&#x2F;a&gt; (a small semantically clean, functional lisp running on the Erlang VM), &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;erlware&#x2F;relx&quot;&gt;relx&lt;&#x2F;a&gt; (best release creation tool in Erlang).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-XCrgX6wctMhx0GLjNQS9nw.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In the following weeks we will be talking with Robert Virding — Erlang co-inventor and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;lfe.io&#x2F;&quot;&gt;Lisp Flavored Erlang&lt;&#x2F;a&gt; creator — , &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;puffnfresh&quot;&gt;Brian McKenna&lt;&#x2F;a&gt; —&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;puffnfresh&#x2F;roy&quot;&gt;Roy&lt;&#x2F;a&gt; language creator— and with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;mirage.io&#x2F;&quot;&gt;MirageOS unikernel&lt;&#x2F;a&gt; dev team. Stay tuned!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;In the Functional Geekery podcast you stated that the Erlang VM (BEAM) is brilliant. What did it get right that other VMs did not?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.functionalgeekery.com&#x2F;episode-20-eric-b-merritt&#x2F;&quot;&gt; Functional Geekery Episode 20 - Eric B. MerrittIn this episode I talk with Eric Merritt. We talk about his background in Erlang, static typing and using OCaml, as…www.functionalgeekery.com&lt;img src=&quot;https:&#x2F;&#x2F;cdn-images-1.medium.com&#x2F;fit&#x2F;c&#x2F;160&#x2F;160&#x2F;0*ssE1kmVx69o3l2qd.&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;BEAM is the only reasonably popular VM that took the language model, in this case Actors, and leveraged that model to make the platform itself more efficient. I find that brilliant. The two major examples of that approach in BEAM are how the Garbage Collector works with the runtime and how IO works.&lt;&#x2F;p&gt;
&lt;p&gt;In many systems, Java included, the Garbage Collector (GC) must examine the entire heap in order to collect all the garbage. There are optimizations to this, like using Generations in a Generational GC, but those optimizations are still just optimizations for walking the entire heap. BEAM takes a different approach, leveraging the actor model on which it is based. That approach basically has the following tenets:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;If a process hasn’t been run, it doesn’t need to be collected&lt;&#x2F;li&gt;
&lt;li&gt;If a process has run, but ended before the next GC run, it doesn’t need&lt;br &#x2F;&gt;
to be collected&lt;&#x2F;li&gt;
&lt;li&gt;If, in the end, the process does need to be collected, only that&lt;br &#x2F;&gt;
single process needs to be stopped while collection occurs&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Those three tenets are one of the primary reasons that Erlang can be a soft-real time system &lt;em&gt;[&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;jlouisramblings.blogspot.com.ar&#x2F;2013&#x2F;01&#x2F;how-erlang-does-scheduling.html&quot;&gt;Elang has a preemptive scheduler that also plays big a part for this&lt;&#x2F;a&gt; &lt;em&gt;]&lt;&#x2F;em&gt;. The fact that the model subsets the work that the GC has to do allows that work to remain small and manageable. Its an impressive achievement.&lt;&#x2F;p&gt;
&lt;p&gt;Another big win for the BEAM and its approach to leveraging Erlang’s Actor model is that it leverages low level, efficient, non-blocking asyncronous IO primitives from the operating system to do IO, but presents a comfortable blocking interface to the language layer. Developers using the platform can use a very human understandable synchronous IO primitives while gaining all the advantages of asyncronous IO. This too, is an impressive achievement. I just gave a talk on this topic for the Seattle Scalability Meetup:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Apart from the Erlang VM (BEAM), what do you think about Erlang as a language?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I think it’s not a bad language. It has the benefit of being both very declarative and very simple. That is a big win in distributed systems where complexity composes and quickly becomes unmanagable. I tend to prefer languages with an algebraic type system and a type inferencing and reasonable meta programming capabilities. Erlang has neither and that’s unfortunate. That said, I have implemented a large number of very reliable systems in Erlang and wouldn’t hesitate to do so again.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;You implemented Joxa, a Lisp for the Erlang VM. Why did you do it?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;For a while there I was working on a problem that was best solved via a suite of DSLs. The platform we built for that was based on Erlang and BEAM, but Erlang doesn’t really lend itself to DSLs. So I decided to write Joxa to facilitate DSL development on the BEAM. It just so happens that creating DSLs for problems is a generally good idea and that makes Joxa a decent general purpose language.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is your opinion about LFE (Lisp Flavored Erlang)?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Joxa took a very different direction than LFE, even though LFE predated it by quite some time. When I ran into the problem that caused Joxa to be created, I investigated it rather deeply to see if it would solve the problem. I ran into a few issues while I was investigating it. In general, I found the implementation very hard to follow. It’s not a bad implementation, it’s just so different from the way I think about languages that it confounded me. That made it difficult for me to expand it.&lt;&#x2F;p&gt;
&lt;p&gt;I was also looking for something with simple semantics that I could build other languages on. LFE is, quite literally, Lisp Flavored Erlang. It is Erlang with S-expression based syntax. That’s not a problem unless you are looking for something with much lower level syntax to build upon. Finally, and this really is a nitpick, Macros are interpreted by LFE and that interpreter is very limited. The rest of the language is interpreted by BEAM. Having to remember if something was going to be run inside the macro interpreter or inside of the normal runtime bothered me a lot.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;And what do you think about Elixir?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I think Elixir has brought a lot of people to the Erlang world that wouldn’t have otherwise come over. That is a very good thing and a powerful contribution to the Erlang eco-system. However, I am not a big fan of Elixir itself. I find the macro system to be a bit inconsistent and I really dislike that Elixir tries to hide immutability. That does make it slightly easier for beginners, but it’s a leaky abstraction. The immutability eventually bleeds through and then you have to think about it. It also introduces additional complexity within bindings in Elixir Macros among other things. It doesn’t help that I have never been a fan of Ruby syntax and Elixir borrows heavily from that sphere.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What do you think about laziness in programming languages? In which cases do you think it is useful, if any?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I love lazyness in concept. I think the idea that computation only occurs when it’s needed is right in line with the trend that has been occurring in functional programming for many decades. The problem that I have with lazyness is more pragmatic. It is very easy to create space leaks and, as of this writing, good tools to detect and debug those space leaks don’t yet exist. That makes me very hesitant to use a language that is lazy by default in production. The Haskell guys are working hard to resolve this, and I think they will, but they haven’t yet.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why do you like Hindley–Milner type system? [the type system used in the ML family (Standard ML, Caml, OCaml, F#) and Haskell]&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-TKFIhHLhfGTz5uMBn6NfkQ.png&quot; alt=&quot;&quot; &#x2F;&gt; Image stolen from &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;learnyousomeerlang.com&#x2F;&quot;&gt;http:&#x2F;&#x2F;learnyousomeerlang.com&#x2F;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Essentially, it’s because I am lazy. Much like resource management, contract management is a slow, manual painful process. By contract management, I mean verifying that the form of data a function recieves is the form of data that it expects. A Hindley-Milner style type system allows me to offload that tedious work to the compiler. Computers are essentially better at that kind of tedious work than humans.&lt;&#x2F;p&gt;
&lt;p&gt;A type system like this is just an evolution of our ongoing effort to offload work to the computer. Originally, we wrote in machine code, then we moved up to Assembly, which was one step higher. Not long after we started using higher level languages like Fortran, Cobol and Lisp. A bit later on we started offloading resource management to the computer as well in the form of GC. An algebraic type system is just a continuation of that. With this type system we are offloading contract checking to the computer. Just like with resource management the contract checking must happen, its just that many languages force the human to do it when the compiler can do it much more effectively.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Do you think that it would be possible to create a language with a Hindley Milner type system for the Erlang VM without affecting the power of Erlang semantics?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Not only do I think its possible, I have been planning to do it for a while now, time being the limiting factor. The main problem you will run into is the mismatch between the untyped bits of the Erlang native system and the typed bits of the new language. Dialyzer attempts to solve this through Success Typing, but there may be a better way. Something like what &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;roy.brianmckenna.org&#x2F;&quot;&gt;Roy&lt;&#x2F;a&gt; [programming languages that tries to meld JavaScript semantics with some features common in static functional languages] is doing in its type system or &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;core.typed&quot;&gt;Clojure’s core.typed&lt;&#x2F;a&gt;. I am not sure, but it’s a fun and solvable problem.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Do you think it would be worthwhile adding algebraic data types to the Erlang VM? Or is using records (Erlang, Joxa) and tagged maps (Elixir) enough for all practical purposes?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Type systems have very little to do with the VM and very much to do with the language. That is, it’s usually a compile time thing rather than a runtime thing. It might actually be useful to add, simply so that BEAM can take advantage of the type annotations to run more optimized versions of the code, but it’s not especially helpful to the efforts to run a well typed language on top of the VM.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;In the past we had to create a few clients and console applications. Python and Ruby were great for building them quickly. However not being able to easily generate standalone binaries for each OS and architecture is a shortcoming of those languages. We are testing Nim and Go since they have good cross compilation and library support. Have you tried them? Could OCaml be a good alternative?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I have not tried either Nim or Go unfortunately. I have used Python extensively and Ruby as well, though to a lesser extent. I have also used OCaml extensively for these types of work and I find that I like OCaml the best. I like it for all the reasons I talked about above. That said, it is very different from other shell programming approaches and takes a bit of getting used to. I should also note that the vast majority of my work with OCaml has been in conjunction with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;janestreet.github.io&#x2F;&quot;&gt;Jane Street Capital’s Core and Async libraries&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What other languages or technologies are you keeping an eye on that we should check?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I haven’t seen any new languages pop up recently that have grabbed my interest. On technologies, I think that microkernels are very, very interesting. Things like &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;osv.io&#x2F;&quot;&gt;OSv&lt;&#x2F;a&gt; for the JVM based languages, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;mirage.io&#x2F;&quot;&gt;Mirage&lt;&#x2F;a&gt; for OCaml and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;rumpkernel.org&#x2F;&quot;&gt;BSD Rump Kernels&lt;&#x2F;a&gt; for the rest. I think those are going to become the fundamental building block of &lt;strong&gt;system orchestration&lt;&#x2F;strong&gt; in the very near future. The other thing to keep an eye on is the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;nixos.org&#x2F;nix&#x2F;&quot;&gt;Nix Package manager&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;nixos.org&#x2F;&quot;&gt;NixOS&lt;&#x2F;a&gt;, and technologies like Atlas from Hashicorp. It’s not going to be too much longer before we declaratively describe out systems as well as our code. I am looking forward to that.&lt;&#x2F;p&gt;
</description>
      </item>
    </channel>
</rss>
