<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>LambdaClass Blog - Elixir</title>
    <subtitle>Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.</subtitle>
    <link rel="self" type="application/atom+xml" href="https://blog.lambdaclass.com/tags/elixir/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2021-07-15T00:00:00+00:00</updated>
    <id>https://blog.lambdaclass.com/tags/elixir/atom.xml</id>
    <entry xml:lang="en">
        <title>BEAM all the things! ClojErl, an implementation of Clojure on the Erlang Virtual Machine</title>
        <published>2021-07-15T00:00:00+00:00</published>
        <updated>2021-07-15T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com/posts/clojerl-an-implementation-of-the-clojure-language-that-runs-on-the-beam/"/>
        <id>https://blog.lambdaclass.com/posts/clojerl-an-implementation-of-the-clojure-language-that-runs-on-the-beam/</id>
        
        <content type="html" xml:base="https://blog.lambdaclass.com/posts/clojerl-an-implementation-of-the-clojure-language-that-runs-on-the-beam/">&lt;h4 id=&quot;an-interview-with-its-creator-juan-facorro&quot;&gt;&lt;strong&gt;An interview with its creator, Juan Facorro.&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Our blog has had a long standing interest in novel uses of the BEAM, or Erlang virtual machine, as shown by the many articles we have published on that topic: we talked to Eric Merritt about &lt;a href=&quot;&#x2F;eric-merritt-erlang-and-distributed-systems-expert-gives-his-views-on-beam-languages-hindley&#x2F;&quot;&gt;languages that run on BEAM&lt;&#x2F;a&gt; from a high-level overview, and went deep on &lt;a href=&quot;&#x2F;an-interview-with-the-creator-of-gleam-an-ml-like-language-for-the-erlang-vm-with-a-compiler&#x2F;&quot;&gt;Gleam&lt;&#x2F;a&gt; (an ML-like language for the Erlang VM with a compiler written in Rust), &lt;a href=&quot;&#x2F;d-day-invasion-with-mlfe-ml-landing-in-the-erlang-world&#x2F;&quot;&gt;MLFE&lt;&#x2F;a&gt; (which is short for ML-Flavored Erlang), &lt;a href=&quot;&#x2F;efene-an-erlang-vm-language-that-embraces-the-python-zen&#x2F;&quot;&gt;Efene&lt;&#x2F;a&gt; (an alternative syntax for Erlang), &lt;a href=&quot;&#x2F;gaming-with-elixir-discovering-new-lands-in-the-beam-realm&#x2F;&quot;&gt;using Elixir for videogame backends&lt;&#x2F;a&gt;, and &lt;a href=&quot;&#x2F;lasp-a-little-further-down-the-erlang-rabbithole&#x2F;&quot;&gt;Lasp&lt;&#x2F;a&gt; (“a suite of libraries aimed at providing a comprehensive programming system for planetary scale Elixir and Erlang applications”).&lt;&#x2F;p&gt;
&lt;p&gt;We also published a guide to learn &lt;a href=&quot;&#x2F;how-to-earn-your-clojure-white-belt&#x2F;&quot;&gt;Clojure&lt;&#x2F;a&gt; and an &lt;a href=&quot;&#x2F;a-pythonist-finds-a-new-home-at-clojure-land&#x2F;&quot;&gt;interview&lt;&#x2F;a&gt; that might persuade you to get into it if you haven’t already.&lt;&#x2F;p&gt;
&lt;p&gt;So our readers will understand it was inevitable for us to be interested in Juan Facorro’s project, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;clojerl&#x2F;clojerl&quot;&gt;ClojErl&lt;&#x2F;a&gt;. And of course, we interviewed him about it. We hope you enjoy it as much as we did.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h4 id=&quot;tell-us-a-little-about-clojerl-what-is-it-how-did-it-come-about&quot;&gt;&lt;strong&gt;Tell us a little about ClojErl, what is it? How did it come about?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;ClojErl is an implementation of the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;clojure.org&#x2F;&quot;&gt;Clojure&lt;&#x2F;a&gt; language that runs on the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;BEAM_(Erlang_virtual_machine)&quot;&gt;BEAM&lt;&#x2F;a&gt; (the Erlang Virtual Machine).&lt;&#x2F;p&gt;
&lt;p&gt;The project started as a learning and exploratory exercise on language implementation. The idea was born out of the combination of my desire to use Clojure at work, and me starting a new job at &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;inaka.github.io&#x2F;&quot;&gt;Inaka&lt;&#x2F;a&gt; where I learned to use Erlang (and the BEAM) to build systems.&lt;&#x2F;p&gt;
&lt;p&gt;I found that the concurrency model of the BEAM made sense to me, because it provided a framework and some guarantees that made it simple for me to think about concurrency. This has not been the case for me with other concurrency models.&lt;&#x2F;p&gt;
&lt;p&gt;The BEAM was built to solve a practical problem (i.e. high availability communication switches) and solving for concurrency was a big part of the solution, which also included immutable data structures. These two concepts, concurrency and immutability, are also at the core of Clojure’s design principles, so it seemed like a good idea to try to bring this language to the BEAM.&lt;&#x2F;p&gt;
&lt;p&gt;I’m not sure if I thought about it at the time, but the abstractions on which Clojure is built make using the language a pleasure. The example that I always use is the fact that you can use the &lt;strong&gt;count&lt;&#x2F;strong&gt; core function with almost any data structure (it only needs to implement the &lt;strong&gt;ICounted&lt;&#x2F;strong&gt; protocol). Even though it is possible to define a function like this in Erlang, I think the resulting code would not be idiomatic Erlang and it would be hard both to maintain and to extend to new types. This is not the case with Clojure.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-advantages-does-the-actor-model-bring-over-clojure-s-concurrency-model&quot;&gt;&lt;strong&gt;What advantages does the actor model bring over clojure’s concurrency model?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;I don’t think there are absolute advantages of one model over the other.&lt;&#x2F;p&gt;
&lt;p&gt;Because of the way systems are built on the BEAM and the tools it provides (i.e. lightweight processes, monitors and links), it is very suitable for building resilient systems that (when designed right) can recover from failure. This can arguably be done with any language and platform (e.g. Akka on the JVM), but I think it is simpler and easier to do when using the BEAM.&lt;&#x2F;p&gt;
&lt;p&gt;Other things are harder and end up being more complex when using Erlang, but I have wondered if this is something that is more related to the size of the community and the problems it is solving, than the language itself. The amount of Elixir libraries that have been written to do almost anything would suggest that this is very likely the case.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;when-would-clojerl-be-a-better-choice-than-regular-jvm-clojure&quot;&gt;&lt;strong&gt;When would ClojErl be a better choice than regular JVM clojure?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;I would say that whenever you need to build a system that is resilient, degrades gracefully and can recover from failures, and you don’t want to spend time on building the mechanism to achieve this from scratch. Using ClojErl will provide a battle-tested platform where all these things are already included in the VM’s design and how systems are built on it.&lt;&#x2F;p&gt;
&lt;p&gt;This assumes that you don’t need a very purpose-specific library that exists only in Java, or a Clojure library that is a lot of work to port from Clojure(Script) into ClojErl.&lt;&#x2F;p&gt;
&lt;p&gt;It also assumes that there is a library (either in Erlang or maybe other BEAM language) for every one of your needs, which unfortunately is sometimes not the case.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-much-impact-does-losing-java-interop-have-on-the-language-in-everyday-use&quot;&gt;&lt;strong&gt;How much impact does losing Java interop have on the language in everyday use?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;There is no impact as far as I can tell, although I’m biased :).&lt;&#x2F;p&gt;
&lt;p&gt;Anything that would necessitate Java interop is either replaced with Erlang interop or an implementation of the set of protocols through which Clojure interacts with the platform (e.g. &lt;strong&gt;IWriter&lt;&#x2F;strong&gt; and &lt;strong&gt;IReader&lt;&#x2F;strong&gt; for I&#x2F;O).&lt;&#x2F;p&gt;
&lt;h4 id=&quot;there-are-certain-clojure-features-that-are-unsupported-why-is-that&quot;&gt;&lt;strong&gt;There are certain Clojure features that are unsupported. Why is that?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;Clojure JVM is implemented on a platform that allows mutability, which is not the case on the BEAM.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;clojure.org&#x2F;reference&#x2F;transients&quot;&gt;Transient data structures&lt;&#x2F;a&gt; for example, rely on the fact that parts of the underlying representation can be updated in-place. The whole point of their existence is to allow for faster operations without the cost of creating new instances after each modification. This cannot be achieved on the BEAM if we want to use the native immutable data structures.&lt;&#x2F;p&gt;
&lt;p&gt;I have not explored the path of implementing a whole set of data structures through &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;erlang.org&#x2F;doc&#x2F;tutorial&#x2F;nif.html&quot;&gt;NIFs&lt;&#x2F;a&gt; that would maybe make this possible. I’m not convinced this is a good idea though, for a number of reasons. The first one is that it would be a lot of work and we would end up with an implementation that needs to be battle-tested before it can be relied upon. The second is that the cost of calling a NIF is not zero and the result might not even provide significant performance gains. And the third is that it would not be possible to use any of the built-in Erlang functions from the standard library or any of the optimizations for them added to the BEAM.&lt;&#x2F;p&gt;
&lt;p&gt;Another feature that is not implemented for Clojure on the BEAM is &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;clojure.org&#x2F;reference&#x2F;refs&quot;&gt;Refs and Transactions&lt;&#x2F;a&gt;. This feature is heavily dependent on how the JVM works and it is also not something that is very widely used (as far as I know) in the wild.&lt;&#x2F;p&gt;
&lt;p&gt;ClojErl relies only on the numeric types provided by the platform. This means that things such as ratios, big decimals, and flags about unchecked math are not available. The BEAM is not designed to provide good performance around numerical operations, so if that is your use case you are better off using another set of tools for that purpose.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-good-is-the-interoperability-with-erlang-what-about-elixir&quot;&gt;&lt;strong&gt;How good is the interoperability with Erlang? What about Elixir?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;One of the design principles for ClojErl was to make interoperability with the platform as seamless as possible.&lt;&#x2F;p&gt;
&lt;p&gt;A function call to an Erlang function is equivalent to any other Clojure function call: &lt;strong&gt;(module&#x2F;function arg1 arg2 … argN)&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Data structures are not equivalent, Clojure’s are implemented on top of Erlang’s. All Clojure core functions related to data structures (e.g. count, first, map, etc.) work for all of Erlang’s though, since the necessary protocols are implemented for them to work. It is possible to write expressions for literal Erlang data structures by using the &lt;strong&gt;#erl&lt;&#x2F;strong&gt; reader macro before a Clojure literal (e.g. &lt;strong&gt;#erl{:a 1}&lt;&#x2F;strong&gt; would be compiled to a literal Erlang map).&lt;&#x2F;p&gt;
&lt;p&gt;As mentioned before ClojErl currently provides only the numerical data types available on the BEAM: integer (unbound) and float (64 bits).&lt;&#x2F;p&gt;
&lt;p&gt;ClojErl strings are Erlang UTF-8 binaries. It is possible to write literal Erlang strings (i.e. lists of integers) by using the #erl reader macro.&lt;&#x2F;p&gt;
&lt;p&gt;Pattern matching is also available in ClojErl when using any of the special forms where bindings are created (i.e. &lt;strong&gt;fn&lt;&#x2F;strong&gt;* , &lt;strong&gt;let&lt;&#x2F;strong&gt;* , &lt;strong&gt;loop&lt;&#x2F;strong&gt;* and &lt;strong&gt;case&lt;&#x2F;strong&gt;*).&lt;&#x2F;p&gt;
&lt;p&gt;A ClojErl anonymous function can be used as an argument to any of the Erlang BIFs that expect a function, as long as the ClojErl function doesn’t use variadic arity or multiple arities. These two features are specific to Clojure, which means that Erlang code wouldn’t know how to correctly call the function in that case.&lt;&#x2F;p&gt;
&lt;p&gt;The story for Elixir is similar to Erlang’s (or any other language on the BEAM). Any function from an Elixir module can be called from ClojErl. Elixir is a little particular in that all its modules have an implicit “&lt;strong&gt;Elixir.&lt;&#x2F;strong&gt; ” prefix added by the compiler to them. There have been some people recently trying this out with some success (see &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;marcio_lopes&#x2F;status&#x2F;1400256642478903299&quot;&gt;here&lt;&#x2F;a&gt;).&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-was-is-the-most-challenging-part-of-the-project&quot;&gt;&lt;strong&gt;What was&#x2F;is the most challenging part of the project?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;The most challenging part was and still is finding ways to reconcile what the BEAM offers with the semantics of the Clojure language. Sometimes the conclusion is that we can’t support a feature (e.g. transient collections), other times we need to provide something similar but a little more limited than the original (e.g. vars), and yet other times we add something completely new to the language because we want to have interoperability with platform features (e.g. pattern matching).&lt;&#x2F;p&gt;
&lt;p&gt;Another big challenge has been performance. Some features, when implemented on the JVM, do not translate very well to how the BEAM works (e.g. transducers) which results in a much worse performance (i.e. an order of magnitude slower) than what the JVM offers. The release of OTP 24 saw the inclusion of a JIT compiler, preliminary micro-benchmarking using this release showed a lot of improvement in the run time performance of some expressions. There is still quite a lot of work to be done performance wise (both with time and memory usage) on ClojErl.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;are-there-currently-any-interesting-use-cases-for-clojerl&quot;&gt;&lt;strong&gt;Are there currently any interesting use cases for ClojErl?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;If we talk about production environment use cases, the short answer is no. The project is still in beta and there hasn’t been (that I know of) any company or individual that has used ClojErl in a production environment.&lt;&#x2F;p&gt;
&lt;p&gt;But there are some use cases that I have found interesting and fun.&lt;&#x2F;p&gt;
&lt;p&gt;One of them is &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;clojerl&#x2F;doodler&quot;&gt;doodler&lt;&#x2F;a&gt; which is an implementation of a canvas for creating animations inspired in the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;quil.info&#x2F;?example=fireworks&quot;&gt;quil&lt;&#x2F;a&gt; Clojure(Script) project.&lt;&#x2F;p&gt;
&lt;p&gt;Another one is the application behind &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;try.clojerl.online&#x2F;&quot;&gt;try.clojerl.online&lt;&#x2F;a&gt; which is built in ClojErl. I think I spent more time on the JS client-side console than on the code necessary to have a remote running ClojErl REPL.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;is-the-project-open-for-contributions-if-so-how-should-people-get-started&quot;&gt;&lt;strong&gt;Is the project open for contributions? If so, how should people get started?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;Yes, absolutely, 100%!&lt;&#x2F;p&gt;
&lt;p&gt;There are open issues to which I haven’t had time to dedicate myself and anyone that is interested in working on them and any other features or improvements, can reach out through the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;clojerl&#x2F;clojerl&quot;&gt;GitHub repository&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;jfacorro&quot;&gt;Twitter&lt;&#x2F;a&gt; ot the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;erlanger.slack.com&#x2F;archives&#x2F;C7KBUEAMC&quot;&gt;#ClojErl Slack channel&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The fastest way to have a working development environment is by using &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;gitpod.io&#x2F;&quot;&gt;gitpod.io&lt;&#x2F;a&gt;, which provides an online IDE for any public project hosted in the major code repositories (e.g. GitHub). Firing up a new environment is as simple as following &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;gitpod.io&#x2F;#github.com&#x2F;clojerl&#x2F;clojerl&quot;&gt;this link&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;How to navigate code is a little bit more complicated because the documentation around this is lacking. There is some documentation in the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.clojerl.org&#x2F;&quot;&gt;ClojErl.org&lt;&#x2F;a&gt; page and there are also &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;hexdocs.pm&#x2F;clojerl&#x2F;clj_compiler.html&quot;&gt;API docs for the Erlang modules in hex.pm&lt;&#x2F;a&gt;. But they provide a limited view and there are some important things that are not included there, therefore until there is more documentation for developing ClojErl I am available for people to reach out with their questions.&lt;&#x2F;p&gt;
&lt;p&gt;Other areas that need some love are tools for developing. The &lt;strong&gt;rebar3_ClojErl&lt;&#x2F;strong&gt; plugin currently provides pretty good support for compiling, testing, building applications and script; and starting up a REPL. The area that is not so great is the editor support for ClojErl. Syntax highlighting is available and simple to get, but it would be an amazing developer experience if &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;erlang-ls&#x2F;erlang_ls&quot;&gt;&lt;strong&gt;Erlang-ls&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; could also parse ClojErl files and help navigate the code both in Erlang and ClojErl.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;can-i-use-any-library-written-in-erlang-directly-in-clojerl&quot;&gt;Can I use any library written in Erlang directly in ClojErl?&lt;&#x2F;h4&gt;
&lt;p&gt;Yes! ClojErl is “just” an Erlang library, which means you can combine it with any other Erlang library and&#x2F;or application by using &lt;strong&gt;rebar3&lt;&#x2F;strong&gt; and the dedicated &lt;strong&gt;rebar3_ClojErl&lt;&#x2F;strong&gt; plugin.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Gaming with Elixir: discovering new lands in the BEAM realm</title>
        <published>2017-04-20T00:00:00+00:00</published>
        <updated>2017-04-20T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com/posts/gaming-with-elixir-discovering-new-lands-in-the-beam-realm/"/>
        <id>https://blog.lambdaclass.com/posts/gaming-with-elixir-discovering-new-lands-in-the-beam-realm/</id>
        
        <content type="html" xml:base="https://blog.lambdaclass.com/posts/gaming-with-elixir-discovering-new-lands-in-the-beam-realm/">&lt;p&gt;In this opportunity I interviewed somebody I don’t normally interview: a client, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;chrisjimison&#x2F;&quot;&gt;Chris Jimison&lt;&#x2F;a&gt;, CTO of Merigo. One of my clients. After working for almost a year with Merigo, I appreciate and understand the differences between using a BEAM language to develop a typical REST JSON system and using it to develop a videogame backend. I am not aware of many companies using Elixir to develop backends. I have only watch a talk by Jamie Winsor called “&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;_i6n-eWiVn4&quot;&gt;Building And Releasing A Massively Multiplayer Online Game”&lt;&#x2F;a&gt;. I hope to be able to interview Jamie in the following weeks.&lt;&#x2F;p&gt;
&lt;p&gt;To sum up I did this interview because I wanted to share my experience of using Elixir for developing a different kind of beast. I am also writting a post about what I like and dislike about Elixir after developing in Erlang for quite a few years.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Discuss and vote at&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;f1wxuc&#x2F;gaming_with_elixir_discovering_new_lands&quot;&gt; &lt;em&gt;lobsters&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;,&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;programming&#x2F;comments&#x2F;66hnpk&#x2F;gaming_with_elixir_discovering_new_lands_in_the&#x2F;&quot;&gt;&lt;em&gt;reddit&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;and&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=14156379&quot;&gt; &lt;em&gt;hn&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-3HjK0CX5813XXtDwfKIhWw.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Could you describe your experience in the software industry?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I started in the software industry about 15 years ago. My career has been focused in the game development industry, specializing in networking problems. This includes games that have a peer-to-peer deterministic game play model, all the way to big MMORPG titles. In the last 7 years I have been working on mobile titles where the game networking requirements are more of a hybrid of REST and MMORPG-style technologies. Some companies I have worked for in the past include EA, Sony R&amp;amp;D, NGMOCO and DeNA.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;merigo.co&#x2F;&quot;&gt;&lt;strong&gt;Merigo&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;About 3 and a half years ago my cofounders and I decided we wanted to start our own company to help game developers be more successful in the market. One of the big issues that has come around in the last 4–5 years is single player games just don’t make that much money in the market place (outside of the occasional indie hit). As mobile game developers move into the “Online Gaming” space, the costs of creating these applications are increasing exponentially. When the iPhone 3G first launched (this was the first model that had the App Store) many game teams consisted of one or two engineers — a “large” game having 3–5 engineers. We are now seeing team sizes of anywhere between 10–20 and have even heard of some titles consisting of over 30 engineers. This means costs of titles are skyrocketing and the need to “fail fast” is more critical. “Fail fast” gets to the heart of game development. A game designer comes up with an idea they “think” will be fun. However you don’t truly know until you have it in your hands to play. Some ideas work, some don’t. With such a high development cost, many game teams must choose to implement a feature and hope that it works because they don’t have the budget to try a second or third time. Merigo wants teams spending more time “focusing on the fun” and less time worrying about how to make it all work.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is SDE?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The Merigo SDE (Server Development Environment) is a system that allows developers to build out their server logic quickly without having to worry about all the pain of how to scale out and manage their stack. We provide many common game services such as authentication, purchase verification, leaderboards, player persistence, etc. However the SDE is not a bunch of black box REST APIs. The SDE enables developers to write custom “scripts” in Elixir that can be loaded&#x2F;updated at runtime, allowing them to create custom APIs and behaviors needed for their application. Since we have provided the basic framework of how the scripts are managed and when they are called we can now “scale” this logic out across a distributed server cluster. Our main philosophy with the SDE is “servers are cheap, people are expensive”. With the SDE we wanted to provide a system that allows for fast development and rapid iteration with the knowledge that you can always spin up new servers to balance the load, even if your business logic is not optimized for high performance. Each team can then decide where they want to invest their time once the game goes “live.” They can decide where to best invest their time: building new features or optimizing their code to reduce their server costs. Basically turning development into a simple Return on Investment (ROI) equation.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What languages&#x2F;platforms did you consider or try before settling on BEAM&#x2F;Elixir?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Java, Scala, Go and for one crazy day I even debated just writing the whole stack in C++.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What made you choose the Erlang VM (BEAM) instead of the JVM?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I hate writing Java… The real reason we didn’t go with a JVM environment is tuning it is kind of a black art and something I have not done in years (since Java 1.4).&lt;&#x2F;p&gt;
&lt;p&gt;Also, we had the following goals:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;High level of fault tolerance&lt;br &#x2F;&gt;
a. Because game teams write “scripts” we did not want them to be able to bring the node down because they wrote bad code&lt;br &#x2F;&gt;
b. If the game server goes down this is VERY bad for game developers. Users will get mad quickly and just download a different game with a very slim chance they may come back&lt;br &#x2F;&gt;
c. User Acquisition (UA) is expensive. To “buy” a user (this is done via Ads or Promotions, etc) you can spend up to $30 per person, and if your game server is crashed that money is gone.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;2. Easy to scale horizontally&lt;&#x2F;p&gt;
&lt;p&gt;3. Easy to upgrade servers with hot patches without taking the system down&lt;&#x2F;p&gt;
&lt;p&gt;With those three goals BEAM is one of the best tools for the job.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Lua is a language that is pretty common in the game development community. The Erlang VM has a Lua based language called Luerl. Why did you choose to implement Playground in Elixir instead of Luerl?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We actually started with Luerl in early 2014 as our scripting language. The problem with Luerl at the time (I have not reviewed it in some years) was its basic architecture didn’t fit our needs. Luerl is designed for you to pass it a bunch of data, process that data in Lua, then get the results back. However if you don’t know what the Lua code will be doing you need to pass in ALL possible data in one big map (and this was pre-Erlang maps so it was a custom struct the Luerl lib created). This meant we had to spend a lot of time modifying the actual Luerl package to extend its basic APIs so the game logic could “ask” our Erlang code for needed data, etc. Around mid&#x2F;late 2014 Elixir had matured and we felt that the language was easy enough that most folks could pick up the basic syntax without a lot of work. In the end we are really happy that we moved off Luerl. Now our System &amp;lt;-&amp;gt; scripting environment has a near zero overhead (we don’t have to serialize&#x2F;deserialize struct, etc). In fact we liked Elixir so much we ended up porting all of our Erlang system to it and now we are pretty much an Elixir shop.&lt;&#x2F;p&gt;
&lt;p&gt;Also Elixir made it easy to “Walk” the code AST where we can check it for operations we don’t allow. For example, when a team writes Elixir business logic we don’t allow them to use OTP, or even spawn processes, etc.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is the biggest difference between implementing a backend for a video game and a HTTP REST JSON api?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;It all boils down to two things: latency and state.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;State&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
Games are very state-full, and if you had to send all the data needed to finish a REST-based transaction your JSON would be HUGE both upstream and downstream. Games also tend to react to events that the user did not generate so bi-directional communication is a very strong requirement. For example: If player 1 attacks player 2, player 2 will need to be notified of this event and different actions may be triggered if player 2 is online or not. Also, this state may need to be presented to other players, so in the last example player 3 may see that players 1 and 2 are in combat so he&#x2F;she may jump in and help player 2.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Latency&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
For a typically ecommerce site a 500ms latency may be completely unnoticeable. However, in a game, 500 ms could be the difference between winning and losing. So we are constantly concerned with latency. This includes things like time spent serializing&#x2F;deserializing your communications, how much data you are sending up and down the wire, how long you spent accessing the DB, etc, etc.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What are the main difference between implementing actual games and game development tools?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;It is the same as developing any tools&#x2F;lib vs a product that goes directly to consumers. With tools you need to think about not just what the tool does but also you have to think about how others will use it. Does it have the flexibility to work in N different use cases, etc. With a game you know exactly how your product should behave and can quickly tell when things work or they don’t. With a tool it may work great with the designed use case, but some other creative engineer decided to repurpose it in a completely different way. As a tools&#x2F;lib developer your challenge is to have the flexibility to support both.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What was your experience using&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;basho&#x2F;riak_core&quot;&gt;&lt;strong&gt;Riak Core&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;? What did you like and what did you not?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Riak Core is a very cool library but really you have to look at it from two angles.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Do I buy into the whole Consistency Hashing thing?&lt;&#x2F;li&gt;
&lt;li&gt;Do I want to implement my own solution for this?&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;About two years ago we said yes to the first question, however getting Riak Core to work in an elixir environment was just too painful so we rolled our own solution. It worked well and was actually a bit faster than Riak Core, however it was not nearly as robust and did not handle node failures and handoffs well. Recently the Phoenix and Basho got a Hex package that actually works in Elixir and we jumped at the chance to try it out. After some evaluation we decided that the little bit of performance gains we got from our system was outweighed by the expanded functionality that Riak Core provided.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Liked&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Very robust software that handles a lot of error cases for us.&lt;&#x2F;li&gt;
&lt;li&gt;Built in gossip protocol&lt;&#x2F;li&gt;
&lt;li&gt;Handles data handoffs when new nodes are brought online&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Dislike&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Dependencies that don’t work because Basho bases all their libs&#x2F;tools on Erlang R15&lt;&#x2F;li&gt;
&lt;li&gt;Very heavy weight&lt;&#x2F;li&gt;
&lt;li&gt;Difficult to track down errors deep in the system code&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Is there anything you miss from implementing actual videogames?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Working on videogames is a truly unique experience. Not only are you working with very smart engineers, you also get to work closely with Artists, Game Designers, Musicians, and sometimes even Actors. That is a very fun and exciting environment to be in.&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
