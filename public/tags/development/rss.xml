<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>LambdaClass Blog - Development</title>
      <link>https://blog.lambdaclass.com</link>
      <description>Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.</description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://blog.lambdaclass.com/tags/development/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Mon, 29 Feb 2016 00:00:00 +0000</lastBuildDate>
      <item>
          <title>Interview with Robert Virding, creator of Lisp Flavored Erlang, an alien technology masterpiece</title>
          <pubDate>Mon, 29 Feb 2016 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/interview-with-robert-virding-creator-lisp-flavored-erlang-an-alien-technology-masterpiece/</link>
          <guid>https://blog.lambdaclass.com/posts/interview-with-robert-virding-creator-lisp-flavored-erlang-an-alien-technology-masterpiece/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/interview-with-robert-virding-creator-lisp-flavored-erlang-an-alien-technology-masterpiece/">&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-0_N8_5MqdROjW5duRb6Dpw.png&quot; alt=&quot;&quot; &#x2F;&gt;As you might know zombies, skeletons and momies are good friends of aliens&lt;&#x2F;p&gt;
&lt;p&gt;This time I interviewed &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;rvirding&quot;&gt;Robert Virding&lt;&#x2F;a&gt;, co-creator of Erlang and creator of &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;lfe.io&#x2F;&quot;&gt;Lisp Flavored Erlang&lt;&#x2F;a&gt; (LFE). I am an Erlang developer and Lisp fan — if you are learning Clojure check out my post &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;this-is-not-a-monad-tutorial&#x2F;how-to-earn-your-clojure-white-belt-7e7db68a71e5#.dtmcog9gk&quot;&gt;How to earn your Clojure white belt&lt;&#x2F;a&gt; — so logically I am very excited about LFE.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;strong&gt;Why did you create LFE?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I discovered and learnt Lisp long before we started working with Erlang, and have always loved it. But I also like the Erlang language (I don’t have problems with the syntax :-)) and how it can build systems. My goal was to make a lisp which was a “real” lisp which builds systems in the Erlang way. Hence LFE.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is the LFE philosophy?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;LFE is a proper lisp based on the features and limitations of the Erlang VM, which coexists seamlessly with vanilla Erlang and OTP and runs on the standard Erlang VM.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;In your talk called&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=afLRmoSOnHA&quot;&gt;&lt;strong&gt;“About Language Design”&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;you said:&lt;br &#x2F;&gt;
&lt;em&gt;“&lt;&#x2F;em&gt; &lt;em&gt;People complain about the Erlang libraries and once thing they complain very rightly about the Elang libraries is they’re inconsistent, the naming conventions is inconsistent, the argument ordering is inconsistent, everything is inconsistent about them and that is correct. They are right and people complain about that.”&lt;&#x2F;em&gt;&lt;br &#x2F;&gt;
At some point, will you create a new standard library in LFE?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I would like to but there are some deep problems trying to do that. Basically you can’t really change any library module that is used by OTP without the effect propagating and going viral in OTP. Adding new libraries yes, modifying old modules not really. Elixir got around this by having their special module aliases which map onto module name ‘Elixir.XXX’ but then you end up with 2 module naming conventions. I preferred to keep the same names.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rvirding&#x2F;lfe&#x2F;blob&#x2F;dev-macro&#x2F;src&#x2F;cl.lfe&quot;&gt;&lt;strong&gt;Common Lisp macros and functions&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;have been added to&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rvirding&#x2F;lfe&#x2F;blob&#x2F;dev-macro&#x2F;src&#x2F;cl.lfe&quot;&gt;&lt;strong&gt;LFE&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;.&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lfex&#x2F;clj&#x2F;issues&#x2F;18&quot;&gt;&lt;strong&gt;Clojure macros and functions&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;are also available as a separate library. LFE follows more traditional LISPs like Common Lisp, Scheme or more modern Lisps like Clojure?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;LFE more has the feel of CL and Scheme, especially CL as it is a lisp-2 not a lisp-1 like Scheme. Clojure is definitely interesting but I felt that the way it does concurrency doesn’t really map well onto Erlang and the style of building systems feels different. Clojure feels more like language with concurrency while Erlang feels more like a operating system with a language.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rvirding&#x2F;flavors&quot;&gt;&lt;strong&gt;LFE Flavors&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;and the&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;oubiwann&#x2F;los&quot;&gt;&lt;strong&gt;LFE Object System&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;? Aren’t they pretty similar?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Flavors is an object system on the Lisp Machine. I did LFE Flavors out of pure fun and curiosity. A long time ago (about 30 yrs) I did an implementation of Flavors for another lisp system, Portable Standard Lisp, and I was curious to see what it would be like to do one for LFE. It worked quite well for the central parts but there is a lot of Lisp machine specifics which can’t be transferred. CLOS is based on Flavors and you can see the heritage.&lt;&#x2F;p&gt;
&lt;p&gt;My plan with LFE Flavors is not to bake it in as part of LFE but have it as a supported compatible plugin. I like to keep the core simple. I also have plans to implements more general structs which will allow more control over data structures and access to them. It would subsume records and elixir structs amongst other things.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;A few months ago you&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;groups.google.com&#x2F;d&#x2F;topic&#x2F;lisp-flavoured-erlang&#x2F;l_Te7ZHkm9M&#x2F;discussion&quot;&gt;&lt;strong&gt;sent an email&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;titled “New macro handling and compiled macros”. How does the macro system work in LFE, what are you changing and why?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Currently macros work by defining them locally in each file where they are used. If you need to share macros then you define them in include files. The new macro handling will allow macros to be exported from modules in much the same way as functions and you would call them in the same way. So for a module foo you call functions with (foo:function …) and macros with (foo:macro …) making the interface much more consistent generic. Most uses of include files will disappear.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What do you think about Elixir?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Ambivalent! I don’t speak Ruby at all, so much of the syntax feels very strange and foreign. It also manages to push some of my programming buttons, for example having multiple ways of representing the same thing and adding syntax for special cases; both which I feel are just wrong. I am jealous of their ability to clean up some of the OTP modules by writing their own interfaces and having a way to avoid overlapping module names. I wonder about some of the complexity but that is just because I have a thing about simplicity.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Have you incorporated any idea from it into LFE?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I have not taken any ideas directly from Elixir though we do share some features, for example having multiple modules in one file (which I am not sure I like but it can be practical).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;I have seen&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;blog.lfe.io&#x2F;design&#x2F;2015&#x2F;07&#x2F;11&#x2F;1720-towards-multi-methods-in-lfe&#x2F;&quot;&gt;&lt;strong&gt;multimethods&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;and&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lfex&#x2F;los&#x2F;issues&#x2F;8&quot;&gt;&lt;strong&gt;protocols&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;mentioned a few times by the LFE community. What do you think about Clojure multimethods and protocols?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;One difficulty doing something like this in Erlang is that Erlang modules must be compiled as one unit, it is impossible to add, or remove, functions afterwards without recompiling the whole module. This makes it very difficult to have methods which are to be in one module in different places. Which lessens the usefulness of multimethods. IMAO.&lt;&#x2F;p&gt;
&lt;p&gt;Flavors gets around this by compiling each component flavor separately and building a object flavor from all its mixin when the first instance is created. This allows us to create the components separately as long as all are done before their first time they are used. After that they cannot be modified.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Do you think adding something like&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;26317325&#x2F;can-someone-explain-clojure-transducers-to-me-in-simple-terms&quot;&gt;&lt;strong&gt;transducers&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;to LFE would be a good idea?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;They probably would be, but they are not really the way I think. I find I tend to be very explicit in which data types I use; for me this is as fundamental as choosing which algorithm to use. This means that having polymorphic transformation functions becomes less interesting for me.&lt;&#x2F;p&gt;
&lt;p&gt;I know that many people prefer working in this way and I see no problems in adding them to the set of standard LFE libraries. They just won’t be integrated into LFE at the lowest level. You will be able to choose.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;I have seen some discussions about Dialyzer in LFE’s mailing list and there is a dialyzer branch in the&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rvirding&#x2F;lfe&#x2F;tree&#x2F;dev-dialyzer&quot;&gt;&lt;strong&gt;LFE repository&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;. How well does LFE support&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;erlang.org&#x2F;doc&#x2F;man&#x2F;dialyzer.html&quot;&gt;&lt;strong&gt;Dialyzer&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Supporting dialyzer is a little tricky as the official interface to dialyzer is very restricted: you either pass in erlang files, or you pass in beam files containing the Erlang AST of the code (compiling with the debug_info option). This does not work with LFE as the LFE compiler generates Core erlang, a language used internally in the compiler.&lt;&#x2F;p&gt;
&lt;p&gt;However, by being a bit cunning I have generated some alternate dialyzer interface modules which can load in the Core erlang forms directly. It works but it is really only an experiment; a better solution would be to do a proper fix of the dialyzer interface but this is not that simple as the current interface is not very cleanly coded. It is actually quite ironic as dialyzer uses Core erlang internally.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What do you think about&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.sbcl.org&#x2F;manual&#x2F;#Handling-of-Types&quot;&gt;&lt;strong&gt;Steel Bank Common Lisp Type system&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;,&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;ts-guide&#x2F;index.html&quot;&gt;&lt;strong&gt;Typed Racket&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;or&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;core.typed&quot;&gt;&lt;strong&gt;Clojure’s core.typed&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;and&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.shenlanguage.org&#x2F;learn-shen&#x2F;types&#x2F;types.html&quot;&gt;&lt;strong&gt;Shen Types&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I have never tried these so I can’t say. Generally I am very dynamically typed. :-)&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is the roadmap for LFE v1.0?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;So far the roadmap has been a little “I just want to add this one last feature and then I’ll release 1.0”. Anyway, my plan now is that when the new macro handling works and is properly integrated then the system will feel well rounded and I will release 1.0.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h4 id=&quot;did-you-like-it-follow-me-on-twitter-unbalancedparen&quot;&gt;Did you like it? F&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;unbalancedparen&quot;&gt;ollow me on Twitter — @unbalancedparen&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;Oh and I recommend that you read this email from Robert about LFE titled &lt;em&gt;“A bit of philosophy and some design principles”&lt;&#x2F;em&gt; :&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;There was a bit of discussion on the IRC about the CL module and where LFE gets its impulses from, that it doesn’t try to stand on its feet. There are things in it from scheme and CL but most of it is based on Erlang and the features it provides and the type of systems you build using it.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;The base of LFE rests directly on what the underlying Erlang VM provides and this determines what LFE can do and how it works. It is based on language features like modules, pattern matching, immutable data and how functions work. This is what defines LFE. I don’t think that LFE tries as hard as Elixir to hide this background.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;This, for example, is why LFE is a lisp-2 not a lisp-1 as it is a better fit for how Erlang handles functions. On top of this there is a set of convenience macros which were originally more scheme inspired but became more CL inspired when LFE became a lisp-2. They are just a better fit. Of course this doesn’t make LFE a scheme or a CL as there are many things in both scheme and CL which LFE can’t do because of the underlying Erlang VM like mutable data and the handling of nil&#x2F;() and symbols with values, plists and function bindings [*].&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;An alternative would have been more inspired by clojure which shares some properties with Erlang. However they are fundamentally different in many ways so it would mainly have been using clojure’s naming conventions. Also clojure’s concurrency model is very different from Erlang&#x2F;LFE so its way of building systems is also very different. You get the feeling, at least I do, that it is based on a central thread of execution where we you can run things in parallel, but there is this central thread. This is very un-Erlangy as Erlang&#x2F;LFE systems typically don’t have a central thread.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;This gets us, finally, to the CL module. It is just a library containing many of the standard CL library functions which gives you the possibility of writing in a CL style. Not everything can be included, for example the nXXXX functions which mutate data, and some features don’t mesh well with Erlang&#x2F;LFE. For example equating nil&#x2F;() and predicates which in Erlang&#x2F;LFE return true&#x2F;false while in CL are truthy and return nil&#x2F;() and anything else [**]. It is in no way a fundamental part of LFE and is just an add-on. If anyone feels inclined to do a similar module for clojure then I will definitely consider including it. Again it would just be an add-on. These could easily be included in the base release.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Packages like flavors, which I did because they are interesting and I think fun, should probably not be part of the base. This wou|d also apply to things like LFE CLOS (if anyone decided to do it) and LFE clojure-like protocols. They are interesting and useful in themselves but not things I would consider part of the LFE base. A set of these should probably kept in a standard place to make them easily accessible for everyone. I would like to keep the base relatively simple, clean and “basic”, a “lean, mean, fighting machine” if you will. It is all too easy to add things, even sensible and useful things, and end up with a bloated mess. I really want to avoid this, hence keeping the base simple and clean.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
</description>
      </item>
      <item>
          <title>Interview with Jay Kreps about Apache Kafka</title>
          <pubDate>Mon, 22 Feb 2016 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/interview-with-jay-kreps-about-apache-kafka/</link>
          <guid>https://blog.lambdaclass.com/posts/interview-with-jay-kreps-about-apache-kafka/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/interview-with-jay-kreps-about-apache-kafka/">&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-lRRJqrarJFi5TPtnBm_8hA.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;This time we interviewed &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;jaykreps&quot;&gt;Jay Kreps&lt;&#x2F;a&gt;, one of the creators of Apache Kafka. Kafka is an open source messaging system with a few design choices that make it particulary useful for high throughput and low latency scenarios.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;“This experience lead me to focus on building Kafka to combine what we had seen in messaging systems with the log concept popular in databases and distributed system internals. We wanted something to act as a central pipeline first for all activity data, and eventually for many other uses, including data deployment out of Hadoop, monitoring data, etc.” — Jay Kreps&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Kafka is built around the concept of a distributed database commit log. If you have no idea what that is, then I highly recommend that after you finish reading the interview you check the links I have pasted at the end. I learnt a lot by reading them.&lt;&#x2F;p&gt;
&lt;p&gt;In the following weeks I am going to publish an interview with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;martinkl&quot;&gt;Martin Kleppmann&lt;&#x2F;a&gt;, one of the authors of Samza, about his book Data Intensive Applications and realtime stream processing systems vs batch processing systems.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;strong&gt;What problem does Kafka solve?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Kafka is a distributed storage system for data streams. It allows you to publish streams of data and subscribe to them. It is built around the concept of a persistent log that is appended to — publishers of data append to this log and consumers subscribe to changes. Perhaps most importantly, it scales really well so it can function as a central hub for these data streams even in a company with a lot of data like LinkedIn or Netflix or Uber.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why RabbitMQ, ActiveMQ and other similar open source projects where not useful to solve this problem?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;There are a few things that are different about Kafka:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;It is built from the ground up as a modern distributed system. It handles replication, fault-tolerance, and partitioning. You think about Kafka as a cluster, not a collection of individual brokers. This impacts everything from how you manage it to how programs behave.&lt;&#x2F;li&gt;
&lt;li&gt;Kafka does a good job of persistence. Data in Kafka is always persisted and can be re-read.&lt;&#x2F;li&gt;
&lt;li&gt;Kafka is faster than traditional messaging system and hence more suitable to really large volume data streams such as would come from logging use cases, or massive streams of sensor data.&lt;&#x2F;li&gt;
&lt;li&gt;Kafka was designed to support distributed stream processing as a layer on top of its core primitives. This is why Kafka is so commonly used with things like Spark Streaming or Storm.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;In what type of structure do you persist messages and in which format?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;A message or record in Kafka is just a key-value pair, where the key and value are some string of bytes.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-4N-FW2mHbx6AsraV.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Kafka provides the abstraction of a “topic” which is split into one or more partitions (usually many) and spread over a cluster of nodes. A topic is a kind of feed of records. Applications publish records into a topic, and the record’s key determines the partition within that topic that the record goes to. Each partition is replicated on multiple machines for fault-tolerance.&lt;&#x2F;p&gt;
&lt;p&gt;The core abstraction Kafka provides (as well as the data structure it uses in its implementation) is a write ahead log. This log is just an ordered sequence of the records written to the cluster that is persisted to disk. Each record is assigned a sequential number called an offset. This offset acts as a position in the log.&lt;&#x2F;p&gt;
&lt;p&gt;An application consuming that partition can be thought of as having a position in the log designated by that offset, which means it has consumed all the records earlier and none of the records after. The application controls that position and can continue to read forward or go back in time to re-read.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;How does Kafka manage to handle easily many dozens of thousand of messages per seconds if it persists them to disk instead of keeping them in memory?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Careful design! Our observation was that there was no fundamental reason that the log abstraction we wanted couldn’t be as fast as the underlying filesystem at linear writes, which means anything from hundreds of MB&#x2F;sec on spinning disks to GBs&#x2F;sec on SSDs. To make this happen Kafka does a good job of batching together lots of small writes into big linear appends to files. This batching happens both in the consumer, in the replication protocol, in the consumer, and in the operating system itself.&lt;&#x2F;p&gt;
&lt;p&gt;I do think the domain of infrastructure engineering is different in this way. Application developers are warned against the dangers of premature optimization, but for infrastructure I think you need to start thinking about performance in the design phase. The reason it is so different is that the fundamental constraints are well known ahead of time and usually system designs are not very flexible, so if you ignore performance initially it is generally very hard to get it back later by optimizing within your existing design.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What guarantees does Kafka provides? In which cases can messages be lost?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Kafka guarantees that writes are replicated across N instances in the same order (where N is a replication factor you choose) and that your write won’t be lost as long as at least one of these instance remains alive.&lt;&#x2F;p&gt;
&lt;p&gt;In combination with the way consumers control their own offset this translates to an “at-least-once” delivery.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;In&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;9RMOc0SwRro&quot;&gt;&lt;strong&gt;this talk&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;you mentioned Kafka streams. Could you briefly explain what is it and why it will be useful?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Kafka Streams is a stream processing layer for Kafka we’ve been working on. It’s a little different from the existing stream processing frameworks that are out there — more focused on building streaming applications and less a kind of real-time version of MapReduce.&lt;&#x2F;p&gt;
&lt;p&gt;We’ll be doing a preview release in early March (we’re really excited).&lt;&#x2F;p&gt;
&lt;p&gt;Combined with the work we did on &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.confluent.io&#x2F;blog&#x2F;announcing-kafka-connect-building-large-scale-low-latency-data-pipelines&quot;&gt;Kafka Connect&lt;&#x2F;a&gt;, we think this makes Kafka a really compelling &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.confluent.io&#x2F;blog&#x2F;stream-data-platform-1&#x2F;&quot;&gt;platform for streaming data&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What needs to be done before releasing Kafka 1.0?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We’ll get there. We thought we needed to at least get a stable version of Connect and Streams done as they are a pretty essential part of the platform.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why did you choose Java to implement Kafka? Did you ever consider using another programming language?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We had a lot of experience with the JVM and knew it was possible to build reliable and fast infrastructure on top of it — and it was more convenient to work with than C or C++.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;I work as an Erlang developer and I was thrilled by your comments about concurrency and languages in&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;blog.empathybox.com&#x2F;post&#x2F;90318905473&#x2F;concurrency-is-not-a-language-thing-anymore&quot;&gt;&lt;strong&gt;“Concurrency is not a language thing anymore”&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;:&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
&lt;em&gt;“In the near-real-time processing domain stream processing frameworks do a good job of providing asynchronous processing without directly thinking about concurrency at all. Again you interact with concurrency and parallelism only at the framework level, the code you write appears completely single-threaded.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;The offline world seems to be moving in the direction of a handful of YARN frameworks for different specialized purposes. What almost all of these share is that they don’t require users to directly manage concurrency.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;This leads me to think that putting more time into language support for single-server concurrency (software transactional memory and all that) is of limited utility. It will only help the implementors of these frameworks, not the end user.”&lt;&#x2F;em&gt;&lt;br &#x2F;&gt;
&lt;strong&gt;Apart from Erlang, some languages like Go and Clojure added a good concurrency model and semantics from the start. Don’t you think there is any area where having good concurrency baked into the language is useful for the normal developer and not only for the implementor of frameworks?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The critique I was trying to make is sort of analogous to the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;End-to-end_principle&quot;&gt;end-to-end principle&lt;&#x2F;a&gt; for network protocols, basically you end up needing to solve the concurrency problem at a higher level anyway which makes the lower-level primitive the languages provide redundant. What I see is each language is trying to provide built-in primitives for multi-core programming. Other than Erlang I think most of these ignore the problem of distributed computing. But what has changed is that modern programming is always done in some framework that introduces a concurrency model at a higher level. Examples of these frameworks would be the whole Apple and Android stacks, numerous microservice frameworks, and things like Spark or Kafka Streams. These higher level frameworks are able to do a better job because they can make assumptions about the environment that just aren’t possible at the language level. So, for example, many of them are able to introduce a model that simultaneously solves for spreading computation over CPU cores on one machine as well as over multiple machines.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why does Kafka depends on Zookeeper? What job does Zookeeper do for Kafka?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.confluent.io&#x2F;blog&#x2F;distributed-consensus-reloaded-apache-zookeeper-and-replication-in-kafka&quot;&gt;This article&lt;&#x2F;a&gt; gives an overview of its role in Kafka’s replication design.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Do you have any recommendation for those of us who want to start learning about distributed systems? Was there any books, papers or codebase that really helped you implement and design Kafka?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I think a great place to start is Martin Kleppman’s book &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;shop.oreilly.com&#x2F;product&#x2F;0636920032175.do?cmp=af-strata-books-videos-product_cj_9781491903094_%25zp&quot;&gt;Designing Data Intensive Applications&lt;&#x2F;a&gt;. I have only read parts of it, but from what I’ve seen it is the best accessible introduction to distributed systems out there. Unfortunately only 9 of 12 chapters are available so we should all bug him to finish it!&lt;&#x2F;p&gt;
&lt;p&gt;A good textbook you &lt;em&gt;can&lt;&#x2F;em&gt; buy today is &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.amazon.com&#x2F;Introduction-Reliable-Secure-Distributed-Programming&#x2F;dp&#x2F;3642152597&quot;&gt;Introduction to Reliable and Secure Distributed Programming&lt;&#x2F;a&gt;. This book isn’t great for learning but it is an order of magnitude better than other text books which are utterly terrible. Unfortunately distributed systems research had several decades in which it wasn’t really very practical and hence it developed a culture that seems to pride itself on it’s lack of connection to mainstream practice. For example, that book, manages to spend on the order of a hundred pages introducing different possible communication primitives and talking about their properties without bothering to connect any of these to the actual mainstream network protocols like UDP and TCP which seems pretty silly to me.&lt;&#x2F;p&gt;
&lt;p&gt;The best thing is that these days there are hundreds of open source distributed systems available and you can learn quite a lot about the design and implementation of these.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;As I mentioned in the introduction to the interview, I highly recomend that you read the following three links about Kafka, its design and uses:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;engineering.linkedin.com&#x2F;distributed-systems&#x2F;log-what-every-software-engineer-should-know-about-real-time-datas-unifying&quot;&gt;The Log: What every software engineer should know about real-time data’s unifying abstractionI joined LinkedIn about six years ago at a particularly interesting time. We were just beginning to run up against the…engineering.linkedin.com&lt;img src=&quot;&#x2F;images&#x2F;fit&#x2F;c&#x2F;160&#x2F;160&#x2F;0-EKXwv5gzf95qmyw9.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.confluent.io&#x2F;blog&#x2F;stream-data-platform-1&#x2F;&quot;&gt;Putting Apache Kafka To Use: A Practical Guide to Building a Stream Data Platform (Part 1)These days you hear a lot about “stream processing”, “event data”, and “real-time”, often related to technologies like…www.confluent.io&lt;img src=&quot;&#x2F;images&#x2F;fit&#x2F;c&#x2F;160&#x2F;160&#x2F;0-wDG3xKC21IQ4qaC7.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.confluent.io&#x2F;blog&#x2F;stream-data-platform-2&#x2F;&quot;&gt;Putting Apache Kafka To Use: A Practical Guide to Building a Stream Data Platform (Part 2)This is the second part of our guide on streaming data and Apache Kafka. In part one I talked about the uses for real…www.confluent.io&lt;img src=&quot;&#x2F;images&#x2F;fit&#x2F;c&#x2F;160&#x2F;160&#x2F;0-D5SxPsgpumFDy5py.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;kafka.apache.org&#x2F;documentation.html#design&quot;&gt;Apache KafkaKafka is a distributed, partitioned, replicated commit log service. It provides the functionality of a messaging system…kafka.apache.org&lt;img src=&quot;&#x2F;images&#x2F;fit&#x2F;c&#x2F;160&#x2F;160&#x2F;0-5a9GIkEZZHsR80Z0.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Jay also gave a few excellent talks about Kafka that explain why it was created and what are its uses:&lt;&#x2F;p&gt;
&lt;h4 id=&quot;&quot;&gt;&lt;&#x2F;h4&gt;
</description>
      </item>
    </channel>
</rss>
