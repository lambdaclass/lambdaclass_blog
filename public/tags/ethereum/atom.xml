<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>LambdaClass Blog - ethereum</title>
    <subtitle>Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.</subtitle>
    <link rel="self" type="application/atom+xml" href="https://blog.lambdaclass.com/tags/ethereum/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-05-16T00:00:00+00:00</updated>
    <id>https://blog.lambdaclass.com/tags/ethereum/atom.xml</id>
    <entry xml:lang="en">
        <title>Celebrating a year of ethrex</title>
        <published>2025-05-16T00:00:00+00:00</published>
        <updated>2025-05-16T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com/posts/celebrating-a-year-of-ethrex/"/>
        <id>https://blog.lambdaclass.com/posts/celebrating-a-year-of-ethrex/</id>
        
        <content type="html" xml:base="https://blog.lambdaclass.com/posts/celebrating-a-year-of-ethrex/">&lt;p&gt;We have been working at LambdaClass on an Ethereum L1 Execution and L2 client called ethrex since June 2024. Now that it’s maturing and&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ethereum&#x2F;hive&#x2F;pull&#x2F;1286&quot;&gt; &lt;em&gt;recently added to Hive&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;, we think it’s time to talk about it a bit and highlight what sets it apart from others.&lt;&#x2F;p&gt;
&lt;p&gt;Ethrex began as an exploratory project with just three team members and has since grown into a 40-person initiative—now one of LambdaClass’ top priorities. It is the first stack to natively incorporate based rollups since day one. We’re preparing to enter the security audit phase and will move directly into production with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;x.com&#x2F;fede_intern&#x2F;status&#x2F;1846035499799978475&quot;&gt;&lt;em&gt;Rogue&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;, alongside several institutions and clients eager to deploy their own L2 stacks.&lt;&#x2F;p&gt;
&lt;p&gt;Most of the ideas that motivate ethrex share a core tenet: simplicity. We recommend reading Vitalik’s &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;vitalik.eth.limo&#x2F;general&#x2F;2025&#x2F;05&#x2F;03&#x2F;simplel1.html&quot;&gt;&lt;em&gt;recent post&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; about simplifying the L1; it shares many of the same ideas we will talk about in this post and greatly resonates with us as a guiding principle.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;why-build-yet-another-ethereum-execution-client&quot;&gt;&lt;strong&gt;Why build yet another Ethereum execution client?&lt;&#x2F;strong&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;At this point, the Ethereum ecosystem has good client diversity: Geth, Besu, Erigon, Nethermind and Reth are all production-grade choices, though with varying degrees of popularity. So why write a new client, and why do it in Rust when Reth exists?&lt;&#x2F;p&gt;
&lt;p&gt;The more we got involved in the crypto space and used its tools and codebases, the more we realized that most of them had more complexity than we were comfortable with; sometimes even actively seeking it as part of their development process. Libraries with dozens of modules to modularize even the slightest things, APIs with tons of traits and generics looking to abstract every contingency, macros used to (debatably) save lines of code at the cost of readability, these are all inconveniences we and others have to constantly deal with when integrating with crypto repositories.&lt;&#x2F;p&gt;
&lt;p&gt;Ethrex is our attempt at solving this. It aims to be the infrastructure, libraries and tooling we wish we had when we started. In line with the&lt;a href=&quot;&#x2F;lambdas-engineering-philosophy&#x2F;&quot;&gt; &lt;em&gt;LambdaClass work ethos&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;, our goal is to always keep things simple and minimal. This is reflected in a few different ways.&lt;&#x2F;p&gt;
&lt;p&gt;We track lines of code for the project, ensuring we never go over a limit. The entire repo currently sits at 62k lines. This includes code for our EVM implementation, our L2 stack (along with ZK provers and TEE code), and our ethereum sdk. Most other clients average around 200k on their main repos, not even counting their dependencies, that are usually split into other repos (EVM, sdk, provers). Including those can easily tip it over 300k or more. Our approach heavily leans into vertical integration and minimalism, ensuring we have control over the whole stack while keeping it as simple as possible.&lt;&#x2F;p&gt;
&lt;p&gt;We have daily automated slack messages to be vigilant about lines of code on our project, and regularly look for dead or unnecessary code and refactor opportunities to trim them down.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;lh7-rt.googleusercontent.com&#x2F;docsz&#x2F;AD_4nXdcALtGQVAcNJIEOOLkG6-jxrPB_TceM-wGY_XHqMNqk7mA0-e5ybIXqr0avzaihCNCcjfkKC-Kyved58JHcVGJ0fBgBMs1JBAOpfhUwm-v9V3DTQ0JwQZHRpbayXHK3aF-YodyWQ?key=QZhQagxqvNX4hb2HYsJWkA&quot; alt=&quot;&quot; &#x2F;&gt;Lines of code report&lt;&#x2F;p&gt;
&lt;p&gt;As the image above shows, the ethrex repo consists only of six self-explanatory main crates:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * blockchain&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * common&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * l2&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * networking (divided into p2p and rpc)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * storage&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * vm&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is very much on purpose; other clients tend to modularize code too much into different packages, hurting readability and simplicity.&lt;&#x2F;p&gt;
&lt;p&gt;Use of traits is kept to a minimum, only when it absolutely makes sense to introduce them. Our codebase contains as few as 12 traits, which we already consider to be too many and are actively looking to reduce them. They are used for the following:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * RLP encoding and decoding.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Signing of data.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Trie Storage, Regular Storage, and L2 Storage.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * RLPx encoding and RPC handlers.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * EVM hooks.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Use of macros is frowned upon throughout the codebase. There are only four of them in ethrex, three used only for tests and one for Prometheus metrics collection.&lt;&#x2F;p&gt;
&lt;p&gt;Dependencies are also kept in check as much as possible. Rust codebases are notorious for piling up crates, and while we still consider we depend on too many of them, we make periodic efforts to reduce them.&lt;&#x2F;p&gt;
&lt;p&gt;Minimalism is also reflected in our decision not to implement historical features; ethrex only supports post merge forks. We believe Ethereum should have a forward-looking accelerationist attitude to win over its competitors in the blockchain landscape, which means moving fast, embracing change, and remaining lean by not being afraid of quickly dropping support for old features. This also improves ROI on the project because it allows us to both develop and maintain it with a smaller team.&lt;&#x2F;p&gt;
&lt;p&gt;We are very opinionated about how to write Rust code. While we love the language for its mix of high performance, memory safety guarantees and high level language constructs, we believe it is easy to get carried away with its features and overcomplicate codebases; having a rich and expressive type system does not mean one should take every opportunity to reify every problem into it through a trait. This obfuscates code for newcomers and makes it more complex at very little benefit.&lt;&#x2F;p&gt;
&lt;p&gt;For developers, all this has an impact not only on readability and ease of use, but also on compilation times. Complex code architectures with many traits and macros add to compile times, which hurts developer experience. It is not uncommon to see Rust projects take multiple minutes to compile on modern machines, and code complexity plays a big part in that.&lt;&#x2F;p&gt;
&lt;p&gt;However, simplicity and minimalism is not just about making developer experience easier. The fewer the lines of code, the easier it is to maintain the code, to find bugs or vulnerabilities, and to spot possible performance bottlenecks and improvements. It also reduces the attack surface for security vulnerabilities to be there in the first place.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ethrex-l2&quot;&gt;&lt;strong&gt;Ethrex L2&lt;&#x2F;strong&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;From the beginning, ethrex was conceived not just as an Ethereum L1 client, but also as an L2 (ZK Rollup) client. This means anyone can use ethrex to deploy an EVM equivalent, multi-prover (supporting SP1, RISC Zero and TEEs) based rollup with just one command. Financial institutions can also use it to deploy their own L2, with the choice of deploying it as a Validium, a based Rollup or a regular ZK Rollup. In fact, our upcoming permissionless based L2&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;x.com&#x2F;fede_intern&#x2F;status&#x2F;1846035499799978475&quot;&gt; &lt;em&gt;Rogue&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; uses ethrex and anyone will be able to join it by just cloning the repo and running a command.&lt;&#x2F;p&gt;
&lt;p&gt;Key to the development of ethrex L2 is the availability of general purpose ZK virtual machines using hash-based proving systems, such as SP1 and RISC Zero, that allow proving arbitrary code written in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;Being in the crypto space for some years now, we have experienced firsthand the pains of writing arithmetic circuits using libraries like Circom, Bellman, Arkworks or Gnark. Doing so requires in-depth knowledge about the internals of zk-SNARKS, which most engineers do not and should not care about. Additionally, requiring a different API or DSL to write circuits means you end up with two implementations of the same thing: one out of circuit and one in-circuit. This is a huge source of problems, because on every code change there’s the possibility of a divergence between the code being executed and the code being proven, and solving those types of bugs can be challenging and time consuming.&lt;&#x2F;p&gt;
&lt;p&gt;With a RISC-V zkVM, those problems go away; engineers can easily write the code to be proven without having to understand any of the internals, and the chances of a divergence are minimal, because almost all code can be shared between the “out of circuit” and the “in circuit” versions.&lt;&#x2F;p&gt;
&lt;p&gt;ZK-rollups like Scroll and ZKsync tightly coupled their proving system with their VM. While this worked, it meant having a non-EVM architecture and going through a lot of hoops to support EVM equivalence. It also meant having an in-house team of expert cryptographers to design and develop all the complex circuits required to prove their execution. At LambdaClass, we believe that the low level cryptography should be left to projects like Starkware’s Stwo, Lita’s Valida, Polygon’s PetraVM, Succinct’s SP1, or a16z’s Jolt. Our job is to then plug their work into ours, decoupling the cryptography from the rest of the codebase, greatly simplifying the development. This is what allowed us to be the only client designed from the beginning to be an L1, an L2 and a based rollup.&lt;&#x2F;p&gt;
&lt;p&gt;All these benefits can be seen very clearly: the entire l2&#x2F;prover directory where all the related code lives has only 1.3k lines of code, and even that can be reduced further since we haven’t moved some behavior to common functions yet. In other projects we have used and worked with, the ZK-related code was massive, sometimes matching or surpassing the regular non-ZK one.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-left&quot;&gt;&lt;strong&gt;What’s left&lt;&#x2F;strong&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;We have made a lot of progress in the past year, from an empty repository to a full-fledged L1 and L2 client, but there is still work to be done to make ethrex production-ready. The main focus right now is on performance. We are currently sitting at around 0.3 gigagas&#x2F;s, and we aim to hit at least 1 gigagas&#x2F;s in the coming weeks, most of it coming from improvements to trie&#x2F;database accesses. Afterwards come security audits and based rollup support. We also have extra features planned on top, including alternative DA support for validiums and custom native token mode, both for ethrex L2.&lt;&#x2F;p&gt;
&lt;p&gt;This year’s Devconnect will take place in our hometown, Buenos Aires. By then, we aim to have a feature-complete version of ethrex running in production, ready to showcase some of its most exciting use cases. As mentioned, a growing number of companies and institutions have expressed interest in ethrex and its potential. Our mission is to help advance Ethereum’s development by building infrastructure and applications that address real-world challenges.&lt;&#x2F;p&gt;
&lt;p&gt;We invite you to follow along our progress as we build in the open and try it out yourself:&lt;&#x2F;p&gt;
&lt;p&gt;Telegram: &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;t.me&#x2F;ethrex_client&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;t.me&#x2F;ethrex_client&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;br &#x2F;&gt;
Github: &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;ethrex&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;ethrex&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>A fast trust minimized intent based bridge solution for Ethereum and L2s powered by multi-proof storage proofs</title>
        <published>2024-01-28T00:00:00+00:00</published>
        <updated>2024-01-28T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com/posts/a-fast-trust-minimized-intent-based-bridge-solution-for-ethereum-and-l2s-powered-by-multi-proof-storage-proofs/"/>
        <id>https://blog.lambdaclass.com/posts/a-fast-trust-minimized-intent-based-bridge-solution-for-ethereum-and-l2s-powered-by-multi-proof-storage-proofs/</id>
        
        <content type="html" xml:base="https://blog.lambdaclass.com/posts/a-fast-trust-minimized-intent-based-bridge-solution-for-ethereum-and-l2s-powered-by-multi-proof-storage-proofs/">&lt;p&gt;&lt;strong&gt;Authors:&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;thisisrj&quot;&gt;Roberto Catalan&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;federicocarrone&quot;&gt;Federico Carrone&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Bridges are generally insecure and economically inefficient. They exhibit an asymmetry between users and bridge operators, where users can easily lose funds. We propose a bridge design that is simple, modular, and utilizes multi-storage proofs and the native messaging system between Ethereum and Layer 2 networks (L2s) as a fallback mechanism.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bridging-is-a-trust-issue&quot;&gt;Bridging is a trust issue&lt;&#x2F;h2&gt;
&lt;p&gt;How can we offer a system where the users don’t have to trust a facilitator to exchange their assets from an L2 to Ethereum?&lt;&#x2F;p&gt;
&lt;p&gt;We propose a simple protocol that follows these steps:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    1. The user specifies a destination address on Ethereum and locks the tokens X to be bridged into an L2 escrow smart contract.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    2. A market maker monitors a change of state in the escrow smart contract.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    3. a. The market maker calls the transfer function of the PaymentRegistry Contract in Ethereum.  &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;b. The transfer function of the PaymentRegistry contract in Ethereum pays the tokens X to the User.
4. A storage proof is generated, containing evidence of a transfer from the market maker’s Ethereum account to the user-specified address in Ethereum.
5. Ethereum PaymentRegistry storage information is used as part of a storage proof.
6. L2 Escrow contract verifies the storage proof of the PaymentRegistry contract in Ethereum and pays the MM with the initial tokens locked by the user.
&lt;img src=&quot;&#x2F;images&#x2F;2024&#x2F;01&#x2F;image.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The same design can be expanded to be used to bridge tokens from an L2 to another L2. The same design can include multi-proof storage proofs instead of using only one. We also have implemented a fallback mechanism using the native message mechanism between Ethereum and L2s in case the storage proof providers are offline.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Fallback mechanism&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
If the storage proof providers are not available, the market maker can prove to the Escrow contract that they fulfilled the user’s intent through the rollup’s native messaging system. Using this messaging system has the same trust assumptions as the L2s used in the transfer.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;risks&quot;&gt;Risks&lt;&#x2F;h2&gt;
&lt;p&gt;For the user, the risks include the existence of a bug in the code of the smart contract, the existence of a bug in the circuits of the ZK&#x2F;validity proof verification and the fact that the storage proof provider can go offline. The first risk is mitigated by having a very simple smart contract. The second risk is mitigated by using multi-proof storage proofs and multiple ZK&#x2F;validity proof implementations or TEEs. If the storage proof provider goes offline the fallback mechanism can be used.&lt;&#x2F;p&gt;
&lt;p&gt;The risks for market makers are the same as for users, plus the risk of reorganization of the chain and the fact that the market maker receives the same tokens on the L2s rather than on Ethereum.&lt;&#x2F;p&gt;
&lt;p&gt;Since the capital is locked for a short period (until the proof is generated or the message arrives), the risks are minimized and the attack surface is smaller for the market maker.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;questions&quot;&gt;Questions&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;What are our disadvantages?&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
The biggest disadvantage of this solution is that users can only bridge tokens that are present in both the origin and destination chains.&lt;br &#x2F;&gt;
Another disadvantage is that the risks don’t disappear; they are simply transferred to the market maker.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;How can users cancel their order?&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
Initially, we are not going to offer the ability to cancel orders. The main reason is to avoid any timing attacks. For instance, a user could create an order and cancel it right after the market maker has paid them on the destination chain, thereby stealing funds from the market maker.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Is there any real-world implementation of this bridge?&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
Yes. We have already implemented this between Starknet and Ethereum. We plan to integrate zkSync, Arbitrum, Optimism, Scroll, Base, and Linea next.&lt;br &#x2F;&gt;
All integrations require the same codebase with a few modifications, except for Starknet, which is not EVM compatible.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;How fast is it?&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
From the user’s perspective, the bridging is completed in less than 30 seconds, as quickly as the time it takes the market maker to observe the user’s deposit and execute a transfer.&lt;br &#x2F;&gt;
From the market maker’s perspective, they will be able to withdraw the money after paying the user and generating the storage proof. This normally takes between 5 and 15 minutes. It’s important to also consider that the market maker will need to rebalance their liquidity using the native bridge and wait for the finality of the native bridge to rebalance their portfolio.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;How cheap is it?&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
The cost of this bridge is similar to an ERC20 transfer plus the cost of proving the state of the L1 and L2. This second cost tends towards zero since it’s amortized by multiple calls that use the same proof, and the proving cost is minimal compared to on-chain transfers.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is new in this design? Didn’t storage proofs solve this problem already?&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
Storage proofs alone don’t fundamentally change the design of a traditional bridge. They merely enable a safer coordination mechanism.&lt;br &#x2F;&gt;
Locking the user’s capital first provides guarantees to the market maker that they will receive the funds in exchange for fulfilling the user’s intent.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Couldn’t you solve this problem without Storage Proofs? What do they add to the table?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Yes, Storage Proofs are not 100% necessary to solve this problem. But they are a key technological component for a future proof architecture. If we want this protocol to scale, storage proofs are the best way to do this. It will allow us to prove many orders together.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What are the benefits against an Optimistic Oracle?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Optimistic Oracles were a great solution before Storage Proofs were a feasible solution, their main disadvantages are:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Optimistic Oracles relay in Game Theory to work and it&amp;#39;s difficult to bootstrap an ecosystem to make them robust.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Codebases are complex&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * The settlement period takes a few hours (depending on the solution) and end up creating inefficiencies for the market makers.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;On the other hand our protocol with the native messaging and storage proofs takes no longer than 15 minutes (between Ethereum and L2) to unlock the funds. The protocol codebase is no more than 500 lines of code and the risks are easy to understand by all the players and therefore easy to come up with ways to mitigate them.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Did anybody do something similar beforehand?&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
Hop Protocol was one of the first bridges to allow cross-chain swaps between rollups and Ethereum with an AMM-based design using multiple messaging systems (native and optimistic). The main issue lies in the capital inefficiency of an AMM model and the significant security risks of locking large amounts of capital in complex cross-chain communications.&lt;&#x2F;p&gt;
&lt;p&gt;Across was the first bridge to leverage intents for a faster bridge experience and lower capital costs per transaction. However, by using an Optimistic Oracle, it naturally has a challenging period that the market has to wait to get its funds back. To optimize some of the problems their settlement mechanism introduces, they offer financial products around their main bridge solution, such as Liquidity Pools that front the capital to the market makers.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What are our advantages?&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
Our bet is that zero-knowledge proofs will continue to improve, becoming faster and safer, thus enhancing our solution and allowing us to offer better prices by lowering risks and shortening the repayment period.&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Fast and cheap bridging experience for the user&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Short capital lock-up period for the market maker&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Low on-chain complexity. The smart contracts in total are not larger than 300 lines of code.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;next-steps&quot;&gt;Next steps&lt;&#x2F;h2&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Speeding up message passing with EigenLayer to allow cross-chain swap settlements between L2s. The protocol should have the option to send faster messages between rollups and Ethereum with similar trust assumptions of the native messaging system.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Introducing Partially Filled Orders, offering cheaper but slower transfers with batching.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Intent-based DeFi Pooling.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Unified wallet abstraction across multiple L2s.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;</content>
        
    </entry>
</feed>
