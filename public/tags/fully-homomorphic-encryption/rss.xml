<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>LambdaClass Blog - Fully Homomorphic Encryption</title>
      <link>https://blog.lambdaclass.com</link>
      <description>Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.</description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://blog.lambdaclass.com/tags/fully-homomorphic-encryption/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Thu, 13 Apr 2023 00:00:00 +0000</lastBuildDate>
      <item>
          <title>Transforming the Future with Zero-Knowledge Proofs, Fully Homomorphic Encryption and new Distributed Systems algorithms</title>
          <pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/transforming-the-future-with-zero-knowledge-proofs-fully-homomorphic-encryption-and-new-distributed-systems-algorithms/</link>
          <guid>https://blog.lambdaclass.com/posts/transforming-the-future-with-zero-knowledge-proofs-fully-homomorphic-encryption-and-new-distributed-systems-algorithms/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/transforming-the-future-with-zero-knowledge-proofs-fully-homomorphic-encryption-and-new-distributed-systems-algorithms/">&lt;p&gt;Disclaimer: To maintain brevity and clarity, we have simplified certain concepts. In this discussion, Zero Knowledge Proofs and Computational Integrity are considered as a single concept, and we will not address the distinct security properties of Proof of Work and Proof of Stake.&lt;&#x2F;p&gt;
&lt;p&gt;The evolution of every scientific discipline or engineering field experiences cycles akin to those observed in economies. Incremental advancements are made daily by corporations, individuals, and academic institutions. Occasionally, a researcher or engineer makes a groundbreaking discovery that alters the course of the field. One such example is Sir Isaac Newton, who made significant contributions to calculus, motion, optics, and gravitation during the time of the bubonic plague, which claimed millions of lives. His relentless pursuit of knowledge throughout the pandemic proved instrumental in shaping the development of mathematics, physics, and engineering. Our comfortable modern lives stand upon the foundation of these monumental discoveries.&lt;&#x2F;p&gt;
&lt;p&gt;The general public is aware of the big breakthroughs made in the aerospatial industry, energy production, internet of things, and last but not least artificial intelligence. However, most don‚Äôt know that during the COVID pandemic, enormous advances were made in cryptography. 47 years ago Diffie and Hellman wrote in their famous cryptography paper: ‚Äúwe stand today on the brink of a revolution in cryptography‚Äù, which enabled two people to exchange confidential information even when they can only communicate via a channel monitored by an adversary. This revolution enabled electronic commerce and the communication between citizens of the free world. We believe the discoveries made by researchers and engineers in cryptography during this COVID pandemic will be as important as the discoveries made by Diffie and Hellman in the upcoming decades.&lt;&#x2F;p&gt;
&lt;p&gt;One of the big discoveries has been how to make Zero-Knowledge Proofs fast enough for real-world applications. This technology has been around since 1984 but as Diffie also said, ‚ÄúLots of people working in cryptography have no deep concern with real application issues. They are trying to discover things clever enough to write papers about‚Äù. Fortunately for humanity, researchers and engineers have made this technology practical enough in the last decade (especially the last 2 years) to be useful.&lt;&#x2F;p&gt;
&lt;p&gt;The financial system depends on the existence of intermediaries: an army of auditors, regulators, and accountants. The correct working of the financial machine depends on the integrity of its financial institutions. Integrity is maintained due to positive economic incentives and jail time, fines, and costly lawsuits if the intermediaries don‚Äôt do what the state and society expect from them. Bitcoin, a result of the 2008 crisis, created a permissionless financial system where its users can send and receive digital money without intermediaries and without anybody being able to block transactions. In countries like Argentina, Nigeria, or Lebanon, where stagnation and inflation erode its citizens‚Äô trust in the financial system and the state, Bitcoin and stablecoins on top of Ethereum are used on a daily basis by the young population to save and avoid capital controls. In developed countries, its usage is not as massive since the traditional financial system and the state is trusted by most citizens. However, the world is becoming more complex. Banks are failing in the US and Europe, a new war is taking place in Europe, debt levels are not sustainable in many countries, the fight between left and the right is retaking the main stage, tension between the West and the East increases, and technological change keeps accelerating.&lt;&#x2F;p&gt;
&lt;p&gt;New applications built on top of unstoppable and trustless technologies that don‚Äôt depend on social trust will grow and thrive in this type of environment. Everything is being questioned. Only things that can‚Äôt be questioned will fully resist the passage of time. This will happen not only in developing countries but also in developed ones. Systems like Bitcoin, where everyone can verify how it‚Äôs running, are more resilient and become more useful by the day in a world that is getting more complex.&lt;&#x2F;p&gt;
&lt;p&gt;Bitcoin‚Äôs focus has been to become a new type of monetary asset and financial network. For this reason, the development of more complex programs on top of Bitcoin has always been restricted by design. Newer blockchains like Ethereum added the ability to create new types of applications. DeFi Protocols that enabled lending and borrowing, exchange of digital currencies and the ability to buy, sell and trade digital collectives and arts rapidly grew on top of Ethereum. However the cost of creating and transferring relevant amounts of assets in blockchains is costly. The ability to create more complex applications that sit on top of blockchains is also very limited. Applications can‚Äôt run more than a few milliseconds on Ethereum.&lt;&#x2F;p&gt;
&lt;p&gt;These systems do not rely on social integrity like traditional systems. Instead, they operate as a permissionless and censorship-resistant network, allowing anyone to add a node and submit updates to its state. To ensure verification, each node must re-execute all transactions, which makes the system decentralized and secure, albeit slower than centralized systems. Consequently, this imposes a limitation on the types of applications that can be built on blockchains. Applications requiring frequent database state updates, such as those exceeding a few times per second, or machine learning algorithms, are not feasible on blockchain platforms.&lt;&#x2F;p&gt;
&lt;p&gt;This is where Zero Knowledge Proofs (ZKPs) and other cryptographic and distributed systems primitives will help society create tools that can be used by everyone. ZKPs enable a party to demonstrate a statement to other parties without revealing any information beyond the proof. In more concrete terms, this enables a person to show another person that the computation they did is correct without having to redo it and without even having to grant access to the data that was used. An important aspect of this is that the verification is done in a much faster time than the proving. In even simpler terms, it proves that the output of a certain computation is correct. The verification is way easier and faster to do than the execution or proving. Anybody can check the proof, and this saves computing time and money.&lt;&#x2F;p&gt;
&lt;p&gt;At the beginning it‚Äôs difficult to grasp, even for engineers, that such a technology is even possible. The mathematics behind it, until recently, seemed magical, and that‚Äôs why it was called moon math. Thanks to ZKPs, transferring money in blockchains similar to Bitcoin is cheaper and way faster since there is no need to re-execute each transaction by each node. Only one node is needed to process all the transactions and prove them using a ZKPs, while the rest simply need to verify it, saving valuable computing resources. Among other things, ZKPs enable creating a financial system that doesn‚Äôt depend on social trust like traditional finance and that doesn‚Äôt depend as much on re-executing algorithms as Bitcoin.&lt;&#x2F;p&gt;
&lt;p&gt;Zero Knowledge Proofs facilitate the development of an entirely new range of applications that are executed and proven on a single computer outside the blockchain, with verification occurring within Ethereum. The verification cost is way cheaper than the time it takes to prove or execute it. Ethereum will evolve from a slow yet secure distributed mainframe, where execution time is shared among all users to run small programs, into a distributed computer that stores and verifies proofs generated externally from the blockchain.&lt;&#x2F;p&gt;
&lt;p&gt;Not only will blockchains benefit from the development of new cryptographic primitives like Zero Knowledge Proofs (ZKPs), but other areas will also be significantly impacted. As AI-generated content begins to overshadow human-generated content on the internet, ZKPs will become essential for verifying that such content was produced by unbiased AI models. ‚ÄúProof of humanity‚Äù systems are already employing ZKPs to ensure the accurate computation of a human accessing specific resources.&lt;&#x2F;p&gt;
&lt;p&gt;Hardware is another area where ZKPs will make an impact. Similar to how graphics cards in the 1990s revolutionized the video game industry, zero-knowledge hardware acceleration will be integrated into computers to enhance efficiency.&lt;&#x2F;p&gt;
&lt;p&gt;ZKPs can also be utilized to balance storage and computation securely. For instance, security cameras generate vast amounts of data. ZKPs can provide a compact proof that AI models did not detect any critical information in the video, allowing the system to delete the footage and save storage space.&lt;&#x2F;p&gt;
&lt;p&gt;ZKPs will even be used for national security purposes. As energy production shifts from centralized power plants to distributed sources like solar panels and wind turbines, verifying the proper execution of software on their controllers becomes vital. In the coming decades, ZKPs will play a crucial role in securing these devices.&lt;&#x2F;p&gt;
&lt;p&gt;Software industry regulations are inevitable, and industries such as online casinos and ad networks using Real-Time Bidding protocols will be legally required to demonstrate that they have not deceived their clients. Laws protecting users from large tech corporations are already in place in Europe, partly due to concerns about data misuse by foreign powers to influence political campaigns.&lt;&#x2F;p&gt;
&lt;p&gt;Requirements for secure storage and processing of encrypted data will become increasingly necessary. Fully Homomorphic Encryption (FHE), a technology akin to ZKPs, will be one of the tools utilized for this purpose. FHE enables computation on encrypted data, ensuring privacy. As FHE becomes more efficient and practical, most databases will integrate some FHE functionality, preventing administrators from accessing user data directly.&lt;&#x2F;p&gt;
&lt;p&gt;Zero-knowledge proofs (ZKPs), which generate evidence for a third party to confirm the accurate execution of a computation, and Fully Homomorphic Encryption (FHE), which enables calculations on encrypted data, will be combined with distributed systems algorithms that are capable of tolerating significant network failures similar to those employed by Bitcoin. Together they will be utilized to comply with regulations while creating trustless applications.&lt;&#x2F;p&gt;
&lt;p&gt;In the past decade, we have successfully launched applications serving dozens of millions of users. Leveraging our expertise, we are now dedicated to providing both technical and financial support to help others create startups focused on developing and implementing these vital technologies. As society grapples with the challenges of our rapidly evolving world these innovations will prove to be indispensable.&lt;&#x2F;p&gt;
&lt;p&gt;Federico Carrone.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>An introduction to Fully Homomorphic Encryption (FHE)</title>
          <pubDate>Fri, 23 Dec 2022 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/fully-homomorphic-encryption/</link>
          <guid>https://blog.lambdaclass.com/posts/fully-homomorphic-encryption/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/fully-homomorphic-encryption/">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;Recently, cloud computing and storage have changed the way businesses and individuals use, store and manage their data. To be secure, data is encrypted using a secure cryptographic scheme, such as AES, where a secret key is needed to decrypt and read the data. Before 2009, if we wanted to perform data analytics on an untrusted server, we needed to provide access to the data in the clear or hand the key encrypting the data to the server. Either option had its risks, as the server could learn valuable or sensitive information, without being able to fully control what it does with it later on. Or, even if the other party were honest, some attacker could breach its security and gain access to our private information in the clear (or the key). Fully homomorphic encryption (FHE) is a powerful cryptographic primitive which allows parties to compute with encrypted data, without the need of decrypting it first. It has applications in finance, health care systems, image and text classification, machine learning, electronic voting, and multiparty computation. An easy example would be wanting to calculate the sum of two numbers, \( a \) and \( b \). Instead of summing them directly, we could encrypt them, \( E(a) \) and \( E(b) \), perform some operation \( E(a)\oplus E(b) \) and get \( E(c)=E(a)\oplus E(b) \), where \( c=a+b \).&lt;&#x2F;p&gt;
&lt;p&gt;More formally, the idea is we have our data as plaintext and we want to compute some function over that plaintext space (for example, we could work with integers, \( \mathbb{Z} \), representing the salaries of individuals and want to compute the average function). To do so, we transform our plaintexts to ciphertexts and perform operations over the ciphertext space, such that the resulting ciphertext is the encryption of the function applied to the plaintexts: \( E(f(x))=\hat{f}(E(x)) \). In a &lt;a href=&quot;&#x2F;arithmetization-schemes-for-zk-snarks&#x2F;&quot;&gt;previous post&lt;&#x2F;a&gt;, we covered that computations could be expressed as arithmetic circuits, where we have two operations: addition and multiplication. If we could get those operations to work on ciphertexts, then, in principle, we could build more complex functions.&lt;&#x2F;p&gt;
&lt;p&gt;A homomorphism is a function between two &lt;a href=&quot;&#x2F;math-survival-kit-for-developers&#x2F;&quot;&gt;algebraic structures&lt;&#x2F;a&gt; of the same kind (such as two groups, rings, fields, or vector spaces, to name a few), which preserves their structure. In particular, we are interested in ring homomorphisms, where we have a set with two operations. Given rings \( (\mathcal{R_1},+,\times) \) and \( (\mathcal{R_2},\oplus,\cdot) \), a function \( f:\mathcal{R_1}\rightarrow \mathcal{R_2} \) is a (ring) homomorphism if, given any \( x,y \) in \( \mathcal{R_1} \),&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * \\( f(x+y)=f(x)\oplus f(y) \\).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * \\( f(x\times y)= f(x)\cdot f(y) \\).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Two common examples of homomorphisms are between integers with ordinary operations \( (\mathbb{Z},+,\times) \) and the integers modulo \(p \) with their operations \( (\mathbb{Z}&#x2F;p\mathbb{Z},+,\times) \). Another example is between polynomials, \( (\mathbb{Z}[X],+,\times) \) and integers \( (\mathbb{Z},+,\times) \) when we use the evaluation of the polynomial at a point as morphism. We can see that it is the same if we first sum or multiply two polynomials and then evaluate them at point \( x_0 \), or we first evaluate the polynomials at \( x_0 \) and then add or multiply the results. Given \( p(x), q(x) \) polynomials and \( \circ \) an operation (addition or multiplication), \( (p\circ q)(x_0)=p(x_0)\circ q(x_0) \).&lt;&#x2F;p&gt;
&lt;p&gt;The first FHE scheme was presented in 2009 by &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;crypto.stanford.edu&#x2F;craig&#x2F;craig-thesis.pdf&quot;&gt;Craig Gentry&lt;&#x2F;a&gt;. To get an idea of how the scheme works, we can imagine the ciphertext to contain an error or noise attached to it. As long as the error is not large, we can decrypt the ciphertext and recover the plaintext. If we add or multiply ciphertexts, the error increases; if it is above a certain threshold, then decryption will not work. The key point introduced in Gentry‚Äôs work is bootstrapping, by which we can take a ciphertext and a public evaluation key and re-encrypt the message, reducing the error. This enables the computation of circuits of higher depth (performing more operations).&lt;&#x2F;p&gt;
&lt;p&gt;Even though Gentry‚Äôs construction proved that FHE is possible, it was extremely slow to be practical, taking as much as half an hour to perform the bootstrapping of 1 bit. Since then, there have been numerous advances and we reached a point where bootstrapping can be done on the scale of microseconds per bit (nearly 10 orders of magnitude). There are 4 generations of FHE as of today. Some constructions are Brakerski&#x2F;Fan-Vercauteren (BFV) and Brakerski-Gentry-Vaikuntanathan (BGV) for integer arithmetic, Cheon-Kim-Kim-Song (CKKS) for real number arithmetic and Ducas-Micciancio (DM) and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2018&#x2F;421.pdf&quot;&gt;Chillotti-Gama-Georgieva-Izabachene&lt;&#x2F;a&gt; (CGGI&#x2F;TFHE) for boolean circuits and arbitrary functions. In this post, we will focus on fully homomorphic encryption over the torus (TFHE).&lt;&#x2F;p&gt;
&lt;p&gt;Currently, schemes can be divided in:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    1. Bootstrapping approach. This has no depth limitations and bootstrapping is done whenever needed to reduce the noise. It works better when the circuit is very deep or its depth is unknown. TFHE is an example of this approach.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    2. Levelled approach. This needs the circuit to be known in advance and works better when the depth of the circuit is small and known in advance. CKKS is an example of this strategy.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The security of many FHE schemes is based on the hardness of the ring learning with errors (RLWE) problem. This is closely related to a famous hard lattice problem, which is thought to be secure against quantum computers. Quantum computers are efficient at breaking homomorphic encryption schemes based on Abelian groups.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;encryption-using-tfhe&quot;&gt;Encryption using TFHE&lt;&#x2F;h2&gt;
&lt;p&gt;TFHE supports various schemes to encrypt different variables or to perform certain operations.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;lwe-scheme&quot;&gt;LWE scheme&lt;&#x2F;h3&gt;
&lt;p&gt;Suppose that we want to encrypt a message \( m \), which can be a bit or a modular integer. To encrypt, we need two numbers, \( p \), and \( q \), a secret key, \( s \), of \( n \) bits (depending on the security level), and an error distribution, from which we will obtain the error, \( e \). To encrypt, we need to sample a random vector \( a \) with \( n \) elements in \( \mathbb{Z}&#x2F;q\mathbb{Z} \). \( q=2^{n_b} \), where \( n_b \) is the number of bits in the ciphertext and \( p=2^{m_b} \), with \( m_b \) the number of bits of the plaintext. Typically, \( q \) is in the order of \( 2^{32} \) to \( 2^{64} \). The error, \( e \) should be less than \( p&#x2F;2q \), otherwise, it could affect the message‚Äôs bits when adding or multiplying.&lt;&#x2F;p&gt;
&lt;p&gt;The ciphertext, \( c \), resulting from the encryption of \( m \) is given by&lt;br &#x2F;&gt;
\[ E(m,s)=c=(a,b) \]&lt;br &#x2F;&gt;
where \( b=\sum_{k=1}^n a_ks_k+e+\Delta m \). Here, \( \Delta \) is the ratio of \( p \) and \( q \), so that the message is encoded in the most significant bits of the ciphertext.&lt;&#x2F;p&gt;
&lt;p&gt;To decrypt, we have to use the key to eliminate \( \sum_{k=1}^n a_ks_k \) and round the result (take the most significant bits),&lt;br &#x2F;&gt;
\[ D(c,s)=\mathrm{round}(b-\sum_{k=1}^n a_ks_k) \]&lt;&#x2F;p&gt;
&lt;p&gt;This scheme supports ciphertext addition and multiplication by a constant factor. The addition, \( \oplus \), of two ciphertexts is&lt;br &#x2F;&gt;
\[ E(m_1,s)\oplus E(m_2,s)=(a_1+a_2,b_1+b_2) \]&lt;br &#x2F;&gt;
The multiplication by a constant factor \( \alpha \) is&lt;br &#x2F;&gt;
\[ \alpha E(m,s)=(\alpha a,\alpha b)\]&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ring-learning-with-errors-rlwe&quot;&gt;Ring Learning with Errors (RLWE)&lt;&#x2F;h3&gt;
&lt;p&gt;In this case, the message is a polynomial \( M \) modulo \( x^N-1 \), which contains \( N \) coefficients. The key \( S(x) \) is a polynomial with coefficients in \( {0,1} \). The encryption function is&lt;br &#x2F;&gt;
\[ E(M(x),S(x))=(A(x),B(x))\]&lt;br &#x2F;&gt;
with \( B(x)=A(x)\cdot S(x)+E(x)+\Delta M(x) \). The error is now a polynomial of degree \( N-1 \), too.&lt;&#x2F;p&gt;
&lt;p&gt;The scheme supports the addition of ciphertexts and multiplication by a constant polynomial.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ring-gsw-rgsw&quot;&gt;Ring GSW (RGSW)&lt;&#x2F;h3&gt;
&lt;p&gt;This scheme supports the addition and multiplication of ciphertexts. The message, key, and error are the same as in RLWE, but the ciphertext is different. We can think of it as a three-dimensional matrix, containing \( \ell \) layers of&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;$A_j(x)$&lt;&#x2F;th&gt;&lt;th&gt;$B_j(x)$&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;$A_j^\star(x)$&lt;&#x2F;td&gt;&lt;td&gt;$B_j^\star(x)$&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;The resulting polynomials are given by the following relations:&lt;br &#x2F;&gt;
\[ B_j(x)=A_j(x)S(x)+E_j(x)-M(x)S(x)\frac{q}{\beta^j} \]&lt;&#x2F;p&gt;
&lt;p&gt;\[ B_j\star(x)=A_j\star(x)S(x)+E_j\star(x)+M(x)S(x)\frac{q}{\betaj} \]&lt;&#x2F;p&gt;
&lt;p&gt;Addition and multiplication by a constant polynomial follow the same rules as the cases before. To multiply two messages, we need to decompose each layer of the first term into \( \ell \) smaller polynomials and perform a multiplication between this decomposition and the corresponding layer of the other ciphertext.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;summary-of-ciphertexts&quot;&gt;Summary of ciphertexts&lt;&#x2F;h3&gt;
&lt;p&gt;The following table summarizes the different types of ciphertexts and the supported operations.&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Case&lt;&#x2F;th&gt;&lt;th&gt;Addition&lt;&#x2F;th&gt;&lt;th&gt;Constant Mult&lt;&#x2F;th&gt;&lt;th&gt;Multiplication&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;LWE&lt;&#x2F;td&gt;&lt;td&gt;Yes&lt;&#x2F;td&gt;&lt;td&gt;Yes&lt;&#x2F;td&gt;&lt;td&gt;No&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;RLWE&lt;&#x2F;td&gt;&lt;td&gt;Yes&lt;&#x2F;td&gt;&lt;td&gt;Yes&lt;&#x2F;td&gt;&lt;td&gt;No&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;RGSW&lt;&#x2F;td&gt;&lt;td&gt;Yes&lt;&#x2F;td&gt;&lt;td&gt;Yes&lt;&#x2F;td&gt;&lt;td&gt;Yes&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h2 id=&quot;turning-private-key-into-public-key-schemes&quot;&gt;Turning private key into public key schemes&lt;&#x2F;h2&gt;
&lt;p&gt;Rothblum‚Äôs theorem states that a semantically secure private key homomorphic encryption scheme, which can perform addition modulo 2, can be turned into a public key semantically secure homomorphic scheme.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;external-product-and-controlled-multiplexer-cmux-gates&quot;&gt;External product and controlled multiplexer (CMux) gates&lt;&#x2F;h2&gt;
&lt;p&gt;The external product, \( \times \), is an operation involving an RLWE ciphertext and an RGSW ciphertext, outputting, and RLWE ciphertext. To perform the outer product, we have to decompose the \( A(x) \) and \( B(x) \) polynomials in the RLWE ciphertext and perform a matrix-vector product between the decomposition and the layers of the RSGW ciphertext.&lt;&#x2F;p&gt;
&lt;p&gt;One interesting application of the external product is related to the controlled mux gate, where we assign values according to an if condition. Given two values, \( y_1, y_2 \) and a boolean variable \( b \), we can construct the following operation&lt;br &#x2F;&gt;
\[ (y_2-y_1)b+y_1=y \]&lt;&#x2F;p&gt;
&lt;p&gt;If \( b \) is \( 0 \), we get \( y_1 \) and if \( b=1 \) we get \( y_2 \).&lt;&#x2F;p&gt;
&lt;p&gt;This is an important building block for the bootstrapping operation.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;key-switching&quot;&gt;Key switching&lt;&#x2F;h2&gt;
&lt;p&gt;The key-switching operation can be used to change encryption keys in different parameter sets. To implement it, we need key switching keys. The procedure has some parallelism with bootstrapping, with the subtle difference that it increases the noise in the ciphertext. The key switching can be applied to change the keys in LWE and RLWE ciphertexts, but it can also be used to transform LWE ciphertexts (one or many) into one RLWE.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;FHE is an important cryptographic primitive which allows us to compute with encrypted data, without the need of decrypting it first, opening the doors for many interesting and new applications. Since 2009, four generations of FHE schemes have been proposed, adding new functionalities and improving performance by several orders of magnitude. There are two types of approaches: bootstrapped and leveled. The first one works for circuits that are deep or their depth is unknown, while the second works for circuits of small depth. The security of many FHE schemes relies on post-quantum hard problems, such as ring learning with errors (RLWE). One powerful scheme is TFHE, a bootstrapped construction that operates on different types of ciphertext to attain rich functionality. In upcoming posts, we will be covering other schemes and we will go deeper into the fundamentals of FHE.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Fully-homomorphic encryption, zero-knowledge proofs, and multiparty computation</title>
          <pubDate>Fri, 16 Dec 2022 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/fully-homomorphic-encryption-zero-knowledge-proofs-and-multiparty-computation/</link>
          <guid>https://blog.lambdaclass.com/posts/fully-homomorphic-encryption-zero-knowledge-proofs-and-multiparty-computation/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/fully-homomorphic-encryption-zero-knowledge-proofs-and-multiparty-computation/">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;Cloud computing and storage have changed the way businesses and people use, store and manage their data. Data is securely stored in an encrypted form, typically using a &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.entropy1729.com&#x2F;symmetric-encryption&#x2F;&quot;&gt;symmetric key encryption scheme&lt;&#x2F;a&gt;, such as AES or ChaCha20. However, to perform data analytics, we have to either give the key to the server so that it can decrypt it or we have to download it, decrypt it, and run the calculations on our own, which can be costly, requiring lots of time or memory. Fully homomorphic encryption (FHE) allows us to delegate computations involving encrypted data to untrusted third parties, without any need to decrypt them first.&lt;&#x2F;p&gt;
&lt;p&gt;Even if this is a very powerful cryptographic primitive, we still face a big challenge: how do we know that the third party performed the calculation it was supposed to do? This is where zero-knowledge proofs (ZKP) come into play. ZKP allow us to prove the integrity of a given computation, without the need to re-execute it. &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.entropy1729.com&#x2F;the-hunting-of-the-zk-snark&#x2F;&quot;&gt;zk-SNARKs&lt;&#x2F;a&gt; (succinct non-interactive arguments of knowledge) yield short proofs which can be verified very fast and have applications in decentralized ledgers (solving both privacy and scalability issues) and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.entropy1729.com&#x2F;decentralized-private-computation-zexe-and-veri-zexe&#x2F;&quot;&gt;decentralized private computations&lt;&#x2F;a&gt;. They also face some challenges: generating proofs for arbitrary computations can be expensive and users with less powerful devices may not be able to generate them. Many zk-SNARKs require trusted setups, which should be generated by an honest party to ensure that nobody can cheat and generate fake proofs.&lt;&#x2F;p&gt;
&lt;p&gt;Both of them can be solved by multiparty computation (MPC). In this scheme, the generation of the proof or the establishment of the trusted setup is entrusted to various parties, which could have partial access to the data. In the case of setup ceremonies, as long as one of the parties involved is honest, the setup is secure. MPC can also be used, with decentralized ledgers, to ensure that anyone can participate in setup ceremonies and prevent malicious parties from blocking honest participants, using proofs with transparent setups (such as STARKs - scalable, transparent argument of knowledge).&lt;&#x2F;p&gt;
&lt;p&gt;Proof generation can be carried out by multiple servers, each of them having partial information on the secret inputs. Each party can submit proof attesting to the correctness of the proof generation protocol. Multiparty computation can also be used to perform calculations among different parties, each of them having different pieces of information relevant to the problem, such as financial information between banks or health-related information for health service providers. FHE helps parties share information and make calculations without revealing it or train machine learning models without compromising sensitive data.&lt;&#x2F;p&gt;
&lt;p&gt;It is clear from all the above that FHE, ZKP, and MPC have many points in common and each has something to offer to the other. ZKP can provide integrity of computations, FHE allows data sharing and calculation without compromising it and MPC gives us the power to delegate expensive computations to other parties. These open the doors for many new and exciting applications in finance, health, and medical sectors, with an emphasis on data privacy and decentralization.&lt;&#x2F;p&gt;
&lt;p&gt;We will now explain the basic idea behind each of these primitives.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fully-homomorphic-encryption&quot;&gt;Fully Homomorphic encryption&lt;&#x2F;h2&gt;
&lt;p&gt;Fully homomorphic encryption is a form of encryption where we can perform operations with encrypted data and the result of those operations is the encrypted form of an operation involving the ciphertext. For example, in the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.entropy1729.com&#x2F;how-to-create-your-own-crappy-rsa-as-a-software-developer&#x2F;&quot;&gt;RSA cryptosystem&lt;&#x2F;a&gt;, we encrypt a message &lt;em&gt;m&lt;&#x2F;em&gt; using the public key by taking&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;E(m)=m e(&lt;&#x2F;em&gt; mod _ &lt;em&gt;n&lt;&#x2F;em&gt;)_&lt;&#x2F;p&gt;
&lt;p&gt;Now suppose that we have &lt;em&gt;m 1&lt;&#x2F;em&gt;,&lt;em&gt;m 2&lt;&#x2F;em&gt; numbers and we want to compute their product &lt;em&gt;m 1&lt;&#x2F;em&gt;√ó &lt;em&gt;m 2&lt;&#x2F;em&gt;. We can see that if we perform the product and then encrypt it, we get&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;E(m 1&lt;&#x2F;em&gt;√ó &lt;em&gt;m 2&lt;&#x2F;em&gt;)=(&lt;em&gt;m 1&lt;&#x2F;em&gt;√ó &lt;em&gt;m 2&lt;&#x2F;em&gt;)e  (mod   &lt;em&gt;n&lt;&#x2F;em&gt;)&lt;&#x2F;p&gt;
&lt;p&gt;If we take the product of the encrypted forms of m1,m2, then&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;E(m 1)&lt;&#x2F;em&gt;√ó &lt;em&gt;E(m 2&lt;&#x2F;em&gt;)=&lt;em&gt;m e1&lt;&#x2F;em&gt;√ó &lt;em&gt;m e2&lt;&#x2F;em&gt;=(&lt;em&gt;m 1&lt;&#x2F;em&gt;√ó &lt;em&gt;m 2&lt;&#x2F;em&gt;)e   (mod &lt;em&gt;n&lt;&#x2F;em&gt;)&lt;&#x2F;p&gt;
&lt;p&gt;which is the same as calculating first the product and then encrypting. The operation in the encrypted space need not be the same as the one in the original. Given this property of the RSA cryptosystem, many researchers started wondering whether it could be possible to build a fully homomorphic encryption scheme. The first FHE scheme was presented in 2009 by &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;crypto.stanford.edu&#x2F;craig&#x2F;craig-thesis.pdf&quot;&gt;Craig Gentry&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;math-interlude-homomorphisms&quot;&gt;Math interlude: Homomorphisms&lt;&#x2F;h3&gt;
&lt;p&gt;To be more precise, a homomorphism is a function between two &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.entropy1729.com&#x2F;math-survival-kit-for-developers&#x2F;&quot;&gt; algebraic structures&lt;&#x2F;a&gt; (such as two groups, two rings, two vector spaces) and preserves their structure. If you had a course on linear algebra, linear transformations are examples of homomorphisms. In the context of groups, suppose we have two groups (ùîæ1,‚ãÖ) and (ùîæ2,‚äï), each with their binary operation (it could be multiplication, addition, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.entropy1729.com&#x2F;what-every-dev-needs-to-know-about-elliptic-curves&#x2F;&quot;&gt; elliptic curve addition&lt;&#x2F;a&gt;, function composition, etc). A function &lt;em&gt;f&lt;&#x2F;em&gt; :ùîæ1‚Üíùîæ2 is an homomorphism if, given &lt;em&gt;x&lt;&#x2F;em&gt; ,&lt;em&gt;y&lt;&#x2F;em&gt; in ùîæ1 we have&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;f(x‚ãÖy)  = f(x)&lt;&#x2F;em&gt; ‚äï &lt;em&gt;f(y)&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Note that the operation between the images &lt;em&gt;f(x),f(y)&lt;&#x2F;em&gt; is the operation over ùîæ2. We also saw examples of homomorphisms between rings, when we defined modular arithmetic: we have a function preserving addition and multiplication from the set of integers with the usual operations, (‚Ñ§,+,√ó) and the ring of integers modulo &lt;em&gt;p&lt;&#x2F;em&gt; , (‚Ñ§&#x2F;&lt;em&gt;p&lt;&#x2F;em&gt; ‚Ñ§,‚äï,‚ãÖ) (we use different symbols for addition and multiplication to remember that these are modulo &lt;em&gt;p&lt;&#x2F;em&gt;). For example, if we take &lt;em&gt;p&lt;&#x2F;em&gt;  = 7, we have ‚Ñ§&#x2F;&lt;em&gt;p&lt;&#x2F;em&gt; ‚Ñ§={0,1,2,3,4,5,6}. We can see that: ‚àí5+3=‚àí2. This is related to 2 ‚äï 3 ‚â° 5 (mod7), where 2 is the element corresponding to ‚àí5 in ‚Ñ§&#x2F;&lt;em&gt;p&lt;&#x2F;em&gt; ‚Ñ§, 3 corresponds to itself and 5 is congruent to ‚àí2.‚àí3√ó4=‚àí12 which relates to 4‚ãÖ4‚â°2(mod7) in the same way as before.&lt;&#x2F;p&gt;
&lt;p&gt;It is important to see that homomorphisms are not necessarily one-to-one functions (the last ring homomorphism shows a clear example). If the homomorphism is a bijective function, it is called an isomorphism. The following is an example of an isomorphism from the real numbers ‚Ñù with addition to the positive real numbers equipped with multiplication, ‚Ñù +,  &lt;em&gt;f&lt;&#x2F;em&gt;  : ‚Ñù‚Üí‚Ñù+ , &lt;em&gt;f  (x)&lt;&#x2F;em&gt; = exp &lt;em&gt;(x)&lt;&#x2F;em&gt;  , with its inverse, &lt;em&gt;f ‚àí1&lt;&#x2F;em&gt; : ‚Ñù+‚Üí  ‚Ñù,  &lt;em&gt;f&lt;&#x2F;em&gt; ‚àí1 (&lt;em&gt;z&lt;&#x2F;em&gt;) = ln(&lt;em&gt;z&lt;&#x2F;em&gt;). You can easily check that &lt;em&gt;f   (x + y )=f (x) ‚ãÖ f (y)&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In the context of cryptography, we would like to have encryption or commitment schemes preserving some operations. For example, the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.entropy1729.com&#x2F;the-hunting-of-the-zk-snark&#x2F;&quot;&gt; Kate-Zaverucha-Goldberg &lt;&#x2F;a&gt; (KZG) commitment scheme is additively homomorphic. The commitment takes polynomials (which we can think of as a group with ordinary polynomial addition, (‚Ñô,+)) and maps them into elliptic curve points (which also have a group structure, with elliptic curve addition, (ùîæ,‚äï)). We can verify that&lt;&#x2F;p&gt;
&lt;p&gt;cm(&lt;em&gt;p&lt;&#x2F;em&gt; 1 (&lt;em&gt;x&lt;&#x2F;em&gt;)  +  &lt;em&gt;p 2&lt;&#x2F;em&gt;(x))  =  cm(&lt;em&gt;p &lt;em&gt;1   (&lt;em&gt;x&lt;&#x2F;em&gt;))  ‚äï  cm(&lt;em&gt;p 2&lt;&#x2F;em&gt;(x))&lt;&#x2F;em&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;This property is useful for &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.entropy1729.com&#x2F;proof-aggregation-schemes-snarkpack-and-aplonk&#x2F;&quot;&gt;proof aggregation&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.entropy1729.com&#x2F;incrementally-verifiable-computation-nova&#x2F;&quot;&gt;folding schemes&lt;&#x2F;a&gt;. Elliptic curve pairings also provide some way to compute multiplications between polynomials in committed form (using KZG).&lt;&#x2F;p&gt;
&lt;p&gt;To be able to construct an FHE scheme we need not only preserve operations but also have a way to decipher the result.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fhe-fundamentals&quot;&gt;FHE fundamentals&lt;&#x2F;h2&gt;
&lt;p&gt;There are many libraries for FHE nowadays, such as &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.openfhe.org&#x2F;&quot;&gt;OpenFHE&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;project&#x2F;microsoft-seal&#x2F;&quot;&gt;Microsoft SEAL&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;cpeikert&#x2F;Lol&quot;&gt;Œõ‚àòŒª&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;homomorphicencryption.org&#x2F;introduction&#x2F;&quot;&gt;many more&lt;&#x2F;a&gt;. With FHE you can make private queries to search engines or pages, such as Wikipedia; see &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;spiralwiki.com&#x2F;&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;FHE schemes are based on lattice cryptography. A lattice is given by linear combinations with integer coefficients of some base vectors. To fix ideas, imagine we have two vectors &lt;em&gt;e x&lt;&#x2F;em&gt; = (1,0) and &lt;em&gt;e y&lt;&#x2F;em&gt; = (0,1) and we consider all possible combinations &lt;em&gt;p  = xex + yey&lt;&#x2F;em&gt; with &lt;em&gt;x&lt;&#x2F;em&gt; ,&lt;em&gt;y&lt;&#x2F;em&gt; in ‚Ñ§, yielding points in space (0,0),(1,0),(1,1),(‚àí1,‚àí2),‚Ä¶. A lattice looks like &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lattice_problem#&#x2F;media&#x2F;File:SVP.svg&quot;&gt; this&lt;&#x2F;a&gt;. Ideal lattices correspond to &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ideal_(ring_theory)&quot;&gt;ideals in polynomial rings&lt;&#x2F;a&gt;, inheriting the natural addition and multiplication operations of the ring (Ideals generalize the idea behind certain subsets of the integers, such as even numbers. The addition of any two even numbers is always even and, whenever we multiply any integer by an even, the result is also even -an absorption property-).&lt;&#x2F;p&gt;
&lt;p&gt;To build an FHE scheme we could picture having a ciphertext with some small attached to it, such that the decryption works as long as the noise is below a certain threshold. If we have ways to homomorphically multiply and add ciphertexts, but at the expense of increasing the noise parameters accordingly, that is, _E(a  + b) =E (a) &lt;em&gt;‚äï _  E (b)&lt;&#x2F;em&gt; and &lt;em&gt;E(a√ób)=E(a)‚ãÖE(b)&lt;&#x2F;em&gt;. We call this a somewhat homomorphic encryption scheme (SHE). If we could add a ‚Äúrecrypt‚Äù algorithm, which can take a given ciphertext &lt;em&gt;E(m)&lt;&#x2F;em&gt; and reduce its noise, obtaining a new ciphertext &lt;em&gt;E‚Ä≤(m)&lt;&#x2F;em&gt; that also encrypts &lt;em&gt;m&lt;&#x2F;em&gt; , then we can obtain an FHE scheme.&lt;&#x2F;p&gt;
&lt;p&gt;The SHE scheme can handle circuits of a certain depth (imagine this as the number of times you can multiply or add before the noise becomes too large). The SHE can be modified to have its decryption circuit have a lower multiplicative depth, making it ‚Äúbootstrappable‚Äù and thus transforming it into an FHE scheme.&lt;&#x2F;p&gt;
&lt;p&gt;Some common schemes for FHE are:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Brakerski-Fan-Vercauteren (BFV) and Brakerski-Gentry-Vaikuntanathan (BGV) for integer arithmetic.&lt;&#x2F;li&gt;
&lt;li&gt;Cheon-Kim-Kim-Song (CKKS) for real number arithmetic.&lt;&#x2F;li&gt;
&lt;li&gt;Ducas-Micciancio (DM) and Chillotti-Gama-Georgieva-Izabachene (CGGI) for boolean circuits and arbitrary functions using lookup tables.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Many cryptographic primitives, such as public key cryptography, are based on the hardness or intractability of mathematical problems, such as &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Integer_factorization&quot;&gt;integer factorization&lt;&#x2F;a&gt; (RSA) or the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Discrete_logarithm&quot;&gt;discrete logarithm problem&lt;&#x2F;a&gt; (elliptic curve cryptography). These problems cannot be solved efficiently with current computers (at least, provided that the integers involved are big enough or the groups have a large number of elements). However, quantum computers could easily handle these problems if certain conditions are met, via &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Shor%27s_algorithm&quot;&gt;Shor‚Äôs algorithm&lt;&#x2F;a&gt;. FHE is based on the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lattice_problem&quot;&gt;shortest vector problem&lt;&#x2F;a&gt; or &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;homomorphicencryption.org&#x2F;wp-content&#x2F;uploads&#x2F;2018&#x2F;11&#x2F;HomomorphicEncryptionStandardv1.1.pdf&quot;&gt;ring learning-with-error&lt;&#x2F;a&gt; (RLWE) problem, which is an NP-hard problem that cannot be tackled with Shor‚Äôs algorithm (FHE is considered to be quantum resistant).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zero-knowledge-proofs&quot;&gt;Zero-knowledge proofs&lt;&#x2F;h2&gt;
&lt;p&gt;Zero-knowledge proofs (ZKP) have been gaining a lot of attention during the last decade, especially after the first efficient SNARK constructions. ZKP play an important role in the solution of two of the main challenges in decentralized ledgers: scalability and privacy. To validate transactions, nodes have to re-execute them, leading to bottlenecks. Besides, all the information in the ledger is public, which can leak sensitive information about individuals and organizations.&lt;&#x2F;p&gt;
&lt;p&gt;zk-SNARKs allow one party to prove a statement, without revealing anything other than the validity of the statement. For example, we can prove that we have a given secret key, without revealing it. We can also prove that we have executed some transaction or computation, without exposing secret or sensitive information. An important property of SNARKs is their succinctness, which means that proofs:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Are short (occupy little memory, about 1 kB for some SNARKs).&lt;&#x2F;li&gt;
&lt;li&gt;Are fast to verify (typically, in the order of milliseconds).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Ethereum has been adding zero-knowledge proof technologies recently to solve scalability issues. Zcash implemented ZKP to provide private transactions, while Aleo uses them to enable running private computations in a decentralized way.&lt;&#x2F;p&gt;
&lt;p&gt;How do SNARKs work under the hood? Even if there are many different constructions (such as Marlin, Plonk, Halo, and STARKs), they have a common recipe. The building blocks of SNARKs are polynomial interactive oracle proofs (PIOP) and polynomial commitment schemes (PCS). Depending on the choices made, the resulting SNARK has different properties and requirements. For example, it may be transparent (does not need a trusted setup), post-quantum secure, need special (pairing-friendly) elliptic curves, take longer times to generate proofs, have shorter proofs (less than 1 kB), allow for easy recursion, etc. A comparison between different polynomial commitment schemes is shown &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;hackernoon.com&#x2F;kzg10-ipa-fri-and-darks-analysis-of-polynomial-commitment-schemes&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;To be able to construct the proof, we first need to transform our computation into some SNARK-friendly format. We can prove the correctness of our execution by reducing it to some kind of NP-complete problem, such as graph coloring or circuit satisfiability. We will work with arithmetic circuits and the transformation of a program into a circuit is known as arithmetization. There are different forms or strategies for doing this transformation; an overview of the most commonly used is &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.entropy1729.com&#x2F;arithmetization-schemes-for-zk-snarks&#x2F;&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;multiparty-computation&quot;&gt;Multiparty computation&lt;&#x2F;h2&gt;
&lt;p&gt;In a secure multiparty computation, a group of participants, &lt;em&gt;p 1,p2,‚Ä¶,pm&lt;&#x2F;em&gt;, each having some secret information &lt;em&gt;s 1,s2,‚Ä¶sm&lt;&#x2F;em&gt;, want to compute a certain function that requires the knowledge of that secret information. For example, we could have m employees wanting to know their average salary without revealing their income. One easy way to do so would be that all of them trust another party and each sends their secret information and the ‚Äútrusted‚Äù party computes the average. The drawback: the ‚Äútrusted‚Äù party learns all the information and could leverage it. Or perhaps he is honest, but he gets hacked and an attacker obtains everything.&lt;&#x2F;p&gt;
&lt;p&gt;Luckily, there is a useful cryptographic primitive to deal with cases like these: &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.geeksforgeeks.org&#x2F;additive-secret-sharing-and-share-proactivization-using-python&#x2F;&quot;&gt; additive secret sharing&lt;&#x2F;a&gt;. Each of the participants can break their secret &lt;em&gt;s k&lt;&#x2F;em&gt; into &lt;em&gt;m&lt;&#x2F;em&gt; shares in such a way that no shareholder can, on his own, learn the secret. To be able to reconstruct the secret, all of the other parties have to collude and share their part. In the example above, each employee can break his salary, &lt;em&gt;s k&lt;&#x2F;em&gt; into &lt;em&gt;m&lt;&#x2F;em&gt; different, random shares. For example, if we have 4 employees and employee A earns 4500, he can have 4 shares, &lt;em&gt;s Ai&lt;&#x2F;em&gt;: -1200, 1500, 3600, 600, such that ‚àëi sAi_ = 4500. He keeps one share and distributes the rest to B, C, and D. In turn, the rest break their secret and divide it. Afterward, each participant sums all the shares he has, obtaining a partial sum, &lt;em&gt;s p,A&lt;&#x2F;em&gt; = ‚àëk sk,A, and then shares these partial sums to compute the final average.&lt;&#x2F;p&gt;
&lt;p&gt;Secret sharing is secure whenever parties knowing at most &lt;em&gt;m&lt;&#x2F;em&gt;  ‚àí 1 have no more information than anyone with no shares at all.&lt;&#x2F;p&gt;
&lt;p&gt;Now, how can we ensure that each party does what it is supposed to do? ZKP give us a way to guarantee that each participant does the computation as expected, by submitting proof that attests to the correct execution. If he cheats, the proof should fail and he could be penalized. Early MPC protocols had significant overhead; the last decade has seen many advances, making it efficient and leading to many applications.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;Fully homomorphic encryption, zero-knowledge proofs, and multiparty computations are important cryptographic primitives that have been gaining more and more attention in recent years, with the introduction of decentralized ledgers and increasing concern over data privacy. Each has its unique features and applications and has something to offer to the other primitives. FHE allows us to make cloud computations on encrypted data without needing to hand our key to the server, which prevents third parties from gaining access to the specific contents of the data. ZKP allow us to prove the correctness of a given computation by submitting a short proof, which can be quickly verified. This is seen as one of the greatest tools to solve the privacy and scalability issues of decentralized ledgers. Multiparty computation helps us distribute a complex computation or calculate something when all the inputs are distributed among several parties in a secure way; it has applications for voting, private auctions, bidding, etc. FHE can help us improve existing ZKP, which in turn can make multiparty computation much simpler and more secure. In turn, MPC is needed for the setup ceremonies of zk-SNARKs and can also help provers reduce their proof generation time by delegating them to untrusted powerful servers. ZKP can also help us ensure that the computations involving encrypted data are carried out correctly. All these fields have seen great advances over the last decade and each will help the others advance, leading to new interesting applications, with a greater focus on decentralization and privacy. In upcoming posts, we will cover in more depth the mathematical foundations of FHE and further applications of MPC and ZKP.&lt;&#x2F;p&gt;
</description>
      </item>
    </channel>
</rss>
