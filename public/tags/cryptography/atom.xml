<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>LambdaClass Blog - cryptography</title>
    <subtitle>Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.</subtitle>
    <link rel="self" type="application/atom+xml" href="https://blog.lambdaclass.com/tags/cryptography/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2023-11-02T00:00:00+00:00</updated>
    <id>https://blog.lambdaclass.com/tags/cryptography/atom.xml</id>
    <entry xml:lang="en">
        <title>If you don&#x27;t know, look it up or how to create lookup tables for zero knowledge proofs</title>
        <published>2023-11-02T00:00:00+00:00</published>
        <updated>2023-11-02T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com/posts/lookups/"/>
        <id>https://blog.lambdaclass.com/posts/lookups/</id>
        
        <content type="html" xml:base="https://blog.lambdaclass.com/posts/lookups/">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;ZK-SNARKs (zero-knowledge succinct, non-interactive arguments of knowledge) and STARKs (scalable transparent arguments of knowledge) are powerful cryptographic constructions with applications in decentralized private computing and blockchain scaling. They allow one party, the prover, to show that he carried a computation correctly to a second party, the verifier, in a way that is both memory and time-efficient. In other words, the prover can submit a short proof (more concise than sending all the values involved in the calculation), which can be verified in less time than we would need for the independent re-execution of the computation. These constructions rely on encoding the information as polynomials, committing to them (via a polynomial commitment scheme, such as FRI or KZG), and showing that certain relationships hold between polynomials. For an introduction to these concepts, see our previous posts on &lt;a href=&quot;&#x2F;diving-deep-fri&#x2F;&quot;&gt;STARKs&lt;&#x2F;a&gt;, &lt;a href=&quot;&#x2F;all-you-wanted-to-know-about-plonk&#x2F;&quot;&gt;Plonk&lt;&#x2F;a&gt;, &lt;a href=&quot;&#x2F;groth16&#x2F;&quot;&gt;Groth 16&lt;&#x2F;a&gt; or the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;zkhack.dev&#x2F;whiteboard&#x2F;&quot;&gt;introductory videos by Dan Boneh&lt;&#x2F;a&gt; at zkhack.&lt;&#x2F;p&gt;
&lt;p&gt;The first step is transforming code into a system of polynomial equations over a finite field. This is known as arithmetization, and typical arithmetization schemes are R1CS (rank one constraint system), Plonkish, and AIR (algebraic intermediate representation). Some operations are expensive to arithmetize, which can lead to signficant costs for the prover. Lookup arguments are a powerful technique that helps us solve this problem by having a precomputed table of values (it can also be dynamic). In this blog post, we will cover the basics of lookup arguments and describe the PlookUp scheme. The topic has been discussed in the ongoing &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;sparkling_water_bootcamp&#x2F;blob&#x2F;main&#x2F;README.md&quot;&gt;Sparkling Water Bootcamp&lt;&#x2F;a&gt;, where we will provide an implementation of the different lookups in our library, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;lambdaworks&quot;&gt;Lambdaworks&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;examples-and-working-principle&quot;&gt;Examples and working principle&lt;&#x2F;h2&gt;
&lt;p&gt;Suppose we want to check that a variable $a$ has to be in a prescribed range, such as a &lt;code&gt;u8&lt;&#x2F;code&gt;. One simple yet ineffective way to do so is to express $a$ in its binary form $a_0 a_1 a_2 a_3 a_4 a_5 a_6 a_7$ and check that:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    1. Every variable is boolean $a_i (1 - a_i ) = 0$&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    2. $a = \sum a_k 2^k$&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This approach makes us add several additional constraints, which scale proportionally with the number of bits. Another approach could be showing that the number is contained in the list of all valid values for the variable. This is an example of a lookup operation. The first lookup arguments depended on the table size (we paid the price both for the lookup operations we did and for the whole table). At the same time, newer constructions make us pay the price only for the number of lookup operations (plus some preprocessing). If we have to do just a few lookup operations, then using these arguments does not pay off (we could accept having more constraints). Still, as the number or complexity of the operations increases, it makes sense to support lookups.&lt;&#x2F;p&gt;
&lt;p&gt;We can prove bitwise operations using lookup tables. For example, for the exclusive or between two bytes $a$ and $b$, $c = a \oplus b$, we can use the arithmetic constraints to represent the operations,&lt;br &#x2F;&gt;
$a_i (1 - a_i ) = 0$&lt;br &#x2F;&gt;
$b_i (1 - b_i ) = 0$&lt;br &#x2F;&gt;
$a_i + b_i - 2a_i b_i - c_i = 0$&lt;br &#x2F;&gt;
We could also have a list with all possible combinations, $a$, $b$, and $c$. Given that each byte takes 256 different values ($2^8$), we could have a table listing all valid input&#x2F;output trios ($2^{ 16 } = 65536$) and check that our $(a , b, c)$ are in that list.&lt;&#x2F;p&gt;
&lt;p&gt;To prove inclusion, we will use tricks similar to those we applied for the &lt;a href=&quot;&#x2F;all-you-wanted-to-know-about-plonk&#x2F;&quot;&gt;permutation arguments&lt;&#x2F;a&gt;. We will first reduce the claim of our tuple $(a , b , c)$ being in table $\mathcal{T}$ to a relationship between two vectors. We will show that, for every component in the vector $f$, there exists some component in the vector $t$ such that $f_i = t_k$. We can zip the table into a single vector by performing a random folding of the columns,&lt;br &#x2F;&gt;
$t = col_0 (\mathcal{T}) + \zeta col_1 (\mathcal{T}) + \zeta^2 col_2 (\mathcal{T})$&lt;br &#x2F;&gt;
We can reduce our tuple $(a, b , c)$ to the vector $f$ by doing the same operation,&lt;br &#x2F;&gt;
$f = a +\zeta b + \zeta^2 c$&lt;&#x2F;p&gt;
&lt;p&gt;To be able to apply a kind of permutation argument, we should know the number of times every element in $f$ appears in $t$, which can be something problematic. Instead, we can work with randomized differences over sorted vectors. This method was introduced in the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2020&#x2F;315.pdf&quot;&gt;PlookUp paper&lt;&#x2F;a&gt;. We build a vector $s$, which results from concatenating the vectors $f$ and $t$ and sorting them by the order they appear in $t$. If the set of non-zero consecutive differences in $s$ is the same as $t$, then this proves that $f$ has all its values in the set given by $t$. If the values of $t$ appear more than once in $f$, the consecutive differences will yield $0$ for equal elements, thus eliminating them from the checks. The randomized differences avoid having to check the initial values,&lt;br &#x2F;&gt;
$\Delta s_i = s_i + \beta’ s_{i + 1}$&lt;br &#x2F;&gt;
$\Delta t_i = t_i + \beta’ t_{i + 1}$&lt;br &#x2F;&gt;
In the case of randomized differences, even if the consecutive elements are the same, the difference will be non-zero. However, we know that the differences will be multiples of $1 + \beta’$, which allows us to identify them. The check involves two bivariate polynomials, $F$ and $G$,&lt;br &#x2F;&gt;
$F = (1 + \beta’)^n \prod (\gamma’ + f_j) \prod (\gamma’ (1 + \beta’ ) + \Delta t_i )$&lt;br &#x2F;&gt;
$G = \prod (\gamma’ (1 + \beta’ ) + \Delta s_i )$&lt;br &#x2F;&gt;
If these two polynomials are the same, we have proven that all the values of $f$ are contained in the set given by $t$.&lt;br &#x2F;&gt;
As in the permutation check, it is useful to define the vector $z$, defined by:&lt;br &#x2F;&gt;
$$z_0 = 1$$&lt;br &#x2F;&gt;
$$z_i = \prod \frac{(1 + \beta’)(\gamma’ + f_i )(\gamma’(1 + \beta’) + \Delta t_i )}{(\gamma’ (1 + \beta’ ) + s_{2i - 1} + \beta’ s_{2i } )(\gamma’ (1 + \beta’ ) + s_{2i} + \beta’ s_{2i + 1} )}$$&lt;br &#x2F;&gt;
We can then interpolate the values of $z$ to obtain the polynomial $z (x)$ which must satisfy the conditions:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    1. $z (x = 1) = 1$&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    2. $z (x = g^N ) = 1$&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    3. $z(x) U(x) - z(gx) V(x) = 0$&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;where the polynomials $U(x)$ and $V(x)$ result from the interpolation of the polynomials $F$ and $G$, respectively. These constraints must be added to the constraints of the proof system we are using.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;plonk-and-lookup-tables&quot;&gt;Plonk and Lookup tables&lt;&#x2F;h2&gt;
&lt;p&gt;For a recap of the Plonk protocol, we recommend reading our &lt;a href=&quot;&#x2F;all-you-wanted-to-know-about-plonk&#x2F;&quot;&gt;previous post&lt;&#x2F;a&gt; or the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;lambdaworks&#x2F;tree&#x2F;main&#x2F;docs&#x2F;src&#x2F;plonk&quot;&gt;Lambdaworks docs&lt;&#x2F;a&gt;. Plonk’s arithmetization used selector variables $q_l , q_r , q_m , q_o , q_c$ to describe the different types of gates, which for a valid execution $(a , b , c)$ should satisfy the following equations:&lt;br &#x2F;&gt;
$q_l (x) a(x) + q_r (x) b(x) + q_m a(x) b(x) + q_o (x) c(x) + q_c (x) + pi(x) = 0$&lt;br &#x2F;&gt;
When introducing lookups into Plonk, we add a new selector variable, $q_{lu}$. This variable will equal $1$ when the values of $(a, b, c)$ must be checked to belong to a given table. The other selectors will be zero in that case, which will trivially satisfy the equations for the other types of gates. We recommend following the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2022&#x2F;086.pdf&quot;&gt;PlonkUp paper&lt;&#x2F;a&gt; for further details.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;setup-and-preprocessed-input&quot;&gt;Setup and preprocessed input&lt;&#x2F;h3&gt;
&lt;p&gt;In Plonk we start with the common preprocessed input, which consists of the selector polynomials, $q_l(x) , q_r (x), q_m (x), q_o (x) , q_C (x)$, plus the copy constraint polynomials $S_{\sigma 1} (x) , S_{\sigma 2} (x) , S_{\sigma 3} (x)$. In the case of lookups, we have more preprocessed information, such as $q_{lu} (x)$, $col_0 (\mathcal{T}) (x) , col_1 (\mathcal{T}) (x) , col_2 (\mathcal{T}) (x)$.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;round-1-committing-to-an-execution-of-the-circuit&quot;&gt;Round 1 - Committing to an execution of the circuit&lt;&#x2F;h3&gt;
&lt;p&gt;Round 1 in the Plonk protocol consists of interpolating the column polynomials $a(x)$, $b(x)$, and $c(x)$ and committing to them. This way, the prover commits to a given execution of the circuit, and he won’t be able to change the values of the execution trace.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;round-2-enter-lookups&quot;&gt;Round 2 - Enter Lookups&lt;&#x2F;h3&gt;
&lt;p&gt;When we have lookups, we add a new round. We will call it Round 2. Here, the prover will zip the table into a vector and start all the work to prove the lookup arguments. The prover samples the folding coefficient $\zeta$ for the table and wirings and obtains the compressed table and queries,&lt;br &#x2F;&gt;
$t = col_0 (\mathcal{T}) + \zeta col_1 (\mathcal{T}) + \zeta^2 col_2 (\mathcal{T})$&lt;br &#x2F;&gt;
$f^\prime = a +\zeta b + \zeta^2 c$&lt;br &#x2F;&gt;
This last polynomial needs blindings to make them zero-knowledge, following the same recipe from Round 1:&lt;br &#x2F;&gt;
$f(x) = f^\prime (x) + Z_H (x) (b_7 + b_8x)$&lt;br &#x2F;&gt;
After that, the prover builds the vector $s$, sorted by $t$. Since this vector’s length is greater than the size of the domain $H$ over which we interpolated $t$ and $f$, we break it down into two parts, $h_1$ and $h_2$, and we create the polynomials $h_1 (x)$ and $h_2 (x)$. Two common approaches exist for breaking the polynomial: take the first half and interpolate and then the second half or split into odd and even terms. The second approach needs one check less, so we will adopt that strategy here, following &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2022&#x2F;086.pdf&quot;&gt;PlonkUp&lt;&#x2F;a&gt;. Since the polynomials $h_1 (x)$ and $h_2 (x)$ contain information about the witness, we also add blindings to these polynomials.&lt;&#x2F;p&gt;
&lt;p&gt;The round ends with the commitment of the queries’s polynomial, $f(x)$, and the parts of the sorted vector $h_1 (x)$, and $h_2 (x)$.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;round-3-computing-the-permutation-and-plookup-polynomials&quot;&gt;Round 3 - Computing the permutation and Plookup polynomials&lt;&#x2F;h3&gt;
&lt;p&gt;Round 3 involves the calculation of the copy constraint polynomial, $z_1 (x)$, and the Plookup polynomial, $z_2 (x)$. The permutation argument polynomial, $z_1 (x)$ is given by the following three terms:&lt;br &#x2F;&gt;
$$z_{11} = (b_{14} x^2 + b_{15} x + b_{16} ) Z_H (x)$$&lt;br &#x2F;&gt;
$$z_{12} = L_{1} (x)$$&lt;br &#x2F;&gt;
$$z_{13} = \sum L_{i + 1} (x) \prod \frac{(\gamma + \beta \omega^i + a_i )(\gamma + k_1 \beta\omega^i + b_i )(\gamma + k_2 \beta\omega^i + c_i )}{(\gamma + \beta S_{\sigma 1,i} + a_i )(\gamma + k_1 \beta S_{\sigma 2, i} + b_i )(\gamma + k_2 \beta S_{\sigma 3,i} + c_i )}$$&lt;br &#x2F;&gt;
The first term corresponds to the blinding polynomial, the second is the first Lagrange basis polynomial (it is one if $x = g$ and zero elsewhere), and the third one contains the grand product.&lt;&#x2F;p&gt;
&lt;p&gt;The Plookup polynomial $z_2 (x)$ looks very similar, given by three terms,&lt;br &#x2F;&gt;
$$z_{21} = (b_{17} x^2 + b_{18} x + b_{19} ) Z_H (x)$$&lt;br &#x2F;&gt;
$$z_{22} = L_{1} (x)$$&lt;br &#x2F;&gt;
$$z_{23} = \sum L_{i + 1} (x) \prod \frac{( 1 + \beta’ )( \gamma’ + f_i )(\gamma’(1 + \beta’) + t_i + \beta’ t_{i + 1} )}{(\gamma’ (1 + \beta’ ) + s_{2i - 1} + \beta’ s_{ 2i } )(\gamma’ (1 + \beta’ ) + s_{2i} + \beta’ s_{2i + 1} )}$$&lt;&#x2F;p&gt;
&lt;p&gt;These polynomials are best calculated by obtaining the components for the grand product check (in evaluation form) and then interpolating using the fast Fourier transform. The prover commits to these two polynomials.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;round-4-transforming-into-quotients&quot;&gt;Round 4 - Transforming into Quotients&lt;&#x2F;h3&gt;
&lt;p&gt;Round 4 computes the linear combination of the constraint polynomial, the copy constraint polynomial, and the Plookup constraints. We have the following constraints:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    1. All the assignments have to satisfy the general gates equations.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    2. The permutation check polynomial $z_1 (x)$ should equal one at the first evaluation point. Using the machinery we learned in STARKs, we could translate the condition as  &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;$$\frac{z_1 (x) - 1}{x - g^1}$$&lt;br &#x2F;&gt;
should be a polynomial. We can transform it into a more suitable form (so that all the constraints have the same vanishing polynomial)&lt;br &#x2F;&gt;
$$L_1 (x) (z_1 (x) - 1)$$
3. The permutation argument’s constraints&lt;br &#x2F;&gt;
$$\begin{align}&lt;br &#x2F;&gt;
(\gamma + \beta x + a (x) )(\gamma + k_1 \beta x + b (x) )(\gamma + k_2 \beta (x) + c (x) )z_1 (x) &amp;amp;- \newline&lt;br &#x2F;&gt;
(\gamma + \beta S_{\sigma 1} (x) + a (x) )(\gamma + k_1 \beta S_{\sigma 2} (x) + b (x) )(\gamma + k_2 \beta S_{\sigma 3} (x) + c (x) )z_1 (g x)&lt;br &#x2F;&gt;
\end{align}$$
4. Enforcing the lookup gates,&lt;br &#x2F;&gt;
$q_{lu} (x) ( a(x) + \zeta b(x) + \zeta^2 c(x) - f (x) )$
5. The product check for the Plookup polynomial&lt;br &#x2F;&gt;
$$\begin{align}&lt;br &#x2F;&gt;
(1 + \beta’)(\gamma’ + f(x) )(\gamma’(1 + \beta’) + t(x) + \beta’ t(g x)) z_2 (x) &amp;amp;- \newline&lt;br &#x2F;&gt;
(\gamma’ (1 + \beta’ ) + h_{1} (x) + \beta’ h_{2} (x) )(\gamma’ (1 + \beta’ ) + h_{2} (x) + \beta’ h_1 (gx) )z_2 (g x)&lt;br &#x2F;&gt;
\end{align}$$
6. The Plookup polynomial should be equal to one at the first point,&lt;br &#x2F;&gt;
$L_1 (x) (z_2 (x) - 1)$&lt;&#x2F;p&gt;
&lt;p&gt;All the constraints should hold over the interpolation domain. Each polynomial is divisible then by $Z_H (x)$, and so is the random linear combination of the polynomials. The result is the quotient polynomial, $q (x)$, which is split into three parts, each of at most degree $N + 1$&lt;br &#x2F;&gt;
$q (x) = q_{lo} (x) + x^{N + 2} q_{mid} (x) + x^{2N + 4} q_{hi} (x)$&lt;&#x2F;p&gt;
&lt;p&gt;The prover commits to each of the parts.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;round-5-evaluations&quot;&gt;Round 5 - Evaluations&lt;&#x2F;h3&gt;
&lt;p&gt;Round 5 computes the evaluations of several polynomials at a random point $z$ and sends them to the verifier so that he has enough information to check the relationship between the quotient and the original polynomial. The prover samples from the transcript $z$ and computes:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * $a(z)$&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * $b(z)$&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * $c(z)$&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * $S_{\sigma 1} (z)$&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * $S_{\sigma 2} (z)$&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * $f(z)$&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * $t(z)$&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * $t (gz)$&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * $z_1 (gz)$&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * $z_2 (gz)$&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * $h_1 (gz)$&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * $h_2 (z)$&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;round-6-wrapping-the-proof&quot;&gt;Round 6 - Wrapping the proof&lt;&#x2F;h3&gt;
&lt;p&gt;Round 6 performs the linearizations and generates the opening proof. So far, the prover has given commitments to polynomials and their evaluations at some point. It’s time to link both and produce the evaluation proof. First, the prover computes the linearization polynomial, $r (x)$, which should equal $0$ at $z$. The prover computes the proof for the evaluation of all the polynomials listed in round 5 at $z$,&lt;br &#x2F;&gt;
$$W_z (x) = \frac{1}{x - z}(r(x) + \sum \alpha^i (p_i(x) - p_i (z)))$$&lt;br &#x2F;&gt;
He does the same for the polynomials at $gz$,&lt;br &#x2F;&gt;
$$W_{gz} (x) = \frac{1}{x - gz}(\sum \alpha^i (p_i(x) - p_i (gz)))$$&lt;&#x2F;p&gt;
&lt;p&gt;The prover commits to these quotient polynomials.&lt;&#x2F;p&gt;
&lt;p&gt;All the evaluations at Round 5 give the proof, plus the commitments to all the polynomials from Rounds 1, 2, 3, 4, and 6.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this post, we covered the basics of lookup arguments, which let us prove that specific calculations are correct by checking their results in a table that contains all valid input&#x2F;output relations. These techniques can result in significant savings when we try to prove difficult or expensive operations to arithmetize, such as range checks or bitwise operations (which can be extensively used). We described the working principles of Plookup, which was among the first arguments to be presented. It can be integrated very neatly into the Plonk protocol, but it results in an extra cost since we have the calculation time increases with table size. Recent constructions reduce the cost associated with the size of the table, paying just a price proportional to the number of lookups. In upcoming posts, we will cover how to code the Plookup protocol and newer lookup arguments.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Message Authentication Codes</title>
        <published>2023-01-18T00:00:00+00:00</published>
        <updated>2023-01-18T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com/posts/message-authentication-codes/"/>
        <id>https://blog.lambdaclass.com/posts/message-authentication-codes/</id>
        
        <content type="html" xml:base="https://blog.lambdaclass.com/posts/message-authentication-codes/">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;We &lt;a href=&quot;&#x2F;symmetric-encryption&#x2F;&quot;&gt;discussed previously&lt;&#x2F;a&gt; how to ensure message confidentiality between two parties, Alice and Bob. We saw that we could use a symmetric key cipher, such as AES or ChaCha20, to encrypt messages between Alice and Bob so that only they can read them. However, when Bob gets a message from Alice, how does he know that it is truly from Alice, nor that a malicious party has not changed it? Here is where authenticity comes into play. For example, a man-in-the-middle (MIM) can try to impersonate Alice and Bob during a key exchange in a Diffie-Hellman protocol. The scheme works as follows:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    1. Alice chooses a random number \\( a \\) and computes \\( g^a \\) and sends it.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    2. The MIM gets \\( g^a \\), chooses \\( a^\prime \\) and sends Bob \\( g^{ a^\prime } \\).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    3. Bob chooses a random number \\( b \\) and computes \\( g^b \\) and sends it.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    4. The MIM gets \\( g^b \\), chooses \\( b^\prime \\) and sends Bob \\( g^{ b^\prime } \\).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    5. Alice gets the shared secret \\( g^{ ab^\prime } \\), and Bob gets \\( g^{ a^\prime b } \\); their messages get decrypted by the MIM, who can read them and then re-encrypt them to Alice or Bob with the corresponding secret key.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Authenticity is also crucial in contexts where confidentiality is not needed. For example, we could have an authentication tag that gives proof of the integrity of files on our hard drive. If an attacker gets access to our hard drive, he may try to change files in our operating system. The authentication tags would tell us if there has been a modification in our files or not.&lt;&#x2F;p&gt;
&lt;p&gt;A message authentication code (MAC) is a primitive which allows us to ensure the integrity of a given message. Several constructions can be used, depending on the context. Two commonly used constructions are CBC-MAC and HMAC. MACs play an essential role in internet protocol security (IPsec), secure shell (ssh), and transport layer security (TLS), generating authentication codes for each packet that is transmitted.&lt;&#x2F;p&gt;
&lt;p&gt;We will discuss later how to combine authentication codes with encryption to obtain authenticated encryption, which can guarantee semantic security (that is, the attacker cannot learn anything from a given ciphertext) and ciphertext integrity, leading to secure encryption against tampering.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-is-a-mac&quot;&gt;What is a MAC?&lt;&#x2F;h2&gt;
&lt;p&gt;A message authentication code is a pair of efficient algorithms, signing, and verification, \( S, V \), which work over a set of messages and tags and take keys. The key space is given by an n-bit string \( {0,1 }^n \). If we know the key, we can add authentication tags and verify them. The signing algorithm takes a message \( m \) and the key \( k \) and outputs a tag \( t \):&lt;br &#x2F;&gt;
\[ S(k,m)=t \]&lt;br &#x2F;&gt;
The verification algorithm gets a tag, \( t \), the key \( k \), and the message \( m \) and outputs a boolean variable \( b \), which tells us whether the tag corresponds to the given message:&lt;br &#x2F;&gt;
\[ V(k,t,m)=b \]&lt;br &#x2F;&gt;
The MAC construction has to be secure to be helpful; otherwise, an attacker could forge messages. We say that an attacker has produced a forgery if he can find a valid pair \( m,t \) without knowing the key.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;attacks-against-mac&quot;&gt;Attacks against MAC&lt;&#x2F;h2&gt;
&lt;p&gt;To see whether a MAC is secure, we need to establish the powers of the attacker and what would be a successful attack.&lt;&#x2F;p&gt;
&lt;p&gt;We suppose the attacker can perform a chosen message attack (CMA). In simple words, the attacker is free to choose any messages \( m_i \) and can get access to the corresponding tag \( t_i=S(k,m_i) \) by having Alice or Bob calculate the tag. He does not have access to the key, though. While this may be seen as an awkward power (because he can get the tag of any message), this is something that could take place in the real world. The goal of the attacker is, given pairs \( (t_i,m_i) \) for \( i=1,2,…j \), to find a new valid pair \( t,m \), where \( m\neq m_i \). This pair is called an existential forgery. We will say the MAC is secure if it is existentially unforgeable under CMA.&lt;&#x2F;p&gt;
&lt;p&gt;MACs could also be rendered insecure by replay attacks. In this situation, an adversary may capture a message and its tag from Alice to Bob and then use it to impersonate Alice by sending the same message To Bob sometime later. To avoid this, MACs include a message number (increased with each new message) or a time stamp, which is authenticated with the original message in the MAC.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;construction-of-mac-by-pseudo-random-functions-prf&quot;&gt;Construction of MAC by pseudo-random functions (PRF)&lt;&#x2F;h2&gt;
&lt;p&gt;We saw examples of pseudo-random functions when we talked about block ciphers. We mentioned that these behave as pseudo-random permutations, where we take a message \( m \) and map it over one of all the possible output messages. For example, the AES block cipher is a function \( f:K\times \{0,1 \}^{128} \rightarrow \{0,1 \}^{128} \), taking a message of 16 bytes and outputting a random string of 16-bytes.&lt;&#x2F;p&gt;
&lt;p&gt;We can construct a MAC from a given PRF, taking messages in a space \( X \) (for example, messages up to GB long), and outputting a tag in \( Y \) (for example, a 128-bit string), \( g: K\times X \rightarrow Y \) by doing&lt;br &#x2F;&gt;
\[ t=g(k,m) \]&lt;br &#x2F;&gt;
This MAC is secure provided that the PFR g is secure and that the output set is large enough; that is, the number of elements \( \vert Y \vert \) is greater than \( 2^{80} \).&lt;&#x2F;p&gt;
&lt;p&gt;If the tag space is small, the attacker has a high probability of outputting the correct tag.&lt;&#x2F;p&gt;
&lt;p&gt;Block ciphers and cryptographic hash functions behave as pseudo-random functions; therefore, their use in constructing MAC is reasonable. In the first case, we get CBC-MAC, while in the second, HMAC.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cbc-mac&quot;&gt;CBC-MAC&lt;&#x2F;h2&gt;
&lt;p&gt;We need a pseudo-random permutation (PRP) to build CBC-MAC, such as a block cipher. We can picture the MAC function as \( f:K^2\times M \rightarrow {0,1}^n\). It takes two different keys, \(k_1,k_2 \), a message and outputs a tag. In the case of using AES as PRP, \( n=128 \). Given that AES works with 16-byte words, the message is split into equal blocks of 16 bytes. We can always pad the message conveniently if it is not a multiple of 16. Let’s call \( m_0,m_1,…m_N \) the blocks composing the message and \( E(k,m)=C \) the AES encryption function, where the first argument is the key and the second is the message block. The algorithm proceeds as follows:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    1. Compute \\( t_1 = E( k_1 , m_0 )\\).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    2. For \\( j = 2, ... ,N \\) do  &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;\( t_{ j-1 }^\prime = t_{ j-1 }\oplus m_j \)&lt;br &#x2F;&gt;
\( t_j = E(k_1 , t_{ j-1 }^\prime)\)
3. Compute \( t = E(k_2 , t_N) \)&lt;&#x2F;p&gt;
&lt;p&gt;This last step is critical to make the MAC secure against existential forgery. If step 3 were omitted, then we can perform the following chosen message attack:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Choose \\( m \\)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Request \\( t = E(k,m) \\)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Obtain the tag for the forged message \\( m,t\oplus m \\).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can see that we have obtained a valid pair by performing the calculations:&lt;br &#x2F;&gt;
\( f(k,m\vert \vert t\oplus m)=E(k,E(k,m)\oplus t\oplus m)=E(k,t\oplus t\oplus m)=E(k,m)=t \)&lt;br &#x2F;&gt;
where we have used the fact that \( a\oplus a\oplus b=b\) (XORing \(b \) twice with the same bitstring returns \( b \)).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;nmac&quot;&gt;NMAC&lt;&#x2F;h2&gt;
&lt;p&gt;The NMAC construction is based on the cascade diagram. In this case, the NMAC function is \( g:K^2\times M\rightarrow K \). As in CBC-MAC, we split the message in \( N+1 \) equal blocks, \( m_0 , m_1 , … m_N \). To obtain the tag,&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    1. Set \\( t_0 = k_1 \\).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    2. For \\(i = 1,...N \\) perform \\( F(t_{i-1} , m_{i-1}) = t_i\\)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    3. Pad \\( t_N \\) with a fix pad element \\( \mathrm{fpad} \\) so that its length corresponds to the size of the elements in \\( M \\), \\( t_{N+1} \\).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    4. Compute \\( t=F(k_2 , t_{N+1}) \\)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Step 2 corresponds to the cascade. Step 4 is necessary once again to prevent a length extension attack. We can see that if we know the result of the cascade \( \mathrm{cascade}(k,m)\), then we can append any string \( w \) and obtain the exit of the cascade \( \mathrm{cascade}(k,m\vert \vert w)\).&lt;&#x2F;p&gt;
&lt;p&gt;Even though we could use NMAC with AES, this proves inconvenient in practice since there is a rapid change in the key scheduling. The strategy works best with cryptographic hash functions.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;pmac&quot;&gt;PMAC&lt;&#x2F;h2&gt;
&lt;p&gt;The problem with the NMAC and CBC-MAC is that they are carried out sequentially. This can be inconvenient in the case of very long messages since we cannot leverage multiple processors to accelerate the calculation. Parallel MAC solves this problem by adopting a different scheme. To build PMAC, we need two functions: a pseudo-random function \( F:K\times M\rightarrow M \) and a function taking a key and a counter \( P:K\times \mathbb{Z_0 }^+ \rightarrow K \). To compute the tag:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    1. For \\( i = 0, 1 ,...N \\) compute \\( {m_i}^\prime = m_i \oplus P(k_1 ,i)\\) and \\( t_i = F(k_2 , {m_i}^\prime) \\).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    2. Compute \\( m^\prime = m_0^\prime \oplus m_1^\prime\oplus ...\oplus m_N^\prime \\).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    3. Obtain \\( t = F(k_2 , m^\prime) \\).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;universal-hashing-and-one-time-mac&quot;&gt;Universal hashing and One-time MAC&lt;&#x2F;h2&gt;
&lt;p&gt;A faster version than PFR function-based MACs is the one-time MAC; this can be secure against all adversaries. They are based on universal hash functions, which are weaker than cryptographic hash functions (they do not need to be collision-resistant) but operate much faster. A universal hash function (UHF) takes a key, \( k \), and a message, \( m \), and gives the hash \( h_m = UHF(k,m) \). The only security requirement is that for any two messages \( m_1 , m_2 \), the probability that they hash to the same value for a random key is negligible:&lt;br &#x2F;&gt;
\[Pr(UHF(k,m_1) = UHF(k,m_2), k\leftarrow K) = \mathrm{neg}\ \forall m_1,m_2 \]&lt;&#x2F;p&gt;
&lt;p&gt;First, we break the message into \( N \) blocks as before. Then, we interpret each of these blocks as a number over a large finite field (that is, every block is an element from \( {0,1,2,..,q-1} \)). We can take each of them as the coefficient of a polynomial. To build the MAC, we fix a large prime \( q \) and take two random integers \( a,b \) in \( {1,2,…q-1}\). The signing algorithm is&lt;br &#x2F;&gt;
\[ S(a,b,m) = a^{N+1} + m_{N} a^N + m_{N-1} a^{N-1} + … a_1 m_1 + b \mod{q} \]&lt;br &#x2F;&gt;
The algorithm evaluates the polynomial with coefficients given by \( m_i \) at point \( a \), adds \( b \), and reduces the result modulo \( q \) so that the tag is also an element in the finite field \( \mathbb{F}_q \).&lt;&#x2F;p&gt;
&lt;p&gt;Poly1305 is an example of such a construction and is used in combination with AES or ChaCha20 (we will soon see why we need to combine them) to provide a fast MAC, used, for example, by Google, to secure HTTPS connections. In particular, Poly1305 breaks the messages into blocks of 16 bytes, interpreting each as a 129-bit number in little-endian form by appending an additional bit to each block. The modulus is \(q = 2^{130}-5 \), and the final result is reduced by taking the remainder by \( 2^{128} \).&lt;&#x2F;p&gt;
&lt;p&gt;The problem with one-time MACs is that we can authenticate only one message. An attacker can easily break the scheme to obtain both \( a \) and \( b \). Note that if the attacker submits a message where each \( m_i=0 \), then \( S(a,b,m)=b \). Then, he can send the message \( m_1=1,m_i=0\ \forall \ i&amp;gt;1 \) and get \( S(a,b,m)=b+a \mod{q} \) and recover \( a \). We can solve this problem by improving the construction and incorporating a pseudo-random function.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;carter-wegman-mac&quot;&gt;Carter-Wegman MAC&lt;&#x2F;h2&gt;
&lt;p&gt;The Carter-Wegman MAC combines a PRF with a one-time MAC. If \( F:K_F\times {0,1}^n \rightarrow {0,1}^n\) is the pseudo-random function and \( S(k_S,m) \) is a secure one-time MAC, the Carter-Wegman MAC is calculated as follows: Pick at random \( r \) in \( {0,1}^n \) and calculate&lt;br &#x2F;&gt;
\[ CW(k_F,k_S,m)=(r,F(k_F,r)\oplus S(k_S,m)) \]&lt;br &#x2F;&gt;
The input to the pseudo-random function is small, and even though \( F \) can be slower than \( S \), it will be computed very fast. We leave the message to the one-time MAC, which can deal efficiently even with large messages.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hmac&quot;&gt;HMAC&lt;&#x2F;h2&gt;
&lt;p&gt;To construct HMAC we need a key, \( k \), inner and outer paddings, \( \mathrm{ipad,opad} \) and a secure cryptographic hash function \( H:{0,1}^\star\rightarrow {0,1}^n \). The signing algorithm is&lt;br &#x2F;&gt;
\[ S(k,m)=H(k\oplus \mathrm{opad},H(k\oplus \mathrm{ipad},m)) \]&lt;br &#x2F;&gt;
The pseudo-random function masks the only weakness of the UHF by XORing the result of the UHF with a strongly random output from the PFR.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;timing-attacks-on-tag-verification&quot;&gt;Timing attacks on tag verification&lt;&#x2F;h2&gt;
&lt;p&gt;MAC verification can be subject to bugs or attacks if not done correctly. One standard attack against poorly implemented MAC verification schemes is timing attacks. In the verification, the verifier takes the key, \( k \), and the message \( m \), computes the authentication tag \( t^\prime \), and compares the received tag \( t \). One naïve way to do this is by performing a byte by byte comparison,&lt;br &#x2F;&gt;
\[ t^\prime[i] == t[i]\]&lt;br &#x2F;&gt;
The problem with checking this way is that, as soon as two bytes differ, for example, byte number 3, an attacker can be sure that the first two bytes are correct. The attacker can try different values for the third byte and measure the time it takes to verify. If it increases, he knows he got right at least another byte. The process can continue until he exhausts the number of bytes in the tag, getting the valid tag \( t \) for a message \( m \), being able to produce an existential forgery. Therefore, the lesson is to ensure the verification is performed in constant time so that no information is leaked from the tag.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;need-to-change-the-key&quot;&gt;Need to change the key&lt;&#x2F;h2&gt;
&lt;p&gt;To be secure, the MAC needs to be long enough. If not, they could be subjected to brute force attacks. We can find bounds for the number of messages we can MAC before changing keys. For example, in CBC-MAC, which outputs tags in \( \{0,1 \}^n \), if the adversary can query \( q \) messages of length \( \ell \), then we need that&lt;br &#x2F;&gt;
\[ \frac{q^2 \ell^2 }{ 2^n } \ll 1\]&lt;br &#x2F;&gt;
This means that \( q\ell \ll 2^n \). If we use AES where \( n=128 \) and we consider that \( 2^{-32}\approx 2\times 10^{-10}\) to be sufficiently small, then \( q\ell \leq 2^{48} \). Given that 1 GB of data is \( 2^{30} \) bytes, we can encrypt several messages containing up to several GB before changing the key.&lt;&#x2F;p&gt;
&lt;p&gt;In the case of HMAC with SHA-256, we have \( n=256 \), and the amount of messages we can tag before reaching the limit is \( q \ll 2^{256&#x2F;2} \), which, for our case, could be something like \( 2^{100}\approx 10^{30} \)&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;Encryption schemes, such as AES or ChaCha20, offer confidentiality but cannot ensure the authenticity of messages nor that an attacker has not modified them. The lack of authenticity can lead to devastating attacks and break cryptographic schemes. Message authentication codes (MAC) provide ways to ensure the integrity of the message, which we can combine with encryption schemes to provide authenticated encryption. To be secure, MACs need to satisfy existential unforgeability under chosen message attacks; given a new message \( m \), an attacker should not be able to generate a valid authentication tag \( t \), even if he has access to other valid pairs \( m_i,t_i \). MAC can be obtained from pseudo-random functions (such as hash functions or block ciphers, like AES) or universal hash functions, each offering advantages and disadvantages in terms of speed, size, processing in parallel, etc.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Symmetric encryption</title>
        <published>2023-01-17T00:00:00+00:00</published>
        <updated>2023-01-17T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com/posts/symmetric-encryption/"/>
        <id>https://blog.lambdaclass.com/posts/symmetric-encryption/</id>
        
        <content type="html" xml:base="https://blog.lambdaclass.com/posts/symmetric-encryption/">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;Encryption has been the main application of cryptography for a very long time. Its goal is to transform a message into another one and send it through an insecure channel, such that only the intended parties (who know all the elements necessary to reverse the transformation) can read it while looking like absolute nonsense to everybody else. For example, suppose that you are a general during a war, and you need to communicate the battle plan to your reinforcement battalions (which are still far from you) and launch a surprise attack at the precise moment. If you sent some messenger with an unencrypted letter containing the plans, then anyone reading the letter would know your strategy and act in consequence. Besides, the messenger could betray you, exchange that information with your enemies, and thwart your masterminded tactic.&lt;&#x2F;p&gt;
&lt;p&gt;Encryption uses an algorithm called cipher and some key to change the message into a random-looking text. More precisely, it takes a plaintext and outputs a ciphertext through some mathematical computations. The cyphertext can only be decrypted if the key is known. In modern encryption, only the key is secret; the details of the encryption algorithm are publicly known. This construction is in accordance with Kerkhoff’s principle, which states that, in a cryptographic system, only the key should be secret. In older times, people tried to hide the message by using unknown algorithms or strategies, hoping that the enemy would not be able to figure out the secret; we call this security through obscurity. Needless to point out, this strategy has failed numerous times with catastrophic consequences.&lt;&#x2F;p&gt;
&lt;p&gt;Symmetric encryption is widely used today, and there are efficient algorithms, some even implemented on hardware. Examples of symmetric encryption algorithms are AES (Advanced Encryption Standard), 3DES, ChaCha, Salsa, Twofish, Blowfish, and Serpent. In this type of encryption, we use the same key to encrypt and decrypt messages (therefore, if someone can send encrypted messages, he can decrypt them as well). We will see in a later chapter that there is asymmetric encryption (or public key cryptography), where we have two different keys: a public key (used to encrypt messages) and a private key (used to decrypt).&lt;&#x2F;p&gt;
&lt;p&gt;Once we have the key, we can send secure messages between the parties. It is unlikely that unwanted parties will decrypt them, thanks to the math and heuristics behind it and the appropriate security levels. However, we find ourselves with the problem of agreeing on the key between the involved parties. If we tried sending it in plaintext over an insecure channel, it could be compromised, and the symmetric encryption would be pointless since adversaries could have obtained it. We will focus in a later post on how to perform key exchanges.&lt;&#x2F;p&gt;
&lt;p&gt;There are two main ciphers types for symmetric encryption: block and stream ciphers. We will analyze their characteristics in the following sections.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;formalization&quot;&gt;Formalization&lt;&#x2F;h2&gt;
&lt;p&gt;We have two parties wanting to communicate securely, which we will call Alice and Bob (for A and B, respectively). Alice wants to send Bob a plaintext, \( P \), so that only Bob can read it and learn its contents. They have previously agreed on a common secret key, \( k \), and they will use some algorithm, such as AES. The encryption algorithm is some function, $E$, taking they plaintext and the key and outputting the ciphertext \( C \):&lt;br &#x2F;&gt;
\[ E(P,k)=C \]&lt;br &#x2F;&gt;
The decryption algorithm, \( D \), on the other hand, takes the ciphertext and the key and returns the plaintext&lt;br &#x2F;&gt;
\[ D(C,k)=P \]&lt;&#x2F;p&gt;
&lt;p&gt;We want some things from our encryption algorithm and the output ciphertext. First, the ciphertext should appear as a random text with no clear patterns. We would also like that if we change even a single bit from the message, the resulting ciphertext is utterly different from the original one: We call this the avalanche effect.&lt;&#x2F;p&gt;
&lt;p&gt;These are related to two properties that a secure cipher should have: confusion and diffusion. Confusion serves to hide the relationship between the key and the ciphertext. Diffusion is related to the fact that the value in the ciphertext of one bit depends on others; equivalently, if we changed one bit from the plaintext, we could expect that many bits would also change their values, which is related to the avalanche effect.&lt;&#x2F;p&gt;
&lt;p&gt;A cipher’s permutation should satisfy the following three conditions to be secure:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * The key should determine the permutation.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Different keys should give rise to different permutations.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * The permutations should look random.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The first condition guarantees that we need the key to be able to decrypt. If the key does not determine the permutations, it plays no role in the process, and anyone could decrypt things without it. The second one means that no two keys yield the same permutation. If it were so, then we could decrypt the messages encrypted with one key with another, and that would make it easier to break the cryptosystem. The third one implies that we should not be able to learn anything about the plaintext from the ciphertext (an example where this fails is on some bitmaps with ECB mode encryption).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;information-versus-computational-security&quot;&gt;Information versus Computational security.&lt;&#x2F;h2&gt;
&lt;p&gt;One important key is related to the security proofs of our cryptographic schemes. In some cases, one can prove that specific methods are mathematically secure, even if the attacker has unbounded computational power. These schemes are known as information-theoretically secure. However, we need to introduce some assumptions to build practical cryptographical schemes. Modern cryptographic algorithms can be proven computationally secure, where the adversary has bounded computing power and can break the system only after spending a lot of time or resources, even with the fastest and most powerful devices available nowadays.&lt;&#x2F;p&gt;
&lt;p&gt;Instead of perfect security, computational security relies on the following:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Security is preserved only against efficient adversaries.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Adversaries can succeed, but only with negligible probability.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can consider our schemes secure for practical purposes if we have sufficiently reasonable bounds for computational power and the probability of success is small enough.&lt;&#x2F;p&gt;
&lt;p&gt;There are two common approaches to analyzing the security of our cryptographic protocols:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    1. Concrete.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    2. Asymptotic.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In the concrete case, we bound the probability of success, \( \epsilon \), after the attacker has spent time \(t \). We say that the scheme is \( (t,\epsilon) \)-secure if an adversary spending time \(t \) has a probability of success of at most \( \epsilon \).&lt;&#x2F;p&gt;
&lt;p&gt;The asymptotic approach is related to complexity theory. It views the running time of the attacker and his success probability as functions of a security parameter, \( \lambda \) (for example, the secret key size). It only guarantees security provided \( \lambda \) is sufficiently large.&lt;&#x2F;p&gt;
&lt;p&gt;We say an algorithm is efficient if its running time is polynomial in \( \lambda \), that is \( c_1 \lambda^{c_2} \) for some numbers \( c_1 \) and \( c_2\). We can also write this in big O notation, \( \lambda^{c_2}\).&lt;&#x2F;p&gt;
&lt;p&gt;As for the probability of success, we consider them to be small if it is smaller than any inverse polynomial in \( \lambda \). More precisely, for every constant \( c \), the attacker’s success probability is smaller than the inverse polynomial in \( \lambda \), \( \lambda^{-c}\). A function growing slower than any inverse polynomial is called negligible.&lt;&#x2F;p&gt;
&lt;p&gt;A scheme is secure if every probabilistic, polynomial-time attacker succeeds in breaking it with only negligible probability.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bit-operations-exclusive-or-xor&quot;&gt;Bit operations: exclusive OR (XOR)&lt;&#x2F;h2&gt;
&lt;p&gt;One operation frequently used in cryptography is the exclusive OR operator (XOR). It is a binary operation, taking two bits and outputting another; we will represent the operation with the \( \oplus \) symbol. Its truth table is:&lt;br &#x2F;&gt;
\( 0\oplus 0=0\)&lt;br &#x2F;&gt;
\( 0\oplus 1=1\)&lt;br &#x2F;&gt;
\( 1\oplus 0=1\)&lt;br &#x2F;&gt;
\( 1\oplus 1=0\)&lt;&#x2F;p&gt;
&lt;p&gt;We can also view the XOR operation as an addition modulo \( 2 \):&lt;br &#x2F;&gt;
\( 0+0\equiv 0 \pmod{2}\)&lt;br &#x2F;&gt;
\( 1+0\equiv 1 \pmod{2}\)&lt;br &#x2F;&gt;
\( 1+1\equiv 0 \pmod{2}\)&lt;br &#x2F;&gt;
These results are expected: adding two odd or two even numbers is always even, whereas adding one odd and one even number is always odd.&lt;&#x2F;p&gt;
&lt;p&gt;Why is this operation helpful? Suppose we want to encrypt a message given as a sequence of bits. One way to encrypt it is to generate a sequence of (pseudo) random bits and XOR each bit to get the ciphertext. An attacker can try to decipher the text, but he finds the following problem:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * If he sees \\( 0 \\) in the ciphertext, it could be because the plaintext had \\( 1 \\) and the random bit was also \\( 1 \\), or both were zero. So, he has a \\( 50 % \\) chance of guessing correctly!&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * If he sees \\( 1 \\) in the ciphertext, either the plaintext is \\(1 \\) and the random bit is \\( 0 \\) or the other way round. Again, he has a \\( 50 % \\) chance of guessing correctly.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If the message is composed of several bytes (for example, 16 bytes - 128 bits), the probability of guessing the correct message is \( 3\times 10^{-39} \)!&lt;&#x2F;p&gt;
&lt;p&gt;We see that the XOR operation is hard to reverse unless we know one of the original inputs. In that case, if \( c=m\oplus r\), then&lt;br &#x2F;&gt;
\[ m=c\oplus r\]&lt;&#x2F;p&gt;
&lt;h2 id=&quot;stream-and-block-ciphers&quot;&gt;Stream and Block ciphers&lt;&#x2F;h2&gt;
&lt;p&gt;A block cipher takes a message of fixed length (128 bits, for example) and encrypts it by performing some random permutation of its elements. Two values characterize the block cipher: the block size (for example, 16 bytes -128 bits-) and the key size. Both determine the level of security of the cipher. This cipher does not operate with individual bits but with fixed-sized blocks.&lt;&#x2F;p&gt;
&lt;p&gt;Block sizes must be neither very large nor very small. In the first case, it can impact the cost and performance of the encryption since the memory footprint and ciphertext length will be significant. However, if the block size is small, it is susceptible to a codebook attack.&lt;&#x2F;p&gt;
&lt;p&gt;In practice, a block cipher is the repetitive application of permutation and substitution steps; these take place in rounds. The main building blocks are:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Substitution boxes (S-boxes).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Mixing permutations.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Key schedule.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If we call \(f_k \) the function corresponding to round \( k \), the ciphertext is&lt;br &#x2F;&gt;
\[ C= f_n(f_{n-1}(…f_2(f_1(P))))\]&lt;&#x2F;p&gt;
&lt;p&gt;The round functions have the same operations but are parametrized by a different key (which leads to other substitutions and permutations). We should not use the same key for all steps; otherwise, our cryptosystem can be vulnerable to slide attacks.&lt;&#x2F;p&gt;
&lt;p&gt;Decryption is the successive application of the inverse functions \( g_k=f_k^{-1}\),&lt;br &#x2F;&gt;
\[ P=g_1(g_2(…g_{n-1}(g_n(C))))\]&lt;&#x2F;p&gt;
&lt;p&gt;Stream ciphers work very differently; instead of combining blocks of text and the key, they deterministically generate a sequence of “random” bits (called the keystream) from the key and perform XOR operations with the text.&lt;&#x2F;p&gt;
&lt;p&gt;The keystream, \( KS \), is derived from the secret key \( k \) and a public nonce \( \mathrm{nonce} \). If we have our message, \( \mathrm{m} \) to encrypt we perform \( C=KS \oplus \mathrm{m} \). To decrypt, we simply XOR again, \( \mathrm{m}=KS\oplus C\). We can easily see that the encrypt and decrypt operations are essentially the same; we only need the keystream to be able to do it. It is important that \( \mathrm{nonce} \), which need not be secret, is never reused. To see why, suppose we have two messages \( \mathrm{m}_1 \) and \( \mathrm{m}_2\), and their corresponding ciphertexts, which have been encrypted using the same key \( k \) and \( \mathrm{nonce} \). We can recover the message \( \mathrm{m}_1 \) using the following operation:&lt;br &#x2F;&gt;
\[ \mathrm{m}_1=C_2\oplus C_1 \oplus \mathrm{m}_2 \]&lt;&#x2F;p&gt;
&lt;p&gt;The above was an implementation error that Microsoft Excel and Word had: they reused the same nonce, which meant that decryption could be done if two versions of the same file were available.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;encryption-algorithms&quot;&gt;Encryption algorithms&lt;&#x2F;h2&gt;
&lt;p&gt;In the following sections, we will cover the basics of each type of cipher, analyzing two commonly used ones. We will start with AES (a block cipher), the most widely used cipher nowadays, and ChaCha (a stream cipher), commonly used in android systems in the form of ChaCha20-Poly1305.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;aes&quot;&gt;AES&lt;&#x2F;h2&gt;
&lt;p&gt;The Advanced Encryption Standard (AES) resulted from an open competition organized by NIST in 1997 that lasted for three years. The proposal by Rijmen and Daemen was nominated as the winner and was standardized in 2001 by NIST. We implemented AES and its arithmetization for use in zero-knowledge proofs &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;AES_zero_knowledge_proof_circuit&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;AES offers three levels of security: AES-128, AES-192, and AES-256, with key sizes of 16, 24, and 32 bytes, respectively. As the key’s size increases, so does security. However, for most applications, AES-128 provides sufficient security levels (the best-known attacks against AES are only slightly better than brute-force attacks, which would require \( 2^{128} \) operations).&lt;&#x2F;p&gt;
&lt;p&gt;AES is a block cipher: it takes a 16-byte block (128 bits) and the variable length key and outputs a 16-byte ciphertext. If the text has less than 16 bytes, it is conveniently padded. After performing decryption, it should be possible to eliminate the padding to recover the message; therefore, we cannot use random padding because we cannot distinguish the original message from the random bits.&lt;&#x2F;p&gt;
&lt;p&gt;Remember that block ciphers are permutations: they map all the possible plaintexts into all possible ciphertexts.&lt;&#x2F;p&gt;
&lt;p&gt;The cipher sees the plaintext as a \( 4\times 4 \) matrix of bytes. AES has a round function, which is applied several times to the plaintext, scrambling and mixing everything well until we obtain the ciphertext. Each round uses a different key (which is generated in a deterministic way from the secret key), making the slightest changes in the bits of the secret key result in an entirely different encryption. The steps in each round function (except in the last one) are:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * SubBytes&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * ShiftRows&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * MixColumns&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * AddRoundKey&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The first three are easily reversible, but the last one is not: it performs an XOR operation between the text and the round key. However, all the steps are necessary to achieve the desired security levels.&lt;&#x2F;p&gt;
&lt;p&gt;AES uses ten rounds to perform encryption. All steps contain the four operations, except for the first (only the round key is added) and the 10th (MixColumns is omitted).&lt;&#x2F;p&gt;
&lt;p&gt;SubBytes (also called substitution boxes) provide the substitution step and is a nonlinear function. Given that we encrypt blocks of 16 bytes, we can do the substitution with the aid of lookup tables.&lt;&#x2F;p&gt;
&lt;p&gt;In ShiftRows and MixColumns, the bytes of the columns&#x2F;rows are moved.&lt;&#x2F;p&gt;
&lt;p&gt;The key schedule function is called to generate the keys for each round: all the keys are derived from the secret key, using the substitution boxes and XOR operations. One drawback of this key scheduling is that if an attacker learns one of the keys, he can reverse the algorithm and discover all other keys, including the secret key.&lt;&#x2F;p&gt;
&lt;p&gt;Why do we need all these operations to have a secure cipher?&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * The MixColumns and ShiftRows guarantee that all the elements are &amp;quot;well mixed&amp;quot;. If one of them is missing, then we could break the cipher into smaller blocks and perform a codebook search over \\( 2^{32} \\) possibilities, which is far better than \\( 2^{128} \\).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * SubBytes gives the nonlinear part to the cipher. Without it, all the operations are linear and easier to reverse.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * AddRoundKey makes the ciphertext depend on the key. If we skip this step, we don&amp;#39;t need any key to decipher.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * The key schedule prevents us from reusing the same key all the time, making the cipher vulnerable to slide attacks.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we want to encrypt a message bigger than the block size, we can divide it into blocks of 16 bytes and pad the last one, if necessary. This simple approach is known as the electronic codebook mode (ECB) and should not be used. As encryption is deterministic, we will get the same ciphertext every time we encrypt a given plaintext. This is problematic when we have, for example, an image with repetitive patterns or large areas of one color since the ciphertext will exhibit those patterns too. There are several modes that we can use to avoid this problem:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Cipher block chaining (CBC)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Propagating cipher block chaining (PCBC)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Cipher Feedback (CFB)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Output feedback (OFB)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Counter (CTR)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For example, in the CBC mode:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    1. Initialize a 16-byte random vector (IV),&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    2. Perform \\( \tilde{B}_1=IV \oplus B_1 \\), where \\( B_1 \\) is the first block and set \\( k=1 \\).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    3. Use AES to encrypt \\( E_1= \tilde{B}_1 \\).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    4. Perform \\( \tilde{B_{k+1}}=E_k \oplus B_{k+1} \\)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    5. Use AES to encrypt \\( E_{k+1}= \tilde{B_{k+1}} \\) and do \\( k=k+1 \\)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    6. If \\( k \neq k_{max} \\), go to step 4. Otherwise, it is the end of the encryption.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The IV guarantees that the resulting ciphertext will be different even if the same plaintext is encrypted.&lt;&#x2F;p&gt;
&lt;p&gt;Another problem we face is that, even though the message has been encrypted, we cannot know whether an attacker has modified it. To prevent modification of the ciphertext, we can add message authentication codes (MAC), which we will cover in another post.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;chacha20&quot;&gt;ChaCha20&lt;&#x2F;h2&gt;
&lt;p&gt;ChaCha20 is a modification of the Salsa20 cipher, invented by Daniel J. Bernstein in 2005. Its working principle is the same as all stream ciphers: it generates a keystream from the secret key and encrypts by performing an XOR operation between the plaintext and the keystream.&lt;&#x2F;p&gt;
&lt;p&gt;ChaCha20 generates the keystream by repeatedly calling a block function that outputs 64 bytes of keystream. It takes as input:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * 256-bit key.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * 96-bit nonce.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * 32-bit counter.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Every time the function outputs 64 bytes of the keystream, the counter is increased by one, and the process continues until the keystream is larger than the plaintext; then, we truncate it to the plaintext length, and we perform an XOR operation. The maximum size we can encrypt is given by the total value of the counter, \( 2^{32} \), and the output of each round, 64 bytes, yielding a maximum of \( 2^{32}\times 64=256 \) GB.&lt;&#x2F;p&gt;
&lt;p&gt;The core operation is the Quarter Round. It takes 4 32-bit unsigned integers, denoted \( a,b,c \) and \(d \) and performs the following operations:&lt;br &#x2F;&gt;
\( a=a+b;\space d=d\oplus a;\space d&amp;lt;&amp;lt;&amp;lt;16\)&lt;br &#x2F;&gt;
\( c=c+d;\space b=b\oplus c;\space b&amp;lt;&amp;lt;&amp;lt;12\)&lt;br &#x2F;&gt;
\( a=a+b;\space d=d\oplus a;\space d&amp;lt;&amp;lt;&amp;lt;8\)&lt;br &#x2F;&gt;
\( c=c+b;\space b=b\oplus c;\space b&amp;lt;&amp;lt;&amp;lt;7\)&lt;br &#x2F;&gt;
where \( &amp;lt;&amp;lt;&amp;lt;n \) denotes an \( n \)-bit rotation towards the left.&lt;&#x2F;p&gt;
&lt;p&gt;The ChaCha state comprises 16 32-bit words: the first four are constants; the next eight correspond to the key, followed by the counter and the nonce.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;Symmetric encryption is one of the most widely used encryption schemes nowadays; it also provides tools upon which we can build hash functions. We can classify symmetric ciphers into two big groups: block (like AES) and stream ciphers (like Chacha20). Both provide confidentiality by scrambling and substituting the message. In a subsequent post, we will deal with how parties can agree on a key over an insecure channel.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>How to create your own crappy RSA as a software developer</title>
        <published>2022-08-26T00:00:00+00:00</published>
        <updated>2022-08-26T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com/posts/how-to-create-your-own-crappy-rsa-as-a-software-developer/"/>
        <id>https://blog.lambdaclass.com/posts/how-to-create-your-own-crappy-rsa-as-a-software-developer/</id>
        
        <content type="html" xml:base="https://blog.lambdaclass.com/posts/how-to-create-your-own-crappy-rsa-as-a-software-developer/">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;One of the key developments in cryptography was the introduction of public key (or asymmetric) cryptosystems. These rely on pairs of keys: one of them is the public key (known to everybody) and the other is the private key (known only to the specific user). The public key is used to encrypt messages (anybody can do this since it is public), while the private key is used to decrypt the messages. This contrasts with symmetric encryption, where there is one key that can perform both operations (and was the only method available before the 1970s). This meant that a secure channel was needed to exchange&#x2F;decide on the key, so that only certain priviledged parties were able to do cryptography. The real-time cryptography and the internet as we know it was enabled by public key cryptography. Depending on the method used, the keys could be numbers -for example, (RSA) or, in the case of elliptic curve cryptography (ECC), a number and a point of an elliptic curve. The algorithm of encryption and decryption is also publicly known, so the security of the whole system depends on never revealing the private key (this is known as &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Kerckhoffs%27s_principle&quot;&gt;Kerckhoff’s principle&lt;&#x2F;a&gt;). Asymmetric cryptography plays a fundamental role in many applications and protocols, offering confidentiality, authenticity, and non-repudiability of data and electronic communications. Internet standards, such as TLS, SSH, and PGP rely on this cryptographic primitive.&lt;&#x2F;p&gt;
&lt;p&gt;RSA (named after Rivest, Shamir, and Adleman) is one of the first public key cryptosystems, the most widely used, and one of the simplest to understand and implement (1). We will discuss today how RSA works, how to implement its basic structure, and what are some of the pitfalls and weaknesses of this system (which have led to its losing ground against ECC).&lt;&#x2F;p&gt;
&lt;p&gt;We will be using some math and cryptography concepts below; you may want to review our math &lt;a href=&quot;&#x2F;math-survival-kit-for-developers&#x2F;&quot;&gt;survival kit&lt;&#x2F;a&gt; first.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;how-rsa-works&quot;&gt;How RSA works&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;non-rigorous-mathematical-idea&quot;&gt;Non-rigorous mathematical idea&lt;&#x2F;h3&gt;
&lt;p&gt;RSA relies on four key steps: key generation, key distribution, encryption, and decryption. Instead of describing each of them in sequence, we will give an overview of the whole process and then go into the details. The basic idea is the following: given a number $n$ (public), there are two numbers $e$ (public key, used for encryption) and $d$ (private key, used for decryption), which are multiplicative inverses (that is, $d\times e=1$, so $e=d^{-1}$). Given a message $M$, expressed as a number between $0$ and $n-1$, the encryption $E(M)$ is done by taking the $e$-th power of $M$,&lt;br &#x2F;&gt;
$E(M)=M^e$&lt;br &#x2F;&gt;
Decryption is done similarly by taking the $d$-th power of the encrypted message,&lt;br &#x2F;&gt;
${E(M)}d=(M{e})d=M{d\times e}=M$&lt;br &#x2F;&gt;
Of course, if you think in terms of high-school math, there are several problems, starting with the obvious fact that knowing $e$ allows you to calculate $d$ and that the encrypted message can grow into a very large number (and take a lot of space). This is where number theory and modular arithmetic come to our rescue.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;steps&quot;&gt;Steps&lt;&#x2F;h3&gt;
&lt;p&gt;Let’s now look in more detail at each of the steps and how we can get something that is very difficult to crack unless you know the secret key.&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    1. Key generation:&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Pick large random prime numbers $p$ and $q$ and keep them secret (2).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Calculate $n=p\times q$. $n$ is released as part of the public key parameters.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Compute the value of [Euler&amp;#39;s totient function](https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Euler%27s_totient_function) $\phi(n)=(p-1)\times (q-1)$ and keep it secret (3).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Choose an integer $1&amp;lt;e&amp;lt;\phi(n)$ which is coprime to $\phi (n)$ (that is, their only common divisor is 1). $65537=2^{16}+1$ is a typical choice since it offers rather fast encryption and security. Another popular choice is $3$, but it is known that this leads to insecure encryption in many settings.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Calculate $d=e^{-1} \mod{\phi(n)}$, that is, $d$ is the multiplicative inverse of $e$ modulo $\phi(n)$ (4). This can be done via taking powers of $e$ or in a faster way using the [extended Euclidean algorithm](https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Extended_Euclidean_algorithm).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    2. Key distribution: If two people Alice and Bob want to communicate, each sends the other their public parameters $(e_A,n_A)$ and $(e_B,n_B)$. Of course, an obvious question arises, how do Bob and Alice know that they got each other&amp;#39;s public parameters and not someone else&amp;#39;s (the infamous man-in-the-middle)?&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    3. Encryption:&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Convert the message $P$ into an integer $1&amp;lt;m&amp;lt;n$ by using an agreed padding scheme.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * $E(m)$ is calculated $E(m)\equiv m^e \pmod{n}$.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    4. Decryption:&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Compute the message $m$ by doing ${E(m)}^d\equiv m \pmod{n}$.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * Reverse the first step of encryption to convert $m$ to $P$.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;example-of-the-calculations&quot;&gt;Example of the calculations&lt;&#x2F;h3&gt;
&lt;p&gt;Let’s pick a toy model to illustrate how the calculations are done (of course, no real model uses these simple numbers, because it is rather easy to break, even by brute force attempts).&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    1. We choose two random primes 17 and 19.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    2. $n=17\times 19=323$&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    3. We evaluate $\phi(323)=288$ or $\lambda(323)=144=lcm(16,18)$.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    4. We pick $e=5$ (remember, a small $e$ is not a good choice). We cannot pick $3$ because $3$ is not coprime to $\phi(n)=288=2^5 \times 3^2$.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    5. $d=5^{11}\equiv 29 \pmod{144}$. (We use Carmichael&amp;#39;s totient function since it is faster). Let&amp;#39;s check we did right: $5\times 29=145\equiv 1 \pmod{144}$, since $145=1\times 144+1$. An even faster alternative would be using the extended Euclidean algorithm.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    6. Our message is $11$. Therefore $E(11)=11^5\equiv 197\pmod{323}$.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    7. We now attempt to decrypt $197^{29}\equiv 11 \pmod{323}$&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;the-math-behind-the-scenes&quot;&gt;The math behind the scenes&lt;&#x2F;h3&gt;
&lt;p&gt;The trick works because we have two numbers $d$ and $e$, such that $d\times e \equiv 1 \pmod{\phi(n)}$. In other words, $d\times e=k\phi(n)+1$. If we perform encryption, followed by decryption, we get&lt;br &#x2F;&gt;
${(me)}d=m^{e\times d}=m^{1+k\phi(n)}=m\times (m{\phi(n)})k \equiv m \pmod{n}$&lt;br &#x2F;&gt;
The last step is a consequence of Euler’s theorem, since&lt;br &#x2F;&gt;
$a^{\phi(n)}\equiv 1 \pmod{n}$, given $a$ and $n$ are coprime.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;security-issues&quot;&gt;Security issues&lt;&#x2F;h3&gt;
&lt;p&gt;There are several issues with RSA, especially when it is not implemented properly. When generating random prime numbers, these must be truly random (therefore, always use a pseudorandom generator that works for cryptographic applications). Many attacks depend on getting to the factorization of the public parameter $n$. If we can find $p$ or $q$, then we get the other and we can calculate $\lambda (n)$ or $\phi(n)$, the multiplicative inverse of $e$, which is none other than the private key. For example, if $p$ and $q$ are very similar in length, we know $p \approx q \approx \sqrt{n}$ and Fermat’s factorization as two squares $n=a2-b2$ is possible. It is easy to see that $a2-b2=(a+b)\times (a-b)$ and so we have both numbers. If we know many different $n$, we can try breaking the factorization by finding the least common divisor. For example, say we know for two people $n_1$ and $n_2$ and that they share a common factor $p$. Then we have $p=gcd(n_1,n_2)$ and the gcd can be found extremely fast (in polynomial time) thanks to Euclid’s algorithm. This way, we break the security of both accounts.&lt;&#x2F;p&gt;
&lt;p&gt;Other methods work even if the factorization is not known. In the case of low exponents $e$ (such as $3$), it may happen that $M^3$ does not exceed the modulus $n$ and so it may be easily broken by taking the cubic root. On the other hand, if the private key is small, you can use &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Wiener%27s_attack&quot;&gt;Wiener’s&lt;&#x2F;a&gt; or &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2020&#x2F;1214.pdf&quot;&gt;Boneh-Durfree’s attacks&lt;&#x2F;a&gt; and get the key. A collection of several strategies is on the following &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;RsaCtfTool&#x2F;RsaCtfTool&quot;&gt;link&lt;&#x2F;a&gt;. You can build your own factorization methods or try using open source tools such as &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.sagemath.org&#x2F;&quot;&gt;SageMath&lt;&#x2F;a&gt; to try and see how easy is to perform the factorization of a composite number.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;implementing-some-of-the-key-functions&quot;&gt;Implementing some of the key functions&lt;&#x2F;h2&gt;
&lt;p&gt;To be able to perform operations with RSA, we need to implement first some of the arithmetic operations and define field elements. We will show how to implement some of these in Rust.&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;use::std::ops::{Add, Sub, Mul, Div};&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;pub struct FieldPoint {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    num: u128,&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    prime: u128,&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The first line imports the standard library (in particular, the operations of addition, subtraction, multiplication, and division) which will allow us to override these operators with the expressions we need to use in modular arithmetic.&lt;&#x2F;p&gt;
&lt;p&gt;In the second line, we define a public structure named &lt;code&gt;FieldPoint&lt;&#x2F;code&gt;, which has two fields: &lt;code&gt;num&lt;&#x2F;code&gt; (a number in the range 0 to prime) and &lt;code&gt;prime&lt;&#x2F;code&gt; (this will give us the size and we will perform all operations modulo prime). For practical applications, we need to replace the unsigned integers &lt;code&gt;u128&lt;&#x2F;code&gt; with appropriate variables that allow us to store large integers.&lt;&#x2F;p&gt;
&lt;p&gt;We can now instantiate some methods over &lt;code&gt;FieldPoint&lt;&#x2F;code&gt;, such as how to create one or how to multiply or divide field elements.&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;impl FieldPoint {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    pub fn new(num: u128, prime: u128) -&amp;gt; FieldPoint {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        if num &amp;gt; prime {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            panic!(&amp;quot;Not a valid input for a field point, num should be nonnegative and less than prime, obtained {}&amp;quot;, num);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        } else {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            FieldPoint {num:num, prime:prime}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Methods are defined following the keyword &lt;code&gt;impl&lt;&#x2F;code&gt; and the name of the &lt;code&gt;struct&lt;&#x2F;code&gt;. We have a constructor for the &lt;code&gt;FieldPoint&lt;&#x2F;code&gt;, which takes two unsigned &lt;code&gt;u128&lt;&#x2F;code&gt; integers.&lt;&#x2F;p&gt;
&lt;p&gt;To define addition, we can implement the trait &lt;code&gt;Add&lt;&#x2F;code&gt; for &lt;code&gt;FieldPoint&lt;&#x2F;code&gt; in this way&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;impl Add for FieldPoint {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    type Output = Self;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    fn add(self, other: Self) -&amp;gt; Self {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        if self.prime == other.prime {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            FieldPoint {num: (self.num + other.num).rem_euclid(self.prime), prime: self.prime}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        } else {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            panic!(&amp;quot;Cannot add these field points, different prime values {},{}&amp;quot;,self.prime,other.prime);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The addition is simply adding the &lt;code&gt;num&lt;&#x2F;code&gt; fields and if the result exceeds the modulus &lt;code&gt;prime&lt;&#x2F;code&gt;, we take the remainder of the Euclidean division between the sum and the modulus.&lt;&#x2F;p&gt;
&lt;p&gt;Multiplication works in a similar way&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;impl Mul for FieldPoint {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    type Output = Self;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    fn mul(self, other: Self) -&amp;gt; Self {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        if self.prime == other.prime {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            FieldPoint {num: (self.num*other.num).rem_euclid(self.prime), prime: self.prime}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        } else {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            panic!(&amp;quot;Cannot multiply these field points, different prime values, {},{}&amp;quot;,self.prime,other.prime);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We need to define the powers of &lt;code&gt;FieldElement&lt;&#x2F;code&gt;. We can do this in a rather efficient way by squaring and taking the remainder:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;pub fn power(&amp;amp;self,index: u128) -&amp;gt; Self {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        if index == 0 {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            FieldPoint {num: 1u128, prime: self.prime}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        } else {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            let mut aux=index.rem_euclid(self.prime-1u128);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            let mut acc: u128 = 1;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            let mut base: u128 =self.num;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            while aux &amp;gt;0{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;                if aux%2 == 0 {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;                    base = (base*base).rem_euclid(self.prime);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;                    aux=aux&#x2F;2u128;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;                } else {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;                    acc = (acc*base).rem_euclid(self.prime);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;                    aux=aux-1u128; &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;                }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            FieldPoint {num: acc, prime: self.prime}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The power function takes a &lt;code&gt;FieldElement&lt;&#x2F;code&gt; and &lt;code&gt;index&lt;&#x2F;code&gt;, a &lt;code&gt;u128&lt;&#x2F;code&gt;. If the index is $0$, the result is trivial and we output a &lt;code&gt;FieldElement&lt;&#x2F;code&gt; with &lt;code&gt;num&lt;&#x2F;code&gt; equal to $1$. In any other case, we first reduce &lt;code&gt;index&lt;&#x2F;code&gt; (if &lt;code&gt;index&lt;&#x2F;code&gt; exceeds &lt;code&gt;prime&lt;&#x2F;code&gt;, we can take the remainder of &lt;code&gt;index&lt;&#x2F;code&gt; by &lt;code&gt;prime-1&lt;&#x2F;code&gt; -this works when the modulus is prime since Euler’s theorem says that $a^{p-1}\equiv 1 \pmod{p}$-. A better version would reduce &lt;code&gt;index&lt;&#x2F;code&gt; by $\phi(n)$) and store it in &lt;code&gt;aux&lt;&#x2F;code&gt;. We also define a variable to calculate the result &lt;code&gt;acc&lt;&#x2F;code&gt; and &lt;code&gt;base&lt;&#x2F;code&gt;, where we will repeatedly square and take the remainder of the &lt;code&gt;num&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We now focus on the squaring and the updating of the result:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;while aux &amp;gt;0{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    if aux%2 == 0 {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        base = (base*base).rem_euclid(self.prime);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        aux=aux&#x2F;2u128;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    } else {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        acc = (acc*base).rem_euclid(self.prime);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        aux=aux-1u128; &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We will go decreasing the index stored in &lt;code&gt;aux&lt;&#x2F;code&gt;: if it is even (the first condition -this could be checked much faster, by inspecting the last bit of &lt;code&gt;aux&lt;&#x2F;code&gt;-), we divide &lt;code&gt;aux&lt;&#x2F;code&gt; by two and update &lt;code&gt;base&lt;&#x2F;code&gt; to the remainder of its square. If it is odd, then we proceed to update the result in &lt;code&gt;acc&lt;&#x2F;code&gt; and decrease &lt;code&gt;aux&lt;&#x2F;code&gt; by one (which means that in the next step it will be even).&lt;&#x2F;p&gt;
&lt;p&gt;To convince ourselves, let’s take a short numerical example, while we follow the instructions. Let’s take &lt;code&gt;prime&lt;&#x2F;code&gt; as 11, &lt;code&gt;num&lt;&#x2F;code&gt; as 4, and &lt;code&gt;index&lt;&#x2F;code&gt; as 39.&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    1. We set `aux` equal to the remainder of 39 and 10 (which is also $\phi(11)$). We get `aux=9`.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    2. Since $9&amp;gt;0$, we go inside the while loop. $9$ is odd, so `acc=9` and `aux=8`.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    3. `aux` is even, so `base=4*4=16`; we have to reduce the number by taking the remainder by $11$, so `base=5` and `aux=4`.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    4. `aux` is even, so `base=5*5=25` and we get `base=3` and `aux=2`.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    5. `aux` is once again even, `base=9` and `aux=1`.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    6. `aux` is odd, we get `acc=9*4=36-&amp;gt;3` and `aux=0`.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    7. Since `aux=0`, we jump outside the while loop and the function returns the `FieldPoint` (`num`=3,`prime`=11).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Another function that we need is the greatest common divisor. A very simple form of the algorithm looks like this&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;pub fn gcd(a: u128,b: u128) -&amp;gt; u128 {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    let mut r0: u128=b;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    let mut r1: u128=a;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    if a&amp;gt;b {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        r0 = b;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        r1 = a;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    let mut r2: u128 = 1;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    while r2 &amp;gt;0 {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        r2=r1.rem_euclid(r0);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        r1=r0;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        r0=r2;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    r1&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We take two numbers $a$ and $b$ and we output their greatest common divisor. If $a$ is smaller than $b$ we initialize the dividend as $b$ and the divisor as $a$ (this makes us chop the larger number by the smaller one); otherwise we invert the selection. Next, we begin by reducing $r_1$ by $r_0$ and we change the roles (since $r_2$ is smaller then $r_0$). A numerical example helps illustrate the points:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    1. Take a=12, b=8 (we can immediately see that the right answer is 4, but this helps us see how the algorithm finds it).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    2. $r_0=8$, $r_1=12$, $r_2=1$ so we immediately enter the while loop.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    3. $r_2=4$ since the remainder of $12$ divided by $8$ is 4.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    4. $r_1=8$ and $r_0=4$.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    5. Since $r_2$ is not zero, we keep it inside the loop.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    6. $r_2=0$ (since $8$ is divisible by $4$), $r_1=4$ and $r_0=0$.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    7. Now $r_2=0$ so we exit the loop and the function outputs $gcd=4$.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Carmichael’s totient function can be easily calculated with the help from the previous function:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;pub fn lambda(p: u128,q: u128) -&amp;gt; u128 {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    let greatest_div: u128=gcd(p-1,q-1);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    (p-1)*(q-1)&#x2F;greatest_div&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Inverses can be easily calculated with help from the extended Euclidean algorithm:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;pub fn inversion(a:i128,b:i128) -&amp;gt; i128 {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    let mut t=0i128;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    let mut r=b;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    let mut t1=1i128;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    let mut r1=a;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    while r1 != 0i128 {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        let q=r.div_euclid(r1);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        (t,t1)=(t1,t-q*t1);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        (r,r1)=(r1,r-q*r1);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    if r != 1i128 {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        return 0i128;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    if t&amp;lt;0{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        t=t+b;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    t&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let’s see how it works for a simple case: $a=3$, $b=5$; the inverse of $3$ (modulo 5) is $2$. The algorithm begins:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    1. $t=0$, $t_1=1$, $r=5$, $r_1=3$.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    2. Since $r_1=3 \neq 0$ we loop: $q=1$, $t=1$, $t_1=0-1\times 1=-1$, $r=3$, $r_1=2$.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    3. $r_1 \neq 0$, $q=1$, $t=-1$, $t_1=1-1\times (-1)=2$, $r=2$, $r_1=1$.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    4. $r_1 \neq 0$, $q=2$, $t=2$, $t_1=-1-2\times 2=-5$, $r=1$ and $r_1=0$.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    5. $r_1 = 0$, so the function outputs $t=2$, which is the correct answer.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can test primality using the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Miller%E2%80%93Rabin_primality_test&quot;&gt;Miller-Rabin test&lt;&#x2F;a&gt;. Given an odd number $n$, we can write it as $n=2^r\times d +1$, for some $r&amp;gt; 0$ and $d$ an odd number. If $d$ is prime, then:&lt;br &#x2F;&gt;
$a^d \equiv 1 \pmod{n}$&lt;br &#x2F;&gt;
$a{2r \times d}\equiv -1 \pmod{n}$&lt;br &#x2F;&gt;
If $n$ is prime, then it satisfies Fermat’s little theorem and the only square roots of $1$ are $-1$ and $1$. If any of these conditions is not fulfilled, $n$ is not prime (if it passes, it could be composite, depending on the choice of $a$, known as the witness). Checking several $a$ allows us to make sure that the test passed for a composite number. The decomposition is easy to do:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;pub fn decompose(n: u128) -&amp;gt; (u128,u128) {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        let mut d: u128=n-1;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        let mut r: u128=0;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        while d%2 == 0 {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            d &#x2F;= 2;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            r += 1;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        (d,r)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since $n-1$ is even, we can take factors of $2$ repeatedly, until $d$ is no longer divisible by $2$. The condition can be checked faster by looking at the last bit of $n-1$.&lt;&#x2F;p&gt;
&lt;p&gt;The core of the Miller-Rabin test is (it yields true if it is probably prime):&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;fn miller_rabin(a: u128, n: u128, d: u128, r: u128) -&amp;gt; bool {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        let n_minus_one: u128 = n - 1u128;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        let field=FieldPoint::new(a,n);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        let mut x = field.power(d);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        let mut count: u128 =1;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        if x.num == 1 || x.num == n_minus_one {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            return true;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        while count &amp;lt; r {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            x = x.power(2u128);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            if x.num == n_minus_one {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;                return true;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            count += 1u128;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        false&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If you have a composite number and try several witnesses, it is very likely it will fail at least one (and stop at the first one) and so we can discard the number.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;We covered the basics of RSA and discussed its mathematical foundations. We also gave some of the attacks it may subjected to, especially when the implementation is not done properly. Finally, we gave some of the basic functions to build RSA (such as modular powers, calculating inverses and checking for primality via the Rabin-Miller test). Even if you could build your own RSA from scratch, it is not advisable, since it could be vulnerable to several attacks (unless it is very well implemented, of course).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;notes&quot;&gt;Notes&lt;&#x2F;h2&gt;
&lt;p&gt;(1) Even if you can code it very fast, there is no guarantee that your implementation is useful for real-life. There are several things to check and one should try to follow the standards. Besides, you should know cryptography and understand some of the underlying math).&lt;br &#x2F;&gt;
(2) For security reasons, $p$ and $q$ should have different number of digits (unless you want your system to be vulnerable to &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fermat%27s_factorization_method&quot;&gt;Fermat’s factorization&lt;&#x2F;a&gt;) and the selection should be truly random (careful with pseudorandom generators which are not meant for cryptographic applications, they are part of the recipe for disaster).&lt;br &#x2F;&gt;
(3) If you want something better, compute &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Carmichael_function&quot;&gt;Carmichael’s totient function&lt;&#x2F;a&gt; $\lambda (n)=lcm(q-1,p-1)$, where $lcm$ stands for least common multiple of $q-1$ and $p-1$. Whenever $\phi$ shows up, you can replace it with $\lambda$.&lt;br &#x2F;&gt;
(4) This is the same as saying that $d\times e-1$ is divisible by $\phi(n)$ or $d\times e=k\phi(n)+1$ for some integer $k$. &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Euler%27s_theorem&quot;&gt;Euler’s theorem&lt;&#x2F;a&gt; states that $a^{\phi(m)}\equiv 1 \pmod{m}$ if $a$ and $n$ are coprime.&lt;br &#x2F;&gt;
If we take $m=\phi(n)$ and $a=e$ we see that $e\times e^{\phi(\phi(n))-1}\equiv 1 \pmod{\phi(n)}$, $d=e^{\phi(\phi(n))-1}$, which means that $d$ can be calculated by performing powers of $e$.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Math Survival Kit for Developers</title>
        <published>2022-08-19T00:00:00+00:00</published>
        <updated>2022-08-19T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com/posts/math-survival-kit-for-developers/"/>
        <id>https://blog.lambdaclass.com/posts/math-survival-kit-for-developers/</id>
        
        <content type="html" xml:base="https://blog.lambdaclass.com/posts/math-survival-kit-for-developers/">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;When working with cryptographic applications you need to understand some of the underlying math (at least, if you want to do things properly). For example, the RSA cryptographic system (which was one of the earliest methods and most widely adopted, until it lost ground to better methods, such as those based on elliptic curves) works by encrypting a message $M$ (expressed as a number in the range 1,2,3,…$n-1$, with $n$ a large composite number) with a public key $e$ doing the following calculation:&lt;br &#x2F;&gt;
$E(M)=M^e \pmod{n}$&lt;br &#x2F;&gt;
If you want to decrypt the message, you need the private key, $d$ and perform:&lt;br &#x2F;&gt;
$M=E(M)^d \pmod{n}$.&lt;br &#x2F;&gt;
Now, what do all these calculations mean and why does RSA work? The trick relies on Euler’s theorem and the fact that $d$ and $e$ are related by $d\times e \equiv 1 \pmod{\phi(n)}$, so that when we apply $e$ and afterward $d$, “it is the same as” elevating the message to 1. Of course, there are quite many symbols you might not understand, but some key concepts are, in fact, quite straightforward. They are just shrouded in the mist by all the math jargon, which makes things very easy to state for those knowing the meaning, but it can be quite challenging for someone who is not acquainted with them.&lt;&#x2F;p&gt;
&lt;p&gt;Another problem frequently showing up is finding prime numbers (in general, very large numbers, with 100 or more digits) or determining whether a certain number is prime or composite. For example, in zk-SNARKs (zero-knowledge succinct non-interactive arguments of knowledge), one of the key ingredients is the ability to perform (something similar to) homomorphic encryption. This is achieved in practice by pairing two elliptic curves over two sets of numbers, where the total number of elements is the prime $m$, satisfying $m=k\times 2^N+1$, with $k$ an odd number and $N$ a large number. We say that $m$ has large 2-adicity and is expressed in compact form as $m-1\equiv 0 \pmod{2^N}$ or $2^N \mid m-1$ (this is read as $2^N$ divides $m-1$). In RSA, the number $n$ is the product of two large prime numbers, $p$ and $q$, that is, $n=p\times q$. If you choose two primes that are very close to each other, your cryptographic system could be easily broken using &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fermat%27s_factorization_method&quot;&gt;Fermat’s method to factorize numbers&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We see, therefore, that we need to understand the math behind it to know which tricks we can apply to solve a problem easily, how to break a cryptographic system or what are the limitations or weaknesses of our own systems. We will be explaining many key ideas of number theory and abstract algebra to help you build the foundations you need to deal with cryptography.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;natural-numbers-integers-rational-real-and-complex-numbers&quot;&gt;Natural numbers, Integers, Rational, Real and Complex numbers.&lt;&#x2F;h2&gt;
&lt;p&gt;Natural numbers are those we use to count objects and were the first things we learned at school: $1,2,3,4…$ are natural numbers. The set (collection) of these numbers is frequently represented by $\mathbb{N}$. Numbers like $-1$, $-2$, $0$, etc, are part of the integers; the set is represented by $\mathbb{Z}$ (from German, &lt;em&gt;zahlen&lt;&#x2F;em&gt; , numbers). Numbers that can be expressed as the ratio of two integers $a$ and $b$ (with $b\neq 0$) are called rational, $r=a&#x2F;b$ and the set is denoted by $\mathbb{Q}$. Rational numbers can be extended with the addition of irrational numbers (such as $\pi$ and $e$) to form the set of real numbers $\mathbb{R}$. You might have also heard of the complex numbers $\mathbb{C}$, which contain numbers such as $i$, where $i^2=-1$.&lt;&#x2F;p&gt;
&lt;p&gt;In the integers, we have the four basic operations: addition, subtraction, multiplication and division. Let’s focus first on addition and subtraction:&lt;br &#x2F;&gt;
If we take $a$ and $b$ in $\mathbb{Z}$, then $c=a+b$ and $d=a-b$ are also in $\mathbb{Z}$. We say the sum and subtraction are closed operations on the set.&lt;br &#x2F;&gt;
2. If we add $0$ to any number $a$, we get $a$, that is, $a+0=0+a=a$. $0$ is the additive identity of $\mathbb{Z}$.&lt;br &#x2F;&gt;
3. We know that if we sum $a$ and $-a$ we get $0$. That is, $a+(-a)=a-a=0$, so subtracting is the same as adding $-a$. $-a$ is the additive inverse of $a$.&lt;br &#x2F;&gt;
4. Given $a$, $b$ and $c$, $a+(b+c)=(a+b)+c$. This is the associative property.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;groups&quot;&gt;Groups&lt;&#x2F;h2&gt;
&lt;p&gt;The above properties show that the set of integers $\mathbb{Z}$ with the $.+.$ operation form an algebraic group. Other sets, combined with different operations, have the same mathematical structure. For example, positive rational numbers with multiplication have a group structure. $n\times n$ invertible matrices form a group under the matrix multiplication. &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Vector_space&quot;&gt;Vector spaces&lt;&#x2F;a&gt; form a group under the addition (if you take any two vectors $u$ and $v$, their sum is always in the vector space). Elliptic curve cryptography uses the fact that adding two points over an elliptic curve always results in a third point over the curve. Groups appear in many applications in Mathematics, Physics and Chemistry. We can define a group as a (non-empty) set $G$ together with a binary operation (that is, an operation that takes two input elements from the set $G$) $\times$ satisfying:&lt;br &#x2F;&gt;
G1. If $a$ and $b$ are in the set, then $a\times b=c$ is also in the set.&lt;br &#x2F;&gt;
G2. There is an identity element, $e$, such that $e\times a=a\times e=a$.&lt;br &#x2F;&gt;
G3. If $a$ is in the set, there is some $b$ in the set such that $a\times b=e$. We say that $b$ is the inverse of $a$ and denote it $b=a^{-1}$.&lt;br &#x2F;&gt;
G4. For $a,b,c$, $a\times (b\times c)=(a\times b)\times c$.&lt;&#x2F;p&gt;
&lt;p&gt;The notation in groups is sometimes confusing and people can freely use additive (+) or multiplicative ($\times$) notation, and call their identities either $0$ or $1$. This doesn’t matter much, since the binary operation can be quite weird (such as “addition” on elliptic curves). If you can start by looking at things a little bit more abstractly, it will pay off very quickly.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Exercise: Take the space of $n\times n$ matrices, such that their determinant is non-zero (that is, the set of invertible matrices). Show that this is a group.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We also learned at school that addition in the integers is commutative (that is, the order of the factors does not change the result $a+b=b+a$). Not all groups satisfy this condition, though. For those privileged groups, we have the name Abelian (or commutative) group. An Abelian group has an additional condition:&lt;br &#x2F;&gt;
G5. If $a$, $b$ are in $G$, $a\times b = b\times a$.&lt;&#x2F;p&gt;
&lt;p&gt;When we look at multiplication and division in the integers, we see that there are some problems.&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    1. If $a$ and $b$ are integers, $a\times b=c$ is also an integer. The operation is closed under multiplication.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    2. If we multiply any number by $1$, we get the same number. $1$ is the multiplicative identity.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    3. Given $a,b,c$, we have $a\times (b\times c)=(a\times b)\times c$.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    4. Given $a$, $b$ and $c$, $a\times (b+c)=a\times b+a\times c$ and $(b+c)\times a=b\times a+c\times a$. This is the distributive property.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    5. If $a$ and $b\neq 0$ are integers, their division $a&#x2F;b$ is not necessarily an integer. For example, $a=3$ and $b=2$ results in $c=3&#x2F;2$, which is a rational (not integer) number. In other words, the operation is not closed.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;rings-and-fields&quot;&gt;Rings and fields&lt;&#x2F;h2&gt;
&lt;p&gt;The set $\mathbb{Z}$ together with addition and multiplication forms a ring. The polynomials with ordinary addition and multiplication also form a ring. $n\times n$ matrices also form a ring under addition and multiplication. Formally, a ring is a set $R$ with two operations $+$ and $\times$ such that:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    1. R is an abelian group under $+$ (that is, R fulfills all the conditions for a group G1 to G4, plus commutativity, G5).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    2. There is a multiplicative identity $e$, such that $a\times e=e\times a=a$. Frequently, we use $e=1$.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    3. Multiplication is associative.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    4. We have the distributive property of multiplication concerning addition.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;em&gt;Exercise: Check that the $n\times n$ matrices form a ring with ordinary matrix addition and multiplication.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;If we look at the rational numbers, for any non-zero element, we have a multiplicative inverse. For example, $1&#x2F;5$ is the multiplicative inverse of $5$, since $5\times 1&#x2F;5=1$. The division is now a closed operation. Besides, multiplication is also commutative. $\mathbb{Q}$ with the ordinary addition and multiplication is a field. Other examples of fields are $\mathbb{R}$ and $\mathbb{C}$. When the number of elements in the set is finite (such as $4$, $2^{255}-19$, etc), the field is known as a finite field. These will be very important for cryptography.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;some-concepts-from-number-theory&quot;&gt;Some concepts from number theory&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;divisibility&quot;&gt;Divisibility&lt;&#x2F;h3&gt;
&lt;p&gt;We will start by talking about divisibility. Given two natural numbers, $a$ and $b$, we say that $a$ divides $b$ (and write it $a\mid b$) if there is another number $c$ such that $a\times c=b$. $a$ is called a divisor of $b$. If $a$ does not divide $b$, we write $a\nmid b$ and we can write $b=q\times a+r$, where $r&amp;lt;a$, with $q$ the quotient and $r$ the remainder of the division. If $a$ divides $b\times c$, then $a\mid b$ or $a\mid c$. Another fact is that if $a\mid b$ and $a\mid c$, then $a\mid (x\times b+y\times c)$ for any numbers $x,y$.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;prime-numbers&quot;&gt;Prime Numbers&lt;&#x2F;h3&gt;
&lt;p&gt;A number $p&amp;gt;1$ is called prime if its only divisors are $1$ and itself. Otherwise, the number is composite. Examples of prime numbers are $2,3,5,7,11,13,17,19,23,29,31,…$. The &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fundamental_theorem_of_arithmetic&quot;&gt;fundamental theorem of arithmetic&lt;&#x2F;a&gt; tells us that any number can be expressed in a unique way (up to ordering) as a product of powers of prime numbers. For example, $20=2^2\times 5$, $186=2\times 3\times 31$, $5=5$, etc. Finding prime numbers is crucial for cryptography. One easy way (but by no means practical for large numbers) to see whether a number $p$ is prime or not consists in checking whether it is divisible by all primer numbers smaller than $p$. The problem is that, if $p$ is very large, this can be pretty inefficient. There are some better and faster algorithms, but we will cover them some other time.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Exercise: Find all prime numbers that are smaller than 100.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;greatest-common-divisor-and-euclid-s-algorithm&quot;&gt;Greatest common divisor and Euclid’s algorithm&lt;&#x2F;h3&gt;
&lt;p&gt;An important concept is that of the greatest common divisor: given two numbers $a$ and $b$ we want to find the largest number $c$ such that $c\mid a$ and $c\mid b$. We denote this by $c=gcd(a,b)$ or simply $c=(a,b)$. For example, $20=2^2\times 5$ and $50=2\times 5^2$. Both numbers are divisible by $1,2,5,10$. $10$ is the greatest number dividing both and so $gcd(20,50)=10$. Two numbers $a,b$ are called relatively prime (or coprime) if $gcd(a,b)=1$. If $a$ and $b$ are both prime (and different), $1$ is the only common divisor. However, $8$ and $9$ are not prime themselves ($8=2^3$ and $9=3^2$), but their only common divisor is $1$ and are coprime.&lt;&#x2F;p&gt;
&lt;p&gt;The greatest common divisor satisfies the following equation, for some $x$ and $y$:&lt;br &#x2F;&gt;
$x\times a+y\times b=gcd(a,b)$&lt;br &#x2F;&gt;
The greatest common divisor can be found very efficiently using the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Euclidean_algorithm&quot;&gt;Euclidean algorithm&lt;&#x2F;a&gt; and the numbers $x$ and $y$ can also be found with little extra cost using the extended Euclidean algorithm.&lt;&#x2F;p&gt;
&lt;p&gt;To understand the algorithm, let’s look at an example: say we want to calculate the gcd(2502,864). The algorithm takes advantage that the remainder is always less than the divisor, so we can “chop down” the larger number; this chopping does not affect the largest common divisor.&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    1. Let&amp;#39;s find the remainder of $2502&#x2F;864$, $r_0=774$.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    2. Let&amp;#39;s find the remainder of $864&#x2F;774$, $r_1=90$.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    3. The remainder of $774&#x2F;90$ is $r_2=54$.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    4. $r_3=36$&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    5. $r_4=18$&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    6. $r_5=0$, since $36$ is divisible by $18$. So, the greatest common divisor is $18$.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can see, from the factorization of $864=2^5\times 3^3$ and $2502=2\times 3^2\times 139$, that the $gcd$ is equal to $2\times 3^2=18$. The advantage is that we found it in a few steps (6) and we didn’t have to know the factorization (which, for large numbers can be really hard to find. As a matter of fact, that is the key to the RSA cryptosystem).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;congruences-and-modular-arithmetic&quot;&gt;Congruences and modular arithmetic&lt;&#x2F;h3&gt;
&lt;p&gt;One problem we face with computers is that the numbers we can work with are limited. Besides, in some cases, we are not interested in a number itself, but rather in its belonging to a certain class or group. For example, when we bet on a roulette, we can choose whether the result will be even or odd. If it is even, then $r=2\times k$, for some $k \in {0,1,2,3…18}$. If it is odd, then $r=2\times k+1$. We notice that if we want to check parity, we only need to look at the remainder, which can take two values in this case: $0$ or $1$. In fact, when we want to check whether a number is even in the computer, we look at the leftmost bit and check whether it is zero or not. For the case of $2$, we see that any number $a$ satisfies either:&lt;br &#x2F;&gt;
$a\equiv 0 \pmod{2}$&lt;br &#x2F;&gt;
$a\equiv 1 \pmod{2}$&lt;br &#x2F;&gt;
We say that $a$ is congruent to $0$ (or $1$) modulo $2$. This way, we split all the numbers into two categories: even and odd. We can do the same for any number $p&amp;gt;1$, remembering that the remainder is $0 \leq r \leq p-1$. This can also be seen as $a\equiv r \pmod{p}$ as $p\mid a-r$ or $a=k\times p+r$. This notation was invented by Gauss and is really powerful to study a lot of complex problems. We can perform usual operations such as addition and multiplication, but we have to be careful of how things work, given that results will always have to be in the range $0 \leq r \leq p-1$ (As a side note, you could choose a different range, such as ${-2,-1,0,1,2,p-3}$, but it can be confusing and we should better stick to our first choice).&lt;&#x2F;p&gt;
&lt;p&gt;In the case of the sum, we can add them just as regular numbers and, if the result exceeds $p$, take the remainder. For example, let’s take $p=7$, so the elements we have are ${0,1,2,3,4,5,6}$. First, we see that $0$ is an element of the set and that adding it to any number does not change the result. If we add $2$ and $3$ the result is $5$. If we add $5$ and $4$, we get $9$, but&lt;br &#x2F;&gt;
$4+5=9\equiv 2 \pmod{7}$&lt;br &#x2F;&gt;
$2$ is just the remainder of the division of $9$ by $7$. We see that the result stays in the original set. What happens when we add $4$ and $3$?&lt;br &#x2F;&gt;
$4+3=7\equiv 0 \pmod{7}$&lt;br &#x2F;&gt;
We get $0$! That is because $7$ is divisible by itself and the remainder is $0$. We see that $4$ is the additive inverse of $3$ under this arithmetic. Similarly, $1$ and $6$ are each other’s inverse, $2$ and $5$. We can recognize that the set ${0,1,2,3,4,5,6}$ with the sum done modulo $7$ is an abelian group. Subtraction can be easily defined as adding the inverse of the number or just performing ordinary subtraction and then taking the result modulo $p$.&lt;&#x2F;p&gt;
&lt;p&gt;With multiplication we get something similar. For example,&lt;br &#x2F;&gt;
$4\times 5=20\equiv 6 \pmod{7}$.&lt;br &#x2F;&gt;
Taking the modulo operation ensures that we always stay inside the set. We also see that $1$ works as the multiplicative identity since any number multiplied by $1$ stays the same. Let’s look at what happens with $6\times 6$:&lt;br &#x2F;&gt;
$6\times 6=36\equiv 1 \pmod{7}$.&lt;br &#x2F;&gt;
We multiplied $6$ by itself and got $1$! We talked before that division $a&#x2F;b$ could be restated as $a\times b^{-1}$, where $b\times b^{-1} = 1 = b^{-1} \times b$. We see that $6$ is its own multiplicative inverse with the multiplication modulo $p$. We can also see that:&lt;br &#x2F;&gt;
$3\times 5 = 15\equiv 1 \pmod{7}$&lt;br &#x2F;&gt;
$2\times 4 = 8\equiv 1 \pmod{7}$&lt;br &#x2F;&gt;
So, $3 = 5^{-1}$ and $2 = 4^{-1}$! This can sound weird, but we have to remember that we are working with congruence. We can understand the precise meaning of this by rephrasing. Let’s take the case of $6$ and $6$. There are two numbers $a = q_1\times 7+6$ and $b = q_2\times 7+6$ (because that is what the congruence means). Let’s take the product $a\times b$:&lt;br &#x2F;&gt;
$a\times b = (q_1\times 7+6)\times (q_2\times 7+6)$&lt;br &#x2F;&gt;
Let’s apply the distributive law:&lt;br &#x2F;&gt;
$a\times b = q_1\times q_2 \times 7^2+6\times 7\times (q_1+q_2)+36$&lt;br &#x2F;&gt;
Let’s split this further $36=1+35=1+7\times 5$ and regroup, taking as a common factor $7$:&lt;br &#x2F;&gt;
$a\times b = 7\times (q_1\times q_2\times 7+6\times(q_1+q_2)+5)+1$&lt;br &#x2F;&gt;
The first term is divisible by $7$, so it is congruent to $0$. Or, if we subtract $1$ to $a\times b$, we see that it is divisible by $7$ (since it is the product of $7$ and an integer).&lt;&#x2F;p&gt;
&lt;p&gt;We can see that, if $p$ is prime, then the set ${0,1,2,…p-1}$ with addition and multiplication modulo $p$ is a finite field.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Exercise: Prove that this is indeed a finite field.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;mathbb-z-n-mathbb-z-as-a-group-cyclic-groups&quot;&gt;$\mathbb{Z}&#x2F;n\mathbb{Z}$ as a group. Cyclic groups.&lt;&#x2F;h3&gt;
&lt;p&gt;You will frequently see these sets are denoted as $\mathbb{Z}&#x2F;p\mathbb{Z}$. We have to be very careful if we want to work with $n$ not prime in $\mathbb{Z}&#x2F;n\mathbb{Z}$ (in this case, it is not a finite field either). For example, let’s try to solve this equation:&lt;br &#x2F;&gt;
$(x+2)\times(x+1)\equiv 0 \pmod{12}$&lt;br &#x2F;&gt;
We could use our knowledge of math and, when the product of two numbers is $0$, at least one of them is $0$ (spoiler’s alert: this will go wrong):&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    1. $(x+2)\equiv 0 \pmod{12}$. If $x=10$, then $x+2=12\equiv 0$, since it is divisible by 12.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    2. $(x+1)\equiv 0 \pmod{12}$. If $x=11$, then $x+1=12\equiv 0$, since it is divisible by 12.  &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let’s pick now $2$ and see what happens:&lt;br &#x2F;&gt;
$(2+2)\times(2+1)=12\equiv 0 \pmod{12}$.&lt;br &#x2F;&gt;
So $2$ is a solution to the equation, but $2+2\equiv 4\not\equiv 0$ and $2+1\equiv 3\not\equiv 0$. This happens because $12$ is not a prime number.&lt;&#x2F;p&gt;
&lt;p&gt;As a matter of fact, given $a$ and $n$, we have that $a$ has an inverse (modulo $n$) if and only if $gcd(a,n)=1$, that is, $a$ and $n$ are coprime. In the previous example, $3$ is not coprime to $12$ (they have $3$ as a common divisor).&lt;&#x2F;p&gt;
&lt;p&gt;If the set is not too large, we can find inverses just by trial and error. However, it would be nice to have some results that help us compute inverses and how to calculate (integer) powers of numbers.&lt;&#x2F;p&gt;
&lt;p&gt;Let’s focus on a prime number $p$ and take all the non-zero elements of the set, $(\mathbb{Z}&#x2F;p\mathbb{Z})^\star$. Let’s fix $p=7$, so $(\mathbb{Z}&#x2F;p\mathbb{Z})^\star = {1,2,3,4,5,6}$ and let’s focus on multiplication over the set. We can define the power $a^n=a\times a\times a\times …\times a$. Obviously, $1$ is not interesting, because $1^n=1$, so let’s take $5$:&lt;br &#x2F;&gt;
$5^1\equiv 5 \pmod{7}$&lt;br &#x2F;&gt;
$5^2\equiv 4 \pmod{7}$&lt;br &#x2F;&gt;
$5^3\equiv 6 \pmod{7}$&lt;br &#x2F;&gt;
$5^4\equiv 2 \pmod{7}$&lt;br &#x2F;&gt;
$5^5\equiv 3 \pmod{7}$&lt;br &#x2F;&gt;
$5^6\equiv 1 \pmod{7}$&lt;br &#x2F;&gt;
$5^7\equiv 5 \pmod{7}$&lt;br &#x2F;&gt;
$5^8\equiv 4 \pmod{7}$&lt;br &#x2F;&gt;
$5^{13}\equiv 5 \pmod{7}$&lt;br &#x2F;&gt;
We see that the powers of $5$ span all the elements of the group. We also see that numbers repeat themselves at an interval of $6$, that is $4 = 5^2 = 5^8 = 5^{14}…$. Let’s look at $3$:&lt;br &#x2F;&gt;
$3^1\equiv 3 \pmod{7}$&lt;br &#x2F;&gt;
$3^2\equiv 2 \pmod{7}$&lt;br &#x2F;&gt;
$3^3\equiv 6 \pmod{7}$&lt;br &#x2F;&gt;
$3^4\equiv 4 \pmod{7}$&lt;br &#x2F;&gt;
$3^5\equiv 5 \pmod{7}$&lt;br &#x2F;&gt;
$3^6\equiv 1 \pmod{7}$&lt;br &#x2F;&gt;
$3^7\equiv 3 \pmod{7}$&lt;br &#x2F;&gt;
We got all the elements (albeit in a different order). Finally, let’s look at $2$:&lt;br &#x2F;&gt;
$2^1\equiv 2 \pmod{7}$&lt;br &#x2F;&gt;
$2^2\equiv 4 \pmod{7}$&lt;br &#x2F;&gt;
$2^3\equiv 1 \pmod{7}$&lt;br &#x2F;&gt;
$2^4\equiv 2 \pmod{7}$&lt;br &#x2F;&gt;
This time we didn’t span all the elements of the group and we got to the same number after $3$. We will show that these results are valid in general (provided we’re working modulo a prime number).&lt;&#x2F;p&gt;
&lt;p&gt;First, we can prove that the set $(\mathbb{Z}&#x2F; p\mathbb{Z})^\star$ together with multiplication forms an abelian group (the product can never give 0 since all the numbers are not divisible by $p$). Second, the group is finite, since the number of elements is finite (6 in our example); its order is $6$. We also saw that by repeatedly multiplying $5$ by itself (that is, taking powers of $5$), we can generate all the elements of the group (note that everything repeats after $6$, which is the order of the group). Since the group can be generated by one of its elements, it is a (finite) cyclic group.&lt;&#x2F;p&gt;
&lt;p&gt;For an element $a$, the lowest positive integer $n$ such that $a^n\equiv 1 \pmod{p}$ is known as the order of $a$. The elements of the group with their respective order in parentheses are: $1 (1)$, $2 (3)$, $3 (6)$, $4 (2)$, $5(6)$, $6(2)$. We can see that the orders of each element divide the order of the group, $6$. We will present the following theorems, which show that this is not a coincidence.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;three-useful-theorems-and-the-magic-behind-rsa&quot;&gt;Three useful theorems and the magic behind RSA&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fermat%27s_little_theorem&quot;&gt;Fermat’s Little Theorem&lt;&#x2F;a&gt;: If $p$ is prime, then, for any integer $a$ we have that $a^p-a$ is divisible by $p$:&lt;br &#x2F;&gt;
$a^p\equiv a \pmod{p}$.&lt;br &#x2F;&gt;
&lt;em&gt;Exercise: Check that this is indeed valid for all elements of $(\mathbb{Z}&#x2F;7\mathbb{Z})^\star$&lt;&#x2F;em&gt;&lt;br &#x2F;&gt;
If $a$ is coprime to $p$, we can write this equivalently:&lt;br &#x2F;&gt;
$a^{p-1}\equiv 1 \pmod{p}$&lt;br &#x2F;&gt;
An interesting consequence is that we can calculate inverses by doing $a^{-1} = a^{p-2}$, even though in some cases we are overestimating the power (for example, $6\times 6\equiv 1 \pmod{7}$).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Euler%27s_theorem&quot;&gt;Euler’s theorem&lt;&#x2F;a&gt;: If $a$ and $n$ are positive coprime integers, then $a^{\phi(n)}\equiv 1 \pmod{n}$, where $\phi(n)$ is &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Euler%27s_totient_function&quot;&gt;Euler’s phi (or totient) function&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Euler’s $\phi(n)$ function counts the numbers $m &amp;lt; n$ that are coprime to $n$. For example, if we take $n = 5$, the numbers $1,2,3,4$ are all coprime to $5$ and $\phi(5) = 4$ (this is reasonable, since $5$ is prime). If we take $8$, we have ${ 1 , 2 , 3 , 4 , 5 , 6 , 7}$; however, only $1,3,5,7$ are coprime to $8$, so $\phi(8)=4$. For prime numbers, we have&lt;br &#x2F;&gt;
$\phi(p)=p-1$&lt;br &#x2F;&gt;
so, Euler’s theorem gives us Fermat’s theorem as a particular case. Another useful property is that if $m$ and $n$ are relatively prime, then&lt;br &#x2F;&gt;
$\phi(m\times n)=\phi(n)\times \phi(m)$&lt;br &#x2F;&gt;
This shows that $\phi$ is a &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Multiplicative_function&quot;&gt;multiplicative function&lt;&#x2F;a&gt;. In particular, if $n$ is the product of two primes, $p$ and $q$, then&lt;br &#x2F;&gt;
$\phi(n) = (p-1)\times (q-1)$&lt;br &#x2F;&gt;
RSA’s working principle is here. The public key $e$ and private $d$ are multiplicative inverses, modulo $\phi(n)$,&lt;br &#x2F;&gt;
$d\times e \equiv 1 \pmod{\phi(n)}$&lt;br &#x2F;&gt;
This means that $d\times e = 1+k\phi(n)$ for some integer $k$, so when we compute&lt;br &#x2F;&gt;
$M^{ e \times d } = M^{ 1 + k \phi(n) } = M \times M^{ k \phi(n) } \equiv M \pmod{n}$&lt;br &#x2F;&gt;
since $M^{k \phi(n) } = {(M^{ \phi(n) })}^k \equiv 1^k \pmod{n}$. RSA is only as hard as it is factoring the number $n$ and over the years the length of the keys has increased significantly (it is around 2000 to 4000 bits); elliptic curves, on the other hand, give the same level of security for shorter keys.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;subgroups-lagrange-s-theorem&quot;&gt;Subgroups. Lagrange’s theorem&lt;&#x2F;h3&gt;
&lt;p&gt;We saw that the order of $(\mathbb{Z}&#x2F;7\mathbb{Z})^\star$ was 6 and that if we take any element $a$, doing $a^6\equiv 1 \pmod{7}$. However, for $2$ we can do $2^3\equiv 1 \pmod{7}$. A subgroup $H$ is a subset of $G$, that is itself a group, that is, satisfies G1-G4. For example, if we consider the subset $H={1}$, this is a subgroup of order $1$. Why? Because $1\times 1=1$, so the operation is closed and all other properties follow from the operations of the group $G$. $G$ is also a subgroup of itself. These two are called the trivial subgroups of $G$ (which are not very interesting). The set ${1,2,4}$ is a subgroup of $(\mathbb{Z}&#x2F;7\mathbb{Z})^\star$. To check this, we need to see that if an element is in the set, so is its inverse, the identity belongs to the set and the operation is closed. Let’s check this:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * $1$ is in the set and $1$ is its own inverse.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    * The operation is closed, because $2\times 2\equiv 4 \pmod{7}$, because $4\times 4=16\equiv 2 \pmod{7}$ and because $2\times 4=8\equiv 1 \pmod{7}$ (we don&amp;#39;t need to check the products with $1$ since that is obvious). We also checked the inverses, since $4=2^{-1}$.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The subset ${1,2,4}$ forms a subgroup of order $3$. &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lagrange%27s_theorem_(group_theory)&quot;&gt;Lagrange’s theorem&lt;&#x2F;a&gt; states that the order of a subgroup divides the order of the group. We have another subgroup ${1,6}$, which is of order $2$. These are non-trivial subgroups. If the order of a group is prime, then its only subgroups are the trivial subgroups (since $p$ is prime, the subgroups can only be of order $1$ and $p$). A group whose only subgroups are the trivial ones is known as a simple group. For example, $\mathbb{Z}&#x2F;7\mathbb{Z}$ with addition is the group ${0,1,2,3,4,5,6}$ of order $7$. There are no subgroups other than the whole group and ${0}$. Note that the order of each element (other than zero, which has order $1$) is $7$, since $7\times a=a+a+a+a+a+a+a$ is divisible by $7$ and, therefore, congruent to $0$ modulo $7$. The fact that some groups can be broken down into smaller subgroups is of concern when working with elliptic curves: if the group is not of prime order, it can be broken down into smaller groups and an attacker may break the system by performing searches on these subgroups.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-discrete-logarithm-problem&quot;&gt;The discrete logarithm problem&lt;&#x2F;h3&gt;
&lt;p&gt;Given a group, we can apply the operation repeatedly on a point $g$ to get to a point $P$, that is $g^k=g\times g\times g\times … \times g=P$. For example, in $(\mathbb{Z}&#x2F;7\mathbb{Z})^\star$, $5$ generates all the elements by successive multiplications with itself. We could then ask how many times $x$ should we multiply $5$ with itself to get to $3$, that is, $5^x\equiv 3 \pmod{7}$. Since we know that the order of the group is $6$, we should only concern ourselves with numbers $0-6$. If we look above or try all combinations, $5^5\equiv 3 \pmod{7}$ so $x=5$. Similarly, if we look for $y$ such that $5^y\equiv 4 \pmod{7}$, we get $y=2$. The problem of finding $x$ so that $g^k=P$ is known as the discrete logarithm problem (in number theory, $x$ and $y$ are known as indices). We quickly see that this logarithm works quite differently from the common logarithm on the real numbers (though the idea is the same, given $y$, find $x$ such that $e^x=y$). There is no obvious pattern, it is not increasing and if we had to search over a large set, it could be really daunting. Many cryptographic systems rely on the hardness of this problem over a finite cyclic group.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;We presented some basic terms and concepts from number theory and algebra that will be useful when reading cryptography, since many key concepts and strategies rely on math. The notions of groups, rings and fields and prime numbers show up almost all the time. Soon we will continue with other important tools and concepts that will help us understand how elliptic curve cryptography works, how to perform faster operations over groups and how to combine elliptic curves to build zk-SNARKs.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>What every developer needs to know about elliptic curves</title>
        <published>2022-08-06T00:00:00+00:00</published>
        <updated>2022-08-06T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com/posts/what-every-developer-needs-to-know-about-elliptic-curves/"/>
        <id>https://blog.lambdaclass.com/posts/what-every-developer-needs-to-know-about-elliptic-curves/</id>
        
        <content type="html" xml:base="https://blog.lambdaclass.com/posts/what-every-developer-needs-to-know-about-elliptic-curves/">&lt;p&gt;Elliptic curves (EC) have become one of the most useful tools for modern cryptography. They were proposed in the 1980s and became widespread used after 2004. Its main advantage is that it offers smaller key sizes to attain the same level of security of other methods, resulting in smaller storage and transmission requirements. For example, EC cryptography (ECC) needs 256-bit keys to attain the same level of security as a 3000-bit key using RSA (another public-key cryptographic system, born in the late 70s). ECC and RSA work by hiding things inside a certain mathematical structure known as a finite cyclic group (we will explain this soon). The hiding is done rather in plain sight: you could break the system if you could reverse the math trick (spoiler alert: if done properly, it would take you several lifetimes). It is as if you put $1.000.000 inside an unbreakable glass box and anyone could take it if they could break it.&lt;&#x2F;p&gt;
&lt;p&gt;In order to understand these objects and why they work, we need to go backstage and look at the math principles (we won’t enter into the hard details or proofs, but rather focus on the concepts or ideas). We will start by explaining finite fields and groups and then jump onto the elliptic curves (over finite fields) and see whether all curves were created equal for crypto purposes.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;finite-fields&quot;&gt;Finite fields&lt;&#x2F;h2&gt;
&lt;p&gt;We know examples of fields from elementary math. The rational, real and complex numbers with the usual notions of sum and multiplication are examples of fields (these are not finite though).&lt;&#x2F;p&gt;
&lt;p&gt;A finite field is a set equipped with two operations, which we will call + and ×. These operations need to have certain properties in order for this to be a field:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;If &lt;em&gt;a&lt;&#x2F;em&gt; and &lt;em&gt;b&lt;&#x2F;em&gt; are in the set, then &lt;em&gt;c=a+b&lt;&#x2F;em&gt; and &lt;em&gt;d=a×b&lt;&#x2F;em&gt; should also be in the set. This is what is mathematically called a closed set under the operations +, ×.&lt;&#x2F;li&gt;
&lt;li&gt;There is a zero element, 0, such that &lt;em&gt;a&lt;&#x2F;em&gt; +0=&lt;em&gt;a&lt;&#x2F;em&gt; for any a in the set. This element is called the additive identity.&lt;&#x2F;li&gt;
&lt;li&gt;There is an element, 1, such that 1× &lt;em&gt;a&lt;&#x2F;em&gt; =&lt;em&gt;a&lt;&#x2F;em&gt; for any a in the set. This element is the multiplicative identity.&lt;&#x2F;li&gt;
&lt;li&gt;If a is in the set, there is an element &lt;em&gt;b&lt;&#x2F;em&gt; , such that &lt;em&gt;a+b&lt;&#x2F;em&gt; =0. We call this element the additive inverse and we usually write it as &lt;em&gt;−a&lt;&#x2F;em&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;If &lt;em&gt;a&lt;&#x2F;em&gt; is in the set, there is an element &lt;em&gt;c&lt;&#x2F;em&gt; such that &lt;em&gt;a×c=1&lt;&#x2F;em&gt;. This element is called the multiplicative inverse and we write is as &lt;em&gt;a&lt;&#x2F;em&gt; −1.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Before we can talk about examples of finite fields, we need to introduce the modulo arithmetic.&lt;&#x2F;p&gt;
&lt;p&gt;We learned that given a natural number or zero, &lt;em&gt;a&lt;&#x2F;em&gt; and a non-zero number &lt;em&gt;b&lt;&#x2F;em&gt; , we could write out a in the following way &lt;em&gt;a=q×b+r&lt;&#x2F;em&gt; where &lt;em&gt;q&lt;&#x2F;em&gt; is the quotient and &lt;em&gt;r&lt;&#x2F;em&gt; is the remainder of the division of &lt;em&gt;a&#x2F;b&lt;&#x2F;em&gt;. This &lt;em&gt;r&lt;&#x2F;em&gt; can take values 0,1,2,…,b−1 We know that if &lt;em&gt;r&lt;&#x2F;em&gt; is zero, then a is a multiple of &lt;em&gt;b&lt;&#x2F;em&gt;. It may not seem new, but this gives us a very useful tool to work with numbers. For example, if &lt;em&gt;b&lt;&#x2F;em&gt; =2 then &lt;em&gt;r&lt;&#x2F;em&gt; =0,1. When it is 0, &lt;em&gt;a&lt;&#x2F;em&gt; is even (it is divisible by 2) and when it is 1, &lt;em&gt;a&lt;&#x2F;em&gt; is odd. A simple way to rephrase this (due to Gauss):&lt;&#x2F;p&gt;
&lt;p&gt;a≡1(mod2)&lt;&#x2F;p&gt;
&lt;p&gt;if &lt;em&gt;a&lt;&#x2F;em&gt; is odd and&lt;&#x2F;p&gt;
&lt;p&gt;a≡0(mod2)&lt;&#x2F;p&gt;
&lt;p&gt;if &lt;em&gt;a&lt;&#x2F;em&gt; is even. We can see that if we sum two odd numbers &lt;em&gt;a1&lt;&#x2F;em&gt; and &lt;em&gt;a2&lt;&#x2F;em&gt; ,&lt;&#x2F;p&gt;
&lt;p&gt;a1+a2≡1+1≡0(mod2)&lt;&#x2F;p&gt;
&lt;p&gt;This shows us that, if we want to know whether a sum is even or not, we can simply sum the remainders of their division by 2 (an application of this is that in order to check divisibility by two, we should only look at the last bit of the binary representation).&lt;&#x2F;p&gt;
&lt;p&gt;Another situation where this arises every day is with time. If we are on Monday at 10 am and we have 36 hours till the deadline of a project, we have to submit everything by Tuesday 10 pm. That is because 12 fits exactly 3 times in 36, leading to Mon-10 pm, Tue-10 am, Tue-10 pm. If we had 39 hours, we jump to Wed-1 am.&lt;&#x2F;p&gt;
&lt;p&gt;An easy way to look at this relation (formally known as congruence modulo p) is that if &lt;em&gt;a≡b&lt;&#x2F;em&gt;(mod &lt;em&gt;p&lt;&#x2F;em&gt;), then &lt;em&gt;p&lt;&#x2F;em&gt; divides &lt;em&gt;a−b&lt;&#x2F;em&gt; , or &lt;em&gt;a=k×p+b&lt;&#x2F;em&gt; for an integer &lt;em&gt;k&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;More informally, we see that operating (mod &lt;em&gt;p&lt;&#x2F;em&gt;) wraps around the results of certain calculations, giving always numbers in a bounded range by &lt;em&gt;p&lt;&#x2F;em&gt; −1.&lt;&#x2F;p&gt;
&lt;p&gt;We can see that if a1≡b1(modp) and a2≡b2(modp), then a1+a2≡b1+b2(mod &lt;em&gt;p&lt;&#x2F;em&gt;) (if b1+b2&amp;gt;p we can wrap around the result). Similar results apply when using subtraction and multiplication. Division presents some difficulties, but we can change things a little bit and make it work this way: instead of thinking of dividing &lt;em&gt;a÷b&lt;&#x2F;em&gt; we can calculate &lt;em&gt;a×b−1&lt;&#x2F;em&gt; , where &lt;em&gt;b&lt;&#x2F;em&gt; −1 is the multiplicative inverse of &lt;em&gt;b&lt;&#x2F;em&gt; (remember &lt;em&gt;b×b −1&lt;&#x2F;em&gt;=1). Consider &lt;em&gt;p&lt;&#x2F;em&gt; =5, so the elements of the group are 0,1,2,3,4.&lt;&#x2F;p&gt;
&lt;p&gt;We can see that 1 is its own multiplicative inverse, since 1×1=1≡1  (mod5). If we take 2 and 3, then 2×3=6≡1  (mod5) (so 3 is the multiplicative inverse of 2) and 4×4=16≡1 (mod5). The set and the operations defined satisfy the conditions for a field.&lt;&#x2F;p&gt;
&lt;p&gt;We can also define integer powers of field elements in a simple way. If we want to square a number &lt;em&gt;a&lt;&#x2F;em&gt; , it is just doing &lt;em&gt;a×a&lt;&#x2F;em&gt; and take mod &lt;em&gt;p&lt;&#x2F;em&gt;. If we want a cube, we do &lt;em&gt;a×a×a&lt;&#x2F;em&gt; and take mod &lt;em&gt;p&lt;&#x2F;em&gt;. RSA uses exponentiation to perform encryption. It is easy to see that if the exponent is rather large (or the base is very large, or both), numbers get really big. For example, we want to evalute 265536(mod &lt;em&gt;p&lt;&#x2F;em&gt;). When we reach a 1000, we get numbers with over 300 digits and we are still a long way to go. We can do this calculation much simpler realizing that 65536=216 and squaring the number and taking the remainder every time. We end up doing only 16 operations like this, instead of the original 65536! thus avoiding huge numbers. A similar strategy will be used when we work with ECs!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;groups&quot;&gt;Groups&lt;&#x2F;h2&gt;
&lt;p&gt;We saw that whenever we add two even integers, we get another one. Besides, as 0 is even and if we sum &lt;em&gt;a&lt;&#x2F;em&gt; and &lt;em&gt;−a&lt;&#x2F;em&gt; we get 0, which is the identity element for the sum. Many different objects have a similar behavior when equipped with a certain operation. For example, the multiplication of two invertible matrices results in an invertible matrix. If we consider the set of invertible matrices of &lt;em&gt;N&lt;&#x2F;em&gt; × &lt;em&gt;N&lt;&#x2F;em&gt; equipped with the multiplication, we can see that if &lt;em&gt;A&lt;&#x2F;em&gt; is in the set, &lt;em&gt;A −1&lt;&#x2F;em&gt; is in the set; the identity matrix is in the set (and it plays the role of identity element with respect to multiplication). In other words, some sets equipped with a certain operation share some properties and we can take advantage of the knowledge of this structure. The set, together with the operation, forms a group. Formally, a group is a set &lt;em&gt;G&lt;&#x2F;em&gt; equipped with a binary operation × such that:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; 1. The operation is associative, that is, _(a×b)×c=a×(b×c)_.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; 2. There is an identity element, _e: e×a=a_ and _a×e=a_. &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; 3. For every element _a_ in the set, there is an element _b_ in the set such that _a×b=e_ and _b×a=e_. We denote _b=a−1_ for simplicity.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can easily see that any field is, in particular, a group with respect to each one of its two operations (conditions 1, 2 and 4 for the field indicate it is also a group with respect to the sum and 1, 3 and 5 for multiplication). If the operation is commutative (that is, &lt;em&gt;a×b=b×a&lt;&#x2F;em&gt;) the group is known as an abelian (or commutative) group. For example, the invertible matrices of &lt;em&gt;N×N&lt;&#x2F;em&gt; form a group, but it is not abelian, since &lt;em&gt;A×B≠B×A&lt;&#x2F;em&gt; for some matrices &lt;em&gt;A&lt;&#x2F;em&gt; and &lt;em&gt;B&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We will be interested in finite groups (those where the set contains a finite number of elements) and, in particular, cyclic groups. These are groups which can be generated by repeatedly applying the operation over an element &lt;em&gt;g&lt;&#x2F;em&gt; , the generator of the group. The &lt;em&gt;n&lt;&#x2F;em&gt; -th roots of unity in the complex numbers form an example of a cyclic group under multiplication; this is the set of solutions of &lt;em&gt;x n&lt;&#x2F;em&gt;=1, which are of the form exp(2 &lt;em&gt;πik&#x2F;n&lt;&#x2F;em&gt;), with &lt;em&gt;k&lt;&#x2F;em&gt; =0,1,2…,&lt;em&gt;n&lt;&#x2F;em&gt; −1. This group can be generated by taking integer powers of exp(2 &lt;em&gt;πi&#x2F;n&lt;&#x2F;em&gt;). The roots of unity play an important role in the calculation of the fast Fourier transform (FFT), which has many applications.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;elliptic-curves-in-a-nutshell&quot;&gt;Elliptic curves in a nutshell&lt;&#x2F;h2&gt;
&lt;p&gt;Elliptic curves are very useful objects because they allow us to obtain a group structure with interesting properties. Given a field &lt;em&gt;F&lt;&#x2F;em&gt; , an elliptic curve is the set of points &lt;em&gt;(x,y)&lt;&#x2F;em&gt; which satisfy the following equation:&lt;&#x2F;p&gt;
&lt;p&gt;_y 2+a1xy+a3y=x3+a2x2+a4x+a6 _&lt;&#x2F;p&gt;
&lt;p&gt;This is known as the general Weierstrass equation. In many cases, this can be written in the simpler form&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;y 2=x3+ax+b&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;which is the (Weierstrass) short-form. Depending on the choice of the parameters a and b and the field, the curve can have some desired properties or not. If _4a 3+27b2≠0 _, the curve is non-singular.&lt;&#x2F;p&gt;
&lt;p&gt;We can define an operation which allows us to sum elements belonging to the elliptic curve and obtain a group. This is done using a geometric construction, the chord-and-tangent rule. Given two points on the curve &lt;em&gt;P1=(x 1,y1)&lt;&#x2F;em&gt; and &lt;em&gt;P 2=(x2,y2)&lt;&#x2F;em&gt;, we can draw a line connecting them. That line intersects the curve on a third point &lt;em&gt;P 3=(x3,y3)&lt;&#x2F;em&gt;. We set the sum of &lt;em&gt;P 1&lt;&#x2F;em&gt; and &lt;em&gt;P 2&lt;&#x2F;em&gt; as &lt;em&gt;(x 3,−y3)&lt;&#x2F;em&gt;, that is, point &lt;em&gt;P 3&lt;&#x2F;em&gt; flipped around the &lt;em&gt;x&lt;&#x2F;em&gt; -axis. The formulae are:  &lt;img src=&quot;&#x2F;images&#x2F;2022&#x2F;12&#x2F;imagen-1.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We can easily see that we have a problem if we try to sum &lt;em&gt;P 1=(x1,y1)&lt;&#x2F;em&gt; and &lt;em&gt;P 2=(x1,−y1)&lt;&#x2F;em&gt;. We need to add an additional point to the system, which we call the point at infinity &lt;em&gt;O&lt;&#x2F;em&gt;. This inclusion is necessary to be able to define the group structure and works as the identity element for the group operation.&lt;&#x2F;p&gt;
&lt;p&gt;Another problem appears when we want to sum &lt;em&gt;P 1&lt;&#x2F;em&gt; and &lt;em&gt;P 1&lt;&#x2F;em&gt; to get to &lt;em&gt;P 3=2P1&lt;&#x2F;em&gt;. But, if we draw the tangent line to the curve on P1, we see that it intersects the curve at another point. If we want to perform this operation, we need to find the slope of the tangent line and find the intersection:&lt;&#x2F;p&gt;
&lt;p&gt;$$s=\frac{3x21+a}{2y1}$$&lt;br &#x2F;&gt;
$$x3=s2−2x1$$&lt;br &#x2F;&gt;
$$y3=s(x1−x3)−y1$$&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;2022&#x2F;12&#x2F;imagen-5.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;It takes a little bit of work, but we can prove that the elliptic curve with this operation has the properties of a group. We will use finite fields to work with these curves and the groups that we will obtain are finite cyclic groups, that is, groups which can be generated by repeteadly using the operation on a generator, &lt;em&gt;g: g,2g,3g,4g,5g,….&lt;&#x2F;em&gt; &lt;img src=&quot;&#x2F;images&#x2F;2022&#x2F;12&#x2F;imagen-3.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;If we plot the collection of points onto a graph, we see that the points are distributed in a rather “random” fashion. For example, &lt;em&gt;2 g&lt;&#x2F;em&gt; could be very far from &lt;em&gt;3 g&lt;&#x2F;em&gt; which in turn are very far from &lt;em&gt;4 g&lt;&#x2F;em&gt;. If we wanted to know how many times &lt;em&gt;k&lt;&#x2F;em&gt; we have to add the generator to arrive at a certain point &lt;em&gt;P&lt;&#x2F;em&gt; (that is solving the equation &lt;em&gt;kg=P&lt;&#x2F;em&gt;) we see that we don’t have an easy strategy and we are forced to perform a brute search over all possible &lt;em&gt;k&lt;&#x2F;em&gt;. This problem is known as the (elliptic curve) discrete logarithm (log for friends) problem (other friends prefer ECDLP).&lt;&#x2F;p&gt;
&lt;p&gt;On the other hand, if we know &lt;em&gt;k&lt;&#x2F;em&gt; , we can compute in a very fast way &lt;em&gt;P=kg&lt;&#x2F;em&gt;. This offers us a way to hide (in plain sight) things inside the group. Of course, if you could break the DLP, you could get k, but it is rather infeasible. If we want to calculate 65536 &lt;em&gt;g&lt;&#x2F;em&gt; , we can do it by realizing that &lt;em&gt;g+g=2 g, 2g+2g=4g, 4g+4g=8&lt;&#x2F;em&gt;…until &lt;em&gt;32768 g+32768g=65535g&lt;&#x2F;em&gt;, so we narrowed the operations 65536 to 16. There are many useful algorithms that allow us to speed up the operations over elliptic curves, allowing us to avoid expensive calculations such as inversions, which appear when we want to calculate the slope.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;are-all-elliptic-curves-useful-for-crypto&quot;&gt;Are all elliptic curves useful for crypto?&lt;&#x2F;h2&gt;
&lt;p&gt;The strength of elliptic curve cryptography lies on the hardness to solve the discrete logarithm problem. This is related to the number of elements (the order of the set) making the cyclic group. If the number is a very large prime, or it contains a very large prime in its factorization (that is, the number is a multiple of a large prime), then the problem becomes infeasible. However, if the order is made up of small primes, it is possible to search over the subgroups and reconstruct the answer with help from the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Chinese_remainder_theorem&quot;&gt;Chinese Remainder Theorem&lt;&#x2F;a&gt;. This is because the difficulty depends on the size of the largest prime involved.&lt;&#x2F;p&gt;
&lt;p&gt;Some curves have desired properties and have been given names. For example, Bitcoin uses secp256k1, which has the following parameters:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;a=0&lt;&#x2F;em&gt;&lt;br &#x2F;&gt;
&lt;em&gt;b&lt;&#x2F;em&gt; =7 &lt;em&gt;p&lt;&#x2F;em&gt; =2256−232−977 &lt;em&gt;g x&lt;&#x2F;em&gt;=&lt;em&gt;0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798&lt;&#x2F;em&gt; &lt;em&gt;g y=0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8&lt;&#x2F;em&gt; &lt;em&gt;r=0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;To get an idea on the number of elements of the group, they’re about &lt;em&gt;r&lt;&#x2F;em&gt; ≈1077. Even if we had 1012 supercomputers performing over 1017 search points per second for a hundred million years we wouldn’t even get close to inspecting all the possibilities.&lt;&#x2F;p&gt;
&lt;p&gt;To be able to guarantee 128-bits of security, ECs need group orders near 256-bits (that is, orders with prime factors around 1077). This is because there are algorithms which can solve the problem doing operations around √r. If the largest prime is less than 94-bits long, it can be broken with help from a desktop computer. Of course, even if your group is large enough, nothing can save you from a poor implementation.&lt;&#x2F;p&gt;
&lt;p&gt;The question arises: how can we know the number of elements of our EC? Luckily, math comes once again to our aid like the Hasse bound, Schoof’s algorithm and how to test whether a number is prime or not. Next time we will continue revealing the math principles behind useful tools in cryptography.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Secure computation in Rust: Using Intel&#x27;s SGX instructions with Teaclave and Fortanix</title>
        <published>2022-05-05T00:00:00+00:00</published>
        <updated>2022-05-05T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com/posts/secure-computation-in-rust-using-intels-sgx-instructions-with-teaclave-and-fortanix/"/>
        <id>https://blog.lambdaclass.com/posts/secure-computation-in-rust-using-intels-sgx-instructions-with-teaclave-and-fortanix/</id>
        
        <content type="html" xml:base="https://blog.lambdaclass.com/posts/secure-computation-in-rust-using-intels-sgx-instructions-with-teaclave-and-fortanix/">&lt;p&gt;If you have been following this blog you should already know that I am a distributed system and Rust zealot.&lt;br &#x2F;&gt;
I started playing with Rust 2014 since it was implemented in OCaml, a language I love, and because it had green threads similar to the ones of Erlang. At the end of 2014, start of 2015 Rust’s runtime system and green-threading model was removed. I continued using Rust because of its great community and its C + ML roots. In addition to this it is a great complement to Erlang since it is has almost opposite semantics, specially in its error handling philosophy.&lt;&#x2F;p&gt;
&lt;p&gt;At the end of 2017 I started working on the crypto space, mostly because I needed the money. I’ve not been very public about it since I was skeptical of the whole movement. Even if I liked working on the technical problems that appeared on the space I thought that most crypto projects were ponzi-scheme or completely useless for users.&lt;&#x2F;p&gt;
&lt;p&gt;In these years I’ve met great engineers and technologies that made me believe more in the movement. That is one of the reasons why we started working on the zero knowledge proof space. One of this projects we are working with requires high standards of data security and privacy. For this we need to abstract ourselves from potential OS security vulnerabilities hosted in third party servers.&lt;br &#x2F;&gt;
The following blog post follows our journey discovering Intel SGX and it’s integration in the development of Rust applications.&lt;&#x2F;p&gt;
&lt;p&gt;As you can already guess this is a project full of challenges, from performance ones to potential security issues. So we would like to abstract ourselves from potential OS security vulnerabilities that the host devices might have, more so when you deploy your application in the cloud. So we’ve been tasked with deploying essential parts of the project in a specific Trusted Execution Environments (or TEEs for short), Intel’s SGX.&lt;&#x2F;p&gt;
&lt;p&gt;The following blog post follows our journey discovering Intel SGX and its integration in the development of Rust applications.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Subscribe to our&lt;&#x2F;em&gt;&lt;a href=&quot;&#x2F;#&#x2F;portal&#x2F;signup&quot;&gt; &lt;em&gt;newsletter&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; &lt;em&gt;to receive news and updates from Not a Monad Tutorial delivered directly to your inbox.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;Imagine you are building a piece of software which handles sensitive information. And that you decided to deploy your application in the cloud.&lt;&#x2F;p&gt;
&lt;p&gt;Since our project handles private keys used to access transactions and e-wallets, we need to ensure enhanced confidentiality and integrity, even in the presence of privileged malware at the OS, BIOS, VMM, or SMM layers.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tees&quot;&gt;TEEs&lt;&#x2F;h3&gt;
&lt;p&gt;TEEs can be thought of as processes that are running “isolated” from the OS and upper layers in a secure part of the CPU. The idea of this is to help to significantly reduce the attack surface. TEEs aim to ensure a subset of data integrity, code integrity and data privacy, which fits our sensitive data manipulation needs. Each CPU vendor has their own implementation, some of which are:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Intel SGX&lt;&#x2F;li&gt;
&lt;li&gt;ARM TrustZone&lt;&#x2F;li&gt;
&lt;li&gt;AMD Secure Encrypted Virtualization&lt;&#x2F;li&gt;
&lt;li&gt;ZAYA TEE for RiscV&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;From now on we’ll be focusing on Intel SGX.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;intel-sgx&quot;&gt;Intel SGX&lt;&#x2F;h3&gt;
&lt;p&gt;SGX is an Intel ISA extension with TEEs support. The environments are called &lt;strong&gt;enclaves&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Some important aspects:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;It’s not possible to read nor write the enclave’s memory space from outside the enclave&lt;&#x2F;strong&gt; , regardless of the privilege level and CPU mode.&lt;&#x2F;li&gt;
&lt;li&gt;In production, it’s not possible to debug enclaves by software nor hardware.&lt;&#x2F;li&gt;
&lt;li&gt;Entering the enclave via function calls, jumps or stack&#x2F;register manipulation is not possible. To do so you have to use a specific CPU instruction which also does some safety checks ([E]call, [O]call).&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Enclave’s memory is encrypted&lt;&#x2F;strong&gt; , and the key used changes on every power cycle. It’s stored within the CPU and is not accessible.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;external&#x2F;Lb332Bp.png&quot; alt=&quot;&quot; &#x2F;&gt;Source: Microsoft Azure Confidential Computing &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;azure&#x2F;confidential-computing&#x2F;confidential-computing-enclaves&quot;&gt;Documentation&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Warning&lt;&#x2F;strong&gt; : if you are considering developing an SGX application, we’d highly suggest &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ayeks&#x2F;SGX-hardware#desktop-cpus-affected-by-the-product-change-notification-from-2015&quot;&gt;checking your CPU&lt;&#x2F;a&gt; and whether it has SGX support. Intel’s C++ SDK has some simulation capabilities (as we’ll see later), but those aren’t fully fleshed out. We managed to run in a Macbook Pro some sample projects using Teclave’s simulation mode… but at what cost? So, only if you like stepping on Legos for fun try running SGX in your M1.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;external&#x2F;hqeSchG.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;sgx-rust-development&quot;&gt;SGX Rust Development&lt;&#x2F;h2&gt;
&lt;p&gt;The Intel SGX’s SDK is implemented on C++, so usually you’ll implement your application using C&#x2F;C++ and their &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;developer&#x2F;tools&#x2F;software-guard-extensions&#x2F;get-started.html&quot;&gt;toolkit&lt;&#x2F;a&gt;.&lt;br &#x2F;&gt;
As a starting point Intel gives a &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;intel&#x2F;linux-sgx&#x2F;tree&#x2F;master&#x2F;SampleCode&quot;&gt;couple of code examples&lt;&#x2F;a&gt; for different implementations.&lt;br &#x2F;&gt;
But, are there any developers worth their salt that want to develop a solid blockchain project in those languages when you’ve got the hip and cool option that is Rust? (in fact, yes) &lt;em&gt;We don’t look forward to that.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;external&#x2F;Whhj2XE.png&quot; alt=&quot;&quot; &#x2F;&gt; Recreation of what the Rust SDK developers may have thought&lt;&#x2F;p&gt;
&lt;p&gt;Since our source code is already written in Rust we looked for crates that allow us an easy and seamless integration of our code with the SGX enclaves.&lt;br &#x2F;&gt;
We found 2 alternatives for this, which use different approaches. Both are open source:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Teaclave SGX SDK&lt;&#x2F;li&gt;
&lt;li&gt;Fortanix Enclave Development Platform&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;teaclave&quot;&gt;Teaclave&lt;&#x2F;h2&gt;
&lt;p&gt;It wraps the Intel SGX’s SDK. You can check their &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;incubator-teaclave-sgx-sdk&quot;&gt;GitHub repo&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;external&#x2F;Bd8I1r5.png&quot; alt=&quot;&quot; &#x2F;&gt;Source: &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.trentonsystems.com&#x2F;blog&#x2F;what-is-intel-sgx&quot;&gt;https:&#x2F;&#x2F;www.trentonsystems.com&#x2F;blog&#x2F;what-is-intel-sgx&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;With Teaclave SDK you will split your application into two:&lt;br &#x2F;&gt;
- Trusted, also called the &lt;em&gt;enclave&lt;&#x2F;em&gt;.&lt;br &#x2F;&gt;
- Untrusted, called the &lt;em&gt;app&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Remember, under the hood you’re still using Intel SDK library.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;external&#x2F;ixchGF6.png&quot; alt=&quot;&quot; &#x2F;&gt;Source: &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.infoq.com&#x2F;presentations&#x2F;intel-sgx-enclave&#x2F;&quot;&gt;https:&#x2F;&#x2F;www.infoq.com&#x2F;presentations&#x2F;intel-sgx-enclave&#x2F;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The Untrusted code is in charge of initializing and shutting down the enclave, and you have to define an interface for the app and the enclave to communicate with each other. During compilation, those interfaces get transformed into [E]calls and [O]calls. In the end you would end up with something like this:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;external&#x2F;rzWrjSw.png&quot; alt=&quot;&quot; &#x2F;&gt;Source: Slide from Yu Ding’s &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.infoq.com&#x2F;presentations&#x2F;intel-sgx-enclave&#x2F;&quot;&gt;talk&lt;&#x2F;a&gt; at infoq about Intel SGX enclaves on Rust&lt;&#x2F;p&gt;
&lt;p&gt;But as the saying goes, not everything that shines is gold. The enclave will run under &lt;code&gt;#[no_std]&lt;&#x2F;code&gt;, so keep in mind that your favorite crates might not be supported. However, the maintainers have been porting and developing a bunch of useful crates to work with and of course you can also port the ones you want as well. Among them there’s the &lt;code&gt;libc&lt;&#x2F;code&gt;, the &lt;code&gt;std&lt;&#x2F;code&gt; (or part of it), synchronization primitives (e.g. &lt;code&gt;SgxMutex&lt;&#x2F;code&gt;, &lt;code&gt;SgxRWLock&lt;&#x2F;code&gt;) and more. However, there is not support for async Rust yet.&lt;&#x2F;p&gt;
&lt;p&gt;The repo is populated with some sample projects, which are great to start learning how to structure the project works and some conventions you need to follow and it’s also where you can take some as templates for your own application.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;simulation-mode&quot;&gt;Simulation Mode&lt;&#x2F;h3&gt;
&lt;p&gt;Since under the hood it uses Intel’s SDK, you still need to meet the necessary requirements. However, Intel also has simulation libraries (although those don’t have all the features implemented) which might come in handy to test your enclave locally despite not having an Intel processor.&lt;br &#x2F;&gt;
You also have available a docker image and you can check the details on how to run it &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;incubator-teaclave-sgx-sdk#running-without-intel-sgx-drivers&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fortanix-edp&quot;&gt;Fortanix EDP&lt;&#x2F;h2&gt;
&lt;p&gt;Fortanix EDP is developed by a company named &lt;em&gt;Fortanix&lt;&#x2F;em&gt;. From their website we read:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Fortanix secures sensitive data across public, hybrid, multicloud and private cloud environments, enabling customers to operate even the most sensitive applications in any environment.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;They came up with a different solution to running Rust code on Intel enclaves.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;external&#x2F;M5pt0Zd.png&quot; alt=&quot;&quot; &#x2F;&gt;Source: Fortanix EDP &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;edp.fortanix.com&#x2F;docs&#x2F;concepts&#x2F;architecture&#x2F;&quot;&gt;architecture documentation&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;First, instead of building an &lt;em&gt;app&lt;&#x2F;em&gt; and an &lt;em&gt;enclave&lt;&#x2F;em&gt; Fortanix EDP helps you build only the enclave and the way of communicating between the app and the enclave is up to you.&lt;&#x2F;p&gt;
&lt;p&gt;The enclave runner is responsible for initializing and shutting down enclaves and handling via a usercall interface the enclave’s needs.&lt;&#x2F;p&gt;
&lt;p&gt;Since it avoids this interfacing between app and enclave, it greatly reduces a lot of bureaucracy regarding project structure and setup. This was one of the benefits considered when &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;tvm&#x2F;issues&#x2F;2887&quot;&gt;TVM swapped Teaclave for Fortanix&lt;&#x2F;a&gt;. You can also see from this Fortanix &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;fortanix&#x2F;rust-sgx&#x2F;tree&#x2F;master&#x2F;examples&#x2F;mpsc-crypto-mining&quot;&gt;example crate&lt;&#x2F;a&gt; that only a few lines were added to the &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;, and the rest is a standard pure Rust project.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;supported-crates-and-std-caveats&quot;&gt;Supported crates and std Caveats&lt;&#x2F;h3&gt;
&lt;p&gt;Of course most of the time there’s going to be a catch. You might sometimes need to create an implementation of a crate for the SGX target. The process is &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;edp.fortanix.com&#x2F;docs&#x2F;tasks&#x2F;dependencies&#x2F;&quot;&gt;documented&lt;&#x2F;a&gt; as well. Also some crates have been adding SGX support for the &lt;code&gt;x86_64-fortanix-unknown-sgx&lt;&#x2F;code&gt; target, such as the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-random&#x2F;rand&#x2F;pull&#x2F;680&#x2F;files&quot;&gt;rand&lt;&#x2F;a&gt; crate.&lt;&#x2F;p&gt;
&lt;p&gt;This project is already a tier 2 target for the Rust compiler (more on &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;rustc&#x2F;platform-support.html#tier-2&quot;&gt;Rust tiers&lt;&#x2F;a&gt;), and that’s great news! It’s based on &lt;code&gt;libstd&lt;&#x2F;code&gt;, practice which may have its drawbacks since it assumes &lt;code&gt;time&#x2F;net&#x2F;env&#x2F;thread&#x2F;process&#x2F;fs&lt;&#x2F;code&gt; are implemented. Some of those are still not implemented (&lt;code&gt;fs&lt;&#x2F;code&gt; for example) and will throw a runtime panic instead of a compile error, breaking the Rust’s philosophy of “if it compiles it works”. More info on &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;edp.fortanix.com&#x2F;docs&#x2F;concepts&#x2F;rust-std&#x2F;&quot;&gt;Rust std support&lt;&#x2F;a&gt; on Fortanix’s documentation.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;i-o&quot;&gt;I&#x2F;O&lt;&#x2F;h3&gt;
&lt;p&gt;The recommended way of handling input&#x2F;output in the enclave is via byte streams, particularly using &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;edp.fortanix.com&#x2F;docs&#x2F;concepts&#x2F;rust-std&#x2F;#stream-networking&quot;&gt;&lt;code&gt;TcpStream&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and using TLS (Transport Layer Security is a protocol used to provide secure communications to a network and mostly known for its use on &lt;em&gt;https&lt;&#x2F;em&gt;) on top of that is strongly suggested.&lt;br &#x2F;&gt;
There are primitives for dealing with pointers to user space as well. These primitives use Rust’s borrowing and ownership mechanism to avoid data races among other issues, and also prevent creating dangerous Rust references to user memory. Still, using &lt;code&gt;TcpStream&lt;&#x2F;code&gt; is preferred.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;an-example-using-both-fortanix-and-teaclave&quot;&gt;An example using both Fortanix and Teaclave&lt;&#x2F;h2&gt;
&lt;p&gt;We’re going to show a simplified of the hello-world &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;incubator-teaclave-sgx-sdk&#x2F;tree&#x2F;master&#x2F;samplecode&#x2F;hello-rust&quot;&gt;example&lt;&#x2F;a&gt; from the Teaclave repo and see how we would do a similar thing using Fortanix’s EDP.&lt;&#x2F;p&gt;
&lt;p&gt;We’ll be omitting some details, so if you’re interested in getting them we suggest that you check out Teaclave’s repo.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;teaclave-1&quot;&gt;Teaclave&lt;&#x2F;h3&gt;
&lt;p&gt;The project structure is:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;external&#x2F;mm0n8rE.png&quot; alt=&quot;&quot; &#x2F;&gt;Example of project structure using Teaclave&lt;&#x2F;p&gt;
&lt;p&gt;Notice that we have the &lt;code&gt;app&#x2F;&lt;&#x2F;code&gt; and the &lt;code&gt;enclave&#x2F;&lt;&#x2F;code&gt; directories. First let’s see the app’s code:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;extern {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    fn say_something(eid: sgx_enclave_id_t, retval: *mut sgx_status_t,&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;                     some_string: *const u8, len: usize) -&amp;gt; sgx_status_t;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We define the function that we want to run in the enclave as an external function, notice that we are not using Rust’s &lt;code&gt;String&lt;&#x2F;code&gt; here, we need to pass the raw parts instead.&lt;&#x2F;p&gt;
&lt;p&gt;You need to initialize the enclave with a &lt;code&gt;SgxEnclave::create&lt;&#x2F;code&gt; call before running code on it. Remember to &lt;strong&gt;always initialize&lt;&#x2F;strong&gt; the enclave first.&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;&#x2F;&#x2F; Initialize the enclave - proceed on success&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;let enclave = match init_enclave() {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    Ok(r) =&amp;gt; {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        println!(&amp;quot;[+] Init Enclave Successful {}!&amp;quot;, r.geteid());&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        r&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    },&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    Err(x) =&amp;gt; {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        println!(&amp;quot;[-] Init Enclave Failed {}!&amp;quot;, x.as_str());&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        return;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    },&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;};&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;let input_string = String::from(&amp;quot;This is a normal world string passed into Enclave!\n&amp;quot;);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;let mut retval = sgx_status_t::SGX_SUCCESS;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Then we make the &lt;code&gt;[E]call&lt;&#x2F;code&gt; into the enclave. This needs to be wrapped with an unsafe block and we need to split the String into its pointer and length.&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;let result = unsafe {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    say_something(enclave.geteid(),&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;                  &amp;amp;mut retval,&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;                  input_string.as_ptr() as * const u8,&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;                  input_string.len())&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;};&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;[E]call&lt;&#x2F;code&gt; will return with a &lt;code&gt;sgx_status_t&lt;&#x2F;code&gt; we can check against to see if the enclave ran successfully.&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;match result {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    sgx_status_t::SGX_SUCCESS =&amp;gt; {},&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    _ =&amp;gt; {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        println!(&amp;quot;[-] ECALL Enclave Failed {}!&amp;quot;, result.as_str());&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        return;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;println!(&amp;quot;[+] say_something success...&amp;quot;);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You have to destroy the enclave before exiting. From the documentation it reads:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;It is highly recommended that the sgx_destroy_enclave function be called after the application has finished using the enclave to avoid possible deadlocks.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;enclave.destroy();&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now into the enclave’s code:&lt;&#x2F;p&gt;
&lt;p&gt;Each &lt;code&gt;[E]call&lt;&#x2F;code&gt; should follow the signature &lt;code&gt;#[no_mangle] pub extern &quot;C&quot; fn func_name(args) -&amp;gt; sgx_status_t&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;#[no_mangle]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;pub extern &amp;quot;C&amp;quot; fn say_something(some_string: *const u8, some_len: usize) -&amp;gt; sgx_status_t &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Again, we need the unsafe block to call &lt;code&gt;from_raw_parts&lt;&#x2F;code&gt; and we get our string slice back.&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;let str_slice = unsafe { slice::from_raw_parts(some_string, some_len) };&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;&#x2F;&#x2F; A sample &amp;amp;&amp;#39;static string&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;let rust_raw_string = &amp;quot;This is a in-Enclave &amp;quot;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;&#x2F;&#x2F; Construct a string from &amp;amp;&amp;#39;static string&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;let mut hello_string = String::from(rust_raw_string);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;&#x2F;&#x2F; Ocall to normal world for output&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;println!(&amp;quot;{}&amp;quot;, &amp;amp;hello_string);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;sgx_status_t::SGX_SUCCESS&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And there’s even more. You need to define the &lt;code&gt;[E]call&#x2F;[O]call&lt;&#x2F;code&gt; interface in the enclave subdirectory in an &lt;code&gt;Enclave.edl&lt;&#x2F;code&gt; file.&lt;&#x2F;p&gt;
&lt;p&gt;It would look something like:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;enclave {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    from &amp;quot;sgx_tstd.edl&amp;quot; import *;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &#x2F;&#x2F; you would have other imports here&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    trusted {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        &#x2F;* define ECALLs here. *&#x2F;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        public sgx_status_t say_something([in, size=len] const uint8_t* some_string, size_t len);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    };&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    untrusted {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        &#x2F;* define OCALLs here. *&#x2F;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;};&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;There are even more files we haven’t touched yet. But this is enough to show that while Teaclave might give you a lot of control of what’s going on, it’s not easy and increases the overall complexity of your project.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;same-implementation-using-fortanix-edp&quot;&gt;Same implementation using Fortanix EDP&lt;&#x2F;h3&gt;
&lt;p&gt;As Fortanix’s documentation says:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;EDP applications should be thought of as providing a service to other parts of your system. An EDP application might interact with other services which themselves might be EDP applications. The service may be implemented as a gRPC server, an HTTPS server with REST APIs, or any other service protocol.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Disclaimer&lt;&#x2F;strong&gt; : we haven’t been able to get our hands into an Intel SGX capable machine, hence we weren’t able to test this example. However, we think this serves as a good illustration example and gives some credit to Teaclave and Intel for the simulation capabilities.&lt;&#x2F;p&gt;
&lt;p&gt;Let’s see how can we accomplish our hello world using Fortanix EDP. Our final project looks like this:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;external&#x2F;8Wh6Nk4.png&quot; alt=&quot;&quot; &#x2F;&gt;Example of a project structure using Fortanix&lt;&#x2F;p&gt;
&lt;p&gt;Let’s look at what the &lt;code&gt;main.rs&lt;&#x2F;code&gt; has to offer:&lt;&#x2F;p&gt;
&lt;p&gt;We needed to add this two lines to the &lt;code&gt;.cargo&#x2F;config&lt;&#x2F;code&gt; file:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;[target.x86_64-fortanix-unknown-sgx]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;runner=&amp;#39;ftxsgx-runner-cargo&amp;#39;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And that’s the only setup we needed (besides the Rust code).&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;use std::net::{TcpListener, TcpStream};&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;use std::io::Read;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;fn main() {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    let listener = TcpListener::bind(&amp;quot;127.0.0.1:7878&amp;quot;).unwrap();&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    let (mut stream, _addr) = listener.accept().unwrap();&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    let mut message = [0; 128];&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    stream.read(&amp;amp;mut message).unwrap();&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    println!(&amp;quot;new client: {:?}&amp;quot;, std::str::from_utf8(&amp;amp;message).unwrap());&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Pretty much like good ol’ Rust code right? In fact, we’re able to compile it without the Fortanix runner and have it running.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;external&#x2F;GPPD8IR.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;This only constitutes the enclave, but an easy way to test it is by making the TCP request, so it should be enough to run the following command:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;echo &amp;quot;Hello World!&amp;quot; | nc 127.0.0.1 7878&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The way this is built means that you could call this from another language as long as you can make the TPC connection.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;sgx_with_rust_blog_post&quot;&gt;&lt;em&gt;Full code here&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;teaclave-vs-fortanix&quot;&gt;Teaclave vs. Fortanix&lt;&#x2F;h2&gt;
&lt;p&gt;One significant difference between the two is their size: Teaclave’s repo contains ~80K lines of Rust code while Fortanix’s one has ~18K lines of code, which is about 4 times less. Some of these could be atributed to the amount of examples Teaclave has in their repo but still that doesn’t make up for the whole difference.&lt;br &#x2F;&gt;
Also, Fortanix is mostly written using Rust code, while Teaclave has another 80K more lines of non Rust code… yikes!&lt;&#x2F;p&gt;
&lt;p&gt;In terms of community activity we ran a comparison of both thru &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;vesoft-inc.github.io&#x2F;github-statistics&#x2F;&quot;&gt;github-statistics&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;external&#x2F;bejTcAq.png&quot; alt=&quot;&quot; &#x2F;&gt;Comparison between Fortanix and Teaclave repos stats&lt;&#x2F;p&gt;
&lt;p&gt;Teaclave seems to have more traction based on the amount of stars and forks. Nevertheless, during 2021 there is a clear increase of the activity in the Fortanix’s EDP repository. So it seems like Teaclave is more widely used but it’s development has stagnated somewhat while Fortanix is taking the lead, a dynamic that has been reinforced since attaining &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;users.rust-lang.org&#x2F;t&#x2F;sgx-target-is-now-a-rust-tier-2-platform&#x2F;24779&quot;&gt;Rust tier 2 in january on 2019&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;weighting-pros-and-cons&quot;&gt;Weighting pros and cons&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;teaclave-2&quot;&gt;Teaclave&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;✅ Uses Intel’s libs, and they’re supposed to be the experts on that.&lt;&#x2F;li&gt;
&lt;li&gt;✅ There are simulation libraries which expand the support a bit.&lt;&#x2F;li&gt;
&lt;li&gt;✅ Already solves connecting the app and the enclave.&lt;&#x2F;li&gt;
&lt;li&gt;✅ There are a few more examples available (&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;incubator-teaclave-sgx-sdk&#x2F;tree&#x2F;master&#x2F;samplecode&quot;&gt;Teaclave SGX SDK repo&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;glassonion1&#x2F;rust-101&#x2F;tree&#x2F;main&#x2F;sgx-sdk&quot;&gt;Rust 101 repo&lt;&#x2F;a&gt;).&lt;&#x2F;li&gt;
&lt;li&gt;❌ Uses Intel’s libs, and they’re supposed to be the experts on that. This might not be a bad thing by itself, but you could think of this as adding an extra dependency with a centralized entity such as Intel. Which is why in a decentralized environment might not be ideal (debatable).&lt;&#x2F;li&gt;
&lt;li&gt;❌ Integrating SGX to an existing system using this SDK is a bit tedious, since you need to restructure your application, use some Makefiles to handle linking the enclave with the application, declaring the interface connecting your applications in a separate &lt;code&gt;.edl&lt;&#x2F;code&gt; file with its own syntax and more.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;external&#x2F;vMOMK15.png&quot; alt=&quot;&quot; &#x2F;&gt;Enclave folder using Teaclave vs Fortanix&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fortanix&quot;&gt;Fortanix&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;✅ You can write all Rust code.&lt;&#x2F;li&gt;
&lt;li&gt;✅ Officially target tier 2 of the Rust compiler.&lt;&#x2F;li&gt;
&lt;li&gt;✅ Add a few lines to your &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt; and you are set.&lt;&#x2F;li&gt;
&lt;li&gt;✅ We trust the fact that it is open source and therefore audited by many users, and being included as a tier 2 target for the Rust compiler means that it has earned some respect from the Rust community as well.&lt;&#x2F;li&gt;
&lt;li&gt;❌ Well, sometimes it’s not that easy. Not all crates have support for SGX although you can add your own implementation for the Fortanix target.&lt;&#x2F;li&gt;
&lt;li&gt;❌ since it uses &lt;code&gt;libstd&lt;&#x2F;code&gt; it assumes that you have implementations for &lt;code&gt;time&#x2F;net&#x2F;env&#x2F;thread&#x2F;process&#x2F;fs&lt;&#x2F;code&gt;, which SGX does not entirely support. This will generate runtime panics when used and you won’t be getting compilation errors.&lt;&#x2F;li&gt;
&lt;li&gt;❌ It’s easier to develop on, but that is because it hides some of the complexity away and you may ask yourself if we can trust on its security when many things are hidden away from the developer.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;&#x2F;h2&gt;
&lt;p&gt;We don’t find a clear winner between Teaclave and Fortanix, as both have their pros and cons.&lt;&#x2F;p&gt;
&lt;p&gt;Having to make a choice we tend to go with Fortanix as its easier to develop in pure Rust. Also as Fortanix is endorsed as Tier 2 we can have a high confidence about its compatilibity with our software allowing for a seamless implementation. As an added bonus this level of trust from the Rust developers gives us a somewhat indirect clue that there aren’t blatant security issues hidden in the code that are meaningful enough to make us to doubt it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-readings&quot;&gt;Further readings&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;dam&#x2F;develop&#x2F;public&#x2F;us&#x2F;en&#x2F;documents&#x2F;intel-sgx-product-brief-2019.pdf&quot;&gt;SGX product brief&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;developer&#x2F;library.html?s=Newest&amp;amp;f:@stm_10309_en=%5BIntel%C2%AE%20Software%20Guard%20Extensions%20(Intel%C2%AE%20SGX)%5D&quot;&gt;Intel technical library - Software Guard Extensions&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;fortanix.com&#x2F;intel-sgx&#x2F;&quot;&gt;Fortanix resources&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;teaclave.apache.org&#x2F;docs&#x2F;&quot;&gt;Teaclave documentation&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
        
    </entry>
</feed>
