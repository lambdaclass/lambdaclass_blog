<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>LambdaClass Blog - Distributed Computing</title>
      <link>https://blog.lambdaclass.com</link>
      <description>Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.</description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://blog.lambdaclass.com/tags/distributed-computing/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Wed, 09 Apr 2025 00:00:00 +0000</lastBuildDate>
      <item>
          <title>The Wisdom of Iroh</title>
          <pubDate>Wed, 09 Apr 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/the-wisdom-of-iroh/</link>
          <guid>https://blog.lambdaclass.com/posts/the-wisdom-of-iroh/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/the-wisdom-of-iroh/">&lt;p&gt;As we‚Äôve written before, most of us at Lambda are internet natives. The formative experiences that made us who we are include meeting people on the other side of the world through IRC, sharing knowledge, media, and code via BitTorrent, wikipedia, and software version control systems, the birth of the first search engines, and the feeling that &lt;em&gt;everything&lt;&#x2F;em&gt;  was accessible. We then grew up and found frustration that this experience did not yet extend to the financial tasks needed to be an adult, and that terms like &lt;em&gt;walled garden&lt;&#x2F;em&gt;  better described the new state of our internet home.&lt;&#x2F;p&gt;
&lt;p&gt;This is why we get a double high when learning about projects like Iroh: an emotional tug from a project that enables building distributed systems in a way that gives users more agency, and a nerdy thrill from the technical challenges they‚Äôve solved to achieve it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-is-it&quot;&gt;What is it?&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.iroh.computer&#x2F;&quot;&gt;Iroh&lt;&#x2F;a&gt; is a distributed systems toolkit, focused on easily setting up reliable p2p connections. It includes facilities for establishing direct connections, moving data, syncing state, and pluggable application-level protocols. It‚Äôs working in production and has managed 200k concurrent connections and millions of devices on the same network with low service costs.&lt;&#x2F;p&gt;
&lt;p&gt;In their own words:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Iroh is a library for establishing the most direct QUIC connection possible between two devices. Every &lt;em&gt;endpoint&lt;&#x2F;em&gt;  uses the public half of a cryptographic keypair to identify itself. Assuming at least one configured &lt;em&gt;relay server&lt;&#x2F;em&gt;  is reachable, an endpoint keeps exactly one TCP connection to a ‚Äúhome relay‚Äù that other nodes use for connection establishment, and as a fallback transport. Iroh uses a suite of &lt;em&gt;discovery services&lt;&#x2F;em&gt;  to resolve home relays &amp;amp; endpoint IDs. Connections between endpoints use QUIC ALPNs to distinguish between &lt;em&gt;protocols&lt;&#x2F;em&gt; , while &lt;em&gt;routers&lt;&#x2F;em&gt;  automate the endpoint accept loop for protocol multiplexing.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;One of the things we like about Iroh is that it is clear on what it is about. It runs on QUIC, started out as a new implementation of IPFS, went through several iterations, and reduced its scope to better solve the problems they were facing. They wrote about this process in their &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.iroh.computer&#x2F;blog&#x2F;smaller-is-better&quot;&gt;Smaller is Better&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.iroh.computer&#x2F;blog&#x2F;road-to-1-0&quot;&gt;Roadmap&lt;&#x2F;a&gt; posts, and we fully agree that this is good engineering practice.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-can-iroh-be-used-for&quot;&gt;What can Iroh be used for?&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;n0.computer&#x2F;&quot;&gt;&lt;code&gt;n0&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, the company behind Iroh, keeps a &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;n0-computer&#x2F;awesome-iroh&quot;&gt;list&lt;&#x2F;a&gt; of projects building on them but to get a quick idea, it can be of use in anything that needs file sync, p2p game streaming, distributed object storage, peer discoverability and swarm membership, local-first design, or compute job orchestration.&lt;&#x2F;p&gt;
&lt;p&gt;One of our partners, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nousresearch&quot;&gt;Nous Research&lt;&#x2F;a&gt; is using it in a decentralized program which relies on iroh to manage communications between nodes training LLMs, sending messages between the clients to advance the state of the network and share the gradients calculated by each node.&lt;&#x2F;p&gt;
&lt;p&gt;Today, we interviewed the team to get some insight.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;1-many-of-the-n0-team-members-are-ex-ipfs-or-libp2p-developers-one-of-the-first-questions-asked-is-how-iroh-compares-to-libp2p-and-as-we-understand-it-the-answer-is-related-to-having-a-tighter-focus-keeping-the-core-about-making-p2p-connections-that-just-work-and-moving-the-rest-to-application-level-protocols-such-as-iroh-gossip-blobs-and-docs-that-can-be-mixed-and-matched-as-desired-can-you-elaborate-on-this-process-and-how-reducing-scope-helped&quot;&gt;&lt;em&gt;1. Many of the n0 team members are ex-IPFS or libp2p developers. One of the first questions asked is how Iroh compares to libp2p and as we understand it, the answer is related to having a tighter focus, keeping the core about making p2p connections that just work, and moving the rest to application-level protocols such as iroh-gossip, -blobs and -docs that can be mixed and matched as desired. Can you elaborate on this process and how reducing scope helped?&lt;&#x2F;em&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;b5: The process was one of slowly divesting ourselves of a lot of ‚Äúp2p project baggage‚Äù. Most p2p projects end up defaulting into a boil-the-ocean stance where they try to ship one of everything: a DHT, transports, pubsub, RPC, and over time we‚Äôve come to believe this is a big contributing factor to p2p projects feeling like half-baked prototypes. It clicked for us when our CTO dig pointed out ‚Äúno one wants the nginx team to ship postgres‚Äù. A DHT is a huge undertaking, reliable sync is a huge undertaking, reliable transports are a huge undertaking. Sometime last year we realized it just wouldn‚Äôt be possible to ship all this stuff with the team we had, so we picked the transport layer, and are focused on integrating with other projects &amp;amp; the community forming near iroh for the things we can‚Äôt ship. Our bet is things will work better if a project like &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;loro.dev&quot;&gt;loro&lt;&#x2F;a&gt; ships &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;loro-dev&#x2F;iroh-loro&quot;&gt;optional iroh support&lt;&#x2F;a&gt;, the loro team makes a truly robust CRDT, and we make a truly robust transport. There‚Äôs pressure on both teams to make the public APIs small &amp;amp; composable, to make integration easier.&lt;br &#x2F;&gt;
A lot of this is testament to just how incredible a technical feat &lt;code&gt;libp2p&lt;&#x2F;code&gt; is, especially when you see the sheer number of language implementations, it‚Äôs truly impressive. But that amount of work comes with a big API surface area, makes it very challenging to port all of that functionality into a robust package that works well on a phone. It also creates the expectation that &lt;code&gt;libp2p&lt;&#x2F;code&gt; maintainers commit to delivering both a robust DHT &lt;em&gt;and&lt;&#x2F;em&gt; a reliable transport. When we more focus we explicitly mean fewer features that both work more consistently &amp;amp; are integrated across organizations.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;2-how-did-the-decision-to-use-quic-come-about-a-few-months-ago-some-research-indicated-quic-might-have-some-downsides-and-there-seems-to-be-anecdotal-evidence-of-hostility-to-the-new-protocol-from-network-engineers-does-your-team-have-opinions-wrt-to-any-aspect-of-this-are-there-any-indications-for-iroh-adopters-that-might-stem-from-quic-usage&quot;&gt;2. How did the decision to use QUIC come about? A few months ago some &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3589334.3645323&quot;&gt;research&lt;&#x2F;a&gt; indicated QUIC might have some downsides and there seems to be anecdotal evidence of hostility to the new protocol from network engineers. Does your team have opinions wrt to any aspect of this? Are there any indications for Iroh adopters that might stem from QUIC usage?&lt;&#x2F;h3&gt;
&lt;p&gt;b5: the goals of QUIC closely resemble what we‚Äôre trying to do with iroh: ship new capabilities on the internet &lt;em&gt;with software&lt;&#x2F;em&gt;  because changing the hardware is impractical. QUIC is trying to tackle protocol ossification that set in because routers can inspect TCP headers, and doing that by dropping down to the UDP layer &amp;amp; working from there. Along with being aligned at ‚Äúspiritual‚Äù level, things like QUIC multipath support seem almost designed for our exact use case. It‚Äôs a young technology that we‚Äôre all-in on.&lt;&#x2F;p&gt;
&lt;p&gt;I haven‚Äôt heard much in the way of hostility from network engineers, but I‚Äôm not entirely surprised. QUIC is intentionally trying to reduce the visible surface area to routers &amp;amp; internet middleboxes, which I‚Äôm sure would be frustrating. I happen to be of the mind that internet middle boxes shouldn‚Äôt be messing with those packets in the first place, but hey, that‚Äôs just me üòÑ&lt;&#x2F;p&gt;
&lt;h3 id=&quot;3-you-ve-mentioned-that-iroh-has-seen-a-million-devices-on-the-same-network-is-this-in-relation-to-the-public-iroh-relays-or-in-another-context-what-are-the-scalability-limits-you-ve-seen-and-in-which-scenarios&quot;&gt;3. You‚Äôve mentioned that Iroh has seen a million devices on the same network. Is this in relation to the public Iroh relays or in another context? What are the scalability limits you‚Äôve seen and in which scenarios?&lt;&#x2F;h3&gt;
&lt;p&gt;The biggest numbers we‚Äôve seen have come from app developers deploying iroh as part of an update to an existing app. Each of those has stressed iroh in different ways. We‚Äôve shipped against those stress tests for the last 6 months. It‚Äôs by no means done, but it is giving us in-production feedback that‚Äôs critical as we work toward our 1.0 release later this year.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;4-iroh-gossip-is-particularly-interesting-as-a-modern-implementation-of-hyparview-and-plumtree-what-made-you-choose-these-protocols-have-you-done-load-tests-on-this-protocol-in-particular-what-is-your-approach-to-testing-and-load-testing-in-general&quot;&gt;4. Iroh-gossip is particularly interesting as a modern implementation of HyParView and Plumtree. What made you choose these protocols? Have you done load tests on this protocol in particular? What is your approach to testing and load testing in general?&lt;&#x2F;h3&gt;
&lt;p&gt;b5: phones. If we‚Äôre going to make p2p work on a mobile devices, ‚Äústar‚Äù topologies that compensate for high network churn with lots of connections simply aren‚Äôt viable, which makes the active&#x2F;passive divide in PlumTree particularly appealing. As I‚Äôm writing this someone in our discord is running a &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;discord.com&#x2F;channels&#x2F;1161119546170687619&#x2F;1161119546644627528&#x2F;1357726363657834788&quot;&gt;2000 node iroh gossip stress test&lt;&#x2F;a&gt; using an erlang supervisor, so yes, it‚Äôs being tested! We also have a battery of smoke &amp;amp; simulation tests that run against the iroh gossip protocol as part of CI.&lt;br &#x2F;&gt;
Gossip has been getting more attention lately, which is driving us to put more time into it. Frando from our team has been actively working on stability as we speak.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;5-you-encourage-users-to-set-up-their-own-relays-for-their-networks-but-are-also-very-generous-with-the-three-public-ones-you-offer-aside-from-avoiding-the-rate-limits-why-use-private-relays-are-there-any-security-or-other-feature-considerations&quot;&gt;5. You encourage users to set up their own relays for their networks but are also very generous with the three public ones you offer. Aside from avoiding the rate limits, why use private relays? Are there any security or other feature considerations?&lt;&#x2F;h3&gt;
&lt;p&gt;b5: It‚Äôs totally fine to use the public relays! Honestly, we‚Äôd love to see more use so we can stress them more :). As a gentle reminder for everyone: relay traffic is e2ee, so the relays can‚Äôt see traffic, but relays &lt;em&gt;do&lt;&#x2F;em&gt; have a list of nodeIDs, and list of connections they‚Äôre facilitating, which is privileged information. Many of our more serious users are using private relays to avoid exposing that information to the public, or even to number 0, which is things working as intended in our view. We have some plans in the works for a complimentary service that will make spinning up relays very easy. Stay tuned for that!&lt;&#x2F;p&gt;
&lt;h3 id=&quot;6-when-developing-distributed-systems-observability-becomes-a-prime-concern-iroh-doctor-seems-like-a-cool-tool-to-have-does-iroh-offer-other-facilities-for-observing-and-debugging-its-internals-or-the-application-what-role-does-iroh-metrics-play-in-this&quot;&gt;6. When developing distributed systems, observability becomes a prime concern. &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.iroh.computer&#x2F;blog&#x2F;iroh-0-16-a-better-client#iroh-doctor-plot&quot;&gt;Iroh-doctor&lt;&#x2F;a&gt; seems like a cool tool to have. Does Iroh offer other facilities for observing and debugging its internals or the application? What role does Iroh-metrics play in this?&lt;&#x2F;h3&gt;
&lt;p&gt;b5: We‚Äôre actively working on this. Gathering actionable network metrics in a p2p system is critical as we make p2p a mature, reliable thing. We‚Äôll have way more to say on this one in the coming months.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;7-p2p-systems-usually-disclose-the-ip-addresses-of-the-participating-nodes-and-iroh-explicitly-chooss-to-give-applications-flexibility-in-what-if-anything-to-do-in-this-regard-what-choices-do-you-see-are-usually-taken-and-what-mechanisms-aside-from-vpns-can-applications-implement&quot;&gt;7. P2P systems usually disclose the IP addresses of the participating nodes and Iroh explicitly chooss to give applications flexibility in what (if anything) to do in this regard. What choices do you see are usually taken, and what mechanisms (aside from VPNs) can applications implement?&lt;&#x2F;h3&gt;
&lt;p&gt;b5: I should clarify that any connection within iroh will &lt;em&gt;always&lt;&#x2F;em&gt; end up exposing your IP address to the peer that you‚Äôre dialing, and the relay server your node uses as it‚Äôs home. This is also true of &lt;em&gt;so&lt;&#x2F;em&gt; many services you use every day, so iroh isn‚Äôt new in this regard. With that said, yeah a VPN is rarely a bad idea, and we expicitly run one-off tests between n0 staff where we start a big file transfer &amp;amp; switch VPN on &amp;amp; off during transfer to confirm it works (spoiler: it does).&lt;br &#x2F;&gt;
The implications of connecting users will be different for each application, but we generally ask folks to use their heads: if your app is 5-100 person invite-only chat rooms, then it makes sense to couple iroh connections with room memberships. If your app is, say, twitter, then you might need to introduce a new opt-in mechanism that makes it clear to the user that you‚Äôre disclosing something that might be abused.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;8-the-local-first-software-movement-prioritizing-user-data-being-stored-and-processed-on-their-own-devices-rather-than-relying-on-cloud-servers-is-new-and-slowly-gaining-traction-do-you-see-iroh-being-used-in-this-context-or-are-most-of-the-main-users-focused-on-other-use-cases&quot;&gt;8. The local-first software movement (prioritizing user data being stored and processed on their own devices rather than relying on cloud servers) is new and slowly gaining traction. Do you see Iroh being used in this context or are most of the main users focused on other use cases?&lt;&#x2F;h3&gt;
&lt;p&gt;b5: YES. we &amp;lt;3 local first in a big way, and think p2p is the only way to get to software that is both local first and networked. The thing user agency, p2p, and local first all have in common is shipping more capabilities to the end-user‚Äôs device than we traditionally get with today‚Äôs ‚Äúview layer on an API‚Äù apps.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;9-coupling-iroh-with-a-crdt-such-as-automerge-seems-to-be-a-common-pattern-iroh-docs-seems-geared-to-be-a-distributed-kv-store-but-is-based-on-range-based-set-reconciliation-do-you-see-these-higher-level-usage-patterns-being-codified-as-other-protocols-are-there-other-protocols-in-development-or-do-you-see-any-particular-pattern-as-a-likely-future-protocol&quot;&gt;9. Coupling Iroh with a CRDT such as &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;automerge.org&#x2F;&quot;&gt;automerge&lt;&#x2F;a&gt; seems to be a common pattern. Iroh-docs seems geared to be a distributed KV store but is based on range-based set reconciliation. Do you see these higher-level usage patterns being codified as other protocols? Are there other protocols in development, or do you see any particular pattern as a likely future protocol?&lt;&#x2F;h3&gt;
&lt;p&gt;b5: yes, iroh + automerge is definitely ‚Äúusing iroh as intended‚Äù, and you get at a good point: there are common patterns like message bootstrapping, incremental updates, and pairwise reconciliation that are commmon across a bunch of these protocols. To be able to actually have those protocols share abstractions for these patterns we‚Äôd need a more robust story for protcol composition than we currently have, because we‚Äôd need a way for a protocol to express dependencies &amp;amp; do protocol version matching across the set of registered protocols at compilation time. Even then, it would require the buy-in from projects like automerge, which really isn‚Äôt a goal of ours right now.&lt;br &#x2F;&gt;
I think it‚Äôs going to take years, but I do think we‚Äôll get to a place where we declare a dependency graph of protocols, the compiler will be able to tell you if you have a version mismatch, and we‚Äôll be able to further decompose these patterns as a community. I‚Äôm doing some experiments in this direction on the side, but don‚Äôt expect to see anything in this department before we cut iroh 1.0.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;10-you-ve-written-about-the-challenges-of-using-async-rust-and-we-can-certainly-relate-in-our-experience-greenspun-s-tenth-rule-applies-transmuted-to-distributed-systems-sometimes-called-virding-s-rule-any-sufficiently-complicated-concurrent-program-in-another-language-contains-an-ad-hoc-informally-specified-bug-ridden-slow-implementation-of-half-of-erlang-what-is-your-experience-with-the-actor-and-message-passing-approach-both-in-rust-when-implementing-iroh-and-more-generally-when-using-iroh-to-build-systems-that-communicate&quot;&gt;10. You‚Äôve &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.iroh.computer&#x2F;blog&#x2F;async-rust-challenges-in-iroh&quot;&gt;written&lt;&#x2F;a&gt; about the challenges of using async rust and we can certainly relate! In our experience Greenspun‚Äôs tenth rule applies transmuted to distributed systems (sometimes called Virding‚Äôs rule) ‚ÄúAny sufficiently complicated concurrent program in another language contains an ad hoc informally-specified bug-ridden slow implementation of half of Erlang.‚Äù What is your experience with the actor and message passing approach, both in Rust when implementing Iroh and more generally when using Iroh to build systems that communicate?&lt;&#x2F;h3&gt;
&lt;p&gt;b5: lol yes very much to the half-Erlang. We‚Äôre very much in that uncanny valley right now with iroh. Most of the internal guts are implemented with actors, but we haven‚Äôt formalized that into an actor abstraction, and it‚Äôs unclear that we ever will. Where that pain is felt more accutely is at the protocol level. At the level of protocol developement, it would be very nice to have easy-to-implement patterns that abstract around distibuted fault tolerance &amp;amp; give you that ‚Äúfail whenever you want‚Äù characteristic the supervisor trees bring. The protocol dev is also at the right height in the stack, dealing with logical messages instead of raw packets.&lt;br &#x2F;&gt;
We‚Äôre still working on the groundwork of getting tutorials in place for writing a protocol in the first place, but I‚Äôd love to see us spend more time cooking up recipes for protcol development atop an actor model abstraction.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;11. Your &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.iroh.computer&#x2F;roadmap&quot;&gt;roadmap&lt;&#x2F;a&gt; is quite clear, webassembly support being oft-requested and recently merged, and better support on the way for clients wanting to use Iroh in browsers without having to send all data over relays. Some notable items in the more distant roadmap are a spec and FFI integrations. Can you elaborate on their importance and&#x2F;or motivation? Do you have an estimate on when 1.0 is due and any comments on what motivates the upcoming features? What are you most excited about?&lt;&#x2F;p&gt;
&lt;p&gt;b5: The spec part is fun because iroh can be pretty easily expressed as a composition of existing specs, which is our plan. In our view 1.0 means you know clearly what the thing is, and how it &lt;em&gt;should&lt;&#x2F;em&gt; behave, so why not write that down in a spec? That said, we‚Äôre far more concerned with working software than a spec, and see taking the time to write out a spec as a means of confirming we‚Äôve considered everything we need to as part of a 1.0 push, and can communicate that consideration clearly. As for FFI bindings, we &lt;em&gt;really&lt;&#x2F;em&gt; , &lt;em&gt;really&lt;&#x2F;em&gt; want to get to languages outside of rust, but have a lot of work to do here. More on FFI in the July-August time range. Current plan for 1.0 is sometime in September.&lt;br &#x2F;&gt;
As for excitement, Divma &amp;amp; Floris on our team have been hard at work on support for QUIC multipath for &lt;em&gt;months&lt;&#x2F;em&gt;. It‚Äôs a huge undertaking, and we‚Äôre all very excited to see it come together.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;12-are-there-any-bindings-or-plans-for-bindings-to-other-languages-iroh-ffi-seems-to-provide-support-for-python-what-is-it-s-status-and-do-you-plan-to-offer-official-support-for-any-other-languages&quot;&gt;12. Are there any bindings or plans for bindings to other languages? Iroh-ffi seems to provide support for Python, what is it‚Äôs status and do you plan to offer official support for any other languages?&lt;&#x2F;h3&gt;
&lt;p&gt;b5: Yes, we have plans, but need to figure out some hard stuff around what basically amounts to duck-typing in UniFFI bindings first :)&lt;&#x2F;p&gt;
&lt;p&gt;Many thanks to the Iroh team for taking the time to answer our questions!&lt;&#x2F;p&gt;
&lt;p&gt;References&lt;br &#x2F;&gt;
‚Ä¢ &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.iroh.computer&#x2F;proto&#x2F;iroh-gossip&quot;&gt;https:&#x2F;&#x2F;www.iroh.computer&#x2F;proto&#x2F;iroh-gossip&lt;&#x2F;a&gt;&lt;br &#x2F;&gt;
‚Ä¢ &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.bartoszsypytkowski.com&#x2F;hyparview&quot;&gt;https:&#x2F;&#x2F;www.bartoszsypytkowski.com&#x2F;hyparview&lt;&#x2F;a&gt;&lt;br &#x2F;&gt;
‚Ä¢ &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;asc.di.fct.unl.pt&#x2F;~jleitao&#x2F;pdf&#x2F;dsn07-leitao.pdf&quot;&gt;https:&#x2F;&#x2F;asc.di.fct.unl.pt&#x2F;~jleitao&#x2F;pdf&#x2F;dsn07-leitao.pdf&lt;&#x2F;a&gt;&lt;br &#x2F;&gt;
‚Ä¢ &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.bartoszsypytkowski.com&#x2F;plumtree&#x2F;&quot;&gt;https:&#x2F;&#x2F;www.bartoszsypytkowski.com&#x2F;plumtree&#x2F;&lt;&#x2F;a&gt;&lt;br &#x2F;&gt;
‚Ä¢ &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;asc.di.fct.unl.pt&#x2F;~jleitao&#x2F;pdf&#x2F;srds07-leitao.pdf&quot;&gt;https:&#x2F;&#x2F;asc.di.fct.unl.pt&#x2F;~jleitao&#x2F;pdf&#x2F;srds07-leitao.pdf&lt;&#x2F;a&gt;&lt;br &#x2F;&gt;
‚Ä¢ &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.iroh.computer&#x2F;proto&#x2F;iroh-docs&quot;&gt;https:&#x2F;&#x2F;www.iroh.computer&#x2F;proto&#x2F;iroh-docs&lt;&#x2F;a&gt;&lt;br &#x2F;&gt;
‚Ä¢ &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.iroh.computer&#x2F;proto&#x2F;iroh-blobs&quot;&gt;https:&#x2F;&#x2F;www.iroh.computer&#x2F;proto&#x2F;iroh-blobs&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;ssl.gstatic.com&#x2F;ui&#x2F;v1&#x2F;icons&#x2F;mail&#x2F;images&#x2F;cleardot.gif&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Ballista, a distributed compute platform made with Rust and Apache Arrow</title>
          <pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/ballista-a-distributed-compute-platform-made-with-rust-and-apache-arrow/</link>
          <guid>https://blog.lambdaclass.com/posts/ballista-a-distributed-compute-platform-made-with-rust-and-apache-arrow/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/ballista-a-distributed-compute-platform-made-with-rust-and-apache-arrow/">&lt;h4 id=&quot;an-interview-with-its-creator-andy-grove&quot;&gt;An interview with its creator, Andy Grove&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-L6SAuZiiRQ4bBaCCiDaP_w.png&quot; alt=&quot;&quot; &#x2F;&gt;Ballista demo. Source: &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;andygrove.io&#x2F;2020&#x2F;07&#x2F;ballista-one-year-on&#x2F;&quot;&gt;Andy Grove&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;‚ÄúI have become frustrated over the years with the proliferation of Big Data tools built in JVM languages. I understand the reasons for this ‚Äî Java, and especially Kotlin and Scala, are productive languages to work in, the ecosystem is very mature, and skills are widespread. However, it really isn‚Äôt the best language for these platforms. The most obvious alternative has been C++ for a long time, but I thought it would be really interesting to see what was possible with Rust.‚Äù ‚Äî Andy Grove&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;As distributed computing platforms continue to become more relevant and new programming languages emerge with a modern approach and a focus on features that more traditional languages aren‚Äôt suited for, new and interesting technologies start appearing. In this interview, Andy Grove, software engineer and creator of &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ballista-compute&#x2F;ballista&quot;&gt;Ballista&lt;&#x2F;a&gt;, a fresh distributed computing platform built primarily on Rust and powered by Apache Arrow technologies, provides some insight on the motivations behind the project as well as the technical details and features that make Ballista different.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-kYa4OnwY6NrvClA6wPpjZQ.png&quot; alt=&quot;&quot; &#x2F;&gt;Ballista is a work in progress. Once completed, its integrations will work like this. (Source: official documentation)&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h4 id=&quot;what-is-ballista-and-what-kind-of-problems-does-it-solve&quot;&gt;What is Ballista and what kind of problems does it solve?&lt;&#x2F;h4&gt;
&lt;p&gt;Ballista is a distributed compute platform with a current focus on executing ETL (extract, transform, and load) jobs based on queries which are defined using either a DataFrame API, SQL, or a combination of both.&lt;&#x2F;p&gt;
&lt;p&gt;Ballista is implemented in Rust and powered by Apache Arrow.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-are-the-main-advantages-of-using-apache-arrow-technologies&quot;&gt;What are the main advantages of using Apache Arrow technologies?&lt;&#x2F;h4&gt;
&lt;p&gt;In my opinion, there are quite a few advantages in using Apache Arrow for this project.&lt;&#x2F;p&gt;
&lt;p&gt;The Arrow memory format is optimized to support vectorized processing of columnar data and therefore enables significant performance improvements over row-based processing, especially when taking advantage of hardware that natively supports vectorized processing, such as SIMD and GPU.&lt;&#x2F;p&gt;
&lt;p&gt;Arrow also provides a ‚ÄúFlight‚Äù protocol, designed to enable Arrow data to be streamed efficiently (without &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.serde.rs&#x2F;serde&#x2F;&quot;&gt;serde&lt;&#x2F;a&gt; overhead) between processes, and Ballista‚Äôs executors implement this protocol.&lt;&#x2F;p&gt;
&lt;p&gt;In addition to these benefits, Arrow is a standard that is becoming adopted more widely over time, so designing Ballista from the ground-up to be Arrow-native helps ensure compatibility with other projects in the ecosystem.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-are-advantages-of-an-implementation-based-on-apache-arrow-over-native-data-structures&quot;&gt;What are advantages of an implementation based on Apache Arrow over native data structures?&lt;&#x2F;h4&gt;
&lt;p&gt;Arrow offers a mature type system and in-memory format for representing columnar data that has been tested and refined over many years, so I think this helps accelerate the development of the Ballista platform since there is no need to reinvent the wheel. It also ensures efficient compatibility with other projects that have also adopted Apache Arrow.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;can-you-tell-us-more-about-the-ballista-query-engine&quot;&gt;Can you tell us more about the Ballista query engine?&lt;&#x2F;h4&gt;
&lt;p&gt;Sure. Ballista is based on the Volcano design but has less overhead as a result of being designed to process batches of columnar data. Its design is very much inspired by Apache Spark but with a focus on being language-agnostic so that it can efficiently support popular programming languages such Python, Java, and C++.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;ballista-has-a-very-similar-usage-to-apache-spark-what-are-the-main-advantages-of-ballista-over-it&quot;&gt;Ballista has a very similar usage to Apache Spark, what are the main advantages of Ballista over it?&lt;&#x2F;h4&gt;
&lt;p&gt;The main advantages of Ballista (at least, once it is more mature) are:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Columnar Design&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Although Apache Spark does have some support for columnar processing, it is still largely row-based. Because Ballista is natively columnar and is implemented in a systems level language, it can take advantage of vectorized processing with SIMD and GPU.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Language Agnostic&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Apache Spark is implemented in Scala and tends to have a Scala-first approach, with other languages paying a penalty to interact with Spark due to overheads of serde. Ballista has been architected to use language-agnostic protocols and serialization formats to avoid this.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Memory Efficiency&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Because Ballista is implemented in Rust, there are no GC pauses, and performance is very consistent and predictable. The combination of Rust and Arrow also results in much lower memory usage than Apache Spark ‚Äî up to 5x lower memory usage in some cases. This means that more processing can fit on a single node, reducing the overhead of distributed compute.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-does-it-compare-to-dask&quot;&gt;How does it compare to Dask?&lt;&#x2F;h4&gt;
&lt;p&gt;I actually do not have any experience with Dask yet, although it has been on my ‚Äúto do‚Äù list for a while now. I have heard a lot of positive things about Dask and I am sure that I could learn a lot from this project.&lt;&#x2F;p&gt;
&lt;p&gt;Dask is obviously Python-centric, so I suspect that is going to be the main differentiator. Although the Ballista scheduler is being implemented in Rust, it is designed to work with executors implemented in any language due to the use of Arrow‚Äôs Flight protocol, and Google Protocol Buffers to represent query plans and scheduler tasks.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-are-the-reasons-behind-the-choice-of-rust-as-the-main-execution-language&quot;&gt;What are the reasons behind the choice of Rust as the main execution language?&lt;&#x2F;h4&gt;
&lt;p&gt;The reason that I started this project (first with DataFusion at the start of 2018, and now with Ballista) is that I have become frustrated over the years with the proliferation of Big Data tools built in JVM languages. I understand the reasons for this ‚Äî Java, and especially Kotlin and Scala, are productive languages to work in, the ecosystem is very mature, and skills are widespread. However, it really isn‚Äôt the best language for these platforms. The most obvious alternative has been C++ for a long time, but I thought it would be really interesting to see what was possible with Rust.&lt;&#x2F;p&gt;
&lt;p&gt;I see Rust as being a good compromise between Java and C++. It has the memory-safety of Java (but implemented in a very different way) and the performance and predictability of C++.&lt;&#x2F;p&gt;
&lt;p&gt;The cost of compute can be very high with Big Data platforms, so it makes sense to use a language that can make efficient use of the available memory and processing power on each node. In some cases, Ballista uses a fraction of the memory of an equivalent Apache Spark job, and this means that each node in a cluster can process a multiple of the amount of data that Spark can support, resulting in smaller clusters that are utilized more effectively.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;apache-spark-has-mllib-a-library-for-handling-machine-learning-projects-what-features-does-ballista-offer-for-these-tasks&quot;&gt;Apache Spark has MLlib, a library for handling Machine Learning projects. What features does Ballista offer for these tasks?&lt;&#x2F;h4&gt;
&lt;p&gt;So far, the focus of Ballista has very much been on ETL workloads. There have been some discussions about supporting ML workloads but this is an area that I do not have experience with so I am hoping that once Ballista is a little more mature in terms of ETL processing then we can start to look at other areas like ML and listen to what the current pain points are.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-will-be-the-main-areas-of-focus-for-future-releases&quot;&gt;What will be the main areas of focus for future releases?&lt;&#x2F;h4&gt;
&lt;p&gt;The main focus now is getting the platform to a level of maturity where users can run real-world ETL workloads, using the TPC-H benchmarks to measure progress.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;beyond-performance-what-are-the-next-goals-for-the-ballista-project&quot;&gt;Beyond performance, what are the next goals for the Ballista project?&lt;&#x2F;h4&gt;
&lt;p&gt;Personally, I think that the most important goal for the Ballista project is to build a community around it. It started out as a personal side-project but I can only commit a relatively small number of hours each weekend to work on the project, and that time is better spent on writing requirements and building a community than trying to code everything myself.&lt;&#x2F;p&gt;
&lt;p&gt;To this end, I have started a weekly newsletter, named &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;ballistacompute.org&#x2F;this-week-in-ballista&#x2F;&quot;&gt;‚ÄúThis Week in Ballista‚Äù,&lt;&#x2F;a&gt; to share news about progress and where help is needed. I am mostly spending my time on the project on tasks such as filing issues and responding to questions in Discord. I am also prototyping new features and then asking for help from the community to complete them.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;do-you-have-any-book-recommendations-on-distributed-computing&quot;&gt;Do you have any book recommendations on distributed computing?&lt;&#x2F;h4&gt;
&lt;p&gt;Last year, I wrote &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.andygrove.io&#x2F;2020&#x2F;02&#x2F;how-query-engines-work&#x2F;&quot;&gt;‚ÄúHow Query Engines Work‚Äù&lt;&#x2F;a&gt;, which is an introductory guide to query engines and it does cover distributed computing at a high level. I would be hesitant in recommending this book specifically to learn about distributed computing though, since it doesn‚Äôt have very much content on this subject yet, although I do plan on extending the content once Ballista is farther along.&lt;&#x2F;p&gt;
</description>
      </item>
    </channel>
</rss>
