<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>LambdaClass Blog - Probabilistic Programming</title>
      <link>https://blog.lambdaclass.com</link>
      <description>Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.</description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://blog.lambdaclass.com/tags/probabilistic-programming/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Tue, 19 May 2020 00:00:00 +0000</lastBuildDate>
      <item>
          <title>Soss: Probabilistic Programming with Julia</title>
          <pubDate>Tue, 19 May 2020 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/soss-probabilistic-programming-with-julia/</link>
          <guid>https://blog.lambdaclass.com/posts/soss-probabilistic-programming-with-julia/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/soss-probabilistic-programming-with-julia/">&lt;h4 id=&quot;an-interview-with-its-creator-chad-scherrer&quot;&gt;An interview with its creator, Chad Scherrer&lt;&#x2F;h4&gt;
&lt;p&gt;By: Javier Rodríguez Chatruc and Federico Carrone&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-m6924vcooeuQEu7FiBOI5A.png&quot; alt=&quot;&quot; &#x2F;&gt;Credit: Chad Scherrer&lt;&#x2F;p&gt;
&lt;p&gt;Probabilistic programming is at this point an established field both for research and industry applications, but like everything else (especially in the tech industry), it is undergoing constant evolution. This is where &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;julialang.org&#x2F;&quot;&gt;Julia&lt;&#x2F;a&gt; comes in — designed for high performance in the world of data science, it seems to be the perfect fit for probabilistic programming.&lt;&#x2F;p&gt;
&lt;p&gt;To learn more about this world we contacted &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;chadscherrer&quot;&gt;Chad Scherrer&lt;&#x2F;a&gt;, the creator of &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;cscherrer&#x2F;Soss.jl&quot;&gt;Soss&lt;&#x2F;a&gt;, a probabilistic programming library written entirely in Julia. With a very clean syntax resembling math notation, Soss seems to bridge the gap between the more academic side of data science and the more technical&#x2F;developer one, while also providing speed and &lt;em&gt;first-class&lt;&#x2F;em&gt; models.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h4 id=&quot;please-tell-us-a-bit-about-yourself-what-is-your-background-what-is-your-current-position&quot;&gt;Please tell us a bit about yourself. What is your background? what is your current position?&lt;&#x2F;h4&gt;
&lt;p&gt;Starting out, I thought I would end up focusing on algebraic topology. So I did coursework along these lines for a few years before switching to stats. My thesis is on a special case of multivariate normal distributions with a group symmetry, so algebra still plays a big part.&lt;&#x2F;p&gt;
&lt;p&gt;After graduating, I worked at Pacific Northwest National Laboratory, mostly doing computational statistics. I learned some Python, then R. The high-level coding was nice, but I was frustrated by how awkward it was to make it fast.&lt;&#x2F;p&gt;
&lt;p&gt;One day I came across this “Great Computer Language Shootout”, where Ocaml was really dominating. So I used that for a few years. Then multicore hardware started really picking up, but at the time the Ocaml team said they wouldn’t really be doing anything with SMP (symmetric multiprocessing). So I started looking around again, and found Haskell.&lt;&#x2F;p&gt;
&lt;p&gt;Along the way, I had collaborated with the high-performance computing group doing &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;1206.6409.pdf&quot;&gt;parallel&lt;&#x2F;a&gt; &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;1212.4174v1.pdf&quot;&gt;machine learning&lt;&#x2F;a&gt; using C&#x2F;OpenMP. And I started getting interested in probabilistic programming. I wanted to make something like &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;mcmc-jags.sourceforge.net&#x2F;&quot;&gt;JAGS&lt;&#x2F;a&gt;, but using Haskell and allowing more high-level expressiveness. So I collaborated with Galois to develop &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;cscherrer.github.io&#x2F;pdf&#x2F;Scherrer%20-%202012%20-%20Passage%20A%20Parallel%20Sampler%20Generator%20for%20Hierarchical%20Bayesian%20Modeling.pdf&quot;&gt;Passage&lt;&#x2F;a&gt;, which works in terms of a now-standard probability monad, and produces C&#x2F;OpenMP code for parallel Gibbs sampling.&lt;&#x2F;p&gt;
&lt;p&gt;Based on the Passage work, Galois started getting involved with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.darpa.mil&#x2F;program&#x2F;probabilistic-programming-for-advancing-machine-Learning&quot;&gt;&lt;em&gt;Probabilistic Programming for Advancing Machine Learning (PPAML)&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;, but they needed someone to serve as technical lead. So I moved to Portland and did that for a few years. Galois is a (mostly) Haskell shop, so I was able to dig deeper into both Haskell and probabilistic programming.&lt;&#x2F;p&gt;
&lt;p&gt;Still wanting to extend some of the ideas from Passage, I moved to Seattle and spent a couple of years at &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.thisismetis.com&#x2F;&quot;&gt;Metis&lt;&#x2F;a&gt; teaching data science. In my free time, I got more up to speed on &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;julialang.org&#x2F;&quot;&gt;Julia&lt;&#x2F;a&gt;, and started work on what would become &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;cscherrer&#x2F;Soss.jl&quot;&gt;Soss&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;These days, I work as a Senior Research Scientist at &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.relational.ai&#x2F;&quot;&gt;RelationalAI&lt;&#x2F;a&gt;. Most machine learning pipelines treat database queries and model training as entirely independent, so to go between them requires throwing away all of the structure and just joining everything.&lt;&#x2F;p&gt;
&lt;p&gt;As it turns out, that throws away some big opportunities for optimization. So our system has an expressive language for reasoning about relational structure, and works in terms that make these optimizations natural for machine learning and probabilistic programming.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-is-probabilistic-programming-how-does-it-differ-from-other-forms-of-programming&quot;&gt;What is probabilistic programming? How does it differ from other forms of programming?&lt;&#x2F;h4&gt;
&lt;p&gt;When people talk about &lt;em&gt;Probabilistic Programming Languages&lt;&#x2F;em&gt; (PPLs), they usually mean a system for building and reasoning about Bayesian models. Maybe the simplest way to think about this is as a way of reasoning about simulations. Say you have a simulation that you can run to make a simulated “world”. Every part of the simulation has some randomness. This includes the things you can actually observe, but also the underlying choices the simulator made for things that affect those observations. But those are random too, so they might depend on &lt;em&gt;other&lt;&#x2F;em&gt; random choices.&lt;&#x2F;p&gt;
&lt;p&gt;Ok, so choices made along the way will affect the distribution of things downstream. But we can also use this to reason the other way! We observe some data, and ask “what choices along the way could have led to this?”&lt;&#x2F;p&gt;
&lt;p&gt;In the simplest case, say we have a simulation for biased coin flips where we pick a random probability of heads, say &lt;code&gt;p ~ Uniform(0,1)&lt;&#x2F;code&gt;, and simulate 20 flips. Then we observe 15 heads and 5 tails. We can’t say for certain what &lt;code&gt;p&lt;&#x2F;code&gt; was, but we can find a distribution that’s updated based on the observed data.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-did-you-get-into-julia-why-choose-julia-over-python-or-r&quot;&gt;How did you get into Julia? Why choose Julia over Python or R?&lt;&#x2F;h4&gt;
&lt;p&gt;I want to be able to express ideas at a high level of abstraction without sacrificing performance. I’ve used Python and R quite a bit, for the things I wanted to do I always felt constrained because getting performance always means pushing things to another language. Then there are concerns with the cost of crossing that language barrier, both in a human and computational sense.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-is-soss-how-did-it-come-about-and-what-was-the-motivation-behind-it&quot;&gt;What is Soss? How did it come about and what was the motivation behind it?&lt;&#x2F;h4&gt;
&lt;p&gt;Soss is a Julia-based PPL that represents the right-hand side of each assignment (&lt;code&gt;=&lt;&#x2F;code&gt;) and sample (&lt;code&gt;~&lt;&#x2F;code&gt;) as an AST. The nice thing about this is, it gives ultimate flexibility in what a model can do. For example, we have inference methods that take a &lt;code&gt;Model&lt;&#x2F;code&gt; and return an &lt;code&gt;AST&lt;&#x2F;code&gt; that generates code at run-time, but we also have model transformation functions that return another model. Models are first-class, and can be used inside other models, etc.&lt;&#x2F;p&gt;
&lt;p&gt;There are some other things too, for example we have an interface to SymPy so you can easily get to a symbolic representation of the log-density. Simplifications here can lead to faster code, so we also have a way to generate SSA Julia code from this. There’s still plenty more speed to be had, but I’ve seen 100x-1000x speedup with this vs a direct implementation.&lt;&#x2F;p&gt;
&lt;p&gt;I’ve wanted to build Soss for a long time, it was just a matter of finding a language with metaprogramming support that could handle the syntax I wanted, while also having the speed and a good numerically-oriented ecosystem.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-does-the-probabilistic-programming-ecosystem-in-julia-compare-to-the-ones-in-python-r-in-particular-how-does-soss-compare-to-pymc3&quot;&gt;How does the probabilistic programming ecosystem in Julia compare to the ones in Python&#x2F;R? In particular, how does Soss compare to PyMC3?&lt;&#x2F;h4&gt;
&lt;p&gt;To get speed, both Python and R have to call to other languages. I’ve spent a lot of time using PyMC3, and I really like it. But it still requires keeping in your head which lines of code are talking to Python, vs which are talking to Theano. There’s a language barrier to play across, and losing track of it tends to break things.&lt;&#x2F;p&gt;
&lt;p&gt;When you write a Soss model, it’s all Julia. You can use Julia functions freely. Even if you want to do Soss development (please do!), it’s still all Julia.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;on-that-note-who-is-the-end-user-for-the-library-is-it-mostly-just-used-in-academic-settings-or-are-there-industry-uses-as-well&quot;&gt;On that note, who is the end user for the library, is it mostly just used in academic settings or are there industry uses as well?&lt;&#x2F;h4&gt;
&lt;p&gt;It’s certainly intended for both. One thing I like about the AST approach is that generated code can be as fast as you can make it.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-were-the-biggest-challenges-in-developing-probabilistic-programming-for-a-new-language&quot;&gt;What were the biggest challenges in developing probabilistic programming for a new language?&lt;&#x2F;h4&gt;
&lt;p&gt;There’s always some overhead in learning a new programming language. Julia has a very Python-like syntax, so learning the basics was very fast. But metaprogramming requires different ways of thinking about things, so that took a lot of spinning up.&lt;&#x2F;p&gt;
&lt;p&gt;Macros weren’t enough, we had to use Julia’s &lt;code&gt;@generated&lt;&#x2F;code&gt; functions, which let you do staged programming. Even with this, the types weren’t quite working out, so I was using &lt;code&gt;eval&lt;&#x2F;code&gt; all over the place, which does evaluation in global scope and can cause some problems.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;thautwarm.github.io&#x2F;Site-32&#x2F;index.html&quot;&gt;Taine Zhao&lt;&#x2F;a&gt; got us out of the rut with some great Julia packages like &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;thautwarm&#x2F;GeneralizedGenerated.jl&quot;&gt;GeneralizedGenerated.jl&lt;&#x2F;a&gt;. Generated functions compile new code for each new type they’re evaluated on, so she realized the model’s type could contain a representation of the entire model. It’s a clever solution, and helped a lot of other parts of the design to fall into place.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;there-seems-to-be-an-explosion-in-probabilistic-programming-on-julia-with-other-libraries-like-turing-or-gen-how-does-soss-compare-to-them&quot;&gt;There seems to be an explosion in probabilistic programming on Julia with other libraries like Turing or Gen, how does Soss compare to them?&lt;&#x2F;h4&gt;
&lt;p&gt;I’d say the syntax is closer to Turing, but the semantics are closer to Gen.&lt;&#x2F;p&gt;
&lt;p&gt;The Gen team independently came up with the same approach we’re using of representing a model as a function. In most PPLs, the model includes some indication of which data will later be observed. But leaving this out until inference time makes it much easier to compose models in different ways.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;any-books-you-recommend-reading-on-the-topic-besides-the-classics-statistical-rethinking-and-bayesian-methods-for-hackers&quot;&gt;Any books you recommend reading on the topic, besides the classics Statistical Rethinking and Bayesian Methods for Hackers?&lt;&#x2F;h4&gt;
&lt;p&gt;Both of these are great. If you’re interested in a particular system, most of the well-funded ones have a nice collection of examples and tutorials; walking through those usually helps.&lt;&#x2F;p&gt;
&lt;p&gt;If you want a broader and deeper view, I’d suggest digging into Bayesian analysis directly. One of my favorites is David MacKay’s &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.inference.org.uk&#x2F;mackay&#x2F;itila&#x2F;&quot;&gt;Information Theory, Inference, and Learning Algorithms&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-s-next-for-soss&quot;&gt;What’s next for Soss?&lt;&#x2F;h4&gt;
&lt;p&gt;There’s always more to do. Currently we’re starting work to make the documentation better. I think we need lots more examples, tutorials, and comparisons to other systems.&lt;&#x2F;p&gt;
&lt;p&gt;If you have any questions about Soss, the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;discourse.julialang.org&#x2F;&quot;&gt;Julia Discourse&lt;&#x2F;a&gt; or &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;julialang.zulipchat.com&quot;&gt;Zulip&lt;&#x2F;a&gt; are both great. And of course, there’s always GitHub issues for &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;cscherrer&#x2F;Soss.jl&quot;&gt;the Soss repo&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Interview with Osvaldo Martin about Bayesian Analysis with Python</title>
          <pubDate>Mon, 11 Feb 2019 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/interview-with-osvaldo-martin-about-bayesian-analysis-with-python/</link>
          <guid>https://blog.lambdaclass.com/posts/interview-with-osvaldo-martin-about-bayesian-analysis-with-python/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/interview-with-osvaldo-martin-about-bayesian-analysis-with-python/">&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-NpQf9G3ZdnMXLT-QT3sErQ.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Like our &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;notamonadtutorial.com&#x2F;inteview-with-thomas-wiecki-about-probabilistic-programming-and-pymc-66a12b6f3f2e&quot;&gt;previous interviewee&lt;&#x2F;a&gt; &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;aloctavodia&quot;&gt;Osvaldo Martin&lt;&#x2F;a&gt; is one of the developers of PyMC3 and ArviZ. He is a researcher specialized in Bayesian statistics and data science. He will be speaking at our &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lambdaclass&#x2F;buzzconf&quot;&gt;BuzzConf&lt;&#x2F;a&gt; this year. I hope you like this interview as much as we did!&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h4 id=&quot;can-you-tell-us-how-data-analysis-has-improved-over-the-years&quot;&gt;Can you tell us how data analysis has improved over the years?&lt;&#x2F;h4&gt;
&lt;p&gt;This is not a simple question to answer, specially if we take into account that we have been doing data analysis from ancient times. The analysis of astronomical data has a long tradition it even predates (modern) science. For most of our history it was motivated by the many different religious liturgies we have invented over the centuries and the more &lt;em&gt;grounded&lt;&#x2F;em&gt; need of improving and controlling the food production. Fast-forwarding thousand of years one can argue that the data-driven studies of astronomers like Tycho Brahe had a decisive impact on setting up the scientific revolution. Astronomy and astrology were not fully separated by that time, but Brahe, based on his observations and experience already thought that astrologists were just charlatans and he maintains that the planets and stars have null influence over the human affairs. If that’s not a Data Scientist, who is?&lt;&#x2F;p&gt;
&lt;p&gt;So the “big thing” we are living now is not that we suddenly realize data is important, we have already known that for centuries, the difference is that now we have tons of available data from scientific disciplines like Biology and Astronomy, just to name two, and from daily interactions with streaming platforms, social networks, cell phones, and sensors all around us. Computers have made this possible by increasing our capacity to storage, process and transmits information by several order of magnitude, and perhaps equally important computers has also changed the way we ask questions and provide answers. There is a whole array of new methods to analyze and generate data, that are impractical without computers. Indeed, the modern practice and development of Bayesian methods have been profoundly influenced by the computers and computational methods up to the point that modern Bayesian statistics IS computational statistics. The only reason we are talking now about probabilistic programming, Machine Learning and Data Science is because we have cheap and fast computers.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;can-you-tell-us-in-brief-how-pymc3-and-arviz-help-with-bayesian-analysis&quot;&gt;Can you tell us in brief how PyMC3 and ArviZ help with Bayesian Analysis?&lt;&#x2F;h4&gt;
&lt;p&gt;PyMC3 is a probabilistic programming language offering two main components: a very clear syntax to define probabilistic models and a powerful set of methods to solve those models, mainly Markov Chain Monte Carlo and Variational Inference. Ideally the methods to solve probabilistic models should be Universal in the sense that they should be able to solve any valid probabilistic model. Unfortunately, even when current methods are very powerful they do not always work as we like, some models are still very difficult or slow to solve. Thus an important step in Bayesian Analysis is to check that inference was done properly. And this is one the motivations for creating ArviZ, a Python package for exploratory analysis of Bayesian models. ArviZ Includes functions for posterior analysis, sample diagnostics, model checking, and comparison. ArviZ works hand-in-hand with PyMC3, and other probabilistic programming language, like PyStan, emcee, Pyro, etc. Where the aim of the probabilistic programming languages is to make it easy to build and solve Bayesian models, the aim of the ArviZ library is to make it easy to process and analyze the results from the Bayesian models.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;can-you-explain-some-of-the-main-concepts-of-bayesian-analysis&quot;&gt;Can you explain some of the main concepts of Bayesian Analysis?&lt;&#x2F;h4&gt;
&lt;p&gt;Bayesian analysis can be summarized in just two concepts. Use probability distributions to represents the uncertainty in your model parameters. Then use Bayes theorem to update those probabilities given the data you have. All the rest derives from these two main concepts. Other concepts that are important to the practice of Bayesian Analysis are shared with other modeling approaches, like evaluating if models make sense by comparing their output against the data and the available domain-knowledge.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;why-do-you-like-working-with-data&quot;&gt;Why do you like working with data?&lt;&#x2F;h4&gt;
&lt;p&gt;I am not sure I “like” working with data, working with data is hard, data collection, data wrangling, cleaning and processing is generally time consuming. Data &lt;em&gt;per se&lt;&#x2F;em&gt; is not important what really matters is understanding phenomena, solving problems and designing better tools to solve problems. What happens is that data is essential to all these tasks. To answer any question in a scientific way you will need data at some point, for some problems you can progress a lot with just theory, but eventually you will need some data. The only scientific discipline that can avoid using data is pure mathematics. And for that reason many people do not think that mathematics is a scientific discipline, or if so they classify it as a logical science and not a factual one.&lt;&#x2F;p&gt;
&lt;p&gt;Everyone is talking about the data deluge and thus is easy to miss that data is produced by someone and that producing data is not always easy or cheap. Even when we have access to pre-existing data it may need further processing or it may not be suitable to answer our questions and thus we may need to generate data from scratch. In general, answering specific questions requires generating specific data under specific conditions. Just a few years ago many computational biologists and bioinformaticians believed that by extracting biological information from scientific journals and databases we will be able to build very reliable models of the cell. It turns out that while this is a good idea, is not that easy as its sounds and not applicable to every question. Papers are behind paywalls, written in formats not that easy to analyze programatically, experiments are performed under so many different conditions that integrating the information coherently is closer to a bad breakup than a romantic dinner, some experimental results are too noisy or the experimental design is flawed, observations can be contradictory, information in databases need to be further curated, etc.&lt;&#x2F;p&gt;
&lt;p&gt;To many people Data Science have put “data” in the spotlight, but science has always been data-driven. Charles Darwin was responsible from one of the most elegant scientific theories, and one of the most misrepresented ones. He spent years and years collecting data, not for the sake of having data but to try to make sense of the diversity and complexity of living organisms. Nowadays evolutionary biologists still spend a lot of time producing and gathering data from carefully designed observations, experiments and simulations in order to refine evolutionary ideas.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-are-the-advantages-and-disadvantages-of-using-python-over-other-languages-for-data-analysis&quot;&gt;What are the advantages and disadvantages of using Python over other languages for data analysis?&lt;&#x2F;h4&gt;
&lt;p&gt;One of the reasons I use Python is that it is a general purpose language, and while I spend a lot of time on data-analysis related stuff I also use Python to solve other types of problems. I learned to program during my PhD without formal training but with the help of great books like Think Python by Allen Downey and A Primer on Scientific Programming with Python by Hans Petter Langtangen, and also helped in many different ways by a large, welcoming and enthusiastic Python community.&lt;&#x2F;p&gt;
&lt;p&gt;At the time of my PhD most of my “coding” was about automating boring stuff and gluing specific scientific packages in order to perform molecular simulations and very very simple data-analysis problems. I used to do that using a collections of poorly documented (and probably poorly written) bash scripts. With the time this approach turns to be too restrictive, so I tried to learn Fortran and C, but I found them overcomplicated for most of the tasks I wanted to solve at the moment, and only very useful for a subsets of them… until I find Python! As someone said Python is not the best programming language for almost any task but is good enough for most of them as I would discover with the pass of time and with every new project that involved Python. One super tedious task for me at that moment was updating plots. I used a software with a GUI (and open source clone of a reeeeeally expensive proprietary scientific plotting software). Updating plots after re-running a simulation or noticing a mistake or getting feedback from my advisors or peers was a lot of work. Somehow, I did not remember the exact moment I found matplotlib, that was a deal-breaker for me and one of the reasons to learn even more Python.&lt;&#x2F;p&gt;
&lt;p&gt;Another epiphany was when I re-wrote a small piece of software a colleague kindly passed to me. Like me, my colleague was a non-computer-scientist. This code was a collection of bash scripts and a Fortran main program. I started with the bash scripts, instead of running several bash scripts I unified all of them into a collection of coherent Python functions. This already make my workflow easier and I was already super-happy, then I decide to change the Fortran code, at first this was mainly an exercise to challenge myself to learn more NumPy and Scipy. After many attempts to get this right (I never truly learned Fortran) I got a working Python version of the code, this code was not only much more shorter, easier to read and more modular, but to my surprise it was also 10x faster! Most of the speed-up come by replacing a lot of Fortran code with a SciPy call and a couple of NumPy array operations. And this was an important lesson to me. Do not re-invent the wheel, there are many specialized, well-tested, efficient routines out there, use them! Because while Python is &lt;em&gt;slow&lt;&#x2F;em&gt; not being proficient programmer in a &lt;em&gt;fast&lt;&#x2F;em&gt; language like Fortran or C can be even slower!&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-aspects-of-doing-bayesian-analysis-with-python-do-you-feel-are-tricky-to-get-past&quot;&gt;What aspects of doing Bayesian Analysis with Python do you feel are tricky to get past?&lt;&#x2F;h4&gt;
&lt;p&gt;For newcomers getting a fully functional Python environment can sometimes be tricky. Anaconda (a scientific Python distribution) and conda (a package manager) have helped a lot to get things installed properly, specially for Windows users.&lt;&#x2F;p&gt;
&lt;p&gt;When I show PyMC3 code to people most of them seem surprised by how much you can do with a few lines of codes. I even get responses like “that’s not programming” which I totally agree is just using a programming language to give instructions to a computer and get things done ;-) The challenge when using PyMC3 is then not so much on the programming-side but on the mental-modeling side, at first most people has problems figuring out how to express they problems in terms of a probabilistic model. This is a matter of practice and the creative part of the job. In the book I tried to show many examples of different models to help ease this transition to thinking probabilistically. This is something that needs practice, knowing that most pop-songs are built from the same chord progression of 3 to 4 chords that’s not automatically makes you a pop-star.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;your-take-on-the-data-analysis-environment-with-regards-to-innovations-in-it-the-knowledge-and-skills-gap-and-software-development-how-do-you-think-the-tech-landscape-is-changing&quot;&gt;Your take on the data analysis environment with regards to innovations in it, the knowledge and skills gap, and software development. How do you think the tech landscape is changing?&lt;&#x2F;h4&gt;
&lt;p&gt;My impression is that we now have something that was completely unimagined just a couple of decades ago: the popularization of very powerful computer methods. One of the side effects of the computer revolution is that any person with a modest understanding of a programming language like Python now has access to a plethora of powerful computational methods for data analysis, simulations, and other complex tasks. I am totally in favor of this, is one of my motivation to work on Open Source Software projects and to give free courses at the University. But I also recognize that this should be an invitation to us, as a community, to be extra careful about these methods not only to be able to apply them correctly from a technical point of view and to avoid making false claims but also from an ethical and democratic perspective. Otherwise we face the risk of giving too much control over important decisions to an increasingly reduced group of rich and powerful people and corporations, something that I am afraid is already happening and with disastrous consequences for those of us that not are part of the super-rich club. To turn this popularization of methods into a true democratization we need not only to make the methods accessible we also need to make other resources widely available. If the majority of the data generating processes, the data itself and the most powerful hardware is controlled by a small group then, we are not aiming for a true democracy we are just spending a lot of resources into training a high skilled work-force to serve the interest of a few and that is just a technocratic version of an oligarchy.&lt;&#x2F;p&gt;
</description>
      </item>
    </channel>
</rss>
