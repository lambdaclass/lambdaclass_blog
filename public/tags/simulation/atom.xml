<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>LambdaClass Blog - Simulation</title>
    <subtitle>Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.</subtitle>
    <link rel="self" type="application/atom+xml" href="https://blog.lambdaclass.com/tags/simulation/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2021-09-02T00:00:00+00:00</updated>
    <id>https://blog.lambdaclass.com/tags/simulation/atom.xml</id>
    <entry xml:lang="en">
        <title>Simulations are about to get way, way faster with JuliaSim</title>
        <published>2021-09-02T00:00:00+00:00</published>
        <updated>2021-09-02T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com/posts/simulations-are-about-to-get-way-way-faster-with-juliasim/"/>
        <id>https://blog.lambdaclass.com/posts/simulations-are-about-to-get-way-way-faster-with-juliasim/</id>
        
        <content type="html" xml:base="https://blog.lambdaclass.com/posts/simulations-are-about-to-get-way-way-faster-with-juliasim/">&lt;p&gt;Today we’re excited to bring you a first glance at the result of a major multi-year project by the Julia Computing team.&lt;&#x2F;p&gt;
&lt;p&gt;JuliaSim is a cloud-based simulation platform built on top of the Julia open source stack, including SciML and ModelingToolkit, which we explored in depth &lt;a href=&quot;&#x2F;scientific-machine-learning-with-julia-the-sciml-ecosystem&#x2F;&quot;&gt;here&lt;&#x2F;a&gt; and &lt;a href=&quot;&#x2F;modeling-complexity-with-symbolics-jl-and-modelingtoolkit-jl&#x2F;&quot;&gt;here&lt;&#x2F;a&gt;, respectively. These were just the base of JuliaSim, which aims to change the way the industry does modeling and simulation with powerful acceleration and integration within a complete ecosystem.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;juliacomputing.com&#x2F;products&#x2F;juliasim&#x2F;&quot;&gt;JuliaSim&lt;&#x2F;a&gt;’s first beta will be released in a few months. We interviewed Chris Rackauckas to learn more about the project.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h4 id=&quot;what-is-juliasim-how-does-it-compare-to-alternatives-like-modelica-dymola&quot;&gt;What is JuliaSim? How does it compare to alternatives like Modelica&#x2F;Dymola?&lt;&#x2F;h4&gt;
&lt;p&gt;JuliaSim is a cloud-based platform for accelerated modeling and simulation. Unlike tools like Dymola, it integrates with a large open source community, the Julia programming language and the SciML ecosystem, to enhance its environment with offerings like easy parallelism, automated generation of ML surrogate models, and much more. In &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=lNbU5jNp67s&quot;&gt;a recent talk at JuliaCon 2021&lt;&#x2F;a&gt; I highlight this community integration as one of its core aspects that gives JuliaSim a competitive advantage in terms of features and performance, since it allows us to contribute to and benefit from the work of many scientists and engineers from across the world.&lt;&#x2F;p&gt;
&lt;p&gt;While JuliaSim has acausal modeling as one of its core features, unlike Modelica-based tools that is just one of its domains. Accelerated simulation of PDEs with neural networks, integrating stochastic simulation into workflows, specific simulation environments for pharmacology and circuit modeling, and much more are all part of the JuliaSim product. We see the future as a place where composability will be necessary to achieve the next level of simulations.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;can-it-integrate-with-the-fmi-will-we-be-able-to-use-models-written-in-e-g-modelica-inside-juliasim&quot;&gt;Can it integrate with the FMI? Will we be able to use models written in, e.g. Modelica, inside JuliaSim?&lt;&#x2F;h4&gt;
&lt;p&gt;Yes, JuliaSim at its release will offer features for integrating with the FMI standard, allowing for FMI imports and FMI exports. This will allow for example the ability to build surrogates of models from Modelica or Simulink platforms, and allow for generating binaries that can integrate back into these platforms.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;a-key-aspect-of-modelica-is-its-standard-library-which-includes-many-of-the-most-common-components-for-modeling-will-there-be-a-similar-thing-in-juliasim&quot;&gt;A key aspect of Modelica is its standard library, which includes many of the most common components for modeling. Will there be a similar thing in JuliaSim?&lt;&#x2F;h4&gt;
&lt;p&gt;With JuliaSim we are building a standard library which includes similar domains to the Modelica Standard Library, but also includes many other domains related to the customers we have been working with. For example, with JuliaSim one will be able to easily search a database of hundreds of physiological and systems biological models for accelerating workflows in biomedical simulation and drug development. We plan to continually improve this model library and mold it to the needs of our customers.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-are-surrogate-models-what-makes-them-important-especially-beyond-academic-applications&quot;&gt;What are surrogate models? What makes them important, especially beyond academic applications?&lt;&#x2F;h4&gt;
&lt;p&gt;Surrogate models are an amortization of compute cost to improve simulation workflows. It gives you a way to say “do 100 simulations now, and all of my future simulations are 100x faster”. When you mix this with cloud resources you can get a major workflow update: pay for a bit of cloud compute to spawn a bunch of simulations in parallel, but now every time you click the simulate button you do not have to wait 30 minutes to check the result.&lt;&#x2F;p&gt;
&lt;p&gt;When I was in graduate school I noticed that there is a very nonlinear effect of code speed on productivity which I captured in a &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.stochasticlifestyle.com&#x2F;the-nonlinear-effect-of-code-speed-on-productivity&quot;&gt;blog post&lt;&#x2F;a&gt;. If you have to wait 30 minutes for a result, that means that instead you’ll start it before lunch or before a 1 hour meeting, so the true “time to see simulation results” gets amplified further. 2 hour simulations are something you will start in the morning and check at night. Thus a surrogate changing a long simulation to something that you can analyze in real-time is invaluable to decreasing labor costs because of how simulation time effects the day-to-day life of an engineer.&lt;&#x2F;p&gt;
&lt;p&gt;While in an academic sense we focus on issues like “training the surrogate costs 100 simulations, but we needed 10,000 simulations for to optimize the building design and thus we saved in the end”, I do not think this calculus is really the major change that surrogates will bring. Even if it takes 100 simulations to train a surrogate that you use 10 times, if you integrate this will cloud compute to do those all in parallel, then to the user you only have to sit through what is effectively 2 simulations. If that’s a two hour simulation time, you’ve now changed a workflow that takes a full day to something that you set to train in the morning and then after lunch you can interactively fiddle with parameters until your controls are correct. And then any time you revisit in the future, it’s ready to be fiddled with again. When you view surrogates in this light, I think you can see why we believe this will be a gamechanger for the everyday engineer.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;one-of-the-main-innovations-brought-by-juliasim-is-the-generation-of-fast-and-accurate-surrogate-models-that-can-speedup-simulations-as-much-as-500x-even-in-the-presence-of-stiff-models-how-is-this-achieved-what-s-a-ctesn&quot;&gt;One of the main innovations brought by JuliaSim is the generation of fast and accurate surrogate models that can speedup simulations as much as 500x, even in the presence of stiff models. How is this achieved? What’s a CTESN?&lt;&#x2F;h4&gt;
&lt;p&gt;A continuous-time echo state network (CTESN) is an implicitly trained machine learning framework for capturing the dynamics of stiff models. These are models with phase transitions, fast transient behavior, and are well-known to be numerically difficult. Across many domains we have shown the CTESN training procedure to be robust due to how it incorporates implicit features of stable differential equation solvers. All that we need to generate it is a chunk of simulations done beforehand, and what results is this really fast object that will predict the simulation behavior at new parameters.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-easy-is-it-to-compose-surrogate-models-with-normal-ones-in-juliasim-what-are-the-advantages-of-this-approach&quot;&gt;How easy is it to compose surrogate models with normal ones in JuliaSim? What are the advantages of this approach?&lt;&#x2F;h4&gt;
&lt;p&gt;The CTESN represents the surrogate of a differential equation model as a differential equation model. Because of this representation, it’s not different from the other physical components. As long as you train it to cover the right states and observables, it will slot right into where you had the larger model before.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;paramount-to-surrogatization-is-the-ability-to-check-the-accuracy-of-the-surrogate-model-and-its-performance-against-the-original-one-how-does-juliasim-tackle-this-are-these-metrics-appropriately-exposed-to-the-user&quot;&gt;Paramount to surrogatization is the ability to check the accuracy of the surrogate model and its performance against the original one. How does JuliaSim tackle this? Are these metrics appropriately exposed to the user?&lt;&#x2F;h4&gt;
&lt;p&gt;JuliaSim generates diagnostics of the surrogate training process to signal to the user important features like the projected maximum error over the timeseries over the user-defined parameter space. A lot of this is done through quasi-random sampling right now, though we are investigating more complex techniques to more quickly achieve good estimates.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;does-juliasim-run-on-top-of-juliahub-or-are-they-separate-things-is-the-pricing-model-expected-to-be-the-same&quot;&gt;Does JuliaSim run on top of &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;juliahub.com&#x2F;lp&#x2F;&quot;&gt;JuliaHub&lt;&#x2F;a&gt; or are they separate things? Is the pricing model expected to be the same?&lt;&#x2F;h4&gt;
&lt;p&gt;JuliaSim is JuliaHub-based platform. JuliaSim users receive a subscription to a set of proprietary packages, such as the standard library and the surrogatization tools, which grants access to their use on JuliaHub. The pricing model of JuliaSim is simply the subscription and pay-for-compute, so users only pay for what they use but have access to the full suite.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;will-there-be-a-gui-for-modeling-or-will-we-mostly-have-to-write-all-the-julia-code-explicitly&quot;&gt;Will there be a GUI for modeling or will we mostly have to write all the Julia code explicitly?&lt;&#x2F;h4&gt;
&lt;p&gt;There will be many GUIs! The first GUI that we are building is more pharmaceutical modeling focused given our early customer base and connections with Pumas-AI. This allows for quickly building chemical reaction network and systems pharmacology models, and representing models in a visual form for presentations and reporting. It also will serve as the basis for visual programming of compartmental models in pharmacokinetics. We also will have a GUI at launch which simplifies the FMU surrogatization process, allowing non-Julia users to quickly accelerate their FMUs by entering in parameter information and clicking “surrogatize”. We have other GUIs planned for the near future as well, such as GUIs for block diagrams and acausal modeling, along with 3D visualization tools.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;juliasim-is-launching-pretty-soon-what-can-we-expect-from-this-first-version-what-features-are-next&quot;&gt;JuliaSim is launching pretty soon; what can we expect from this first version? What features are next?&lt;&#x2F;h4&gt;
&lt;p&gt;JuliaSim’s first beta will be launching fairly soon. I wouldn’t call it the first version quite yet, though the beta will already be usable as we have been working with a group of customers to showcase the performance advantage for their specific applications. The first release will be a mix of GUIs, cloud parallel surrogatization, and standard libraries. And for the future we are aiming for a lot more. The full vision of JuliaSim is expressed in &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=lNbU5jNp67s&quot;&gt;the JuliaCon 2021 video&lt;&#x2F;a&gt; so refer to that for more details.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Modeling complexity with Symbolics.jl and ModelingToolkit.jl</title>
        <published>2021-03-18T00:00:00+00:00</published>
        <updated>2021-03-18T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com/posts/modeling-complexity-with-symbolics-jl-and-modelingtoolkit-jl/"/>
        <id>https://blog.lambdaclass.com/posts/modeling-complexity-with-symbolics-jl-and-modelingtoolkit-jl/</id>
        
        <content type="html" xml:base="https://blog.lambdaclass.com/posts/modeling-complexity-with-symbolics-jl-and-modelingtoolkit-jl/">&lt;h4 id=&quot;an-interview-with-chris-rackauckas&quot;&gt;An interview with Chris Rackauckas&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-sHzrVkhNvHxdiJ2IBmfVPA.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;As we often mentioned on Not a Monad Tutorial, the world is complex, and we increasingly understand where our tools fall short when trying to model this complexity.&lt;&#x2F;p&gt;
&lt;p&gt;We’ve previously interviewed Chris Rackauckas on &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;notamonadtutorial.com&#x2F;scientific-machine-learning-with-julia-the-sciml-ecosystem-b22802951c8a&quot;&gt;SciML&lt;&#x2F;a&gt;; this time he joins us to answer questions regarding new developments in the area of symbolic computation with Julia, its relation to numerical computing, causal vs acausal approaches, how these matters are represented in Symbolics.jl and ModelingToolkit.jl, and how these packages relate to the existing simulation tooling landscape.&lt;&#x2F;p&gt;
&lt;p&gt;These packages compose easily and thus allow modelling larger, more complex systems by reusing parts, as well as helping community efforts. Having these interoperable packages is key to building a modern simulation software stack which can address the aforementioned needs of complex modelling.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h4 id=&quot;what-is-symbolics-jl-what-are-the-motivations-behind-the-creation-of-the-system&quot;&gt;What is Symbolics.jl? What are the motivations behind the creation of the system?&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;JuliaSymbolics&#x2F;Symbolics.jl&quot;&gt;Symbolics.jl&lt;&#x2F;a&gt; is a Computer Algebra System (CAS) in the Julia programming language developed by the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;juliasymbolics.org&#x2F;&quot;&gt;JuliaSymbolics Organization&lt;&#x2F;a&gt;. Think symbolic computation: write down equations and ask the computer to come up with symbolic solutions. It’s a modern CAS, meaning it’s built on a widely used modern programming language (Julia), making use of modern tooling like pervasive parallelism, new algorithms like E-Graphs, integration with machine learning, and more.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-is-modelingtoolkit-jl-what-are-the-needs-it-addresses&quot;&gt;What is ModelingToolkit.jl? What are the needs it addresses?&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;SciML&#x2F;ModelingToolkit.jl&quot;&gt;ModelingToolkit.jl&lt;&#x2F;a&gt; is an equation-based acausal modeling system. It’s similar to systems like Modelica which allow for composing models to quickly generate realistic simulations. This lets you take pre-built models created by other scientists and build complete systems. For example, you can take a high fidelity model of an air conditioning, then make a model of a building, and stick the air conditioning into the building and ask what kind of energy efficiency you get. Then change the building to start designing what’s most efficient.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-does-acausal-modeling-relate-to-tools-like-simulink&quot;&gt;How does acausal modeling relate to tools like Simulink?&lt;&#x2F;h4&gt;
&lt;p&gt;Simulink is a causal modeling tool. You have to know “what causes what” in order to develop the simulation. This can be difficult in our complex world: the heat of the building is read by the thermostat which turns the AC on which then changes the heat of the building. Feedbacks and “algebraic loops” cause issues in causal modeling systems: users have to break the loops or change the model. For this reason &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1909.00484&quot;&gt;experts consider causal modeling as not suitable for complex simulations&lt;&#x2F;a&gt; as they do not compose well. This is the reason acausal tools like Modelica have seen a lot of adoption. Even MATLAB has an acausal tool now, SimScape. Given the advancements in these techniques, I see the next generation of engineers all using acausal tools, with ModelingToolkit.jl being one of the only fully-featured free and open-source acausal systems.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;why-is-symbolic-computation-needed-at-all-what-are-the-advantages-compared-to-numerical-computation-when-is-one-preferred-to-the-other&quot;&gt;Why is symbolic computation needed at all? What are the advantages compared to numerical computation? When is one preferred to the other?&lt;&#x2F;h4&gt;
&lt;p&gt;Are you sure you know enough mathematics to have written the mathematical model in the most numerically-stable form? Even if you know all of the tricks that you’re supposed to do, do you want to do it all by hand? I see the main use of symbolic computation in symbolic-numerics, i.e. using symbolic techniques to improve the models which are then used in numerical methods. For example, in a recent blog post titled &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.stochasticlifestyle.com&#x2F;generalizing-automatic-differentiation-to-automatic-sparsity-uncertainty-stability-and-parallelism&#x2F;&quot;&gt;Generalizing Automatic Differentiation to Automatic Sparsity, Uncertainty, Stability, and Parallelism&lt;&#x2F;a&gt;, I describe how a two-dimensional pendulum simulation without the small angle approximation requires a differential-algebraic equation. The intuitive model of “position moves by velocity, velocity moves by acceleration, and length is constant” is actually an unstable description of the full pendulum. You have to differentiate the “length is constant” equation twice, then substitute other relationships, and then you arrive at an “index-1” DAE which is easier to numerically solve. Even if you know enough of these details to do it, you don’t want to handle that! Symbolic-numeric computation is how we will get to a future where that is all automated.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;wolfram-mathematica-and-sympy-in-python-are-some-of-the-most-popular-choices-when-dealing-with-symbolic-manipulation-nowadays-what-are-the-advantages-symbolics-jl-offers-in-comparison-to-them&quot;&gt;Wolfram Mathematica and SymPy in Python are some of the most popular choices when dealing with symbolic manipulation nowadays. What are the advantages Symbolics.jl offers in comparison to them?&lt;&#x2F;h4&gt;
&lt;p&gt;Symbolics.jl is being built from the ground up for speed, being built from the ground up with parallelism, and last but not least, it’s being built up from a community of tools. There is so much good stuff out there that I think it would be unreasonable to silo one’s organization off and do everything from scratch. Julia has many great initiatives like &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.computeralgebra.de&#x2F;sfb&#x2F;&quot;&gt;OSCAR.jl&lt;&#x2F;a&gt; which are building fast implementations of the mathematical guts. We are using the fact that Julia is a high performance language to both develop high level interfaces and ensure that all of these tools can be used with minimal overhead, mental and computational. So while you might know nothing about Galois fields, there might be a fancy algorithm underneath the hood when you call factorize(x² + 2x + 1) that does it efficiently and scales to large systems.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-is-modelingtoolkit-jl-related-to-symbolics-jl-what-role-does-julia-s-composability-play-in-the-relationship-between-the-two-packages&quot;&gt;How is ModelingToolkit.jl related to Symbolics.jl? What role does Julia’s composability play in the relationship between the two packages?&lt;&#x2F;h4&gt;
&lt;p&gt;Acausal modeling requires symbolic transformations of equations. In that pendulum example, “differentiate the equation twice and substitute”, what kind of tool provides features like differentiation and high performance equation rewriting (i.e. substitution)? A CAS! So ModelingToolkit.jl let’s someone say “this is an ODE”, where it’s equations are described by Symbolics.jl expressions. There are then functions that do things like “transform this to index-1 form” and “analytically discover which equations are redundant and delete them”, and those transformations are written using the tools of Symbolics.jl. This means that as the CAS grows more powerful, so will ModelingToolkit.jl and its environment.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-does-modelingtoolkit-jl-compare-to-other-modeling-frameworks-such-as-modelica-and-simulink-how-easily-would-a-person-with-some-background-on-these-frameworks-adapt-to-modelingtoolkit-jl&quot;&gt;How does ModelingToolkit.jl compare to other modeling frameworks such as Modelica and Simulink? How easily would a person with some background on these frameworks adapt to ModelingToolkit.jl?&lt;&#x2F;h4&gt;
&lt;p&gt;ModelingToolkit.jl’s focus at this point has mainly been on flexibility and speed. In terms of flexibility, ModelingToolkit.jl is the only one which has a hackable compiler that allows composing transformations. All of the symbolic enhancements that are allowed in the Modelica and Simulink compilers are those that are built-in. While it sounds like that’s all that most users need, what that really does is stifle innovation. There are people working in these fields that need a common framework to build off of. Many of these researchers are now in Julia. So for example, could we add an analysis pass that automatically tells you whether you can distinguish between parameters with the data you have? Yes, anyone could extend the ModelingToolkit.jl system with a pass that does that, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;alexeyovchinnikov&#x2F;SIAN-Julia&quot;&gt;and we’re already talking with authors of Julia libraries about doing this&lt;&#x2F;a&gt;. There is so much going on in this space that it’s hard to express, but expect tons of unique transformations to be allowed on your models. “Make a model that doesn’t solve in other systems solve here” is not just a dream.&lt;&#x2F;p&gt;
&lt;p&gt;And then there’s speed. We haven’t done complete and comprehensive benchmarking against all of the systems yet, but we have seen &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2103.05244&quot;&gt;some good performance against some Modelica compilers&lt;&#x2F;a&gt;, indicating we’re doing really well. One NASA user of ModelingToolkit.jl said &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;tQpqsmwlfY0&quot;&gt;a 15 minute Simulink simulation took 50ms in ModelingToolkit.jl&lt;&#x2F;a&gt;. A user mentioned at the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;FMVOUvWNlLE&quot;&gt;AAS&#x2F;AIAA Space Flight Mechanics meeting that every case against a Fortran package with a MATLAB interface, they saw at least an order of magnitude acceleration by moving to ModelingToolkit.jl&lt;&#x2F;a&gt;. In a very early version of ModelingToolkit.jl, we did a demo with Pfizer where we &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;juliacomputing.com&#x2F;case-studies&#x2F;pfizer&#x2F;&quot;&gt;demonstrated a 175x acceleration over their original C-based simulations&lt;&#x2F;a&gt;. Part of all of this is just due to the solvers, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;benchmarks.sciml.ai&#x2F;html&#x2F;MultiLanguage&#x2F;wrapper_packages.html&quot;&gt;which benchmark really well in a cross-language way&lt;&#x2F;a&gt;. Another good chunk is due to the feature sets of the solvers, and ModelingToolkit.jl automatically enabling some of the best choices of combinations. This is explored a bit in a talk at JuliaCon 2020 titled &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=UNkXNZZ3hSw&quot;&gt;Auto-Optimization and Parallelism in DifferentialEquations.jl&lt;&#x2F;a&gt;, which was the video that announced the release of ModelingToolkit.jl as a new front end to the solvers for further improving speed.&lt;&#x2F;p&gt;
&lt;p&gt;That said, we have focused so far on the details. We want the biggest hardest models with the users who have the most demands. These other tools have put a lot more time into user interface, specifically graphical user interfaces (GUIs). Modelica and Simulink has a lot of tooling for drag-and-drop model building. Also, they have libraries of premade libraries. But, this will change very soon. Keep your eyes peeled for some announcements.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-are-the-main-challenges-to-solve-in-order-to-build-such-a-high-level-modeling-library&quot;&gt;What are the main challenges to solve in order to build such a high level modeling library?&lt;&#x2F;h4&gt;
&lt;p&gt;You want to make the modeling language be expressive enough so that every detail you can mathematically specialize on and optimize for is there, but you want to make it easy for users to actually use. Striking that balance is difficult. ModelingToolkit.jl has around 4 years in various prototype forms going through and breaking designs until we found one that could actually solve the problem to the level we hoped.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-is-julia-code-generated-from-symbolic-expressions&quot;&gt;How is Julia code generated from symbolic expressions?&lt;&#x2F;h4&gt;
&lt;p&gt;The symbolic expressions use the same exact pieces under different symantics. For example, square roots in the model are &lt;code&gt;sqrt&lt;&#x2F;code&gt; in Symbolics.jl and &lt;code&gt;sqrt&lt;&#x2F;code&gt; in Julia. This means all we have to do is take the symbolic expression and write it into a Julia function, and invoke the compiler. Invoking compilation on the fly as part of a symbolic language is an interesting challenge though, something that a tool like SymPy skips but which reduces speed by orders of magnitude. The specific details of this are pretty esoteric so I will spare you, but to make this all work we created a new hook into the Julia compiler called &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;SciML&#x2F;RuntimeGeneratedFunctions.jl&quot;&gt;RuntimeGeneratedFunctions&lt;&#x2F;a&gt; which allow for staged compilation that composes with garbage collection, making generated code safe.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-are-the-mechanisms-that-allow-easy-model-composition-with-modelingtoolkit-jl&quot;&gt;What are the mechanisms that allow easy model composition with ModelingToolkit.jl?&lt;&#x2F;h4&gt;
&lt;p&gt;It’s the acasual modeling. You can develop pieces in isolation and just declare relationships between the components. For example, build a model of a power generator, and a model of a computer chip. Now you want to connect these two completely different models? Physically, a wire would connect them and then Kirchoff’s laws would have to hold, i.e. the voltages would have to be equal at the connection points and the currents would sum to zero. So in ModelingToolkit.jl that’s what you’d do: you’d say “current from generator + current to chip = 0” and “voltage at generator = voltage at chip” and bingo you’re there. Now this might produce some redundant variables and equations, but it’s okay: the symbolic preprocessing system eliminates all of this and simplifies down to the most efficient problem to simulate. Then at the end, you can ask “give me the timeseries of the voltage at the chip” and it will give you it, regardless if it was actually in the simulation of not, because it has the information to reconstruct these values.&lt;&#x2F;p&gt;
&lt;p&gt;ModelingToolkit.jl goes one step further. There are &lt;code&gt;connect&lt;&#x2F;code&gt; statements which let you define a common behavior. For example, a &lt;code&gt;Pin&lt;&#x2F;code&gt; in an electrical circuit always has a voltage and a current, and those laws from above are how “connections” physically work. So at this higher level you can say “connect the pin of the generator to the pin of the circuit”, and it generates all of the physical relationships associated with that statement. There are many prebuilt systems which are coming very soon (likely to be completed before these responses are public!), so heat flow, enthalpy relationships, etc. are all simple &lt;code&gt;connect&lt;&#x2F;code&gt; statements. The connection mechanism is extendable too, so if you have a common meaning in say pharmacological models which differs, you can create a new variable type and make connections automatically enforce the laws you want. Connect the heart to the kidney means blood flow is conserved but oxygen is not. This makes it easy to specialize the systems to each of the specific scientific domains.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-are-the-advantages-of-symbolic-preprocessing-of-models&quot;&gt;What are the advantages of symbolic preprocessing of models?&lt;&#x2F;h4&gt;
&lt;p&gt;From the previous statement, note that simple modeling requires the ability to build things in isolation, and then just say “a=b”. Numerically simulating with “a=b” is rather difficult though, numerical methods really want to not solve equations exactly. But if the current at one side is 10^(-8) higher than the other, you lose conservation of current, and you can have the power of the system steadily rising until it spirals out of control and the simulation crashes. This is actually a very common behavior in causal modeling systems. But if you eliminate the variable “b” and replace it with “a” in every place where it shows up, and then if the user asks for “b” you give them “a”, now you’ve symbolically enforced equality and you will never have a numerical issue due to that effect. So not only does it make the set of equations you have to solve smaller (making the solving process faster), but it also makes the numerical solving a lot more stable and more likely to succeed.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;who-are-modelingtoolkit-jl-and-symbolics-jl-aimed-to-beyond-academia-do-you-consider-people-in-the-industry-might-find-them-useful&quot;&gt;Who are ModelingToolkit.jl and Symbolics.jl aimed to? Beyond academia, do you consider people in the industry might find them useful?&lt;&#x2F;h4&gt;
&lt;p&gt;Symbolics.jl is more academically focused. People doing symbolic computer algebra are everywhere, but I tend to see more in academia. Physicists, computational biologists, etc. Because Symbolics.jl allows for translating back and forth between Julia code and symbolic code automatically, we’re seeing computer scientists even adopt it as a nice and easy way to analyze code.&lt;&#x2F;p&gt;
&lt;p&gt;ModelingToolkit.jl on the other hand is more focused towards engineers and modelers. Mechanical engineers, robotics experts, building designers, synthetic biologists. These people are found commonly in both academia and industry. We’re getting a lot of praise from industry users of ModelingToolkit.jl already, so it’s likely to find a nice foothold there.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-many-people-are-involved-in-the-projects-what-are-their-backgrounds&quot;&gt;How many people are involved in the projects? What are their backgrounds?&lt;&#x2F;h4&gt;
&lt;p&gt;There are far too many involved, so I’m just going to give a shoutout to the top few. Yingbo Ma is a super star, still an undergrad but a major contributor to both SciML (the differential equation solvers and ModelingToolkit.jl) and JuliaSymbolics. Shashi Gowda is a PhD student at MIT who has been driving a lot of the internals of JuliaSymbolics. Then there have been many contributions by NASA folks, high schoolers, professors in math departments and biology departments, pandemic researchers, etc. It’s still very early on in the project but the community around it is already great.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-are-the-next-steps-for-each-project&quot;&gt;What are the next steps for each project?&lt;&#x2F;h4&gt;
&lt;p&gt;We’re going to have a major announcement very soon, so stay tuned.&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
