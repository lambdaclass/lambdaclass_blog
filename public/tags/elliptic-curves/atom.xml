<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>LambdaClass Blog - elliptic curves</title>
    <subtitle>Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.</subtitle>
    <link rel="self" type="application/atom+xml" href="https://blog.lambdaclass.com/tags/elliptic-curves/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2022-08-12T00:00:00+00:00</updated>
    <id>https://blog.lambdaclass.com/tags/elliptic-curves/atom.xml</id>
    <entry xml:lang="en">
        <title>Need for speed: Elliptic curves chapter</title>
        <published>2022-08-12T00:00:00+00:00</published>
        <updated>2022-08-12T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com/posts/need-for-speed-elliptic-curves-chapter/"/>
        <id>https://blog.lambdaclass.com/posts/need-for-speed-elliptic-curves-chapter/</id>
        
        <content type="html" xml:base="https://blog.lambdaclass.com/posts/need-for-speed-elliptic-curves-chapter/">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;Elliptic curves (EC) have gained widespread acceptance as tools for cryptography. They offer several advantages over other methods, such as RSA, providing equal levels of security with shorter keys (for example, 228-bit keys in EC cryptography are as good as 2300-bit RSA keys). This represents an advantage, since more and more cryptography is done on smart-phones, which are less powerful than computers. These are curves defined by the equation $y^2 = x^3 + ax + b$ over some &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Field_(mathematics)&quot;&gt;field&lt;&#x2F;a&gt; (for example, the real numbers). Their shape depends on $a$ and $b$, but they look more or less like the following picture:&lt;br &#x2F;&gt;
&lt;img src=&quot;&#x2F;images&#x2F;external&#x2F;rk6M8y0.jpg&quot; alt=&quot;An elliptic curve over the real numbers&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In cryptography, we are not interested in curves defined over the real numbers. We work with them over some finite field $\mathcal{F_p}$ (that is, a set with a finite number of elements, such as $53$, $101$ o $2^{255}-19$), because that gives us a mathematical structure (a &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Finite_group&quot;&gt;finite group&lt;&#x2F;a&gt;) which is very convenient. The curve looks like scattered points with no clear pattern over a finite field:&lt;br &#x2F;&gt;
&lt;img src=&quot;&#x2F;images&#x2F;external&#x2F;sQDajke.jpg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Elliptic curves play a role in key exchange when connecting via SSH to a server or to prove ownership in bitcoin. They also appear when performing digital signatures, generating random numbers (though there have been some problems) and they are useful even to factor numbers (&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lenstra_elliptic-curve_factorization&quot;&gt;Lenstra’s algorithm&lt;&#x2F;a&gt;). For example, in the elliptic curve digital signature algorithm (ECDSA) you have these steps (don’t worry if you do not understand all the terms now, we will cover them one by one afterwards):&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    1. Calculate E=hash(message), where hash is a secure [hash function](https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hash_function).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    2. Take Z equal to the $n$ leftmost bits of E, where $n$ is the order of the group (that is, the number of elements making the group).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    3. Select a cryptographically secure random number $k$ (never use the same $k$ twice or you&amp;#39;ll be revealing your key).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    4. Evaluate $(x_1,y_1)=kg$, where $g$ is the generator of the group.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    5. Let $r=x_1$.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    6. Evaluate $s=k^{-1}(Z+rs_k) \pmod{n}$, where $s_k$ is the secret key.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    7. The signature is the pair $(r,s)$.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this example, we have to evaluate in step 4 an addition on the curve to arrive at point $(x_1,y_1)$, which gives us $r$. In general, $k$ is a large number (having 256 bits, for example), so that operation can be quite expensive. Besides, if the implementation is not done properly, elliptic curve cryptography could be targeted by side-channel attacks, such as timing and cache attacks. Some elliptic curves have properties that allow for a constant-time implementation, which makes them resistant to these strategies.&lt;&#x2F;p&gt;
&lt;p&gt;Elliptic curves also appear in zk-SNARKs (zero-knowledge succint non-interactive arguments of knowledge; we’ll go hunting for the SNARK on another post) to provide homomorphic hiding. The word sounds important, but the idea behind is simple. Suppose that there are two variables, $x$ and $y$ and you want (or need) to know $x+y$. The problem is, you don’t know them directly, but you have their encrypted form $E(x)$ and $E(y)$. If you have homomorphic hiding, you can compute $E(x+y)=E(x)\times E(y)$, where $\times$ is the operation over the encrypted variables. So, even if you don’t know the variables themselves, you can perform mathematical operations on them (and luckily, that’s just what you need). This is achieved in practice by means of two elliptic curves (known as a pairing; not all elliptic curves are that sociable or get along quite well with others). To be a good match, we need that the operations can be performed as quickly as possible (among other things). A simple example is the exponential function, $f: \mathbb{R} \rightarrow \mathbb{R}^+&#x2F; f(x)=\exp(x)$. If you have $x=2.303$, $\exp(2.303)\approx 10$, $y=3$, $\exp(3)\approx 20.09$, then $\exp(x+y)=\exp(x)\exp(y)=10\times 20.09=200.9$, which is equal to $\exp(5.303)$ and $x+y=5.303$. Of course, in this case it is very easy to go back and know the exact numbers $x$, $y$ and $x+y$; in the case of elliptic curves, this is very hard, owing to the particular group structure.&lt;&#x2F;p&gt;
&lt;p&gt;To be able to work with elliptic curves, we need to define an operation involving the points on the curve. We can do this using the chord-and-tangent construction: given two points on the curve, we can draw a line connecting them; the line intersects the curve at a third point and we reflect it around the $x$-axis to obtain the sum (remember the picture of the curve defined over real numbers). The formulae are&lt;br &#x2F;&gt;
$s=\frac{y_2-y_1}{x_2-x_1}$&lt;br &#x2F;&gt;
$x_3=s^2-x_1-x_2$&lt;br &#x2F;&gt;
$y_3=s(x_1-x_3)-y_1$&lt;&#x2F;p&gt;
&lt;p&gt;There are some special cases, such as when we want to add a point to itself (we call that “doubling”). To make things work, we need to add a special point $\mathcal{O}$, the point at infinity. The curve, together with the operation, form a finite cyclic group. In simple words, every time we add two points we get a third one which belongs to the curve (it is closed under the operation). We also have an identity point (the point at infinity, $P+\mathcal{O}$) and each point $P$ has an inverse $P^\prime$, such that $P+P^\prime=\mathcal{O}$. Moreover, the elements of the group can be generared by repeteadly adding a point $g$ (the generator) to itself. In other words, for $P$ in the group, there is some $k$ such that $kg=P$. If we are given $k$, we can quickly calculate $P$, but doing the operation the other way around (that is, given $P$, find $k$) can be very difficult (this is known as the discrete logarithm problem) and we used this idea in a previous paragraph.&lt;&#x2F;p&gt;
&lt;p&gt;All these calculations are done with the operations of the finite field $\mathcal{F}_p$. We see that, at each addition step, we have to calculate the slope of the line, which involves a division on elements of the finite field. This can be rewritten as $s=(x_2-x_1)^{-1}(y_2-y_1)$, where $(x_2-x_1)^{-1}=b$ is the multiplicative inverse of $x_2-x_1$. In simpler form, $b(x_2-x_1)\equiv 1 \pmod{p}$ (When we write $a \equiv b \pmod{p}$, we say that there is some integer $q$ such that a=pq+b. It is read $a$ is congruent to $b$ modulo $p$). Computing inverses is possible, but quite more expensive than multiplications. There is a result from number theory called &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fermat%27s_little_theorem&quot;&gt;Fermat’s little theorem&lt;&#x2F;a&gt;, which tells us that $a^{p-1}\equiv 1 \pmod{p}$ if $a$ and $p$ have no common divisors other than 1 (we say $a$ and $p$ are coprime). We can write this in a different fashion,&lt;&#x2F;p&gt;
&lt;p&gt;$a^{p-2}a\equiv 1 \pmod{p}$&lt;&#x2F;p&gt;
&lt;p&gt;and we see that $b=a^{p-2}$ (we can make things simple and then reduce $b$ to $a^{p-2} \pmod{p}$). So, to get the multiplicative inverse, we have to perform many multiplications. (Sometimes it is much easier. Let’s take $p=5$ and we try to find $4^{-1}$. We can see that if we do $4\times 4=16 \equiv 1 \pmod{5}$, so $4^{-1}=4$. This is rather strange, but we have to remember that operations on the finite field have a different behavior). As a matter of fact, $p-1$ gives an upper bound to the power $n$ we have to apply to a field element $a$ to get its inverse, that is $a^n \equiv 1 \pmod{p}$. We call the lowest (positive) exponent $n$ such that $a^n \equiv 1 \pmod{p}$ the order of the element. &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lagrange%27s_theorem_(group_theory)&quot;&gt;Lagrange’s Theorem&lt;&#x2F;a&gt; says that the order $n$ divides $p-1$. For example, take $p=7$, so $p-1=6$. We see that $4^3=64\equiv 1 \pmod{7}$, so $4^2\equiv 2 \pmod{7}$ is the inverse of $4$ ($2\times 4=8 \equiv 1 \pmod{7}$). In the same way, $2^3\equiv 1 \pmod{7}$. In the case of $3$, $3^6 \equiv 1 \pmod{7}$ and $3^5 \equiv 5 \pmod{7}$ and we also have $5^6 \equiv 1 \pmod{7}$. So, we see that the orders $n$ are among the divisors of $p-1=6$.&lt;&#x2F;p&gt;
&lt;p&gt;So, even if the equations for point addition over elliptic curves look really simple, they involve many calculations and these may be expensive. If every time we want to add two points, we have to find the multiplicative inverse modulo a large prime, we see that we are paying a high price. There are a couple of tricks we can perform, such as transforming the curve, to gain a lot of speed or avoid some other issues, such as side-channel attacks.&lt;&#x2F;p&gt;
&lt;p&gt;If you are one of those not willing to pay the cost of finding inverses and saving some time or just love speed for the sake of it, then the next section is for you.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;projective-coordinates&quot;&gt;Projective coordinates&lt;&#x2F;h2&gt;
&lt;p&gt;We can save ourselves from costly inversions if we move from our nice 2 dimensional space to a 3 dimensional space. This was introduced by Moebius and helps us also to represent the point at infinity properly. We can map our points from our elliptic curve $(x,y)$ to points in projective space $(X,Y,Z)$ as $(x,y) \rightarrow (X=x,Y=y,Z=1)$ and $\mathcal{O} \rightarrow (0,1,0)$. We can go back using the transformation $(X,Y,Z) \rightarrow (x=X&#x2F;Z,y=Y&#x2F;Z)$, except for the point at infinity, where it is ill-defined. We can visualize this process with the following picture, where we take three points from an elliptic curve and transform them to 3-d.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;external&#x2F;zmlMAg9.jpg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We can think of this as transforming our 2-d points to lines passing through the origin in 3-d space. For example, the point $(x_1,y_1)$ in 2-d transforms to the line $(\mu x_1,\mu y_1, \mu)$ with $\mu$ an element in the field. Thus, two points $P_1=(X_1,Y_1,Z_1)$ and $P_2=(X_2,Y_2,Z_2)$ are the same in 2-d (more precisely, are congruent) if we can find $\eta$ such that $(\eta X_1,\eta Y_1,\eta Z_1)=(X_2,Y_2,Z_2)$. These lines do not contain the origin $(0,0,0)$. It is usual to write points is projective space as $(X:Y:Z)$, instead of $(X,Y,Z)$. In our picture, the point A (yellow) gets mapped to the point D (red above it). All the points that lie on the same straight line passing through the origin and D (pink dashed) are considered equivalent to D. Similarly, point B (blue) is mapped to point F (light blue) and all the ponts over the light green dotted line (except the origin) are equivalent to F. When we add points in this space, the components $(X,Y,Z)$ will change, but we can go back to the point belonging to the curve by just retracing our steps to $Z=1$ along the line that passes through the origin. Why go all this length? We will shortly see that we avoid inversions at each addition step and do just one at the time of finding the point in 2-d (for example, when we need to find $r=x_1$ in ECDSA). Of course, if we have to do $P=2g$ we didn’t gain anything, but if we have to perform $P=kg$ with $k$ in the order of 256 bits, we saved many costly inversions.&lt;&#x2F;p&gt;
&lt;p&gt;Making the substitutions into the elliptic curve equation&lt;br &#x2F;&gt;
$$\left(\frac{Y}{Z}\right)^2 = \left(\frac{X}{Z}\right)^3 + a\left(\frac{X}{Z}\right) + b$$&lt;br &#x2F;&gt;
We can multiply by $Z^3$ and get the equation&lt;br &#x2F;&gt;
$$ZY^2 = X^3 + aZ^2 + bZ^3$$&lt;br &#x2F;&gt;
If we want to sum $P$ and $Q$ to yield $R = P + Q$ in projective space, we can use the formulae:&lt;&#x2F;p&gt;
&lt;p&gt;$Z_R = Z_PZ_Q(X_PZ_Q-X_QZ_P)^3$&lt;br &#x2F;&gt;
$X_R = (X_PZ_Q-X_QZ_P)(Z_QZ_P(Y_PZ_Q-Y_QZ_P)^2 - (X_PZ_Q-X_QZ_P)^2(X_PZ_Q+X_QZP))$&lt;br &#x2F;&gt;
$Y_R = Z_PZ_Q(X_QY_P-X_PY_Q)(X_PZ_Q-X_QZ_P)^2 - (Y_PZ_Q-Y_QZ_P)A$&lt;br &#x2F;&gt;
$A = Z_PZ_Q(Y_PZ_Q-Y_QZ_P)^2 - (X_PZ_Q+X_QZ_P)(X_PZ_Q-X_QZ_P)^2$.&lt;&#x2F;p&gt;
&lt;p&gt;This looks more complicated and difficult than the simple formulae for 2 dimensional (2-d) space. However, we do not have to calculate any inverses! To get the sum, we have to perform 12 multiplications and 2 squarings. In 2-d, we have 2 multiplications, one squaring and one inversion. Inversions can be 20 times or more expensive than multiplications, so we’ve saved at least 10 multiplications (some authors say inversions are about 80 times more expensive than multiplications).&lt;&#x2F;p&gt;
&lt;p&gt;Some curves can go even faster. If $x^3 + ax + b$ has a solution in $\mathcal{F_p}$, we can work with an equivalent Jacobi quartic $v^2 = a^\prime u^4 + du^2 + 1$, where $a^\prime$ and $d$ depend on the root. We can transform the curve $(u,v)$ to 3-d space $(U,V,W)$ using $u = U&#x2F;W$ and $v = V &#x2F; W^2$ and get the equation&lt;&#x2F;p&gt;
&lt;p&gt;$$V^2 = a^\prime U^4 + dU^2 W^2 + W^4$$&lt;&#x2F;p&gt;
&lt;p&gt;If we want to sum $P_3 = P_1+P_2$, in these coordinates we have:&lt;&#x2F;p&gt;
&lt;p&gt;$U_3 = U_1W_1V_2 + U_2W_2V_1$&lt;br &#x2F;&gt;
$V_3 = ((W_1 W_2)^2 + a^\prime (U_1 U_2)^2)(V_1 V_2 + dU_1 U_2 W_1 W_2) + 2a^\prime U_1 U_2 W_1 W_2 ({U_1}^2 {W_2}^2 + {U_2}^2 {W_1}^2)$&lt;br &#x2F;&gt;
$W_3 = (W_1 W_2)^2 - a^\prime (U_1 U_2)^2$&lt;&#x2F;p&gt;
&lt;p&gt;These allow us to further reduce the costs for adding to 6 multiplications and 4 squarings. Other models with fast implementations are Edwards curves and Montgomery curves, which have some of the fastest implementations.&lt;&#x2F;p&gt;
&lt;p&gt;Montgomery curves satisfy the following equation&lt;br &#x2F;&gt;
$$By^2 = x^3 + Ax^2 + x$$&lt;br &#x2F;&gt;
where $B(A^2-4)\neq 0$. This expression can be cast in the Weierstrass form by making some transformation. If we take $(x,y)$ and map it to $(x^\prime , y^\prime)$ given by $(x,y) \rightarrow (x&#x2F;B+A&#x2F;3B,y&#x2F;B)$, we get&lt;br &#x2F;&gt;
$$y^2 = x^3 + \left(\frac{3 - A^2}{ 3B^2 }\right)x + \frac{2A^3 - 9A}{27B^3}$$&lt;br &#x2F;&gt;
Transforming a Weierstrass curve into a Montgomery curve is not always possible, though. The order of the group must be divisible by $4$ and $x^3 + ax + b = 0$ must have a solution.&lt;&#x2F;p&gt;
&lt;p&gt;Montgomery curves can also be related to twisted Edwards curves, which obey the following equation&lt;br &#x2F;&gt;
$$ax^2 + y^2 = 1+dx^2 y^2$$&lt;br &#x2F;&gt;
The parameters are related via $A=2(a+d)&#x2F;(a-d)$ and $B=4&#x2F;(a-d)$. We say these two curves are birrationally equivalent. For example, the well-known Edwards curve 25519, with $p = 2^{255}-19$ is (birrationally) equivalent to the Montgomery curve $t^2 = u^3 + 486662u^2 + u$. The mappings are&lt;br &#x2F;&gt;
$(x,y) = (\sqrt{-486664}u&#x2F;t,(u-1)&#x2F;(u+1))$&lt;br &#x2F;&gt;
$(u,t) = ((1+y)&#x2F;(1-y),\sqrt{-486664}(1+y)&#x2F;(x(1-y)))$&lt;&#x2F;p&gt;
&lt;p&gt;Montgomery curves have some interesting properties that lend themselves to constant time implementation. We can work in projective coordinates just using the $x$ component, with the transformation $x=X&#x2F;Z$. Doubling a point takes the simple form:&lt;br &#x2F;&gt;
$4R = (X_1+Z_1)^2 - (X_1-Z_1)^2$&lt;br &#x2F;&gt;
$X_2 = (X_1+Z_1)^2 (X_1-Z_1)^2$&lt;br &#x2F;&gt;
$Z_2 = R((X_1-Z_1)^2 + ((A+2)&#x2F;4)R)$&lt;&#x2F;p&gt;
&lt;p&gt;Twisted Edwards curves have there advantages, too. The expressions for point addition and doubling are the same. Given $P_1 = (x_1 , y_1)$, $P_2 = (x_2,y_2)$ we get&lt;br &#x2F;&gt;
$x_3 = \frac{x_1y_2 + x_2y_1}{1 + dx_1x_2y_1y_2}$&lt;br &#x2F;&gt;
$y_3 = \frac{y_1y_2 - ax_1x_2}{1 - dx_1x_2y_1y_2}$&lt;br &#x2F;&gt;
If we let $x_1 = x_2$ and $y_1 = y_2$ we get the expressions for point doubling. There are several alternatives to speeding up the calculations, such as projective, inverted or extended coordinates.&lt;&#x2F;p&gt;
&lt;p&gt;There are some other tricks to add and multiply points over elliptic curves, such as the technique by Gallant, Lambert and Vanstone (GLV) and generalized by Galbraith, Lin and Scott (GLS).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;Elliptic curves have gained acceptance in cryptography because they offer good levels of security with short key lengths and allow for faster implementations than other methods such as RSA. This allows smartphones and other less powerful devices to perform cryptographic operations in a fast and reliable way.&lt;&#x2F;p&gt;
&lt;p&gt;Using the chord-and-tangent method, we can generate finite cyclic groups; in applications, we are generally interested in calculating $kg$, where $k$ is an integer and $g$ is a point in the elliptic curve. The main drawback is that we need to find multiplicative inverses of field elements, which involve many multiplications.&lt;&#x2F;p&gt;
&lt;p&gt;We can improve the speed of these computations by performing transformations between curves (for example, taking a Weierstrass curve to Montgomery form) and using projective coordinates. This way, we avoid calculating multiplicative inverses at each step, at the expense of a few extra multiplications (this extra cost is usually negligible to the overall cost of the inversion). There are also more advanced techniques allowing us to jump from one point to a very distant one, such as with GLS.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>What every developer needs to know about elliptic curves</title>
        <published>2022-08-06T00:00:00+00:00</published>
        <updated>2022-08-06T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com/posts/what-every-developer-needs-to-know-about-elliptic-curves/"/>
        <id>https://blog.lambdaclass.com/posts/what-every-developer-needs-to-know-about-elliptic-curves/</id>
        
        <content type="html" xml:base="https://blog.lambdaclass.com/posts/what-every-developer-needs-to-know-about-elliptic-curves/">&lt;p&gt;Elliptic curves (EC) have become one of the most useful tools for modern cryptography. They were proposed in the 1980s and became widespread used after 2004. Its main advantage is that it offers smaller key sizes to attain the same level of security of other methods, resulting in smaller storage and transmission requirements. For example, EC cryptography (ECC) needs 256-bit keys to attain the same level of security as a 3000-bit key using RSA (another public-key cryptographic system, born in the late 70s). ECC and RSA work by hiding things inside a certain mathematical structure known as a finite cyclic group (we will explain this soon). The hiding is done rather in plain sight: you could break the system if you could reverse the math trick (spoiler alert: if done properly, it would take you several lifetimes). It is as if you put $1.000.000 inside an unbreakable glass box and anyone could take it if they could break it.&lt;&#x2F;p&gt;
&lt;p&gt;In order to understand these objects and why they work, we need to go backstage and look at the math principles (we won’t enter into the hard details or proofs, but rather focus on the concepts or ideas). We will start by explaining finite fields and groups and then jump onto the elliptic curves (over finite fields) and see whether all curves were created equal for crypto purposes.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;finite-fields&quot;&gt;Finite fields&lt;&#x2F;h2&gt;
&lt;p&gt;We know examples of fields from elementary math. The rational, real and complex numbers with the usual notions of sum and multiplication are examples of fields (these are not finite though).&lt;&#x2F;p&gt;
&lt;p&gt;A finite field is a set equipped with two operations, which we will call + and ×. These operations need to have certain properties in order for this to be a field:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;If &lt;em&gt;a&lt;&#x2F;em&gt; and &lt;em&gt;b&lt;&#x2F;em&gt; are in the set, then &lt;em&gt;c=a+b&lt;&#x2F;em&gt; and &lt;em&gt;d=a×b&lt;&#x2F;em&gt; should also be in the set. This is what is mathematically called a closed set under the operations +, ×.&lt;&#x2F;li&gt;
&lt;li&gt;There is a zero element, 0, such that &lt;em&gt;a&lt;&#x2F;em&gt; +0=&lt;em&gt;a&lt;&#x2F;em&gt; for any a in the set. This element is called the additive identity.&lt;&#x2F;li&gt;
&lt;li&gt;There is an element, 1, such that 1× &lt;em&gt;a&lt;&#x2F;em&gt; =&lt;em&gt;a&lt;&#x2F;em&gt; for any a in the set. This element is the multiplicative identity.&lt;&#x2F;li&gt;
&lt;li&gt;If a is in the set, there is an element &lt;em&gt;b&lt;&#x2F;em&gt; , such that &lt;em&gt;a+b&lt;&#x2F;em&gt; =0. We call this element the additive inverse and we usually write it as &lt;em&gt;−a&lt;&#x2F;em&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;If &lt;em&gt;a&lt;&#x2F;em&gt; is in the set, there is an element &lt;em&gt;c&lt;&#x2F;em&gt; such that &lt;em&gt;a×c=1&lt;&#x2F;em&gt;. This element is called the multiplicative inverse and we write is as &lt;em&gt;a&lt;&#x2F;em&gt; −1.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Before we can talk about examples of finite fields, we need to introduce the modulo arithmetic.&lt;&#x2F;p&gt;
&lt;p&gt;We learned that given a natural number or zero, &lt;em&gt;a&lt;&#x2F;em&gt; and a non-zero number &lt;em&gt;b&lt;&#x2F;em&gt; , we could write out a in the following way &lt;em&gt;a=q×b+r&lt;&#x2F;em&gt; where &lt;em&gt;q&lt;&#x2F;em&gt; is the quotient and &lt;em&gt;r&lt;&#x2F;em&gt; is the remainder of the division of &lt;em&gt;a&#x2F;b&lt;&#x2F;em&gt;. This &lt;em&gt;r&lt;&#x2F;em&gt; can take values 0,1,2,…,b−1 We know that if &lt;em&gt;r&lt;&#x2F;em&gt; is zero, then a is a multiple of &lt;em&gt;b&lt;&#x2F;em&gt;. It may not seem new, but this gives us a very useful tool to work with numbers. For example, if &lt;em&gt;b&lt;&#x2F;em&gt; =2 then &lt;em&gt;r&lt;&#x2F;em&gt; =0,1. When it is 0, &lt;em&gt;a&lt;&#x2F;em&gt; is even (it is divisible by 2) and when it is 1, &lt;em&gt;a&lt;&#x2F;em&gt; is odd. A simple way to rephrase this (due to Gauss):&lt;&#x2F;p&gt;
&lt;p&gt;a≡1(mod2)&lt;&#x2F;p&gt;
&lt;p&gt;if &lt;em&gt;a&lt;&#x2F;em&gt; is odd and&lt;&#x2F;p&gt;
&lt;p&gt;a≡0(mod2)&lt;&#x2F;p&gt;
&lt;p&gt;if &lt;em&gt;a&lt;&#x2F;em&gt; is even. We can see that if we sum two odd numbers &lt;em&gt;a1&lt;&#x2F;em&gt; and &lt;em&gt;a2&lt;&#x2F;em&gt; ,&lt;&#x2F;p&gt;
&lt;p&gt;a1+a2≡1+1≡0(mod2)&lt;&#x2F;p&gt;
&lt;p&gt;This shows us that, if we want to know whether a sum is even or not, we can simply sum the remainders of their division by 2 (an application of this is that in order to check divisibility by two, we should only look at the last bit of the binary representation).&lt;&#x2F;p&gt;
&lt;p&gt;Another situation where this arises every day is with time. If we are on Monday at 10 am and we have 36 hours till the deadline of a project, we have to submit everything by Tuesday 10 pm. That is because 12 fits exactly 3 times in 36, leading to Mon-10 pm, Tue-10 am, Tue-10 pm. If we had 39 hours, we jump to Wed-1 am.&lt;&#x2F;p&gt;
&lt;p&gt;An easy way to look at this relation (formally known as congruence modulo p) is that if &lt;em&gt;a≡b&lt;&#x2F;em&gt;(mod &lt;em&gt;p&lt;&#x2F;em&gt;), then &lt;em&gt;p&lt;&#x2F;em&gt; divides &lt;em&gt;a−b&lt;&#x2F;em&gt; , or &lt;em&gt;a=k×p+b&lt;&#x2F;em&gt; for an integer &lt;em&gt;k&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;More informally, we see that operating (mod &lt;em&gt;p&lt;&#x2F;em&gt;) wraps around the results of certain calculations, giving always numbers in a bounded range by &lt;em&gt;p&lt;&#x2F;em&gt; −1.&lt;&#x2F;p&gt;
&lt;p&gt;We can see that if a1≡b1(modp) and a2≡b2(modp), then a1+a2≡b1+b2(mod &lt;em&gt;p&lt;&#x2F;em&gt;) (if b1+b2&amp;gt;p we can wrap around the result). Similar results apply when using subtraction and multiplication. Division presents some difficulties, but we can change things a little bit and make it work this way: instead of thinking of dividing &lt;em&gt;a÷b&lt;&#x2F;em&gt; we can calculate &lt;em&gt;a×b−1&lt;&#x2F;em&gt; , where &lt;em&gt;b&lt;&#x2F;em&gt; −1 is the multiplicative inverse of &lt;em&gt;b&lt;&#x2F;em&gt; (remember &lt;em&gt;b×b −1&lt;&#x2F;em&gt;=1). Consider &lt;em&gt;p&lt;&#x2F;em&gt; =5, so the elements of the group are 0,1,2,3,4.&lt;&#x2F;p&gt;
&lt;p&gt;We can see that 1 is its own multiplicative inverse, since 1×1=1≡1  (mod5). If we take 2 and 3, then 2×3=6≡1  (mod5) (so 3 is the multiplicative inverse of 2) and 4×4=16≡1 (mod5). The set and the operations defined satisfy the conditions for a field.&lt;&#x2F;p&gt;
&lt;p&gt;We can also define integer powers of field elements in a simple way. If we want to square a number &lt;em&gt;a&lt;&#x2F;em&gt; , it is just doing &lt;em&gt;a×a&lt;&#x2F;em&gt; and take mod &lt;em&gt;p&lt;&#x2F;em&gt;. If we want a cube, we do &lt;em&gt;a×a×a&lt;&#x2F;em&gt; and take mod &lt;em&gt;p&lt;&#x2F;em&gt;. RSA uses exponentiation to perform encryption. It is easy to see that if the exponent is rather large (or the base is very large, or both), numbers get really big. For example, we want to evalute 265536(mod &lt;em&gt;p&lt;&#x2F;em&gt;). When we reach a 1000, we get numbers with over 300 digits and we are still a long way to go. We can do this calculation much simpler realizing that 65536=216 and squaring the number and taking the remainder every time. We end up doing only 16 operations like this, instead of the original 65536! thus avoiding huge numbers. A similar strategy will be used when we work with ECs!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;groups&quot;&gt;Groups&lt;&#x2F;h2&gt;
&lt;p&gt;We saw that whenever we add two even integers, we get another one. Besides, as 0 is even and if we sum &lt;em&gt;a&lt;&#x2F;em&gt; and &lt;em&gt;−a&lt;&#x2F;em&gt; we get 0, which is the identity element for the sum. Many different objects have a similar behavior when equipped with a certain operation. For example, the multiplication of two invertible matrices results in an invertible matrix. If we consider the set of invertible matrices of &lt;em&gt;N&lt;&#x2F;em&gt; × &lt;em&gt;N&lt;&#x2F;em&gt; equipped with the multiplication, we can see that if &lt;em&gt;A&lt;&#x2F;em&gt; is in the set, &lt;em&gt;A −1&lt;&#x2F;em&gt; is in the set; the identity matrix is in the set (and it plays the role of identity element with respect to multiplication). In other words, some sets equipped with a certain operation share some properties and we can take advantage of the knowledge of this structure. The set, together with the operation, forms a group. Formally, a group is a set &lt;em&gt;G&lt;&#x2F;em&gt; equipped with a binary operation × such that:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; 1. The operation is associative, that is, _(a×b)×c=a×(b×c)_.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; 2. There is an identity element, _e: e×a=a_ and _a×e=a_. &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; 3. For every element _a_ in the set, there is an element _b_ in the set such that _a×b=e_ and _b×a=e_. We denote _b=a−1_ for simplicity.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can easily see that any field is, in particular, a group with respect to each one of its two operations (conditions 1, 2 and 4 for the field indicate it is also a group with respect to the sum and 1, 3 and 5 for multiplication). If the operation is commutative (that is, &lt;em&gt;a×b=b×a&lt;&#x2F;em&gt;) the group is known as an abelian (or commutative) group. For example, the invertible matrices of &lt;em&gt;N×N&lt;&#x2F;em&gt; form a group, but it is not abelian, since &lt;em&gt;A×B≠B×A&lt;&#x2F;em&gt; for some matrices &lt;em&gt;A&lt;&#x2F;em&gt; and &lt;em&gt;B&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We will be interested in finite groups (those where the set contains a finite number of elements) and, in particular, cyclic groups. These are groups which can be generated by repeatedly applying the operation over an element &lt;em&gt;g&lt;&#x2F;em&gt; , the generator of the group. The &lt;em&gt;n&lt;&#x2F;em&gt; -th roots of unity in the complex numbers form an example of a cyclic group under multiplication; this is the set of solutions of &lt;em&gt;x n&lt;&#x2F;em&gt;=1, which are of the form exp(2 &lt;em&gt;πik&#x2F;n&lt;&#x2F;em&gt;), with &lt;em&gt;k&lt;&#x2F;em&gt; =0,1,2…,&lt;em&gt;n&lt;&#x2F;em&gt; −1. This group can be generated by taking integer powers of exp(2 &lt;em&gt;πi&#x2F;n&lt;&#x2F;em&gt;). The roots of unity play an important role in the calculation of the fast Fourier transform (FFT), which has many applications.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;elliptic-curves-in-a-nutshell&quot;&gt;Elliptic curves in a nutshell&lt;&#x2F;h2&gt;
&lt;p&gt;Elliptic curves are very useful objects because they allow us to obtain a group structure with interesting properties. Given a field &lt;em&gt;F&lt;&#x2F;em&gt; , an elliptic curve is the set of points &lt;em&gt;(x,y)&lt;&#x2F;em&gt; which satisfy the following equation:&lt;&#x2F;p&gt;
&lt;p&gt;_y 2+a1xy+a3y=x3+a2x2+a4x+a6 _&lt;&#x2F;p&gt;
&lt;p&gt;This is known as the general Weierstrass equation. In many cases, this can be written in the simpler form&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;y 2=x3+ax+b&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;which is the (Weierstrass) short-form. Depending on the choice of the parameters a and b and the field, the curve can have some desired properties or not. If _4a 3+27b2≠0 _, the curve is non-singular.&lt;&#x2F;p&gt;
&lt;p&gt;We can define an operation which allows us to sum elements belonging to the elliptic curve and obtain a group. This is done using a geometric construction, the chord-and-tangent rule. Given two points on the curve &lt;em&gt;P1=(x 1,y1)&lt;&#x2F;em&gt; and &lt;em&gt;P 2=(x2,y2)&lt;&#x2F;em&gt;, we can draw a line connecting them. That line intersects the curve on a third point &lt;em&gt;P 3=(x3,y3)&lt;&#x2F;em&gt;. We set the sum of &lt;em&gt;P 1&lt;&#x2F;em&gt; and &lt;em&gt;P 2&lt;&#x2F;em&gt; as &lt;em&gt;(x 3,−y3)&lt;&#x2F;em&gt;, that is, point &lt;em&gt;P 3&lt;&#x2F;em&gt; flipped around the &lt;em&gt;x&lt;&#x2F;em&gt; -axis. The formulae are:  &lt;img src=&quot;&#x2F;images&#x2F;2022&#x2F;12&#x2F;imagen-1.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We can easily see that we have a problem if we try to sum &lt;em&gt;P 1=(x1,y1)&lt;&#x2F;em&gt; and &lt;em&gt;P 2=(x1,−y1)&lt;&#x2F;em&gt;. We need to add an additional point to the system, which we call the point at infinity &lt;em&gt;O&lt;&#x2F;em&gt;. This inclusion is necessary to be able to define the group structure and works as the identity element for the group operation.&lt;&#x2F;p&gt;
&lt;p&gt;Another problem appears when we want to sum &lt;em&gt;P 1&lt;&#x2F;em&gt; and &lt;em&gt;P 1&lt;&#x2F;em&gt; to get to &lt;em&gt;P 3=2P1&lt;&#x2F;em&gt;. But, if we draw the tangent line to the curve on P1, we see that it intersects the curve at another point. If we want to perform this operation, we need to find the slope of the tangent line and find the intersection:&lt;&#x2F;p&gt;
&lt;p&gt;$$s=\frac{3x21+a}{2y1}$$&lt;br &#x2F;&gt;
$$x3=s2−2x1$$&lt;br &#x2F;&gt;
$$y3=s(x1−x3)−y1$$&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;2022&#x2F;12&#x2F;imagen-5.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;It takes a little bit of work, but we can prove that the elliptic curve with this operation has the properties of a group. We will use finite fields to work with these curves and the groups that we will obtain are finite cyclic groups, that is, groups which can be generated by repeteadly using the operation on a generator, &lt;em&gt;g: g,2g,3g,4g,5g,….&lt;&#x2F;em&gt; &lt;img src=&quot;&#x2F;images&#x2F;2022&#x2F;12&#x2F;imagen-3.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;If we plot the collection of points onto a graph, we see that the points are distributed in a rather “random” fashion. For example, &lt;em&gt;2 g&lt;&#x2F;em&gt; could be very far from &lt;em&gt;3 g&lt;&#x2F;em&gt; which in turn are very far from &lt;em&gt;4 g&lt;&#x2F;em&gt;. If we wanted to know how many times &lt;em&gt;k&lt;&#x2F;em&gt; we have to add the generator to arrive at a certain point &lt;em&gt;P&lt;&#x2F;em&gt; (that is solving the equation &lt;em&gt;kg=P&lt;&#x2F;em&gt;) we see that we don’t have an easy strategy and we are forced to perform a brute search over all possible &lt;em&gt;k&lt;&#x2F;em&gt;. This problem is known as the (elliptic curve) discrete logarithm (log for friends) problem (other friends prefer ECDLP).&lt;&#x2F;p&gt;
&lt;p&gt;On the other hand, if we know &lt;em&gt;k&lt;&#x2F;em&gt; , we can compute in a very fast way &lt;em&gt;P=kg&lt;&#x2F;em&gt;. This offers us a way to hide (in plain sight) things inside the group. Of course, if you could break the DLP, you could get k, but it is rather infeasible. If we want to calculate 65536 &lt;em&gt;g&lt;&#x2F;em&gt; , we can do it by realizing that &lt;em&gt;g+g=2 g, 2g+2g=4g, 4g+4g=8&lt;&#x2F;em&gt;…until &lt;em&gt;32768 g+32768g=65535g&lt;&#x2F;em&gt;, so we narrowed the operations 65536 to 16. There are many useful algorithms that allow us to speed up the operations over elliptic curves, allowing us to avoid expensive calculations such as inversions, which appear when we want to calculate the slope.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;are-all-elliptic-curves-useful-for-crypto&quot;&gt;Are all elliptic curves useful for crypto?&lt;&#x2F;h2&gt;
&lt;p&gt;The strength of elliptic curve cryptography lies on the hardness to solve the discrete logarithm problem. This is related to the number of elements (the order of the set) making the cyclic group. If the number is a very large prime, or it contains a very large prime in its factorization (that is, the number is a multiple of a large prime), then the problem becomes infeasible. However, if the order is made up of small primes, it is possible to search over the subgroups and reconstruct the answer with help from the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Chinese_remainder_theorem&quot;&gt;Chinese Remainder Theorem&lt;&#x2F;a&gt;. This is because the difficulty depends on the size of the largest prime involved.&lt;&#x2F;p&gt;
&lt;p&gt;Some curves have desired properties and have been given names. For example, Bitcoin uses secp256k1, which has the following parameters:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;a=0&lt;&#x2F;em&gt;&lt;br &#x2F;&gt;
&lt;em&gt;b&lt;&#x2F;em&gt; =7 &lt;em&gt;p&lt;&#x2F;em&gt; =2256−232−977 &lt;em&gt;g x&lt;&#x2F;em&gt;=&lt;em&gt;0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798&lt;&#x2F;em&gt; &lt;em&gt;g y=0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8&lt;&#x2F;em&gt; &lt;em&gt;r=0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;To get an idea on the number of elements of the group, they’re about &lt;em&gt;r&lt;&#x2F;em&gt; ≈1077. Even if we had 1012 supercomputers performing over 1017 search points per second for a hundred million years we wouldn’t even get close to inspecting all the possibilities.&lt;&#x2F;p&gt;
&lt;p&gt;To be able to guarantee 128-bits of security, ECs need group orders near 256-bits (that is, orders with prime factors around 1077). This is because there are algorithms which can solve the problem doing operations around √r. If the largest prime is less than 94-bits long, it can be broken with help from a desktop computer. Of course, even if your group is large enough, nothing can save you from a poor implementation.&lt;&#x2F;p&gt;
&lt;p&gt;The question arises: how can we know the number of elements of our EC? Luckily, math comes once again to our aid like the Hasse bound, Schoof’s algorithm and how to test whether a number is prime or not. Next time we will continue revealing the math principles behind useful tools in cryptography.&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
