<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>LambdaClass Blog - Functional Programming</title>
      <link>https://blog.lambdaclass.com</link>
      <description>Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.</description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://blog.lambdaclass.com/tags/functional-programming/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Sun, 26 Jul 2020 00:00:00 +0000</lastBuildDate>
      <item>
          <title>For the first time, enjoy all the talks of BuzzConf 2020 online and free of charge!</title>
          <pubDate>Sun, 26 Jul 2020 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/for-the-first-time-enjoy-all-the-talks-of-buzzconf-2020-online-and-free-of-charge/</link>
          <guid>https://blog.lambdaclass.com/posts/for-the-first-time-enjoy-all-the-talks-of-buzzconf-2020-online-and-free-of-charge/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/for-the-first-time-enjoy-all-the-talks-of-buzzconf-2020-online-and-free-of-charge/">&lt;h3 id=&quot;come-see-buzzconf-2020-a-software-and-data-science-conference-open-and-online-for-one-and-for-all&quot;&gt;Come see BuzzConf 2020, a software and data science conference, open and online for one and for all!&lt;&#x2F;h3&gt;
&lt;p&gt;The third edition of BuzzConf will be held freely online via Zoom and Youtube live. We’re very proud of our speaker lineup, which covers a wide range of topics that expand the frontiers of our technical knowledge.&lt;&#x2F;p&gt;
&lt;p&gt;We will dive into the topics of functional programming, Julia, Python, data science, machine learning, observability, operating systems and more! We believe Functional Programming and Data Science are two of the most interesting topics in the field which will open many opportunities in the near future, and we want to bring the latest developments in these areas to the global community.&lt;&#x2F;p&gt;
&lt;p&gt;This conference is the result of a combined effort of private and public sectors from Argentina, which aspires to help the development of our country’s technical capabilities while spreading and sharing knowledge with the world.&lt;&#x2F;p&gt;
&lt;p&gt;We thank the generosity of the speakers who agreed to donate their time and we hope you enjoy their talks as much as we will.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-LzNJkTEcILfT_6U8t2baDg.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;mon-july-27-2pm-pdt-6pm-gmt-3-9pm-utc&quot;&gt;Mon, July 27–2pm PDT &#x2F; 6pm GMT-3 &#x2F; 9pm UTC&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;charity-majors-what-got-you-here-won-t-get-you-there-how-your-team-can-become-a-high-performing-team-by-embracing-observability&quot;&gt;Charity Majors — “What got you here won’t get you there: How your team can become a high-performing team by embracing observability”&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;em&gt;To Be Announced&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on Zoom:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;92898927496&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;92898927496&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on YouTube:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;QK6zEFdvXYw&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;youtu.be&#x2F;QK6zEFdvXYw&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-fTWA2R7HUM90oPA7.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;mon-july-27-3pm-pdt-7pm-gmt-3-10pm-utc&quot;&gt;Mon, July 27–3pm PDT &#x2F; 7pm GMT-3 &#x2F; 10pm UTC&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;maria-vanina-martinez-symbolic-reasoning-to-model-sentiment-and-knowledge-diffusion-in-social-networks&quot;&gt;María Vanina Martinez: “Symbolic Reasoning to model Sentiment and Knowledge Diffusion in Social Networks”&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;em&gt;Social media platforms, taken in conjunction, can be seen as complex networks; in this context, understanding how agents react to sentiments expressed by their connections is of great interest. We show how Network Knowledge Bases help represent the integration of multiple social networks, and explore how information flow can be handled via belief revision operators for local (agent-specific) knowledge bases. We report on preliminary experiments on Twitter data showing that different agent types react differently to the same information — this is a first step toward developing symbolic tools to predict how agents behave asinformation flows in their social environment.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on Zoom:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;92898927496&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;92898927496&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on YouTube:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;QK6zEFdvXYw&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;youtu.be&#x2F;QK6zEFdvXYw&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-Urum4vQ0RP0TZub3.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tue-july-28-2pm-pdt-6pm-gmt-3-9pm-utc&quot;&gt;Tue, July 28–2pm PDT &#x2F; 6pm GMT-3 &#x2F; 9pm UTC&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;will-kurt-the-limits-of-probability&quot;&gt;Will Kurt: “The Limits of Probability”&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;em&gt;Probability is an increasingly ubiquitous part of our daily lives, especially as developers, researchers and data scientists. It is easy to mistakenly think this powerful tool is all we need to understand our world. This talk will show how our current environment of global pandemic, political unrest and economic uncertainty forces us to face the limits of probability as a tool for reasoning and understanding. This talk will cover both practical examples of the limitations of probability as well as dive into the philosophical roots of these limitations to show that it cannot be our only means to engage with our world.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on Zoom:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;97859783809&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;97859783809&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on YouTube:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;N75ebGWz2o4&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;youtu.be&#x2F;N75ebGWz2o4&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-a3kX6m-ky8tQK27S.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tue-july-28-3pm-pdt-7pm-gmt-3-10pm-utc&quot;&gt;Tue, July 28–3pm PDT &#x2F; 7pm GMT-3 &#x2F; 10pm UTC&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;lightning-talks&quot;&gt;Lightning Talks&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;Juan Pablo Lorenzo:&lt;&#x2F;strong&gt; “Delete your code: in search of a minimalist approach to software development”&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Gajendra Deshpande:&lt;&#x2F;strong&gt; “Computation Techniques for Encrypted Data using Python”&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on Zoom:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;97859783809&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;97859783809&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on YouTube:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;N75ebGWz2o4&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;youtu.be&#x2F;N75ebGWz2o4&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wed-july-29-2pm-pdt-6pm-gmt-3-9pm-utc&quot;&gt;Wed, July 29–2pm PDT &#x2F; 6pm GMT-3 &#x2F; 9pm UTC&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;aditya-siram-what-fp-can-learn-from-static-introspection&quot;&gt;Aditya Siram: “What FP Can Learn From Static Introspection”&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;em&gt;What if compile time and type level programming in functional programming languages were easy, something you reach for without even thinking about it? What if you could debug type errors with a simple compile time print statement? Write highly flexible systems by being able to introspect into types at compile time? Pre-calculate large portions of your programs for great efficiency? Typed functional programming is a great and fun way to write resilient software, and as type systems have become more and more expressive in recent years, we are able to program sophisticated and useful properties at the type level for even better compile time safety. Just one problem: It is very difficult, requires advanced knowledge of the type system, the syntax is convoluted, the error messages are impenetrable, and it is nearly impossible to debug. This talk will dive into why we should steal static introspection from languages like Nim, and D, state-of-the-art imperative programming languages which can solve all these issues, make type systems much more approachable without losing any expressive power, and offer new design possibilities for functional programs.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on Zoom:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;95139644343&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;95139644343&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on YouTube:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;yGq0KnkqOgI&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;youtu.be&#x2F;yGq0KnkqOgI&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-Koxyxq-wrBx9iGfe.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wed-july-29-3pm-pdt-7pm-gmt-3-10pm-utc&quot;&gt;Wed, July 29–3pm PDT &#x2F; 7pm GMT-3 &#x2F; 10pm UTC&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;sergio-chouhy-deeploying-deep-q-learning-with-pytorch&quot;&gt;Sergio Chouhy: “Deeploying Deep Q Learning with Pytorch”&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;em&gt;Many things are being said about Deep Reinforcement Learning, but sometimes it is really hard to know where to start. In this talk, I will tell you all about the basis of this algorithms and show you how to deploy Deep Q Learning from scratch using Pytorch. I will be also talking about industrial applications for this technology.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on Zoom:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;95139644343&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;95139644343&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on YouTube:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;yGq0KnkqOgI&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;youtu.be&#x2F;yGq0KnkqOgI&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-82lbeMCqONPXiKq1.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;thu-july-30-2pm-pdt-6pm-gmt-3-9pm-utc&quot;&gt;Thu, July 30–2pm PDT &#x2F; 6pm GMT-3 &#x2F; 9pm UTC&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;viral-b-shah-julia-a-language-for-ai-and-much-more&quot;&gt;Viral B. Shah: “Julia — A language for AI and much more”&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;em&gt;The Julia language is now used by over half a million programmers worldwide. Created to solve the two language problem, Julia is demonstrating performance gains of 50x-100x for many data science tasks such as data loading, data processing, graph processing, machine learning and scaling. Robust support for modern deep learning and the ability to do differentiable programming in an intuitive way is quickly leading to Julia becoming the language of choice for AI workloads. My talk will discuss the origin story of Julia, the formation of the Julia community, and all the amazing things happening in the world of Julia.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on Zoom:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;94906592252&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;94906592252&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on YouTube:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;fbKHLdoG7wA&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;youtu.be&#x2F;fbKHLdoG7wA&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0--gyZtKfGpWBIxRoz.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;thu-july-30-3pm-pdt-7pm-gmt-3-10pm-utc&quot;&gt;Thu, July 30–3pm PDT &#x2F; 7pm GMT-3 &#x2F; 10pm UTC&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;chris-rackauckas-sciml-how-language-is-changing-scientific-research&quot;&gt;Chris Rackauckas: “SciML: How Language is Changing Scientific Research”&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;em&gt;Scientific machine learning is a burgeoning field and its taking off in Julia. Why? The purpose of this talk is to dive into that question: how has language accelerated the development of Julia’s SciML ecosystem? The core is composibility through multiple dispatch. We will showcase how this feature is not only what makes standard Julia code as fast as C or Fortran, but also allows Julia to eschew the traditional idea of “machine learning frameworks” and instead have machine learning directly work on the standard functions and libraries of the whole Julia programming language. This language-wide differentiable programming then builds a foundation where existing climate models, helicopter simulations, and efficiency simulators for battery-powered airplanes can be instantly composed with new tools for machine learning, and we will demonstrate how this has changed the way that researchers in Julia do science.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on Zoom:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;94906592252&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;94906592252&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on YouTube:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;fbKHLdoG7wA&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;youtu.be&#x2F;fbKHLdoG7wA&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-2EbV5-0r03R6aPYH.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fri-july-31-2pm-pdt-6pm-gmt-3-9pm-utc&quot;&gt;Fri, July 31–2pm PDT &#x2F; 6pm GMT-3 &#x2F; 9pm UTC&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;pablo-fernandez-machine-learning-in-the-real-world&quot;&gt;Pablo Fernandez: “Machine Learning in The Real World”&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;em&gt;A tour of the last 3 years of my career where I’ve productionized 3 different machine learning projects on kind-of-a-big-company (Despegar). Some of the challenges faced, not only technical but also from a product standpoint, some of the pedagogical work needed to convince others of letting important decisions be made by a machine. Hopefully insights that help you bring your own models to production.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on Zoom:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;92628004626&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;92628004626&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on YouTube:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;t-ebpSHyBEE&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;youtu.be&#x2F;t-ebpSHyBEE&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-7y4gqQ8d8_6veW_j.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fri-july-31-3pm-pdt-7pm-gmt-3-10pm-utc&quot;&gt;Fri, July 31–3pm PDT &#x2F; 7pm GMT-3 &#x2F; 10pm UTC&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;peter-alvaro-what-not-where-why-a-blue-sky-os&quot;&gt;Peter Alvaro: “What not where: why a blue sky OS?”&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;em&gt;A world of distributed, persistent memory is on its way. Our programming models traditionally operate on short-lived data representations tied to ephemeral contexts such as processes or computers. In the limit, however, data lifetime is infinite compared to these transient actors. We discuss the implications for programming models raised by a world of large and potentially persistent distributed memories, including the need for explicit, context-free, invariant data references. We present a novel operating system that uses wisdom from both storage and distributed systems to center the programming model around data as the primary citizen, and reflect on the transformative potential of this change for infrastructure and applications of the future.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on Zoom:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;92628004626&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;zoom.us&#x2F;j&#x2F;92628004626&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Join us on YouTube:&lt;&#x2F;em&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;t-ebpSHyBEE&quot;&gt;&lt;em&gt;https:&#x2F;&#x2F;youtu.be&#x2F;t-ebpSHyBEE&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-MOD81ymGRUNUrv7m.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We hope to see you there! There will be time for Q&amp;amp;A with the speakers. &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.eventbrite.com.ar&#x2F;e&#x2F;buzzconf-2020-tickets-111836742708&quot;&gt;Register now&lt;&#x2F;a&gt;!&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Interview with Robert Virding, creator of Lisp Flavored Erlang, an alien technology masterpiece</title>
          <pubDate>Mon, 29 Feb 2016 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/interview-with-robert-virding-creator-lisp-flavored-erlang-an-alien-technology-masterpiece/</link>
          <guid>https://blog.lambdaclass.com/posts/interview-with-robert-virding-creator-lisp-flavored-erlang-an-alien-technology-masterpiece/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/interview-with-robert-virding-creator-lisp-flavored-erlang-an-alien-technology-masterpiece/">&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-0_N8_5MqdROjW5duRb6Dpw.png&quot; alt=&quot;&quot; &#x2F;&gt;As you might know zombies, skeletons and momies are good friends of aliens&lt;&#x2F;p&gt;
&lt;p&gt;This time I interviewed &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;rvirding&quot;&gt;Robert Virding&lt;&#x2F;a&gt;, co-creator of Erlang and creator of &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;lfe.io&#x2F;&quot;&gt;Lisp Flavored Erlang&lt;&#x2F;a&gt; (LFE). I am an Erlang developer and Lisp fan — if you are learning Clojure check out my post &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;this-is-not-a-monad-tutorial&#x2F;how-to-earn-your-clojure-white-belt-7e7db68a71e5#.dtmcog9gk&quot;&gt;How to earn your Clojure white belt&lt;&#x2F;a&gt; — so logically I am very excited about LFE.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;strong&gt;Why did you create LFE?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I discovered and learnt Lisp long before we started working with Erlang, and have always loved it. But I also like the Erlang language (I don’t have problems with the syntax :-)) and how it can build systems. My goal was to make a lisp which was a “real” lisp which builds systems in the Erlang way. Hence LFE.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is the LFE philosophy?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;LFE is a proper lisp based on the features and limitations of the Erlang VM, which coexists seamlessly with vanilla Erlang and OTP and runs on the standard Erlang VM.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;In your talk called&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=afLRmoSOnHA&quot;&gt;&lt;strong&gt;“About Language Design”&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;you said:&lt;br &#x2F;&gt;
&lt;em&gt;“&lt;&#x2F;em&gt; &lt;em&gt;People complain about the Erlang libraries and once thing they complain very rightly about the Elang libraries is they’re inconsistent, the naming conventions is inconsistent, the argument ordering is inconsistent, everything is inconsistent about them and that is correct. They are right and people complain about that.”&lt;&#x2F;em&gt;&lt;br &#x2F;&gt;
At some point, will you create a new standard library in LFE?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I would like to but there are some deep problems trying to do that. Basically you can’t really change any library module that is used by OTP without the effect propagating and going viral in OTP. Adding new libraries yes, modifying old modules not really. Elixir got around this by having their special module aliases which map onto module name ‘Elixir.XXX’ but then you end up with 2 module naming conventions. I preferred to keep the same names.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rvirding&#x2F;lfe&#x2F;blob&#x2F;dev-macro&#x2F;src&#x2F;cl.lfe&quot;&gt;&lt;strong&gt;Common Lisp macros and functions&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;have been added to&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rvirding&#x2F;lfe&#x2F;blob&#x2F;dev-macro&#x2F;src&#x2F;cl.lfe&quot;&gt;&lt;strong&gt;LFE&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;.&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lfex&#x2F;clj&#x2F;issues&#x2F;18&quot;&gt;&lt;strong&gt;Clojure macros and functions&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;are also available as a separate library. LFE follows more traditional LISPs like Common Lisp, Scheme or more modern Lisps like Clojure?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;LFE more has the feel of CL and Scheme, especially CL as it is a lisp-2 not a lisp-1 like Scheme. Clojure is definitely interesting but I felt that the way it does concurrency doesn’t really map well onto Erlang and the style of building systems feels different. Clojure feels more like language with concurrency while Erlang feels more like a operating system with a language.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rvirding&#x2F;flavors&quot;&gt;&lt;strong&gt;LFE Flavors&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;and the&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;oubiwann&#x2F;los&quot;&gt;&lt;strong&gt;LFE Object System&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;? Aren’t they pretty similar?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Flavors is an object system on the Lisp Machine. I did LFE Flavors out of pure fun and curiosity. A long time ago (about 30 yrs) I did an implementation of Flavors for another lisp system, Portable Standard Lisp, and I was curious to see what it would be like to do one for LFE. It worked quite well for the central parts but there is a lot of Lisp machine specifics which can’t be transferred. CLOS is based on Flavors and you can see the heritage.&lt;&#x2F;p&gt;
&lt;p&gt;My plan with LFE Flavors is not to bake it in as part of LFE but have it as a supported compatible plugin. I like to keep the core simple. I also have plans to implements more general structs which will allow more control over data structures and access to them. It would subsume records and elixir structs amongst other things.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;A few months ago you&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;groups.google.com&#x2F;d&#x2F;topic&#x2F;lisp-flavoured-erlang&#x2F;l_Te7ZHkm9M&#x2F;discussion&quot;&gt;&lt;strong&gt;sent an email&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;titled “New macro handling and compiled macros”. How does the macro system work in LFE, what are you changing and why?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Currently macros work by defining them locally in each file where they are used. If you need to share macros then you define them in include files. The new macro handling will allow macros to be exported from modules in much the same way as functions and you would call them in the same way. So for a module foo you call functions with (foo:function …) and macros with (foo:macro …) making the interface much more consistent generic. Most uses of include files will disappear.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What do you think about Elixir?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Ambivalent! I don’t speak Ruby at all, so much of the syntax feels very strange and foreign. It also manages to push some of my programming buttons, for example having multiple ways of representing the same thing and adding syntax for special cases; both which I feel are just wrong. I am jealous of their ability to clean up some of the OTP modules by writing their own interfaces and having a way to avoid overlapping module names. I wonder about some of the complexity but that is just because I have a thing about simplicity.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Have you incorporated any idea from it into LFE?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I have not taken any ideas directly from Elixir though we do share some features, for example having multiple modules in one file (which I am not sure I like but it can be practical).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;I have seen&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;blog.lfe.io&#x2F;design&#x2F;2015&#x2F;07&#x2F;11&#x2F;1720-towards-multi-methods-in-lfe&#x2F;&quot;&gt;&lt;strong&gt;multimethods&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;and&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lfex&#x2F;los&#x2F;issues&#x2F;8&quot;&gt;&lt;strong&gt;protocols&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;mentioned a few times by the LFE community. What do you think about Clojure multimethods and protocols?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;One difficulty doing something like this in Erlang is that Erlang modules must be compiled as one unit, it is impossible to add, or remove, functions afterwards without recompiling the whole module. This makes it very difficult to have methods which are to be in one module in different places. Which lessens the usefulness of multimethods. IMAO.&lt;&#x2F;p&gt;
&lt;p&gt;Flavors gets around this by compiling each component flavor separately and building a object flavor from all its mixin when the first instance is created. This allows us to create the components separately as long as all are done before their first time they are used. After that they cannot be modified.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Do you think adding something like&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;26317325&#x2F;can-someone-explain-clojure-transducers-to-me-in-simple-terms&quot;&gt;&lt;strong&gt;transducers&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;to LFE would be a good idea?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;They probably would be, but they are not really the way I think. I find I tend to be very explicit in which data types I use; for me this is as fundamental as choosing which algorithm to use. This means that having polymorphic transformation functions becomes less interesting for me.&lt;&#x2F;p&gt;
&lt;p&gt;I know that many people prefer working in this way and I see no problems in adding them to the set of standard LFE libraries. They just won’t be integrated into LFE at the lowest level. You will be able to choose.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;I have seen some discussions about Dialyzer in LFE’s mailing list and there is a dialyzer branch in the&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rvirding&#x2F;lfe&#x2F;tree&#x2F;dev-dialyzer&quot;&gt;&lt;strong&gt;LFE repository&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;. How well does LFE support&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;erlang.org&#x2F;doc&#x2F;man&#x2F;dialyzer.html&quot;&gt;&lt;strong&gt;Dialyzer&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Supporting dialyzer is a little tricky as the official interface to dialyzer is very restricted: you either pass in erlang files, or you pass in beam files containing the Erlang AST of the code (compiling with the debug_info option). This does not work with LFE as the LFE compiler generates Core erlang, a language used internally in the compiler.&lt;&#x2F;p&gt;
&lt;p&gt;However, by being a bit cunning I have generated some alternate dialyzer interface modules which can load in the Core erlang forms directly. It works but it is really only an experiment; a better solution would be to do a proper fix of the dialyzer interface but this is not that simple as the current interface is not very cleanly coded. It is actually quite ironic as dialyzer uses Core erlang internally.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What do you think about&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.sbcl.org&#x2F;manual&#x2F;#Handling-of-Types&quot;&gt;&lt;strong&gt;Steel Bank Common Lisp Type system&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;,&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;ts-guide&#x2F;index.html&quot;&gt;&lt;strong&gt;Typed Racket&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;or&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;core.typed&quot;&gt;&lt;strong&gt;Clojure’s core.typed&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;and&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.shenlanguage.org&#x2F;learn-shen&#x2F;types&#x2F;types.html&quot;&gt;&lt;strong&gt;Shen Types&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I have never tried these so I can’t say. Generally I am very dynamically typed. :-)&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is the roadmap for LFE v1.0?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;So far the roadmap has been a little “I just want to add this one last feature and then I’ll release 1.0”. Anyway, my plan now is that when the new macro handling works and is properly integrated then the system will feel well rounded and I will release 1.0.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h4 id=&quot;did-you-like-it-follow-me-on-twitter-unbalancedparen&quot;&gt;Did you like it? F&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;unbalancedparen&quot;&gt;ollow me on Twitter — @unbalancedparen&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;Oh and I recommend that you read this email from Robert about LFE titled &lt;em&gt;“A bit of philosophy and some design principles”&lt;&#x2F;em&gt; :&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;There was a bit of discussion on the IRC about the CL module and where LFE gets its impulses from, that it doesn’t try to stand on its feet. There are things in it from scheme and CL but most of it is based on Erlang and the features it provides and the type of systems you build using it.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;The base of LFE rests directly on what the underlying Erlang VM provides and this determines what LFE can do and how it works. It is based on language features like modules, pattern matching, immutable data and how functions work. This is what defines LFE. I don’t think that LFE tries as hard as Elixir to hide this background.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;This, for example, is why LFE is a lisp-2 not a lisp-1 as it is a better fit for how Erlang handles functions. On top of this there is a set of convenience macros which were originally more scheme inspired but became more CL inspired when LFE became a lisp-2. They are just a better fit. Of course this doesn’t make LFE a scheme or a CL as there are many things in both scheme and CL which LFE can’t do because of the underlying Erlang VM like mutable data and the handling of nil&#x2F;() and symbols with values, plists and function bindings [*].&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;An alternative would have been more inspired by clojure which shares some properties with Erlang. However they are fundamentally different in many ways so it would mainly have been using clojure’s naming conventions. Also clojure’s concurrency model is very different from Erlang&#x2F;LFE so its way of building systems is also very different. You get the feeling, at least I do, that it is based on a central thread of execution where we you can run things in parallel, but there is this central thread. This is very un-Erlangy as Erlang&#x2F;LFE systems typically don’t have a central thread.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;This gets us, finally, to the CL module. It is just a library containing many of the standard CL library functions which gives you the possibility of writing in a CL style. Not everything can be included, for example the nXXXX functions which mutate data, and some features don’t mesh well with Erlang&#x2F;LFE. For example equating nil&#x2F;() and predicates which in Erlang&#x2F;LFE return true&#x2F;false while in CL are truthy and return nil&#x2F;() and anything else [**]. It is in no way a fundamental part of LFE and is just an add-on. If anyone feels inclined to do a similar module for clojure then I will definitely consider including it. Again it would just be an add-on. These could easily be included in the base release.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Packages like flavors, which I did because they are interesting and I think fun, should probably not be part of the base. This wou|d also apply to things like LFE CLOS (if anyone decided to do it) and LFE clojure-like protocols. They are interesting and useful in themselves but not things I would consider part of the LFE base. A set of these should probably kept in a standard place to make them easily accessible for everyone. I would like to keep the base relatively simple, clean and “basic”, a “lean, mean, fighting machine” if you will. It is all too easy to add things, even sensible and useful things, and end up with a bloated mess. I really want to avoid this, hence keeping the base simple and clean.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
</description>
      </item>
      <item>
          <title>Interview with Jesper Louis Andersen about Erlang, Haskell, OCaml, Go, Idris, the JVM, software and…</title>
          <pubDate>Tue, 29 Dec 2015 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and-60901251608c356716f2f92e/</link>
          <guid>https://blog.lambdaclass.com/posts/interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and-60901251608c356716f2f92e/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and-60901251608c356716f2f92e/">&lt;h3 id=&quot;interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and-protocol-design-part-ii&quot;&gt;Interview with Jesper Louis Andersen about Erlang, Haskell, OCaml, Go, Idris, the JVM, software and protocol design — PART II&lt;&#x2F;h3&gt;
&lt;p&gt;This is part II of the interview with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;jlouis666&quot;&gt;Jesper Louis Andersen&lt;&#x2F;a&gt;. You can read &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;this-is-not-a-monad-tutorial&#x2F;interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and-b0de06440fbd#.4gidstolk&quot;&gt;part I here.&lt;&#x2F;a&gt; This part of the interview is mostly about Erlang, one of my favorite languages. If you want to learn Erlang, take a look at &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;spawnedshelter.com&#x2F;&quot;&gt;Spawned Shelter&lt;&#x2F;a&gt;, a website I made for Erlang newcomers.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-DCzEYU60hk2pO7WCJj3GoQ.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What are the advantages of the Erlang VM over the JVM and vice versa?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;From a perspective of history, the choice of building the BEAM VM for Erlang was the correct one. Massive concurrency was less on the radar for many people, and Ericsson needed a platform which they controlled. Furthermore, the BEAM can exploit it is executing functional languages only: the GC needs no generation forward set for instance.&lt;&#x2F;p&gt;
&lt;p&gt;The roll-your-own-design decision has proven to be very valuable, even though compared to the JVM, the OTP team is far smaller. My guess is that for every hour sunk into BEAM, there is at least 15–20 hours of work in the JVM. In turn, there are things which you cannot do efficiently on the BEAM. It is still (2015) bytecode interpreted and has no JIT, which means raw execution of computationally intensive tasks is about 10–20 times slower than typical well-written Java. Projects such as Quasar&#x2F;Pulsar and Akka promises Erlang-style concurrency on the JVM, but they are recently developed whereas the BEAM has been in production for many years.&lt;&#x2F;p&gt;
&lt;p&gt;The key differing design criteria comes from the design space originating in Bjarne Däcker’s thesis. Most notably the soft real-time constraints and the need for seamless hardware interaction, but also the need for running very large software systems in which feature interaction is complex. It turns out in such a world that the major problems are rarely raw execution speed, but rather how parts of the system operate as a coherent whole. Many of the problems in the design space requires a different approach than sheer execution brute force, especially in a multicore world. Had fast execution been important, it would have been addressed a long time ago. But it turns out every major release of BEAM provides a far more important set of new features. There is a lot of power in having a large industrial company backing the system, as the new features tend to be operational&#x2F;industrial in nature.&lt;&#x2F;p&gt;
&lt;p&gt;The key difference in implementation is that the BEAM is built from the ground up as a resource sharing system, much like in an operating system. In an OS, two processes A and B are isolated and gets a fair share of the resources. If B is badly written, this has considerably less impact on A. Suppose for instance B has bad GC productivity and allocates a lot. Then the GC of B has to run far more often and B has to pay: either in lower throughput, or worse latency. At the same time, A will keep on running, without B having any bad impact on its operation. The BEAM isolates resources in such a way that a B application cannot directly impact an A application from a resource standpoint.&lt;&#x2F;p&gt;
&lt;p&gt;The contrast are systems where one large shared heap is used. They hedge both A and B on the same GC heap, hoping it is fast enough to power through. But clearly, a badly written B can affect a well written A far more. It matters in very-large-scale development since you cannot hope every part of the system is perfectly written.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;If the Erlang VM uses asynchronous I&#x2F;O&lt;&#x2F;strong&gt; &lt;strong&gt;how does it do to present a normal api to the developer? Why aren’t callbacks needed like in Node.js?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Node.js uses a cooperative scheduling algorithm as seen in old operating systems such as MacOS 9, Windows 95 running legacy 16-bit code, MS-DOS and so on. The method, in which the program explicitly yields the CPU for the next task, has a number of advantages: it is easy to adapt existing languages and systems to the method. It is highly efficient in throughput. And it allows you to “pack” lots of work into a single process.&lt;&#x2F;p&gt;
&lt;p&gt;The weakness of the cooperative model is its fragility in server settings. If one of the tasks in the task queue monopolizes the CPU, hangs or blocks, then the impact is worse throughput, higher latency, or a deadlocked server. The fragility has to be avoided in large-scale systems, so the Erlang runtime is built preemptively. The normal code is “instrumented” such that any call which may block automatically puts that process to sleep, and switches in the next one on the CPU. Furthermore, Erlang being functional, any process must loop by calling functions. An internal funcall counter measures “reductions” and once 2000 of these has been used, the process is forced off the CPU and the next one is switched in. The process is entirely automatic and follows the modern idea of time-sharing in operating systems: AmigaOS, UNIX, Windows NT+, and so on.&lt;&#x2F;p&gt;
&lt;p&gt;Note that in Erlang there is &lt;em&gt;no way&lt;&#x2F;em&gt; to call blocking operations at all, since they are all handled by the runtime. This means the model is coherent and I can use any library I like without fear of it doing something bad. As an example, BEAM uses its own PCRE Regex library which cooperatively yields expensive NFA traversals. It also breaks up expensive crypto-computations, long-running GCs, and costly term serializations. It even includes a blocking monitor built-in so you can get notified if a monopolization has happened. Calls to foreign code written in C is harder though, since you have to take its blocking behavior into account.&lt;&#x2F;p&gt;
&lt;p&gt;You can get much of the same in any other language by using an appropriate framework. However, this breeds fragmentation: library code in one framework is not usable in another framework without adaptation. And code written for no framework has to be inspected for eventual blocking behavior. In turn, code is colored in different colors, and you can’t mix them.&lt;&#x2F;p&gt;
&lt;p&gt;A far better approach is seen in Quasar&#x2F;Pulsar: take existing bytecode and rewrite it by instrumentation, much like in Erlang. You can insert forced preemptions into loops, and protect any potentially blocking call by a lightweight fiber switch. If you add your own I&#x2F;O manager underneath, you almost have a full implementation of the Erlang model. But it takes a serious amount of work to get the lower parts to run fast in this model, since you have to reimplement all of the Erlang VM inside Java.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;In practical term what do you gain from using a VM like the Erlang VM that has a preemptive scheduler?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Preemption is an exchange in which you sacrifice explicit control for gains in productivity. First, you don’t have to adapt existing code to your model, which saves time. In languages without proper abstraction barriers, calling the wrong function at the wrong time can block a scheduler. Second, in a post-DevOps world where you run your own systems, productivity is directly tied to the maintenance overhead of existing systems. The lower fragility of the model means you have more time to actually write new code rather than fix old problems. You can afford to let bad behavior live for longer in the system since its impact simply gracefully degrades the system a bit.&lt;&#x2F;p&gt;
&lt;p&gt;Most importantly however, you don’t have to worry about every nook and cranny of the code. Rarely run code can be written slightly less performance-oriented since its cost is automatically amortized over the whole of the program by the scheduler. And even in the critical paths, the smearing operation of the scheduler helps a lot to alleviate spikes. Long running background jobs can simply be started without much worry.&lt;&#x2F;p&gt;
&lt;p&gt;Another gain is had from the observation “N starts out small and then grows” which is to say that over time, a piece of software gets to handle gradually more and more data. Without a preemptive scheduler, this growth very often ends up having a considerable latency or throughput impact. Erlang systems errs on the side of maintaining good low-latency for slightly worse throughput in these situations. As load increases on a system, this is often the desirable behavior as it is less likely to affect other systems directly. The system simply degrades gracefully rather than abruptly.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;You wrote:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;In Haskell, Type Classes are often the abstraction way to go. In ML, the key is to use modules.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Don’t you miss type classes or ML modules in Erlang?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I do miss them a lot, but they both rely on efficient type worlds in order to function. Adding them to an untyped language like Erlang is going to be rather hard. A far more reasonable way to go at Erlang programs is to look inside the Elixir and Clojure communities. Clojure’s “procotols” would be a good addition I think, and it fits the Erlang design space far more. Another good place for inspiration is Scheme48’s implementation of modules, which took inspiration from Standard ML’s functors among other things. Scheme48 being a R5RS (&lt;em&gt;Revised^5 Report on the Algorithmic Language Scheme&lt;&#x2F;em&gt;) implementation also shares lots of its design space with Erlang.&lt;&#x2F;p&gt;
&lt;p&gt;It is often said a Haskell type class construction can be implemented with an ML module. The correspondence to Erlang would be to use a process. Processes forces code to modularize and isolate, since the communication can only be done through exchange of messages. Granted, it happens at runtime, but used correctly it yields emergent behaviors in the source code: the same module is executed by many isolated processes at runtime, and their interaction defines the behavior of the program. The literature on swarm intelligence provide more information in this area.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Is it possible to implement a rich static type system and also have message passing at the same time?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Yes it is! Most such systems introduces some kind of “box” which can be typed as in a “box containing type X”. The box is often a single-message mailbox, or a channel. The type system doesn’t even need to be rich for this to work out, as Go shows. It works because the box threads a type with it, so when you put things into the box or extract things from the box, you can statically reason about the type of the extracted&#x2F;inserted value.&lt;&#x2F;p&gt;
&lt;p&gt;Haskell has several highly interesting communication models which enjoy rich typing. There is also John Reppy’s ConcurrentML, which takes communication a step further: not only are channels first class values which can be manipulated, &lt;em&gt;events&lt;&#x2F;em&gt; are first class. CML has an algebra for manipulating events, and combining them. Once you call &lt;em&gt;sync&lt;&#x2F;em&gt; on the event, then the scenario plays out. It is akin being able to have &lt;em&gt;receive&lt;&#x2F;em&gt; -clauses as values which you can join: &lt;em&gt;sync join(Recv1, Recv2)&lt;&#x2F;em&gt;. The most mind-altering operation in Reppy’s calculus is the &lt;em&gt;withNack&lt;&#x2F;em&gt; which is an event firing if &lt;em&gt;another&lt;&#x2F;em&gt; event is picked. It is often used for cancellation situations.&lt;&#x2F;p&gt;
&lt;p&gt;Most of these models assume a non-distributed setting though. They assume that communication cannot fail, and that code cannot be upgraded as it is running. CMLs event resolution in a distributed setting is likely to run into the CAP theorem for instance. Most type systems assume total static knowledge&#x2F;control, something you rarely have in a distributed system. Hence you have to verify interactions between distributed agents, which somewhat defeats the holistic aspect of static typing.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What do you think about monads in erlang? Are they useful? Have you tried out&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rabbitmq&#x2F;erlando&quot;&gt;&lt;strong&gt;erlando&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I do use a monad construction in Erlang from time to time, when the code is going to flow better with a monad, but I rarely use tools such as erlando when doing so. The packages assumes a monad is a module whereas I often use a record for my monad work. To me, monads have always been a tool best used in special cases, and to understand formal logics. Personally, I much prefer the hybrid approaches of OCaml and Erlang, where the languages are imperative rather than the approach of Haskell and purity above all. The latter “forces” monads upon you in ways I don’t always appreciate.&lt;&#x2F;p&gt;
&lt;p&gt;The monad story in Erlang is somewhat weaker than I would like it to be. In Haskell, it is nice because the compiler can use the types to implicitly infer what monad is to be used and then use that monad. A lot of the power comes from the ability to interweave the monadic bind into your code. A Haskell weakness is when you have monad transformer stacks where your code has to change whenever you reorder to stack, but perhaps the work on Free’er monads by Kiselyov can amend this weakness. I feel the productivity is slightly less so in e.g., OCaml (4.02), which needs explicit reference to the monad in order to use it. In Erlang, simple monads are easy to comprehend. But once you raise a complex system out of abstraction, you really need a proper type system to guide you, which you don’t get in Erlang. In turn, Erlang code tends to be less abstraction heavy.&lt;&#x2F;p&gt;
&lt;p&gt;I don’t necessarily think it is a bad idea to have code which uses relatively few abstractions. My own code style, even in OCaml and Haskell, tend to rely on simple principles rather than high levels of abstraction. If you introduce many abstractions, you are also introducing the need for readers to have that knowledge. It is possible to go overboard here, and end up with code which only a few people in the world can read and understand. It might be very efficient and very elegant, but you won’t get many programmers looking at the code. Hence, I tend to use a couple of abstractions when they really help the code, but I refrain from using them in most other situations, preferring to rewrite code through simpler means.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What do you think about Idris Erlang?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Sam Elliot wrote a thesis on this subject[0], and I take that it is this work you are asking about. Among the contributions is a proof-of-concept Erlang-backend for Idris. It allows you to take Idris modules and compile them as Erlang modules. A proper backend would definitely need more work, and it should target Erlang’s Core rather than concatenating strings together to form an Erlang program. Yet, one has to remember what the goals of a thesis are, which is to say it is not about producing production quality backends for languages. But the thesis also explores another path which was perhaps a bit overlooked: how do we type message communication?&lt;&#x2F;p&gt;
&lt;p&gt;Looking at the Erlang message model, and squinting your eyes a lot, you get what is essentially IP&#x2F;UDP communication of messages, of arbitrary size. If you know a Process ID, you know it’s “IP” and you have a capability to send that PID a message. You also have the property that message loss might occur but it is very unlikely unless something is going seriously wrong. Since the risk of failure is low, you can usually handle it by restarting from a known good state, rather than implementing complex recovery schemes.&lt;&#x2F;p&gt;
&lt;p&gt;This model is extremely flexible and you can build almost any kind of messaging on top of it. But on the other hand, generality weakens the meta-theoretic properties of any protocol: we can’t say anything about the well-formedness of messages.&lt;&#x2F;p&gt;
&lt;p&gt;What Elliot points out in his thesis is the notion of constraining our communication to certain limited patterns. By giving up the general messaging, we can suddenly define a typed world in which we understand what is going on. In turn, we can prove well-typed patterns enjoy desirable properties. With enough work, we may be able to capture essentially all the healthy patterns of communication, while rejecting the bad ones. If this could lead to removal of subtle concurrency&#x2F;distribution mistakes, we have come a long way.&lt;&#x2F;p&gt;
&lt;p&gt;Another thesis I have to mention in passing is Simon Fowlers on monitoring communication patterns in Erlang&#x2F;OTP[1]. Fowler explores the idea of monitoring messaging at runtime through an altered &lt;em&gt;gen_server&lt;&#x2F;em&gt; construct. One of his major observations is that many Erlang message patterns are not captured by a typical two-party session type, let alone a multi-party session type. In particular multi-party session types doesn’t allow for the dynamic introduction of new members nor for the termination of members while the session is ongoing. Fowler proposes several interesting solutions and paths in his thesis on how to adapt the system to handle these problems.&lt;&#x2F;p&gt;
&lt;p&gt;All in all, these observations seem to suggest we need some more research work in the area to understand the full interplay between a language such a Idris, and a highly concurrent ecosystem such as the Erlang BEAM VM. It would seem Erlang is a more generic fabric on top of which we could &lt;em&gt;patch in&lt;&#x2F;em&gt; restrictions which improves the quality of our systems through automatic fault removal. In any case, typing concurrent&#x2F;distributed programming in a very general communication model such as Erlang seems to be very hard.&lt;&#x2F;p&gt;
&lt;p&gt;We also need to explore messaging patterns in Erlang which are typeable in some type system. Usually such patterns have additional desirable structure embedded in them because the type system enforces rigidity. By researching in this area, one may hope to improve the understanding of why certain patterns are used, or not.&lt;&#x2F;p&gt;
&lt;p&gt;[0] &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;lenary.co.uk&#x2F;publications&#x2F;dissertation&#x2F;&quot;&gt;http:&#x2F;&#x2F;lenary.co.uk&#x2F;publications&#x2F;dissertation&#x2F;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;[1] &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;simonjf.com&#x2F;writing&#x2F;msc-thesis.pdf&quot;&gt;http:&#x2F;&#x2F;simonjf.com&#x2F;writing&#x2F;msc-thesis.pdf&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Since it is very common to use a pool of gen servers in Erlang: Wouldn’t it be a good idea for Erlang&#x2F;OTP to have a default gen_pool implementation?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Erlangs tenet is “provide tools, not solutions”. That is, provide the tooling for building a pool, but don’t provide a pool. The reason has to do with the fact pools are not alike. Over the last 10 years I’ve come across perhaps 5 different pool implementations and the key observation is they are all &lt;em&gt;valid&lt;&#x2F;em&gt; such implementations. How to hand out resources from the pool differ: some do round-robin proxying. Some queue requests and hand them out in FIFO order. Some uses LIFO order. Some are distributed Job-Idle Queue implementations, whereas some can only run on a single machine. Some provide automatic health checks and reconnections. Some block the caller when there is no work, others errors, and some queues the caller for a while, before erroring.&lt;&#x2F;p&gt;
&lt;p&gt;The other observation is how such pools handle failure, reclaim stale resources, handle errors in the pool implementation itself etc. Again, it is not clear what &lt;em&gt;the&lt;&#x2F;em&gt; implementation should be, and what would be the correct operation. It is mostly a function of context in which the pool is used.&lt;&#x2F;p&gt;
&lt;p&gt;My experience is that this problem space requires either chaos monkeys, concuerror or QuickCheck+PULSE to remove faults, and it is hard to get entirely right. But such tools require a specification of “correct operation”, and there are several such specifications.&lt;&#x2F;p&gt;
&lt;p&gt;Had Erlang&#x2F;OTP provided a default gen_pool implementation, then people would use it even if it doesn’t fit their problem space. This tend to create subtle hard-to-find faults.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Interview with Jesper Louis Andersen about Erlang, Haskell, OCaml, Go, Idris, the JVM, software and…</title>
          <pubDate>Mon, 28 Dec 2015 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and/</link>
          <guid>https://blog.lambdaclass.com/posts/interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and/">&lt;h3 id=&quot;interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and-protocol-design-part-i&quot;&gt;Interview with Jesper Louis Andersen about Erlang, Haskell, OCaml, Go, Idris, the JVM, software and protocol design — PART I&lt;&#x2F;h3&gt;
&lt;p&gt;In this occasion we interviewed Jesper Louis Andersen, a type theorist with lot of practical knowledge and experience. His &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;@jlouis666&quot;&gt;blog&lt;&#x2F;a&gt; (you should also check his old &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;jlouisramblings.blogspot.com&#x2F;&quot;&gt;blog&lt;&#x2F;a&gt;, you will find a lot of good things over there) and code (specially things like &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jlouis&#x2F;safetyvalve&quot;&gt;safetyvalve&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jlouis&#x2F;fuse&quot;&gt;fuse&lt;&#x2F;a&gt;) have been a big inspiration to me. That is why I published the interview in two parts: I had too many questions for him. I hope you enjoy reading his answers as much as I did.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-mIrYVuSZtaYe3WJkRwUqwQ.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I published part II of the interview. &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;this-is-not-a-monad-tutorial&#x2F;interview-with-jesper-louis-andersen-about-erlang-haskell-ocaml-go-idris-the-jvm-software-and-5628fe591295&quot;&gt;Check it out!&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;strong&gt;Your reply to the picture that is below was:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;The typical applications I write in Erlang have 3–4 functions above it in the call stack&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Modern comfortable programming language #java:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-Ee-kDajNT561ZgOd.jpeg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why is it so? Why this is not the case in most OOP languages?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;It is not really an artifact of OOP-style languages as much as it is an artifact of how we develop software. In biology, it has been observed solutions are usually not rewriting code, but rather patching code. Imagine a world where we are more inclined to build on top of what we already have rather than go down and rewrite older parts. I think each new generation of programmers tend to add a layer on top of what we already have, mostly to put their mark on programming and to simplify and abstract the parts of the lower levels which are in common use while also hiding the rare parts. What you get is the deep call stack. Another similar view would be in geology where you can see older layers and go back in time to older periods. Much of the Java stack has this in it.&lt;&#x2F;p&gt;
&lt;p&gt;Erlang is no different, but from the outset, small-community languages are less susceptible to patching. Especially if it is easy to rewrite code, which means an itch can be scratched by writing something new, rather than building on top of what others did. What brings the call stack down to 3–4 frames, however, are processes. In an Erlang-system a typical web request is served by cooperation of 3–4 processes, each of those having a call stack. Add them all together, and you approach the above size, but in isolation, they are small. An eventual error will result in a crash report with 3 things in it: the backtrace, the state &lt;em&gt;before&lt;&#x2F;em&gt; the process crashed and the incoming message which made it crash. The reason we have the original state is because of functional programming: every data structure is persistent, so we can version it. Usually this is enough to quickly isolate and figure out where the error is and what went wrong.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;You tweeted:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Lets talk agile: The ultimate agile language is one in which you can deliver working code quickly, which is also maintainable. Hence there are only a few agile languages in existence: Haskell, Ocaml and Erlang are 3. Go, Javascript, Python and the rest lacks the necessary abstractions to be regarded as agile. You end up having to recode. However, the &lt;strong&gt;real&lt;&#x2F;strong&gt; solution is to stop doing agile. The idea is bullshit in the first place.”&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Why Haskell, OCaml and Erlang are the only agile languages?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;If the waterfall model risks not building the right product, then agile risks not building the product right. I’m very fond of Erlang creator Mike Williams point: “If you don’t make experiments before starting a project, then your whole project will be an experiment”. My hunch is what a lot of Agile process misses is that you need to experiment before you build.&lt;&#x2F;p&gt;
&lt;p&gt;If we instead ask about prototyping, then we need a programming language with certain traits. The team is usually small, so we need an expressive language, and we need to address the core kernel of the system in isolation, first. We don’t need a lot of interfacing to foreign systems and in general we won’t care too much if the system we build is fast. Also, we usually won’t need to operate the prototype in production, since it is simply a proof of concept.&lt;&#x2F;p&gt;
&lt;p&gt;From a perspective of rapid prototyping and proof-of-concept development, functional languages tend to have an edge over imperative ones. Their higher level and expressivity allows more to be said succinctly, in fewer lines of code. They also tend to describe data structures and algorithms in ways that are clearer, which helps understanding of the problem space.&lt;&#x2F;p&gt;
&lt;p&gt;In turn, since agile values the minimum viable product, moving fast and making experiments, then you need languages in which it is easy to experiment with the unknown ideas many agile projects face. In languages such as Haskell, Erlang and OCaml you can often iterate over far more designs in a limited time window. Thus you can carry out more experiments and this often leads to a better product, even if the final product is not even written in a functional language. In general I feel we value experimentation too little. Build it, throw it away, and rewrite with the new knowledge.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What do you think about Clojure?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Sadly, my experience with Clojure is limited to carrying out a set of Koans in the language, and I have not ever used it for anything serious work. I must admit I don’t find the language especially compelling, and in general I don’t find Lisp-dialects interesting. My language roots are closer to Standard ML, which may be the reason it did not catch my interest when I finally tried toying with Scheme and Common Lisp.&lt;&#x2F;p&gt;
&lt;p&gt;That said, people are doing lots of outright &lt;em&gt;amazing&lt;&#x2F;em&gt; stuff in Clojure. I think the Datomic project is genuinely interesting as a database system. And the work Kyle Kingsbury has done with his “Jepsen” framework and his “Knossos” linearizability checker in Clojure is solid work. I’m also following David Nolen’s work with interest. But I’m pretty sure the language isn’t “for me”.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;You tweeted:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Functional programming semantics are far more important than static typing for removing errors from programs.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Why? Could you elaborate?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I’ve somewhat alluded to this before, but never in more than 140 characters. In an imperative program a function depends on two things: the parameters it is passed and also the current state of the machine store. In a functional language, only the former matters. The consequence of this choice if far reaching:&lt;&#x2F;p&gt;
&lt;p&gt;One, the state space we have to reason about as human beings is far smaller for FP, which makes it harder to make a programming mistake. Two, we can test functions in isolation and be rather confident we have covered the functions execution well. Three, data processing is inductive in nature, recursing over the &lt;em&gt;structure&lt;&#x2F;em&gt; of data rather than manipulating the store from afar. The programming is closer to a proof by induction, which force the programmer to handle corner cases rigorously.&lt;&#x2F;p&gt;
&lt;p&gt;The ease of reasoning also comes into play once you have found a bug. It is often easier to figure out what the program is doing wrong just by taking a close look. It is rare you need to attach a debugger, which you can’t in a concurrent and&#x2F;or distributed system where some parts are outside of your direct control.&lt;&#x2F;p&gt;
&lt;p&gt;When you add typing to the above, you obtain another dimension where your system is (automatically) checked for additional rigor. But I often find people forget how much power there is to be had just by functional programming on its own, with no regard to types. From my own experience, functional programs tend to have an order of magnitude fewer errors than imperative counterpart programs, especially when these are subtle corner-case errors, types or not. Naturally, types + functional programming help even more. But had I the choice between imperative programming with types or functional without, I know what I’d pick without hesitation.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is your opinion regarding dependent types like the one Idris has?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I have not studied Idris very much yet, but I did some work in Agda and Coq, which both employs dependent types, albeit the type theory is subtly different between all of them. I’ve deliberately been pushing it ahead of me for a while, like I also have done with Rust. Mostly because I’d like them to settle down and mature a bit more before I start looking into them. I’d probably start looking around 2017 on both. From a research perspective, Idris is extremely important. We need to explore this area more for real world programs as well, and having a language designed for programs rather than proof-assistance is fairly important. Of course, one would like to see a more mature language, but one has to understand how much is being sunk into Idris to make this happen currently.&lt;&#x2F;p&gt;
&lt;p&gt;I’m not yet entirely convinced we necessarily want to add dependent types to mainstream languages in its full form. Perhaps it turns out we’d rather want a simpler type system in some areas in order to extend it along other dimensions. I’m somewhat interested in the Curry-Howard correspondence between distributed programming and epistemic logic for instance. And it is not a priori clear we even understand what it means to marry dependent types to such a beast. We may have to cut the cake differently in order to understand the type-level interactions.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Don’t you think that OCaml and Go compete for the same space? What has been your experience with the two languages and how do you think they compare?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;If you squint your eyes hard enough, OCaml is an imperative language on top of which you added a lambda calculus. Or it is a lambda calculus with primitive operations for imperative execution. Either way, Go and OCaml are very much alike in the core: both are garbage collected, and natively compiled languages. They tend to provide execution speed in the same ballpark: usually they are in the same order of magnitude when it comes to executing programs.&lt;&#x2F;p&gt;
&lt;p&gt;What sets the two languages apart is the underlying ideology of how to design a programming language. Go is a modest cleanup of the C semantics on top of which you add channels, goroutines and interfaces. OCaml is a programming language in the tradition of Milners Meta-Language (ML), drawing inspiration from several sources including Haskell and Standard ML, among others.&lt;&#x2F;p&gt;
&lt;p&gt;Go usually opts for simplicity and separation of features into a small basis. The language is specifically addressing concerns when programming in the large. This yields programs which are highly coherent because the programmer have relatively few abstraction tools at their disposal. In addition, the interface concept in Go is implicit, which means you have less need to alter other parts of the system. In a large setting with 100s of programmers, altering code someone else “owns” is usually measured in days, whereas local alterations takes hours. So the time lost on lower abstraction can be deceiving.&lt;&#x2F;p&gt;
&lt;p&gt;The simple coherent design of Go also fosters fast compilation with little to no abstraction overhead. It doesn’t matter what abstractions you use, your program will usually compile fast and it will be pretty obvious what the performance behavior of the program is. Fast compilation speed matters in large settings because waiting on the compiler is often wasted time[*]&lt;&#x2F;p&gt;
&lt;p&gt;Russ Cox noted that some abstractions, generics for instance, makes a trade-off between putting the onus on the programmer, the compiler or the execution speed. Leave out generics and the programmer has to work around it. Add generics, and the compiler has to do more work in the compilation phase. Or abstract away generics by a boxing construction, which affects execution speed. Go opts for the first of these.&lt;&#x2F;p&gt;
&lt;p&gt;OCaml contrasts heavily. From an abstraction perspective, it leaves Go in the dust, and supports so much more efficient use of the programmers time. The compiler is also relatively fast and it handles the added abstraction well, though at the current time there is an overhead to the abstraction use. In the notion of Cox, the current version of OCaml (4.02) sacrifices execution speed in some cases. The new FLambda IR in OCaml 4.03, shifts this onus around and puts more into the compiler[0].&lt;&#x2F;p&gt;
&lt;p&gt;Another important dividing factor is the current lack of a proper Multicore support in OCaml, which also means the lack of a proper concurrency runtime built-in by default. In OCaml, you have to rely on a system such as LWT or Async to achieve the same as goroutines do in Go. And the fact there is two, means everyone has to support both for their libraries. The situation is far from perfect.&lt;&#x2F;p&gt;
&lt;p&gt;I usually grab OCaml for problems which have certain traits. Symbolic manipulation is one thing at which OCaml excels because it has proper algebraic datatypes. Thus, I would never write a compiler or proof assistant in something else. Programs generating programs is another area in which OCaml excels. Finally, problems which have embarrassingly parallel structure can easily be handled by just spawning more OS processes in OCaml, and the cogen of OCaml is quite efficient.&lt;&#x2F;p&gt;
&lt;p&gt;I usually write Go for simple brute-force programs where the interactions are not very complex and there is a simple channel network inside the program. I avoid it for anything with complex interactions, because the simplicity of the language often gets in the way. But some problems have the virtue of being simple by construction, which makes Go a really good language.&lt;&#x2F;p&gt;
&lt;p&gt;Personally, I prefer the OCaml ideology. Add abstractions to the language, build a powerful module system, with functors, in which you can program in the large by β-reducing modules into one another. And use the compiler and computer as a sacrifice to pay for this additional abstraction. Those programs are easier to maintain, and easier to recombine.&lt;&#x2F;p&gt;
&lt;p&gt;Go and OCaml are best used for the programs where there is a part of the program which is heavily CPU-bound and you are not memory bound. The vast majority of the programs I write have little to no need to run on a tight CPU-schedule and there I usually just write them in Erlang. If you are bound by memory, you often end up in situations where the gain of dropping to OCaml or Go is small. And if you are bound by outside interaction, disk or network, there is almost no gain.&lt;&#x2F;p&gt;
&lt;p&gt;[*] Fast compilation and linking speed are two major reasons I like Erlang too.&lt;&#x2F;p&gt;
&lt;p&gt;[0] A worthwhile aside: The MLton Standard ML compiler takes this to an extreme by compiling &lt;em&gt;all&lt;&#x2F;em&gt; of the program in one fell swoop. Thus, it is able to perform whole-program analysis and optimization with perfect knowledge of the program. This makes a lot of the abstractions free, but the price is long compilation times.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;In a great post where you explained the drawbacks of JSON and REST HTTP APIS you also wrote:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;“We need to go back to our roots and start building protocols again. This change will never come from a large company. It has to rely on an open tinkerer culture. We need well-defined protocols and multiple implementations of these. Protocol design is quickly becoming a lost art. Rather, people are satiated with “APIs” to the point where they can’t recover.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;We need de-centralization. The internet is built on the idea of end-to-end interaction between machines. The current state is more of a client&#x2F;server infrastructure in which few central entities drive the status quo.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;We need distribution. If we rely on big players, we tie ourselves to their solutions. This will be a bane going forward as we build infrastructure around vendors only interesting in lock-in.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;And finally, we need education. A lot of the current “protocol design” is so bad compared to what can be found in old RFCs. If you want to implement something new, you need to study the past a lot before you build it. If you reject an old idea, you need to explain why. If you reinvent an old idea, you need to know you reinvented it and what happened historically for that idea not to catch on.”&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Could you give us some recommendations of RFC, books, articles to read and exercises to do learn how to design protocols?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Good protocol design is an art form. The goal is produce protocols which are simple to implement, are hard to implement wrong and have future extensibility. Take the TCP protocol for instance. You can implement it in hardware as a simple stop-and-go protocol, ignoring everything about sliding windows. This is a correct and valid implementation of the protocol, though it will be slow. Once that works, you can add layers on top which makes the protocol faster. In addition to the RFCs for TCP, James E. White’s RFCs, 707 and 708, are dear to my heart. They were written in 1976, and they handle a lot of problems we still have to this day: how will distributed machines communicate.&lt;&#x2F;p&gt;
&lt;p&gt;The BitTorrent protocol deserves mention as well. It defines how clients communicate, but it gives relatively few rules about how a client is supposed to implement their behavior. Once you set forth and start implementing the protocol however, you find there is only one true way of doing each part. So that could be left out of the specification. Instead, a minimal viable protocol is given, and the details can be altered as you go along. But also note how the original BT protocol used a Bit-array of 64 bits in the handshake rendezvous in order to negotiate what additional features were supported. This was later replaced with a fully extensible system because it proved to be inadequate. Whenever you see such patches of the protocol design, think about how it could have been avoided in the first place.&lt;&#x2F;p&gt;
&lt;p&gt;Another incredibly well-designed protocol is the 9p protocol from Plan9. And it is generic enough it can be adapted to a lot of other situations as well. It implements many good ideas, like out-of-order messaging, proper multiplexing of messages on one channel, requests initiated from both ends of the connection, and so on.&lt;&#x2F;p&gt;
&lt;p&gt;The general advice is to cut out any part which nominates how the peer should behave itself internally. You need to maximize the freedom of the implementer and only establish the basis for communication. Cut cut cut. Leave out everything which will not destroy the coherency and internal consistency of the protocol. Layer the protocol and push things into separate layers. A layered protocol is much easier to reason about formally, and you better be doing so though either Model Checking or quickchecking the protocol internals.&lt;&#x2F;p&gt;
&lt;p&gt;One should read the critiques of HTTP&#x2F;2.0 and how we got there from HTTP&#x2F;1.1. The protocol suffers from some rushed work, sadly. Read some of the simpler alternative approaches. As an example the PUSH message from Server to Client in HTTP&#x2F;2.0 grows out of White’s observation in RFC707: both peers in a protocol needs to be able to initiate communication. But HTTP is skewed, like most RPC, since all communication is initiated from the client toward the server.&lt;&#x2F;p&gt;
&lt;p&gt;A good approach is that of Roy T. Fielding — define what constraints you need, and then squeeze hard until the minimal protocol comes out. That is, start by defining a large framing of what you need your protocol to do and then create a protocol with those properties. TCP is defined by its constraints of being a stream protocol, connection oriented and without data loss. ZeroMQ is a message channel, connection oriented, without data loss. UDP are message oriented, datagram oriented, with loss. SCTP is …, and so on.&lt;&#x2F;p&gt;
&lt;p&gt;Protocols are far better than APIs because they invite multiple competing implementations of the same thing. They debug themselves over time by virtue of non-interaction between peers. And they open up the design space, rather than closing it down. In a distributed world, we should not be slaves to API designs by large mega-corporations, but be masters of the protocols.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Efene: an Erlang VM language that embraces the Zen of Python</title>
          <pubDate>Fri, 27 Nov 2015 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/efene-an-erlang-vm-language-that-embraces-the-python-zen/</link>
          <guid>https://blog.lambdaclass.com/posts/efene-an-erlang-vm-language-that-embraces-the-python-zen/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/efene-an-erlang-vm-language-that-embraces-the-python-zen/">&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-Y6aaUiw3qoh372nY7WNzJg.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In this ocasion we interviewed &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;marianoguerra&quot;&gt;Mariano Guerra&lt;&#x2F;a&gt;, creator of Efene. &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;efene.org&#x2F;&quot;&gt;Efene&lt;&#x2F;a&gt; is &lt;em&gt;“an alternative syntax for the Erlang Programming Language focusing on simplicity, consistency, ease of use and programmer UX”.&lt;&#x2F;em&gt; After reading the interview with Mariano Guerra, check &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;efene.org&#x2F;quick-efene-introduction-busy-programmer.html&quot;&gt;Efene Quick Introduction for the Busy&#x2F;Lazy Programmer&lt;&#x2F;a&gt; for learning more about Efene.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why did you create efene?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I learn by doing, and a while ago I wanted to learn Erlang, it was the first functional programming language I wanted to learn coming from C, C++, ASM, Java and Python so I was looking for some toy project to learn it.&lt;&#x2F;p&gt;
&lt;p&gt;For a while I couldn’t find a project that was interesting to me and also matched the strengths of Erlang at some point I decided that I would do a small calculator in Erlang, you can see the first commit &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;marianoguerra&#x2F;match&#x2F;commit&#x2F;cc048638b4cc99719ad5c28cea2f9e8163b9661c&quot;&gt;here&lt;&#x2F;a&gt; and the full project &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;marianoguerra&#x2F;match&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;At first I was doing all the eval stuff myself but pretty quickly I added support to compile the expression to an Erlang &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;marianoguerra&#x2F;match&#x2F;commit&#x2F;6c726f641e5d651f6bb46b2ae04202e557ea022b&quot;&gt;module with a function&lt;&#x2F;a&gt;. The next commit added function support and then I realized there was a programming language there, you can read the rest of the commits to see how it morphed into one.&lt;&#x2F;p&gt;
&lt;p&gt;At that point the only other beam language other than Erlang was &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;reia-lang.org&#x2F;&quot;&gt;Reia&lt;&#x2F;a&gt;. I wasn’t planning anything in particular with my powerful calculator&#x2F;language hybrid, but at some point people from Erlang Factory asked me if I wanted to give a talk about my language and of course I said yes, then I got a dose of impostor syndrome, so I started the project from scratch to do a proper programming language and I decided to support every feature that Erlang supports and not much more. At that point the project changed from a toy to an actual programming language.&lt;&#x2F;p&gt;
&lt;p&gt;After &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.erlang-factory.com&#x2F;conference&#x2F;London2010&#x2F;speakers&#x2F;MarianoGuerra&quot;&gt;my talk&lt;&#x2F;a&gt; and some initial excitement things got quiet. I just had got my Engineers degree and had a new job so development stopped for a while, then Elixir appeared and got much more attention, so I thought “OK, someone got it right, I will just stop pushing efene” and some years passed. But then looking into Elixir I saw that the Elixir ideas weren’t exactly the ideas of efene and I decided to rewrite it to try to fill the niche of “just a different syntax for Erlang, reuse as much as possible from the Erlang ecosystem, unified tooling and documentation as the core of the project”. The language has been complete for a while now. I’m just working on documentation, rebar3 plugins andwaiting for some of the surrounding tools to mature to avoid having to redo the documentation (mainly &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rebar&#x2F;rebar3&quot;&gt;rebar3&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=YGuAXS0Cy_8&quot;&gt;cowboy 2&lt;&#x2F;a&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why do you embrace the&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.python.org&#x2F;dev&#x2F;peps&#x2F;pep-0020&#x2F;&quot;&gt;&lt;strong&gt;Zen of Python&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-6_ijRzr0oB6Zckr8GTrq4A.png&quot; alt=&quot;&quot; &#x2F;&gt; Zen of Python&lt;&#x2F;p&gt;
&lt;p&gt;Python was the first language I enjoyed coding in before I coded in C, C++, ASM and Java, but just because it was what I knew or they provided something I needed. With Python it was the first time I said “I’m a Python programmer” and not “I’m a programmer”, also the Python Argentina community helped a lot witht hat.&lt;&#x2F;p&gt;
&lt;p&gt;Python has this attitude of simplicity and community that I like and instead of coming up with an “ad hoc, informally-specified, bug-ridden, slow implementation of half of the python zen” I decided just to copy it.&lt;&#x2F;p&gt;
&lt;p&gt;David Nolen summarized it well the other day:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;swannodette&#x2F;status&#x2F;667694050426945536&quot;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;That’s why efene is a mixture of what I like about the languages, communities and philosophies of Python, Javascript and Erlang, don’t expect a lot of novelty in efene, just a remix of what’s there :).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Could you show to us a short and good example of an efene program?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I can’t think of a particularly short snippet of code that will show you all the interesting bits of efene, mainly because there are no clever parts to efene, the idea is to be regular, simple, explicit and readable.&lt;&#x2F;p&gt;
&lt;p&gt;This means it doesn’t try to win a codegolf competition, or some clever language trick.&lt;&#x2F;p&gt;
&lt;p&gt;But I think you can take a look at this project which is a client for an API that supports REST, Web Sockets, Server Sent Events and COMET and then starts some clients that send some pseudo-random stuff to test the server:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;marianoguerra&#x2F;ioriofn&#x2F;&quot;&gt;marianoguerra&#x2F;ioriofnioriofn - ioriodb client and tests in efenegithub.com&lt;img src=&quot;https:&#x2F;&#x2F;cdn-images-1.medium.com&#x2F;fit&#x2F;c&#x2F;160&#x2F;160&#x2F;0*zv67McG0GOVsOXyh.&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;If your reaction is “I understand this and this is boring”, then I would be happy :), of course knowing some Erlang will help the understanding since efene semantics and patterns are the same as Erlang’s.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Which are the biggest advantages of coding in a language that runs on top of the Erlang VM (BEAM)?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The semantics of the VM are really thought out and really simple to learn.&lt;&#x2F;p&gt;
&lt;p&gt;The stability and scalability of the platform is great and there’s a lot of people that have worked on really hard problems for a long time on top of the Erlang VM, this means you can get really good advice and help from them.&lt;&#x2F;p&gt;
&lt;p&gt;One thing I really like and I don’t think is mentioned that much is the level of runtime introspection and visibility the VM has, and the tooling that is build and can be built around it is great.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What difficulties did you find in implementing efene?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Learning the limits of the parser and what syntax is valid an unambiguous, learning to avoid introducing crazy ideas into the language because syntax and semantics are always tricky and you don’t want to have a “WAT” language.&lt;&#x2F;p&gt;
&lt;p&gt;Also learning about Erlang and its VM while doing it.&lt;&#x2F;p&gt;
&lt;p&gt;But to sum it up, it ended up not being as difficult as I thought it will be, it just requires persistence and some hammock-driven development ;)&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Do you have any recommendation for those of us that did not implemented any language yet?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Learn about lexing and parsing, then build a calculator using S-Expressions (Lisp-like) or reverse-polish syntax (Forth-like).&lt;&#x2F;p&gt;
&lt;p&gt;Start it as an interpreter, copy the semantics from a simple language you already know, coming up with good semantics is hard, don’t try to invent them the first time.&lt;&#x2F;p&gt;
&lt;p&gt;Then ride on top of a language you know, either transpile to that language or compile to bytecode or some intermediate representation.&lt;&#x2F;p&gt;
&lt;p&gt;Try to reuse as much of the tooling from the other language as possible (&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.erlang.org&#x2F;doc&#x2F;apps&#x2F;erts&#x2F;absform.html&quot;&gt;AST from Erlang&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;ast.html&quot;&gt;AST from Python&lt;&#x2F;a&gt; or similar), this will allow you to reuse all the tooling and code built around those representations.&lt;&#x2F;p&gt;
&lt;p&gt;Read about Lisps and Forth. Implement a simple Lisp (Scheme) or Forth.&lt;&#x2F;p&gt;
&lt;p&gt;Once you learn to lex and parse you can think syntax for languages and try to parse them.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is the match expression and why did you introduce it?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;At the core of efene rewrite was the concept of “Everything revolves around 4 main things, pattern matching, functions, guards and data”, pattern matching is done when using the equal sign (=), on the argument list of a function definition and on other Erlang expressions. I wanted to unify the pattern matching under a single syntax and reuse it everywhere, that’s where the “case clauses” came to be.&lt;&#x2F;p&gt;
&lt;p&gt;If you haven’t look at efene yet, the shape of efene expressions is something like:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;&amp;lt;keyword&amp;gt; [&amp;lt;expr-args&amp;gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &amp;lt;case-clauses&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    [else: &amp;lt;body&amp;gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;end&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A case-clause has this shape:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;case &amp;lt;case-args&amp;gt; [when &amp;lt;guards&amp;gt;]: &amp;lt;body&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For example try&#x2F;catch:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;try&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &amp;lt;body&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;catch&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &amp;lt;case-clauses&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    [else: &amp;lt;body&amp;gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;[after &amp;lt;body&amp;gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;end&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Receive:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;receive&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &amp;lt;case-clauses&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    [else: &amp;lt;body&amp;gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;[after &amp;lt;after-expr&amp;gt;: &amp;lt;body&amp;gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;end&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Functions:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;fn [&amp;lt;name&amp;gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &amp;lt;case-clauses&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    [else: &amp;lt;body&amp;gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;end&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You should see a pattern there, since the case keyword was already taken and it’s what Erlang use for what “match” does in efene I had to look for a new keyword.&lt;&#x2F;p&gt;
&lt;p&gt;One thing I like about python is this concept of “executable pseudocode”, I like the fact that if you read Python code aloud it sounds like what it does, so I thought “what am I doing here”, “I’m matching and expression against cases”, in imperative it would be “match A [against] case B, case C, else … end” and that’s how I ended up with match.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why did you introduce a &lt;em&gt;for&lt;&#x2F;em&gt; expression?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The initial idea for efene was to be familiar for people coming from “algol-like” or “mainstream” languages, so they can focus on learning what’s interesting about Erlang which are the semantics and the abstractions and avoid learning a new syntax on the way to epiphany.&lt;&#x2F;p&gt;
&lt;p&gt;Since list comprehensions aren’t available in many of those languages but “for” is, I decided to implement list comprehensions as a more familiar construct but in fact it does the same.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is the arrow operator and why did you add it?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;First a quick introduction for people unfamiliar with efene or the arrow operator.&lt;&#x2F;p&gt;
&lt;p&gt;There’s this thing in Erlang where if you want to apply a sequence of operations to a list you have to create a new binding for each intermediate result:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;MyList = create_list(),&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;MyList1 = op1(MyList),&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;MyList2 = op2(MyList1),&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;MyList3 = op3(MyList2),&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;MyList4 = op4(MyList3).&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Then if you want to reorder or remove some of the operations you have to rearrange the names to fit.&lt;&#x2F;p&gt;
&lt;p&gt;The idea of the arrow operator is to help with that, it’s a compile operation, this means that if you write:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;MyList = create_list() -&amp;gt; op1() -&amp;gt; op2() -&amp;gt; op3() -&amp;gt; op4()&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It will compile to:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;MyList = op4(op3(op2(op1(create_list))))&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The thing is that the Erlang libraries don’t have a standard position for the thing you are operating on like in other languages where it tends to be the first argument, inspired by Clojure (&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;clojuredocs.org&#x2F;clojure.core&#x2F;-%3E&quot;&gt;http:&#x2F;&#x2F;clojuredocs.org&#x2F;clojure.core&#x2F;-%3E&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;clojuredocs.org&#x2F;clojure.core&#x2F;-%3E%3E&quot;&gt;http:&#x2F;&#x2F;clojuredocs.org&#x2F;clojure.core&#x2F;-%3E%3E&lt;&#x2F;a&gt;)&lt;br &#x2F;&gt;
I created two variants:&lt;&#x2F;p&gt;
&lt;p&gt;_“- &amp;gt;” _adds the result of evaluating the expression on the left as first argument on the function call on the right&lt;&#x2F;p&gt;
&lt;p&gt;_“- &amp;gt;&amp;gt;” _adds the result of evaluating the expression on the left as last argument on the function call on the right&lt;&#x2F;p&gt;
&lt;p&gt;But thinking about symmetry and other common idiom in Erlang and other functional languages which is higher order functions (passing functions as arguments to other functions) I decided to create the reverse of those but with a more restricted use.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;“ &amp;lt;-”&lt;&#x2F;em&gt; adds the case clauses on the right as an anonymous function as last argument on the function call on the left.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;“ &amp;lt;&amp;lt;-”&lt;&#x2F;em&gt; adds the case clauses on the right as an anonymous function as first argument on the function call on the left.&lt;&#x2F;p&gt;
&lt;p&gt;You can see it says “case clauses” and not “anonymous function”, this is because you don’t have to write the &lt;em&gt;fn&lt;&#x2F;em&gt; keyword, it gives this expression a DSL taste that I like, for example:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;lists.map(Things) &amp;lt;&amp;lt;-&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; case 0: zero&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; case A when A % 2 is 0: even&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt; else odd&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;end&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Going back to the restricted uses of the right-to-left arrows it’s because since code reads from left to right, putting something on the right that is just a value doesn’t help readability hence I decided not to support it.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;I just saw that you are creating a new language for the BEAM called interfix. What is it?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;As I said above, efene is a language that doesn’t try to come up with anythingnew. This led me to avoid doing experiments on efene itself, but I still wanted to do those experiments somewhere else.&lt;&#x2F;p&gt;
&lt;p&gt;With time the number of ideas for crazy languages I had grew and condensed to a point I thought I had a nice little language. Then coming back from a conference I had a lot of dead time on airports and no internet so I decided to give it a try.&lt;&#x2F;p&gt;
&lt;p&gt;After I landed, the language was growing and all the ideas I had didn’t seem to have any problems so I kept growing it quite fast and for the last days it’s almost a complete language (in the sense that it can do everything Erlang can do).&lt;&#x2F;p&gt;
&lt;p&gt;At this point I’m finishing adding the remaining features and when everything is there and I know everything fits I will move to cleaning the code and adding some tooling and docs around it for people that want to play with a more “experimental” language.&lt;&#x2F;p&gt;
&lt;p&gt;I say experimental in the sense that it has some crazy ideas in it but not experimental in that it will crash, break backward compatibility or compile the code to wrong bytecode.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;You wrote the&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;marianoguerra.github.io&#x2F;little-riak-core-book&#x2F;&quot;&gt;&lt;strong&gt;Little Riak Core Book&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;and you gave a talk called F&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=eiVqDnA0k0U&quot;&gt;&lt;strong&gt;rom 0 to a working distributed system with riak_core&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;. Could you explain what riak core is and why it can be useful for those of us who implement distributed systems?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Riak Core is the foundation of Riak KV and other Basho projects, it’s the generic and reusable part of a “dynamo style” distributed system, it provides some abstractions and utilities to build multi-node, master-less distributed systems.&lt;&#x2F;p&gt;
&lt;p&gt;In a Riak Core based application you build your system by implemented interfaces to handle the work your application does inside virtual nodes (vnodes) that live inside a ring of vnodes, the work is done by routing commands consistently to those vnodes by hashing a key that you specify.&lt;&#x2F;p&gt;
&lt;p&gt;It also provides ways to run a command in more than one vnode and compare the results, grow or shrink the cluster without downtime, migrate vnodes between physical nodes, authentication&#x2F;authorization and a metadata system to hold information about the cluster and your application in a distributed manner.&lt;&#x2F;p&gt;
&lt;p&gt;This frees you from having to implement all this building blocks so you can focus on what actually makes your application different and building upon a tested and production ready foundation.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;While reading your blog I could see that you have used Scala and Clojure apart from Erlang. What has been your experience with Scala and Clojure? What advantages and disadvantages did you find when comparing Scala, Clojure and Erlang?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The experience with the 3 programming languages has been really good, I’ve built similar systems with those programming languages (a kind of pub&#x2F;sub system with persistence), the reason I moved this backend initially from Scala (lift+akka) to Clojure (immutant) was because the system handled lot of semi-structured data both from the frontend and the backend and I was using a lot of time putting that data into “rigid” types to serialize it to json again&lt;&#x2F;p&gt;
&lt;p&gt;after some operations, and each time the shape of the data evolved on the frontend or the storage I had to go and change those types in a backward compatible manner and it was getting really tiring since the backend was really simple in what it actually did.&lt;&#x2F;p&gt;
&lt;p&gt;So I decided to move to Clojure and it resulted in a huge reduction on code but after the code evolved I saw myself implementing this pub&#x2F;sub like system by hand with low level tools like agents, atoms and promises copying the Erlang “patterns”, at this point some customers were asking about scalability and clustering, so I decided to do a prototype using riak_core and after some coding we tried at a new project and since we could improve it fast and it was working quite nice we decided to adopt it as our default backend.&lt;&#x2F;p&gt;
&lt;p&gt;I’m still using scala for Spark jobs, I use clojure for internal tools and internal frontends with clojurescript but the backend now is Erlang.&lt;&#x2F;p&gt;
&lt;p&gt;I just want to clarify that our backend is quite simple in what it does so moving between languages in the backend is not a big deal, the bulk of what we do is in our frontend code.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Interview with Brian McKenna about Roy, Purescript, Haskell, Idris and dependent types</title>
          <pubDate>Wed, 26 Aug 2015 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://blog.lambdaclass.com/posts/interview-with-brian-mckenna-about-roy-purescript-haskell-idris-and-dependent-types/</link>
          <guid>https://blog.lambdaclass.com/posts/interview-with-brian-mckenna-about-roy-purescript-haskell-idris-and-dependent-types/</guid>
          <description xml:base="https://blog.lambdaclass.com/posts/interview-with-brian-mckenna-about-roy-purescript-haskell-idris-and-dependent-types/">&lt;p&gt;As promised in our &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;this-is-not-a-monad-tutorial&#x2F;eric-merritt-erlang-and-distributed-systems-expert-gives-his-views-on-beam-languages-hindley-a09b15f53a2f&quot;&gt;last interview&lt;&#x2F;a&gt; for &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;this-is-not-a-monad-tutorial&quot;&gt;This is not a Monad tutorial&lt;&#x2F;a&gt; we interviewed &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;puffnfresh&quot;&gt;Brian McKenna&lt;&#x2F;a&gt;, creator of the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;roy.brianmckenna.org&#x2F;&quot;&gt;Roy&lt;&#x2F;a&gt; programming language. In this interview Brian talks about Roy, its implementation, how it compares with Purescript, and also about dependent types and other interesting technologies like Morte and Unison. I highly recommend that you check &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;brianmckenna.org&#x2F;blog&#x2F;&quot;&gt;Brian’s blog&lt;&#x2F;a&gt; after you finish reading this interview.&lt;&#x2F;p&gt;
&lt;p&gt;In the following weeks we will be talking with the creators of &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.red-lang.org&#x2F;&quot;&gt;Red programming language&lt;&#x2F;a&gt;, Robert Virding — Erlang co-inventor and &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;lfe.io&#x2F;&quot;&gt;Lisp Flavored Erlang&lt;&#x2F;a&gt; creator — and with &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;mirage.io&#x2F;&quot;&gt;MirageOS unikernel&lt;&#x2F;a&gt; dev team.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-vYf7TCGE19Gni5ssKXQaHA.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What are Roy’s main features?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Roy featured things common to languages which are well suited to typed&lt;br &#x2F;&gt;
functional programming:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Types and type inference (with row polymorphism)&lt;&#x2F;li&gt;
&lt;li&gt;Algebraic data types and pattern matching&lt;&#x2F;li&gt;
&lt;li&gt;Monadic syntax&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Why did you create it?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I created Roy after doing years of JavaScript work. I learned Haskell&lt;br &#x2F;&gt;
and it made a huge amount of sense to me. Functional programming with&lt;br &#x2F;&gt;
types seemed like the ideal way for me to work on software and so I&lt;br &#x2F;&gt;
wanted to bring it to web programming.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;I am tempted to say that Roy has some big similarities with&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.purescript.org&#x2F;&quot;&gt;&lt;strong&gt;Purescript&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;. What are the main differences between the two languages?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Roy was first!&lt;&#x2F;p&gt;
&lt;p&gt;PureScript had almost the exact same goals as Roy but had a much&lt;br &#x2F;&gt;
better implementation. Quoting the PureScript wiki:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Roy is probably the most similar language on the list, and was a&lt;br &#x2F;&gt;
large influence on the development of PureScript.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;I stopped working on Roy once PureScript got around equal in&lt;br &#x2F;&gt;
functionality. PureScript’s implementation means it’s a lot easier to&lt;br &#x2F;&gt;
work on and has much fewer bugs.&lt;&#x2F;p&gt;
&lt;p&gt;Originally the PureScript FFI started off being very different (i.e.&lt;br &#x2F;&gt;
it used inline JS instead of an externs file) but recently changed to&lt;br &#x2F;&gt;
being similar to the original design Roy had. That was probably the&lt;br &#x2F;&gt;
biggest difference the projects had.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;You implemented the lexer and the parser. Did you do so to learn&#x2F;play or because you thought that the available tools were not good enough?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I implemented a whitespace sensitive lexer which was passed into the&lt;br &#x2F;&gt;
Jison parser generator. It was the same approach which CoffeeScript&lt;br &#x2F;&gt;
took.&lt;&#x2F;p&gt;
&lt;p&gt;A custom lexer was necessary because the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;this-is-not-a-monad-tutorial&#x2F;interview-with-brian-mckenna-about-roy-purescript-haskell-idris-and-dependent-types-63bb1289ea3d&quot;&gt;Jison&lt;&#x2F;a&gt; lexer generator was not&lt;br &#x2F;&gt;
capable of stateful scanning of whitespace.&lt;&#x2F;p&gt;
&lt;p&gt;I prefer working with parser combinators such as Parsec and Trifecta.&lt;br &#x2F;&gt;
They’re easier to work with and allow you to write reusable&lt;br &#x2F;&gt;
abstractions.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why did you use a whitespace sensitive grammar a la Python&#x2F;Haskell in Roy?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Just to look like Haskell. I hate thinking about syntax — I copy&lt;br &#x2F;&gt;
things as much as I can. I’m also annoyed that we’re still writing&lt;br &#x2F;&gt;
programs using text. They’re trees, not lists of characters!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why is it useful to have monadic sugar in a language that has unrestricted side effects?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Roy was not designed to allow side-effects, but you could do anything&lt;br &#x2F;&gt;
with the FFI and so it was possible.&lt;&#x2F;p&gt;
&lt;p&gt;Scala has (pretty limited) monadic sugar and also unrestricted&lt;br &#x2F;&gt;
side-effects. People use monadic sugar for things as straight-forward&lt;br &#x2F;&gt;
as Option:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;for {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  name &amp;lt;- maybeFirstName&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  user &amp;lt;- lookup(name)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  avatar &amp;lt;- getAvatar(user)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;} yield avatar&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which can be easier to type than:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;maybeFirstName.flatMap { name =&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  lookup(name).flatMap { user =&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    getAvatar(user)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It doesn’t have anything to do with side-effects.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;From what we could read in the Damas-Hindley-Milner type inference algorithm source comments it is based on Robert Smallshire’s Python code. Do you have any recommendation for those who want to implement it?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I recommend reading “Generalizing Hindley-Milner Type Inference&lt;br &#x2F;&gt;
Algorithms” which turns the algorithm into explicit separate&lt;br &#x2F;&gt;
constraint collection and constraint solving problems, which is a bit&lt;br &#x2F;&gt;
easier to work with than plain Algorithm W. It’s then possible to do&lt;br &#x2F;&gt;
tree annotation via the cofree comonad, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;brianmckenna.org&#x2F;blog&#x2F;type_annotation_cofree&quot;&gt;which gives a pretty nice&lt;&#x2F;a&gt;&lt;br &#x2F;&gt;
&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;brianmckenna.org&#x2F;blog&#x2F;type_annotation_cofree&quot;&gt;implementation&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What reading material do you recommend for implementing your first programming language?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Source code of other languages are great resources. I think the&lt;br &#x2F;&gt;
PureScript and Idris compilers are somewhat easy to play around with.&lt;&#x2F;p&gt;
&lt;p&gt;Hackage has a lot of code to look at, such as reference&lt;br &#x2F;&gt;
implementations of Algorithm W:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;hackage.haskell.org&#x2F;packages&#x2F;&quot;&gt;https:&#x2F;&#x2F;hackage.haskell.org&#x2F;packages&#x2F;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What would you recommend us to read to learn about different type systems?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.cis.upenn.edu&#x2F;~bcpierce&#x2F;tapl&#x2F;&quot;&gt;Types and Programming Languages&lt;&#x2F;a&gt; by Benjamin Pierce is a brilliant&lt;br &#x2F;&gt;
resource for understanding both. It’s surprised me by being a very&lt;br &#x2F;&gt;
good introduction to types and having pretty good reference&lt;br &#x2F;&gt;
implementations in OCaml for each of the discussed type-systems. Very&lt;br &#x2F;&gt;
highly recommended.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Have you tried&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;elm-lang.org&#x2F;&quot;&gt;&lt;strong&gt;Elm&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;? What do you think of&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Functional_reactive_programming&quot;&gt;&lt;strong&gt;FRP&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I think Functional Reactive Programming could be generalised a bit to&lt;br &#x2F;&gt;
just general stream combinator libraries and we could make it as&lt;br &#x2F;&gt;
simple as libraries such as pipes, machines and scalaz-stream. I’d&lt;br &#x2F;&gt;
like to implement one of those libraries in PureScript and try to&lt;br &#x2F;&gt;
write combinators to fill in the gaps for developing user interfaces&lt;br &#x2F;&gt;
to see how close we get to current FRP libraries.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;You recently gave a talk about&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.idris-lang.org&#x2F;&quot;&gt;&lt;strong&gt;Idris&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;, a language with&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dependent_type&quot;&gt;&lt;strong&gt;dependent types&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;. Could you explain what are dependent types?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In non-dependently typed languages we have a way of making values&lt;br &#x2F;&gt;
depend upon other values: functions! In dependent typed languages we&lt;br &#x2F;&gt;
have those functions, but also functions which can return types.&lt;&#x2F;p&gt;
&lt;p&gt;Haskell has two completely separate languages: the language of values&lt;br &#x2F;&gt;
and the language of types. Recent versions of GHC give a way of&lt;br &#x2F;&gt;
promoting certain values up to types, but if you want to write a&lt;br &#x2F;&gt;
function over those values, you’ll have to write a version at the&lt;br &#x2F;&gt;
value level and separately at the type level.&lt;&#x2F;p&gt;
&lt;p&gt;Dependent-types remove the separation. If you write a function, you&lt;br &#x2F;&gt;
can reuse it for terms at any level.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What are the practical benefits of using a language with dependent types?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Since you can use values in your types, you can specify a lot more.&lt;br &#x2F;&gt;
For example, I can specify that list reversal is an involution, i.e.&lt;br &#x2F;&gt;
reversing twice is the same as not reversing at all:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #E1E4E8; background-color: #24292E;&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;reverseInvolution : (xs : List a) -&amp;gt; reverse (reverse xs) = r&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;No need for tests — if I implement a value for that type, I have a&lt;br &#x2F;&gt;
proof for all possible values.&lt;&#x2F;p&gt;
&lt;p&gt;Or we can specify that a sort function will generate a list where each&lt;br &#x2F;&gt;
element is smaller than the next. The implementation of sort will only&lt;br &#x2F;&gt;
compile if we prove that to be true.&lt;&#x2F;p&gt;
&lt;p&gt;We can also do things like metaprogramming, since we know more about&lt;br &#x2F;&gt;
the values which are passed in, we can compute fancy types for things&lt;br &#x2F;&gt;
such as literals.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;From what we have read from your blog you have learnt Coq and Agda. What can code monkeys like us learn from programming languages like Coq and Agda?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I know a tiny amount of Coq and Agda. They teach people what types are&lt;br &#x2F;&gt;
capable of and how they can be used to interactively prove programs&lt;br &#x2F;&gt;
correct. It’ll also show the potential of typed metaprogramming, for&lt;br &#x2F;&gt;
example allowing the type of printf to depend upon the input string or&lt;br &#x2F;&gt;
how it’s possible to write your own statically checked literal&lt;br &#x2F;&gt;
strings.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Have you checked&lt;&#x2F;strong&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;goto.ucsd.edu&#x2F;~rjhala&#x2F;liquid&#x2F;haskell&#x2F;blog&#x2F;about&#x2F;&quot;&gt;&lt;strong&gt;LiquidHaskell&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;&lt;strong&gt;? What do you think about and refinement types?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I think refinement types are interesting. It’s very exciting to just&lt;br &#x2F;&gt;
be able to add on annotations to existing programs and let proof&lt;br &#x2F;&gt;
searching do the rest but I’d prefer dependent types to be a research&lt;br &#x2F;&gt;
area for a couple of reasons:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;LiquidHaskell can do some dependent looking things but doesn’t have&lt;br &#x2F;&gt;
full pi-types so can’t do as much as real dependent types&lt;&#x2F;li&gt;
&lt;li&gt;We’re relying on an SMT solver to come up with a reasoning for why&lt;br &#x2F;&gt;
something is true, dependent types allow you to create and manipulate&lt;br &#x2F;&gt;
your own justifications — this might be solvable just via tooling,&lt;br &#x2F;&gt;
though&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;What other languages or technologies are you keeping an eye on that we should check?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Morte&lt;&#x2F;strong&gt; by Gabriel Gonzalez is a brilliant way of talking about&lt;br &#x2F;&gt;
distributable programs. I want to work on Morte to create a database&lt;br &#x2F;&gt;
of super-optimised code, where package management is about functions,&lt;br &#x2F;&gt;
not libraries. Morte has a pretty good introduction &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;morte-1.2.1&#x2F;docs&#x2F;Morte-Tutorial.html&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Paul Chiusano’s &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;unisonweb.org&#x2F;&quot;&gt;&lt;strong&gt;Unison&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; is an attempt at removing the “list of&lt;br &#x2F;&gt;
characters” problem from programming. It’s also trying to create a&lt;br &#x2F;&gt;
better UX for functional programming.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
      </item>
    </channel>
</rss>
