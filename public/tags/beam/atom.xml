<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>LambdaClass Blog - Beam</title>
    <subtitle>Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.</subtitle>
    <link rel="self" type="application/atom+xml" href="https://blog.lambdaclass.com/tags/beam/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2021-07-15T00:00:00+00:00</updated>
    <id>https://blog.lambdaclass.com/tags/beam/atom.xml</id>
    <entry xml:lang="en">
        <title>BEAM all the things! ClojErl, an implementation of Clojure on the Erlang Virtual Machine</title>
        <published>2021-07-15T00:00:00+00:00</published>
        <updated>2021-07-15T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com/posts/clojerl-an-implementation-of-the-clojure-language-that-runs-on-the-beam/"/>
        <id>https://blog.lambdaclass.com/posts/clojerl-an-implementation-of-the-clojure-language-that-runs-on-the-beam/</id>
        
        <content type="html" xml:base="https://blog.lambdaclass.com/posts/clojerl-an-implementation-of-the-clojure-language-that-runs-on-the-beam/">&lt;h4 id=&quot;an-interview-with-its-creator-juan-facorro&quot;&gt;&lt;strong&gt;An interview with its creator, Juan Facorro.&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Our blog has had a long standing interest in novel uses of the BEAM, or Erlang virtual machine, as shown by the many articles we have published on that topic: we talked to Eric Merritt about &lt;a href=&quot;&#x2F;eric-merritt-erlang-and-distributed-systems-expert-gives-his-views-on-beam-languages-hindley&#x2F;&quot;&gt;languages that run on BEAM&lt;&#x2F;a&gt; from a high-level overview, and went deep on &lt;a href=&quot;&#x2F;an-interview-with-the-creator-of-gleam-an-ml-like-language-for-the-erlang-vm-with-a-compiler&#x2F;&quot;&gt;Gleam&lt;&#x2F;a&gt; (an ML-like language for the Erlang VM with a compiler written in Rust), &lt;a href=&quot;&#x2F;d-day-invasion-with-mlfe-ml-landing-in-the-erlang-world&#x2F;&quot;&gt;MLFE&lt;&#x2F;a&gt; (which is short for ML-Flavored Erlang), &lt;a href=&quot;&#x2F;efene-an-erlang-vm-language-that-embraces-the-python-zen&#x2F;&quot;&gt;Efene&lt;&#x2F;a&gt; (an alternative syntax for Erlang), &lt;a href=&quot;&#x2F;gaming-with-elixir-discovering-new-lands-in-the-beam-realm&#x2F;&quot;&gt;using Elixir for videogame backends&lt;&#x2F;a&gt;, and &lt;a href=&quot;&#x2F;lasp-a-little-further-down-the-erlang-rabbithole&#x2F;&quot;&gt;Lasp&lt;&#x2F;a&gt; (“a suite of libraries aimed at providing a comprehensive programming system for planetary scale Elixir and Erlang applications”).&lt;&#x2F;p&gt;
&lt;p&gt;We also published a guide to learn &lt;a href=&quot;&#x2F;how-to-earn-your-clojure-white-belt&#x2F;&quot;&gt;Clojure&lt;&#x2F;a&gt; and an &lt;a href=&quot;&#x2F;a-pythonist-finds-a-new-home-at-clojure-land&#x2F;&quot;&gt;interview&lt;&#x2F;a&gt; that might persuade you to get into it if you haven’t already.&lt;&#x2F;p&gt;
&lt;p&gt;So our readers will understand it was inevitable for us to be interested in Juan Facorro’s project, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;clojerl&#x2F;clojerl&quot;&gt;ClojErl&lt;&#x2F;a&gt;. And of course, we interviewed him about it. We hope you enjoy it as much as we did.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h4 id=&quot;tell-us-a-little-about-clojerl-what-is-it-how-did-it-come-about&quot;&gt;&lt;strong&gt;Tell us a little about ClojErl, what is it? How did it come about?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;ClojErl is an implementation of the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;clojure.org&#x2F;&quot;&gt;Clojure&lt;&#x2F;a&gt; language that runs on the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;BEAM_(Erlang_virtual_machine)&quot;&gt;BEAM&lt;&#x2F;a&gt; (the Erlang Virtual Machine).&lt;&#x2F;p&gt;
&lt;p&gt;The project started as a learning and exploratory exercise on language implementation. The idea was born out of the combination of my desire to use Clojure at work, and me starting a new job at &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;inaka.github.io&#x2F;&quot;&gt;Inaka&lt;&#x2F;a&gt; where I learned to use Erlang (and the BEAM) to build systems.&lt;&#x2F;p&gt;
&lt;p&gt;I found that the concurrency model of the BEAM made sense to me, because it provided a framework and some guarantees that made it simple for me to think about concurrency. This has not been the case for me with other concurrency models.&lt;&#x2F;p&gt;
&lt;p&gt;The BEAM was built to solve a practical problem (i.e. high availability communication switches) and solving for concurrency was a big part of the solution, which also included immutable data structures. These two concepts, concurrency and immutability, are also at the core of Clojure’s design principles, so it seemed like a good idea to try to bring this language to the BEAM.&lt;&#x2F;p&gt;
&lt;p&gt;I’m not sure if I thought about it at the time, but the abstractions on which Clojure is built make using the language a pleasure. The example that I always use is the fact that you can use the &lt;strong&gt;count&lt;&#x2F;strong&gt; core function with almost any data structure (it only needs to implement the &lt;strong&gt;ICounted&lt;&#x2F;strong&gt; protocol). Even though it is possible to define a function like this in Erlang, I think the resulting code would not be idiomatic Erlang and it would be hard both to maintain and to extend to new types. This is not the case with Clojure.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-advantages-does-the-actor-model-bring-over-clojure-s-concurrency-model&quot;&gt;&lt;strong&gt;What advantages does the actor model bring over clojure’s concurrency model?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;I don’t think there are absolute advantages of one model over the other.&lt;&#x2F;p&gt;
&lt;p&gt;Because of the way systems are built on the BEAM and the tools it provides (i.e. lightweight processes, monitors and links), it is very suitable for building resilient systems that (when designed right) can recover from failure. This can arguably be done with any language and platform (e.g. Akka on the JVM), but I think it is simpler and easier to do when using the BEAM.&lt;&#x2F;p&gt;
&lt;p&gt;Other things are harder and end up being more complex when using Erlang, but I have wondered if this is something that is more related to the size of the community and the problems it is solving, than the language itself. The amount of Elixir libraries that have been written to do almost anything would suggest that this is very likely the case.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;when-would-clojerl-be-a-better-choice-than-regular-jvm-clojure&quot;&gt;&lt;strong&gt;When would ClojErl be a better choice than regular JVM clojure?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;I would say that whenever you need to build a system that is resilient, degrades gracefully and can recover from failures, and you don’t want to spend time on building the mechanism to achieve this from scratch. Using ClojErl will provide a battle-tested platform where all these things are already included in the VM’s design and how systems are built on it.&lt;&#x2F;p&gt;
&lt;p&gt;This assumes that you don’t need a very purpose-specific library that exists only in Java, or a Clojure library that is a lot of work to port from Clojure(Script) into ClojErl.&lt;&#x2F;p&gt;
&lt;p&gt;It also assumes that there is a library (either in Erlang or maybe other BEAM language) for every one of your needs, which unfortunately is sometimes not the case.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-much-impact-does-losing-java-interop-have-on-the-language-in-everyday-use&quot;&gt;&lt;strong&gt;How much impact does losing Java interop have on the language in everyday use?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;There is no impact as far as I can tell, although I’m biased :).&lt;&#x2F;p&gt;
&lt;p&gt;Anything that would necessitate Java interop is either replaced with Erlang interop or an implementation of the set of protocols through which Clojure interacts with the platform (e.g. &lt;strong&gt;IWriter&lt;&#x2F;strong&gt; and &lt;strong&gt;IReader&lt;&#x2F;strong&gt; for I&#x2F;O).&lt;&#x2F;p&gt;
&lt;h4 id=&quot;there-are-certain-clojure-features-that-are-unsupported-why-is-that&quot;&gt;&lt;strong&gt;There are certain Clojure features that are unsupported. Why is that?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;Clojure JVM is implemented on a platform that allows mutability, which is not the case on the BEAM.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;clojure.org&#x2F;reference&#x2F;transients&quot;&gt;Transient data structures&lt;&#x2F;a&gt; for example, rely on the fact that parts of the underlying representation can be updated in-place. The whole point of their existence is to allow for faster operations without the cost of creating new instances after each modification. This cannot be achieved on the BEAM if we want to use the native immutable data structures.&lt;&#x2F;p&gt;
&lt;p&gt;I have not explored the path of implementing a whole set of data structures through &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;erlang.org&#x2F;doc&#x2F;tutorial&#x2F;nif.html&quot;&gt;NIFs&lt;&#x2F;a&gt; that would maybe make this possible. I’m not convinced this is a good idea though, for a number of reasons. The first one is that it would be a lot of work and we would end up with an implementation that needs to be battle-tested before it can be relied upon. The second is that the cost of calling a NIF is not zero and the result might not even provide significant performance gains. And the third is that it would not be possible to use any of the built-in Erlang functions from the standard library or any of the optimizations for them added to the BEAM.&lt;&#x2F;p&gt;
&lt;p&gt;Another feature that is not implemented for Clojure on the BEAM is &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;clojure.org&#x2F;reference&#x2F;refs&quot;&gt;Refs and Transactions&lt;&#x2F;a&gt;. This feature is heavily dependent on how the JVM works and it is also not something that is very widely used (as far as I know) in the wild.&lt;&#x2F;p&gt;
&lt;p&gt;ClojErl relies only on the numeric types provided by the platform. This means that things such as ratios, big decimals, and flags about unchecked math are not available. The BEAM is not designed to provide good performance around numerical operations, so if that is your use case you are better off using another set of tools for that purpose.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-good-is-the-interoperability-with-erlang-what-about-elixir&quot;&gt;&lt;strong&gt;How good is the interoperability with Erlang? What about Elixir?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;One of the design principles for ClojErl was to make interoperability with the platform as seamless as possible.&lt;&#x2F;p&gt;
&lt;p&gt;A function call to an Erlang function is equivalent to any other Clojure function call: &lt;strong&gt;(module&#x2F;function arg1 arg2 … argN)&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Data structures are not equivalent, Clojure’s are implemented on top of Erlang’s. All Clojure core functions related to data structures (e.g. count, first, map, etc.) work for all of Erlang’s though, since the necessary protocols are implemented for them to work. It is possible to write expressions for literal Erlang data structures by using the &lt;strong&gt;#erl&lt;&#x2F;strong&gt; reader macro before a Clojure literal (e.g. &lt;strong&gt;#erl{:a 1}&lt;&#x2F;strong&gt; would be compiled to a literal Erlang map).&lt;&#x2F;p&gt;
&lt;p&gt;As mentioned before ClojErl currently provides only the numerical data types available on the BEAM: integer (unbound) and float (64 bits).&lt;&#x2F;p&gt;
&lt;p&gt;ClojErl strings are Erlang UTF-8 binaries. It is possible to write literal Erlang strings (i.e. lists of integers) by using the #erl reader macro.&lt;&#x2F;p&gt;
&lt;p&gt;Pattern matching is also available in ClojErl when using any of the special forms where bindings are created (i.e. &lt;strong&gt;fn&lt;&#x2F;strong&gt;* , &lt;strong&gt;let&lt;&#x2F;strong&gt;* , &lt;strong&gt;loop&lt;&#x2F;strong&gt;* and &lt;strong&gt;case&lt;&#x2F;strong&gt;*).&lt;&#x2F;p&gt;
&lt;p&gt;A ClojErl anonymous function can be used as an argument to any of the Erlang BIFs that expect a function, as long as the ClojErl function doesn’t use variadic arity or multiple arities. These two features are specific to Clojure, which means that Erlang code wouldn’t know how to correctly call the function in that case.&lt;&#x2F;p&gt;
&lt;p&gt;The story for Elixir is similar to Erlang’s (or any other language on the BEAM). Any function from an Elixir module can be called from ClojErl. Elixir is a little particular in that all its modules have an implicit “&lt;strong&gt;Elixir.&lt;&#x2F;strong&gt; ” prefix added by the compiler to them. There have been some people recently trying this out with some success (see &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;marcio_lopes&#x2F;status&#x2F;1400256642478903299&quot;&gt;here&lt;&#x2F;a&gt;).&lt;&#x2F;p&gt;
&lt;h4 id=&quot;what-was-is-the-most-challenging-part-of-the-project&quot;&gt;&lt;strong&gt;What was&#x2F;is the most challenging part of the project?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;The most challenging part was and still is finding ways to reconcile what the BEAM offers with the semantics of the Clojure language. Sometimes the conclusion is that we can’t support a feature (e.g. transient collections), other times we need to provide something similar but a little more limited than the original (e.g. vars), and yet other times we add something completely new to the language because we want to have interoperability with platform features (e.g. pattern matching).&lt;&#x2F;p&gt;
&lt;p&gt;Another big challenge has been performance. Some features, when implemented on the JVM, do not translate very well to how the BEAM works (e.g. transducers) which results in a much worse performance (i.e. an order of magnitude slower) than what the JVM offers. The release of OTP 24 saw the inclusion of a JIT compiler, preliminary micro-benchmarking using this release showed a lot of improvement in the run time performance of some expressions. There is still quite a lot of work to be done performance wise (both with time and memory usage) on ClojErl.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;are-there-currently-any-interesting-use-cases-for-clojerl&quot;&gt;&lt;strong&gt;Are there currently any interesting use cases for ClojErl?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;If we talk about production environment use cases, the short answer is no. The project is still in beta and there hasn’t been (that I know of) any company or individual that has used ClojErl in a production environment.&lt;&#x2F;p&gt;
&lt;p&gt;But there are some use cases that I have found interesting and fun.&lt;&#x2F;p&gt;
&lt;p&gt;One of them is &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;clojerl&#x2F;doodler&quot;&gt;doodler&lt;&#x2F;a&gt; which is an implementation of a canvas for creating animations inspired in the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;quil.info&#x2F;?example=fireworks&quot;&gt;quil&lt;&#x2F;a&gt; Clojure(Script) project.&lt;&#x2F;p&gt;
&lt;p&gt;Another one is the application behind &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;try.clojerl.online&#x2F;&quot;&gt;try.clojerl.online&lt;&#x2F;a&gt; which is built in ClojErl. I think I spent more time on the JS client-side console than on the code necessary to have a remote running ClojErl REPL.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;is-the-project-open-for-contributions-if-so-how-should-people-get-started&quot;&gt;&lt;strong&gt;Is the project open for contributions? If so, how should people get started?&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;Yes, absolutely, 100%!&lt;&#x2F;p&gt;
&lt;p&gt;There are open issues to which I haven’t had time to dedicate myself and anyone that is interested in working on them and any other features or improvements, can reach out through the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;clojerl&#x2F;clojerl&quot;&gt;GitHub repository&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;jfacorro&quot;&gt;Twitter&lt;&#x2F;a&gt; ot the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;erlanger.slack.com&#x2F;archives&#x2F;C7KBUEAMC&quot;&gt;#ClojErl Slack channel&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The fastest way to have a working development environment is by using &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;gitpod.io&#x2F;&quot;&gt;gitpod.io&lt;&#x2F;a&gt;, which provides an online IDE for any public project hosted in the major code repositories (e.g. GitHub). Firing up a new environment is as simple as following &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;gitpod.io&#x2F;#github.com&#x2F;clojerl&#x2F;clojerl&quot;&gt;this link&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;How to navigate code is a little bit more complicated because the documentation around this is lacking. There is some documentation in the &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.clojerl.org&#x2F;&quot;&gt;ClojErl.org&lt;&#x2F;a&gt; page and there are also &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;hexdocs.pm&#x2F;clojerl&#x2F;clj_compiler.html&quot;&gt;API docs for the Erlang modules in hex.pm&lt;&#x2F;a&gt;. But they provide a limited view and there are some important things that are not included there, therefore until there is more documentation for developing ClojErl I am available for people to reach out with their questions.&lt;&#x2F;p&gt;
&lt;p&gt;Other areas that need some love are tools for developing. The &lt;strong&gt;rebar3_ClojErl&lt;&#x2F;strong&gt; plugin currently provides pretty good support for compiling, testing, building applications and script; and starting up a REPL. The area that is not so great is the editor support for ClojErl. Syntax highlighting is available and simple to get, but it would be an amazing developer experience if &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;erlang-ls&#x2F;erlang_ls&quot;&gt;&lt;strong&gt;Erlang-ls&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; could also parse ClojErl files and help navigate the code both in Erlang and ClojErl.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;can-i-use-any-library-written-in-erlang-directly-in-clojerl&quot;&gt;Can I use any library written in Erlang directly in ClojErl?&lt;&#x2F;h4&gt;
&lt;p&gt;Yes! ClojErl is “just” an Erlang library, which means you can combine it with any other Erlang library and&#x2F;or application by using &lt;strong&gt;rebar3&lt;&#x2F;strong&gt; and the dedicated &lt;strong&gt;rebar3_ClojErl&lt;&#x2F;strong&gt; plugin.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>LAM: an actor-model VM for WebAssembly and native</title>
        <published>2021-02-26T00:00:00+00:00</published>
        <updated>2021-02-26T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.lambdaclass.com/posts/lam-an-actor-model-vm-for-webassembly-and-native/"/>
        <id>https://blog.lambdaclass.com/posts/lam-an-actor-model-vm-for-webassembly-and-native/</id>
        
        <content type="html" xml:base="https://blog.lambdaclass.com/posts/lam-an-actor-model-vm-for-webassembly-and-native/">&lt;p&gt;An interview with its creator, Leandro Ostera.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;1-ZA5-hKa-yYGz8FX-kmZh9g.png&quot; alt=&quot;&quot; &#x2F;&gt;Source: &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;abstractmachines.dev&#x2F;&quot;&gt;https:&#x2F;&#x2F;abstractmachines.dev&#x2F;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Here, at NAMT, we are in love with the Actor Model.&lt;br &#x2F;&gt;
Within this paradigm, the basic units of computation are called actors. There is no shared state between them, instead, they interact via message passing. This has the advantage that actors become trivial to paralellize (in Erlang, an actor is called a &lt;em&gt;process&lt;&#x2F;em&gt;) and errors became easier to handle.&lt;&#x2F;p&gt;
&lt;p&gt;The actor model is a concurrency paradigm created by Carl Hewitt in 1973 with the goal of making the task of writing concurrent programs simpler. It is based on the idea of actors, entities that can only send, receive and process messages. By reducing the amount of shared state it reduces the need of locks for synchronization. There exists several battle-tested implementations of the Actor Model such as Erlang&#x2F;OTP, Akka (Scala&#x2F;Java) and Orleans (C#).&lt;&#x2F;p&gt;
&lt;p&gt;In this interview, we chat with Leandro Ostera, the founder of Abstract Machines. Ostera is working on LAM, The Little Actor Machine, an embeddable virtual machine for the actor model that runs native or compiles to WebAssembly.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;The questions for this interview were thought by Juan Pablo Amoroso, Javier Chatruc &amp;amp; Federico Carrone. Joaquín Centeno and Juan Bono wrote the introduction and edited the article.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;strong&gt;Tell us a bit about your project lab, Abstract Machines. What kind of work do you do?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I started Abstract Machines with a single goal in mind: build tools that would help me think more clearly.&lt;&#x2F;p&gt;
&lt;p&gt;Right now what I do think about the most is writing software. I think typed languages help me think clearly, so I’m building Caramel, an OCaml for the BEAM. I also think that understanding the program that runs your programs is fundamental to thinking clearly about the quality of what you build, so I’m building LAM, an actor-model VM.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;LAM’s tagline is “A Little Actor Machine that runs on Native and WebAssembly”. Could you give us a brief overview of the actor system?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The original name was Leandro’s Abstract Machine. Like Prolog’s WAM was named after Warren, Warren’s Abstract Machine, and the early Erlang VM was JAM after Joe’s Abstract Machine. But Little I think it’s a much better name overall: LAM should be small, tiny even.&lt;&#x2F;p&gt;
&lt;p&gt;The actor system it implements is in spirit very close to Erlang’s take on the actor model — processes with mailboxes, message passing across them, fair scheduling through reduction counting. There’s a few more things in the roadmap, like process linking and monitoring. Overall, if you have worked with Erlang or Elixir before, you should feel right at home with LAM.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What is the motivation behind LAM? Why build a BEAM alternative?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;LAM’s mission is to make Actor concurrency available everywhere by providing a specified, lightweight runtime. Think LuaVM meets the Actor Model. I’ve always liked the LuaVM, there’s a certain elegance to it that I find very appealing.&lt;&#x2F;p&gt;
&lt;p&gt;One of the reasons to build an alternative is that the BEAM is rather large, and the implementation is the only real spec. [Erik Stenmans’ Beam Book] or [kvavks Beam Wisdoms] have tried to document it, but without an official effort to produce a JVM style spec (like the one you can get in a bookshelf), it’s unlikely we will have a reliable drop-in alternative any time soon.&lt;&#x2F;p&gt;
&lt;p&gt;So I thought I could instead make a new thing that could learn from both the LuaVM and the BEAM. At 35 instructions, LAM can run an interesting amount of Erlang programs, in fact I’d like most code that runs on the BEAM to be bytecode-translatable to run on LAM. Not all of it tho, and we’ll see what doesn’t make the cut.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;One of LAM’s targets is WebAssembly. Is there any alternative actor system for the web? How do they compare with LAM?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Yes, there are plenty! A most promising one these days is Lunatic, but on the Erlang side of things, there’s the up-and-coming Lumen.&lt;&#x2F;p&gt;
&lt;p&gt;Most of the rest are libraries for building actor applications in other languages, like how Actix lets you use Actors in Rust. Lumen in particular is more of a compiler + runtime that brings Erlang down to LLVM and gives you this single optimized executable.&lt;&#x2F;p&gt;
&lt;p&gt;LAM by contrast is a higher level VM: you feed it bytecode (spawn, send, receive, call, make list, etc), and as it runs it, side-effects happen through FFI&#x2F;Bindings depending on the platform.&lt;&#x2F;p&gt;
&lt;p&gt;Around LAM there’s a tiny compilation toolchain that takes that bytecode, lowers it to something that can be run a little faster, and packs it &lt;em&gt;with the VM&lt;&#x2F;em&gt; in a single binary that is optimized for a specific platform.&lt;&#x2F;p&gt;
&lt;p&gt;Because the VM is tiny, and the FFIs are pluggable, it’s straightforward to compile it to WebAssembly and run your bytecode there.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;The documentation mentions that one of the goals is to support Erlang&#x2F;OTP’s supervision tree structure. Would this allow more reliable&#x2F;resilient web UIs, capable of gracefully recovering from errors?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Absolutely! I expect it to let you build even more natural and flexible UIs. After all the “event” model fits perfectly: when process Button receives message Click, do this&#x2F;that.&lt;&#x2F;p&gt;
&lt;p&gt;The main problem is that preemptive scheduling makes it impossible to guarantee certain processes will have enough time to make stuff like animations run smoothly. But I’m borrowing the idea of dirty schedulers and considering introducing Greedy Processes instead, that can either request upfront how much time they need, or just run to completion. Definitely interesting to experiment with hard-real time scheduling as well.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What are some interesting use cases for LAM?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Off the top of my head, there’s 2. The first one is perhaps why I want it the most these days: fast cli tools. Write ’em in Erlang&#x2F;Elixir&#x2F;Caramel, ships as a single binary.&lt;&#x2F;p&gt;
&lt;p&gt;The second one will have the largest impact on how we build for the BEAM: actually writing full-stack applications in a single BEAM Language.&lt;&#x2F;p&gt;
&lt;p&gt;Write your backend in Elixir and run it on the BEAM, write your frontend in Elixir too but run it on LAM. And it doesn’t have to be a web-based app, it could be an actual native GUI application too.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why write it in Rust? Is the Rust-WASM toolchain mature enough to target WASM reliably with LAM?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I love Rust. It’s a good language and the learning curve has certainly taught me a lot about how to build software. I think the Rust-wasm toolchain is pretty mature these days too.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Besides performance (LAM compiles AOT), what will be the advantages of LAM over the BEAM?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Really the AOT stuff I can’t consider an advantage — I don’t expect LAM to be fundamentally faster than the BEAM, especially after the BeamJIT work. Nor do I expect it to compete in speed with Lumen.&lt;&#x2F;p&gt;
&lt;p&gt;What I see as an advantage is that LAM is being built to have a Specification and to be Embeddable.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;WebAssembly lacks a garbage collector and the BEAM is a GC environment. How does LAM tackle this?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;There is a wasm-gc spec in the works, and some other folks are waiting on it as well (like the OCaml-wasm efforts).&lt;&#x2F;p&gt;
&lt;p&gt;But since WebAssembly isn’t the only LAM target, we’ll have to embed a GC anyway. I expect it to work very closely to the BEAMs (per process collections, ref counted binary strings, etc). I haven’t looked so deeply into this, but I have a chunky book waiting for me (The Garbage Collection Handbook).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Is this a solo project or are you looking for contributors? If you are looking for contributors, how should they get started (first issues, roadmap, etc)?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;So far it is just me, but I’d love to build a friendly and welcoming community around it. At the moment I’ve been focused on getting this vertical slice of the project up and running so it becomes easier to do some horizontal scoping: how far along are we with the specification, or how much of the BEAM bytecode can we support via translation.&lt;&#x2F;p&gt;
&lt;p&gt;There’s tons of work to do starting at the design level. From figuring out how to build the right layers to FFIs across platforms (native, wasi, web), to how to optimize the main emulator loop to crunch the bytecode as fast as possible, to GC and bundling the final binaries, to writing the spec and the manual.&lt;&#x2F;p&gt;
&lt;p&gt;Formalizing the spec is a big topic where I hope I can get some interest from the TLA+ community to guide me into doing justice to both TLA+ and LAM.&lt;&#x2F;p&gt;
&lt;p&gt;LAM could use help across the board, so if you’re reading this please tweet at me (&lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;leostera&#x2F;&quot;&gt;@leostera&lt;&#x2F;a&gt;)!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;For our last question, in general, what are your favorite books, articles or resources for programmers?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I think that if you asked me this a year ago I would have regurgitated a bunch of books that I should list here, but that didn’t really further my understanding. There’s a lot of reference material that is just terrible for learning, because its meant to be a compendium of information rather than a pedagogically written introduction to a subject.&lt;&#x2F;p&gt;
&lt;p&gt;For example, Types and Programming Languages by Benjamin Pierce is deemed &lt;em&gt;the ultimate&lt;&#x2F;em&gt; reference for type stuff. But I learned more about the nature of typing by reading The Little Typer. After that it was a lot easier to get into the right headspace to understand what Pierce wanted me to get out of the book.&lt;&#x2F;p&gt;
&lt;p&gt;So if you’re getting into a subject, don’t rush for the ultimate reference, and find something written to teach you &lt;em&gt;the core&lt;&#x2F;em&gt; of the subject. Then the rest becomes a little easier.&lt;&#x2F;p&gt;
&lt;p&gt;Virtual Machines by Iain D. Craig, and Formal Development of a Network-Centric RTOS have been very useful in working with LAM. Hillel Wayne’s Practical TLA+, and Alloy’s Software Abstraction books have been really good to get a better grip on how to specify systems as well. Of course &lt;a rel=&quot;noopener external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;lamport.azurewebsites.net&#x2F;tla&#x2F;book.html&quot;&gt;“Specifying Systems” by Lamport&lt;&#x2F;a&gt; has been a good reference as well.&lt;&#x2F;p&gt;
&lt;p&gt;Some books that have had a massive impact in how I think and communicate have (unsurprisingly) nothing to do with computers. Like Umberto Eco’s “6 Walks in the Fictional Woods” (focused on how to create narratives and rhetoric) or Mandelbrot’s “The (Mis)Behavior of Markets” (a historical account of how fractal geometry describes better the financial markets). Nonetheless, they’ve helped shape the way I think and I’ve come out a better programmer.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;max&#x2F;2000&#x2F;0-nPPWbd4-7dJavk5P.gif&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
