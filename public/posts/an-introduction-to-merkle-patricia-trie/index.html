<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>An introduction to Merkle Patricia Trie - LambdaClass Blog</title>
    <meta name="description" content="Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">An introduction to Merkle Patricia Trie</h1>
        
        <div class="page-meta">
            <time datetime="2025-06-09">June 09, 2025</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <h2 id="introduction">Introduction</h2>
<p>Ethereum relies on cryptographic data structures to efficiently store and verify its state. One of these structures is the Merkle Patricia Trie (MPT), which powers Ethereum’s state management. After exploring this tool in more depth, it becomes clear that the MPT is a complex structure—far more intricate than a simple Merkle tree. That’s why we felt it was important to create this post: to make MPTs more accessible and easier to understand. Here we’ll explain what an MPT is, how Ethereum uses it and how its proofs work. In an upcoming post, we will explain how to arithmetize the MPT to be able to generate proofs for showing that we verified that elements are in the tree or that the tree has been updated successfully.</p>
<p>In what follows we only assume that you have a basic knowledge of <a rel="noopener external" target="_blank" href="https://decentralizedthoughts.github.io/2020-12-22-what-is-a-merkle-tree/">Merkle Trees</a> and cryptographic hash functions.</p>
<h2 id="quick-merkle-tree-recap">Quick Merkle Tree Recap</h2>
<p>A Merkle Tree is a binary tree where:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * _Leaves_ contain hashes of data.</span></span>
<span class="giallo-l"><span>    * _Non-leaf nodes_ contain hashes of the concatenation of their child nodes.</span></span>
<span class="giallo-l"><span>    * The _root hash_ acts as a cryptographic fingerprint of all the leaves data. In other words, it&#39;s a short, fixed-size summary (a hash) that uniquely identifies a large set of data — like a unique signature.</span></span></code></pre>
<p>Merkle trees are used for <strong>data integrity proofs</strong> : you can prove efficiently that a piece of data belongs to the tree’s leaves by providing a Merkle path (a sequence of hashes from the leaf to the root).</p>
<h2 id="what-is-a-trie">What is a trie?</h2>
<p>A Trie (short for retrieval tree, also known as a prefix tree) is a tree-like data structure used to efficiently store and retrieve key-value pairs, especially when the keys are strings or sequences.</p>
<p>Each level of the trie represents a character in the key, and the path from the root to a leaf corresponds to an entire key. Shared prefixes between keys are stored only once, making tries very space-efficient for datasets with common prefixes.</p>
<p>Let’s see a toy example to make it easier to understand. Let’s say we want to store these key-value pairs:</p>
<table><thead><tr><th>Key</th><th>Value</th></tr></thead><tbody>
<tr><td>cat</td><td>curious</td></tr>
<tr><td>cake</td><td>sweet</td></tr>
<tr><td>cup</td><td>fragile</td></tr>
<tr><td>cups</td><td>plural</td></tr>
<tr><td>book</td><td>heavy</td></tr>
</tbody></table>
<p>Our toy trie would look something like this:</p>
<p><img src="/images/external/HyXnHtvzgl.png" alt="image" /></p>
<p>To look up the value of the key “cake”:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. Start at the root.</span></span>
<span class="giallo-l"><span>    2. Follow the nodes corresponding to the key&#39;s characters: `c -&gt; a -&gt; k -&gt; e`.</span></span>
<span class="giallo-l"><span>    3. Retrieve value &quot;sweet&quot; at the last node `e`.</span></span></code></pre><h2 id="what-is-a-merkle-patricia-trie">What is a Merkle Patricia Trie?</h2>
<p>Ethereum uses a specialized form of trie called the Modified Merkle Patricia Trie (MPT). The name combines three core ideas:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * **Trie:** For organizing keys by shared prefixes.</span></span>
<span class="giallo-l"><span>    * **Merkle:** Every node is hashed, forming a Merkle structure that enables cryptographic verification of the entire dataset.</span></span>
<span class="giallo-l"><span>    * **Patricia:** Short for Practical Algorithm to Retrieve Information Coded in Alphanumeric — a variant of a trie that compresses paths where nodes have a single child (also called radix or compact trie).</span></span></code></pre><h2 id="how-are-mpts-used-in-ethereum">How are MPTs used in Ethereum?</h2>
<p>Ethereum uses several MPTs, but we’ll focus on just one of them, the <strong>State Trie</strong> , and use it as an example to explain how they work.</p>
<p>In the State Trie, the state of every account is stored as a key-value pair where:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * The **key** is the Keccak-256 hash of the account address.</span></span>
<span class="giallo-l"><span>    * The **value** is the account, which is the [RLP](https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/) encoding of a four item array: `[nonce, balance, storageRoot, codeHash]`.</span></span></code></pre>
<p>To reach consensus, when a new block appears with a transaction set, every Ethereum node would need to execute all those transactions and verify that the resulting state is the same for all the nodes. However, comparing every account would be computationally very expensive, so instead they use an MPT. The states of all the accounts of Ethereum are stored in a single Merkle trie called <strong>State Trie</strong> that is constantly updated after each transaction execution. To reach consensus, the nodes just compare the <strong>StateRoot</strong> (the root of the State Trie). If two nodes have the same StateRoot, their states match.</p>
<h2 id="immutability-the-big-mpt-s-advantage">Immutability: The big MPT’s advantage</h2>
<p>Ethereum needs to be able to revert easily to previous states: when nodes disagree on the next block, a blockchain fork is necessary. This is possible because tries keep the old state around, instead of deleting or modifying it directly. The trie is persistent and versionable, rather than a mutable in-place structure.</p>
<p>When the state changes (e.g., an account balance updates), the trie creates new nodes for the changed paths, while the rest of the trie (the unchanged parts) are reused. Therefore, previous versions of the trie are still accessible via their root. Every block stores a state root in its header and this root uniquely identifies the entire Ethereum state at that point in time. So, if Ethereum needs to rollback, it just uses the state root of a previous block. Since the old nodes were never deleted, the trie can rebuild the old state efficiently. This means Ethereum can restore the old state just by switching back to an earlier root hash.</p>
<h2 id="mpt-structure">MPT Structure</h2>
<p>Let’s explain how the State Trie is built. As we said above the keys of this trie consist of the hashes of the addresses, represented as a hexadecimal string. As we showed in the toy example, each node of the trie will store a character of the hex string, that is, a single <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Nibble">nibble</a> (four bits of data).</p>
<p>There are three types of nodes in an MPT:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. **Branch Node**</span></span>
<span class="giallo-l"><span>       * It stores a 17-item array.</span></span>
<span class="giallo-l"><span>       * The first 16 items represent one of each hexadecimal digit the key prefix can be. If the key prefix is the digit $i$, then at index $i$ you&#39;ll find the pointer to the next node that continues the key&#39;s path.</span></span>
<span class="giallo-l"><span>       * The last item can allocate a value in the case a key ends there.</span></span>
<span class="giallo-l"><span>       * Example:  </span></span></code></pre>
<p><code>[0x, 0x, child_hash, 0x, 0x, other_child_hash, 0x, 0x, 0x, 0x, 0x, 0x, 0x, 0x, 0x, 0x, value]</code><br />
Here, <code>"0x"</code> represents the unused slots, i.e. digits that don’t have children.
2. <strong>Extension Node</strong>
* It’s the result of an optimization to compresses shared key prefixes.
* It stores a two item array that contains the shared key prefix and a pointer to the next node.
* Example: <code>[shared_prefix, child_hash]</code>
3. <strong>Leaf Node</strong>
* It stores a two item array with the remaining key fragment and its associated value, ending the path.
* Example: <code>[key_remaining, value]</code></p>
<p>The three types of nodes store a single array encoded in <a rel="noopener external" target="_blank" href="https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/">RLP</a>. The pointer to a certain node is always the hash of this RLP string data that stores. The root can be of any type, but usually, since we have a lot of data, the root is a branch node.</p>
<h3 id="node-and-parity-flags">Node and parity flags</h3>
<p>When traversing a key path nibble by nibble (or character by character), we may end up with a leaf or extension node that has an odd number of nibbles to store. But since all data is stored in bytes, this creates a problem. For instance, if we wanted to store the nibble <code>1</code>, we would have to save it as <code>01</code>, but we wouldn’t be able to tell whether it came from the two nibbles <code>01</code>, or from a single nibble <code>1</code>. To indicate whether we are storing an even or odd number of nibbles — and what type of node we are dealing with (leaf or extension) — the partial path is prefixed with the following flags.</p>
<table><thead><tr><th>flag</th><th>node type</th><th>path length parity</th></tr></thead><tbody>
<tr><td>00</td><td>Extension</td><td>Even</td></tr>
<tr><td>1</td><td>Extension</td><td>Odd</td></tr>
<tr><td>20</td><td>Leaf</td><td>Even</td></tr>
<tr><td>3</td><td>Leaf</td><td>Odd</td></tr>
</tbody></table>
<h2 id="example-building-an-mpt-step-by-step">Example: Building an MPT step by step</h2>
<p>The best way to understand what is an MPT is to see a full example. Let’s simulate a real State Trie. Let’s say we have data for five accounts that translate into the following key-value pairs:</p>
<ul>
<li>| Keys | Values<br />
—|—|—<br />
1 | 0x616b6c64 | 0x01<br />
2 | 0x616b6c65 | 0x02<br />
3 | 0x616b6c78 | 0x03<br />
4 | 0x616b6d31 | 0x04<br />
5 | 0x31323334 | 0x05</li>
</ul>
<p>As we mentioned earlier, the keys should be the hashes of the account addresses. Since Ethereum uses Keccak-256, the keys should be 32 bytes long (or 64 hexadecimal characters). However, for this example, we’ll use much shorter keys so that the resulting trie isn’t too large and is easier to understand. Ethereum also uses optimizations, such as inlining small nodes, which we’ll skip in this example for clarity.</p>
<p>Now we are ready to build the MPT:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. Start with an empty MPT and add the first key-value pair: `(0x616b6c64, 0x01)`. Since it is just one key, it results in a trie of only one leaf node. To create that node proceed in the following way:</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>       * **Write a two-item array:** The first element should be the whole key and second one the value. Add the prefix flag `20` to the first element indicating that the node is a leaf and that the key has an even amount of nibbles. Then, the array should look like this: `[&quot;0x20616b6c64&quot;,&quot;0x01&quot;]`.</span></span>
<span class="giallo-l"><span>       * **Encode in RLP the array:** You can use an [RLP converter](https://toolkit.abdk.consulting/ethereum#rlp) or this python script:</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>import rlp</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>key = bytes.fromhex(&quot;20616b6c64&quot;)</span></span>
<span class="giallo-l"><span>value = bytes.fromhex(&quot;01&quot;)</span></span>
<span class="giallo-l"><span>encoded = rlp.encode([key, value])</span></span>
<span class="giallo-l"><span>print(encoded.hex())</span></span></code></pre>
<p>This should output this hex: <code>c78520616b6c6401</code>.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>       * **Hash the RLP encoding** using Keccak-256 to get the pointer of this node. You can use an [online hasher](https://emn178.github.io/online-tools/keccak_256.html) or this script:</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>from eth_utils import keccak</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>rlp_bytes = bytes.fromhex(&quot;c78520616b6c6401&quot;)</span></span>
<span class="giallo-l"><span>hash_pointer = keccak(rlp_bytes)</span></span>
<span class="giallo-l"><span>print(hash_pointer.hex())</span></span></code></pre>
<p>This should output:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>4e2d0fbe6726eac15c5ecf49a4e1f947aa50e0531f4f3e98b8e1577ba52e1783</span></span></code></pre>
<p>The resulting MPT should look like this:<br />
<img src="/images/external/BJ7XSE1mex.png" alt="image" /></p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    2. Add the second key-value pair: `(0x616b6c65, 0x02)`. Since this key shares the first 7 digits with the previous one, we proceed in the following way:</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>       * **Build one leaf for each key:** In each leaf, the array&#39;s first element should be the remaining path, but since the two keys share every digit except the last one, the remaining path is empty. So, we should just write there the flag `20` indicating that we are in a leaf node and that the path has an even amount of digits (zero digits). After that, encode the arrays in RLP and hash the RLP encodings, as we did in the step 1.</span></span>
<span class="giallo-l"><span>       * **Build a branch node:** Create a 17-item array. Write the hash of the first key&#39;s leaf node at index $4$ and the hash of the second key&#39;s leaf node at index $5$. Encode the array in RLP and hash the encoding.</span></span>
<span class="giallo-l"><span>       * **Build the extension and root node:** Create a two item array that contains the shared prefix as first element and the hash of the previous built branch node as second element. Since the shared prefix has an odd number of digits, add the flag `1` to it. Encode the array in RLP and hash the encoding.  </span></span></code></pre>
<p><img src="/images/external/BJaRZEJQll.png" alt="image" />
3. Add the key-value pair <code>(0x616b6c78, 0x03)</code>:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>       * **Add a leaf node:** Notice that in this case, since the new key shares with the previous ones all the digits except the last two, the array&#39;s first item will have just one digit as remaining path and the flag `3` indicating that it is a leaf node with an odd amount of path digits.</span></span>
<span class="giallo-l"><span>       * **Add a branch node:** Its array should contain at index $6$ the hash pointer of the branch node built in step 2, and at index $7$ the hash pointer of the new leaf node we recently added.</span></span>
<span class="giallo-l"><span>       * **Add an extension node:** The root will be another extension node. Its array should contain the shared prefix as first element and the hash of the recently added branch node as second element. Since the share prefix has an even number of digits, add the flag `00` to it.</span></span></code></pre>
<p>The current trie should look lik this:<br />
<img src="/images/external/HJrfJHJXee.png" alt="image" /></p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    4. Add the last two key-value pairs continuing in this way, following the same steps as we did for the previous keys. When you&#39;re done, you should have the following MPT:  </span></span></code></pre>
<p><img src="/images/external/Skc3rByXee.png" alt="image" /></p>
<h2 id="trie-proof">Trie Proof</h2>
<p>Let’s now understand what a proof looks like in an MPT. Continuing with the previous example, let’s say we want to prove that the key-value pair <code>(0x616b6d31, 0x04)</code> belongs to our State Trie. How do we build the proof?</p>
<p>The proof will consist of the <strong>StateRoot</strong> <code>0x13ea...bed7</code> (the hash of the root node) along with a path that starts at the root and traverses the trie downward, following every digit of the target key until it reaches its leaf. Let’s go step by step to see how we build this path:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. The first element of the path is the RLP of the root node: `0xf851...8080`.  </span></span></code></pre>
<p>If we decode this RLP, we find that the root is a branch node. The array it represents has all empty slots except at indices 3 and 6 (because all the keys start with the digit <code>3</code> or <code>6</code>). This means that the root node branches into two child nodes. Since the first digit of the key we’re looking for is <code>6</code>, we need to look at the hash stored in the array at index 6 and move to that node.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    2. We move to the next node and store its RLP content as the second element of the path: `0xe583...67e9`.  </span></span></code></pre>
<p>This node is an extension node because all keys starting with 6 share the same next four digits: <code>16b6</code>. To determine where to go next, we decode the RLP and get a two-item array. The second item gives us the hash of the next node we need to access.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    3. Again, we move to the next node and store its RLP content as the third element of the path: `0xf851...8080`.  </span></span></code></pre>
<p>This node is a branch node. Since our key continues with the digit <code>d</code>, we need to look at the hash stored in this node’s array at index $d$ and move to the node that this hash points to.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    4. Finally, we reach the leaf node: `0xc482203104`. We store the RLP content of this final node, and with that, the proof is complete.</span></span></code></pre>
<p>Then the proof for the key-value <code>(0x616b6d31, 0x04)</code> should look like this:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>state_root = 0x13ea549e268b5aa80e9752c6be0770cffba34d2b1aa1f858cb90f3f13ac3bed7</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>proof_path = </span></span>
<span class="giallo-l"><span>    [</span></span>
<span class="giallo-l"><span>    0xf851808080a0a26b2ac124718443aeed68fa0309225d0c8dd9dbee45685909e92fb594e1a4638080a02ccd118c9470c051689543b233ab109ad74d2fb4f57eb429c4d43294d6ae686780808080808080808080,</span></span>
<span class="giallo-l"><span>    0xe5831616b6a0917fa5cab26d915e2a89a263a578fa5f9ecf02cc0b1d3eeb433e7f32499267e9,</span></span>
<span class="giallo-l"><span>    0xf851808080808080808080808080a0cc97f12ea3217345e666974cd81b117ca02404f19c15d31158ac1d1e55398706a0822a55ca308aa885ad385d5e61aabaca54c2e4361eb03b6f851668c0f095ab77808080,</span></span>
<span class="giallo-l"><span>    0xc482203104</span></span>
<span class="giallo-l"><span>    ]</span></span></code></pre><h2 id="verify">Verify</h2>
<p>If a verifier receives the StateRoot and the proof path for a certain key, how does he verify that the proof is valid?</p>
<p>A key distinction from standard Merkle Trees is the verification direction. While a typical Merkle proof is verified from the bottom up (from the leaf to the root), a Merkle Patricia Tries proof is verified from the top down. The process starts at the <code>StateRoot</code> and traverses the trie downwards, node by node, using the provided path to eventually reach the target leaf.</p>
<p>Let’s say the verifier receives the proof of above for the key-value <code>(0x616b6d31, 0x04)</code>. Then, he has to follow these steps:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. [Hash](https://emn178.github.io/online-tools/keccak_256.html) the first element of the path and check that it matches the given **StateRoot**. Indeed:</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>keccak(bytes.fromhex(</span></span>
<span class="giallo-l"><span>    &quot;f851808080a0a26b2ac124718443aeed68fa0309225d0c8dd9dbee45685909e92fb594e1a4638080a02ccd118c9470c051689543b233ab109ad74d2fb4f57eb429c4d43294d6ae686780808080808080808080&quot;</span></span>
<span class="giallo-l"><span>)).hex() ==</span></span>
<span class="giallo-l"><span>    &quot;13ea549e268b5aa80e9752c6be0770cffba34d2b1aa1f858cb90f3f13ac3bed7&quot;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    2. [Decode](https://toolkit.abdk.consulting/ethereum#rlp) the **first RLP element** of the path and verify that in the index $6$ has the hash of the second path element. Indeed:</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>rlp.decode(bytes.fromhex(</span></span>
<span class="giallo-l"><span>    &quot;f851808080a0a26b2ac124718443aeed68fa0309225d0c8dd9dbee45685909e92fb594e1a4638080a02ccd118c9470c051689543b233ab109ad74d2fb4f57eb429c4d43294d6ae686780808080808080808080&quot;</span></span>
<span class="giallo-l"><span>))[6].hex() ==</span></span>
<span class="giallo-l"><span>    &quot;2ccd118c9470c051689543b233ab109ad74d2fb4f57eb429c4d43294d6ae6867&quot;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    3. Decode the **path&#39;s second RLP element**. You&#39;ll find a two-item array whose first element is `0x1616b6`. Since its first digit is `1` we know that we are on an extension node. Check that the rest of the digits correspond to the key we are looking for. Verify the array&#39;s second element is the hash of the path&#39;s next element.</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    4. Decode the **third path element**. You&#39;ll find a branch node. Verify that at index $d$ it stores the hash of the path&#39;s element.</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    5. Decode the **path&#39;s last element**. You&#39;ll find a two item array whose first element is `0x2031`. Since its firs two digits are `20`, we know that we reach a leaf node. Verify that the first item contains the remaining key&#39;s digits `31` and the second item contains the key&#39;s value `0x04`.</span></span></code></pre><h2 id="summary">Summary</h2>
<p>The Merkle Patricia Trie is the backbone of Ethereum’s state management. It combines the key-navigation efficiency of tries, and the cryptographic guarantees of Merkle trees. This structure allows Ethereum to store, verify, and revert state efficiently and securely. With the MPT, Ethereum nodes can independently execute transactions and verify consensus simply by comparing state roots, enabling a scalable and trustless blockchain system. In an upcoming post we will develop how to arithmetize the MPT update and show that we verified inclusion proofs.</p>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
