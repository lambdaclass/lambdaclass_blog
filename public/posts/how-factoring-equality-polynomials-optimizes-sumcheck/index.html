<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>How factoring equality polynomials optimizes sumcheck - LambdaClass Blog</title>
    <meta name="description" content="Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">How factoring equality polynomials optimizes sumcheck</h1>
        
        <div class="page-meta">
            <time datetime="2025-09-25">September 25, 2025</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <h2 id="introduction">Introduction</h2>
<p>In this article we will continue our study and analysis of the work by Bagad, Dao, Domb and Thaler,’‘Speeding up SUMCHECK’’ regarding optimizations for the SUMCHECK protocol applied to polynomials that are products of multilinear polynomials. It is now time to dive into specificity: since equality polynomials are widely used in cryptographic environments, a great deal of interest is order.</p>
<h2 id="once-upon-a-time">Once upon a time…</h2>
<p>The reader of this article surely must have surely come across equality polynomials (also known as ’‘eq polynomials’’) - polynomials that evaluate to zero at all points of their domain but one, where they evaluate to one. In the usual real analysis jargon, they also known as indicator functions for points in the cartesian space. Recalling the role of multilinear polynomials in one and several variables, equality polynomials can be obtained by multiplying together “smaller ones”. Concretely, suppose $\mathbb{F}$ is a field and let $\omega \in \mathbb{F}^\ell$: this is</p>
<p>$$\omega = (\omega_1, \omega_2, \ldots, \omega_\ell)$$</p>
<p>for $\omega_i \in \mathbb{F}$. Suppose now that we partition $\omega$ in blocks; for instance, suppose we want to split it into three blocks, say</p>
<p>$$\omega = (\omega_L,\omega_C,\omega_R)$$</p>
<p>where $L,C,R$ are a partition of $[\ell] = \{1,2,\ldots \ell \}$ such that $$l &lt; c &lt; r \quad \forall\ l \in L, c\in C, r\in R$$. These subsets indicate the indices involved in each ’‘chunk’’ of $\omega$. If the reader needs some help visualizing this, just think</p>
<p>$$\omega = (2,3,4,2,5,5) = ((2,3), (4,2), (5,5))$$</p>
<p>for $L = \{1,2\}, C = \{3,4}, R = \{5,6\}$.</p>
<blockquote>
<p>The good thing about block partitioning points is that it is compatible with factorization of equality polynomials: $$\omega = (\omega_L ,\omega_R )\implies eq_\omega (x) = eq_{\omega_L}(x_L ) eq_{\omega_R} (x_R )$$ for $x = (x_L,x_R)$, a block partition of the variable $x$.</p>
</blockquote>
<p>This is of course absolutely compatible with the tensor nature of the interpolation basis of multilinear polynomials, and comes as no surprise. One extra observation comes handy and will play a crucial role, especially when summing evaluations of polynomials defined over finite fields. Whenever a polynomial $f$ can be block-factored as shown above, then its integral (i.e. the sum of its evaluations) can be done sequentially, or in other words: there is a clever way of reordering the domain of evaluation we can take advantage of. Specifically, suppose $x\in\mathbb{F}^\ell$ and that</p>
<p>$$f(x) = f_L (x_L ) f_R (x_R )$$</p>
<p>then <strong>the sum over all $x$ can be indexed according to any of its blocks</strong> :</p>
<p>$$\sum\limits_{x\in\mathbb{F}^\ell } f(x) = \sum\limits_{ x\in\mathbb{F}^\ell } f_L (x_L ) f_R (x_R ) = \sum\limits_{ x_R\in\mathbb{F}^R }\sum\limits_{ x_L\in\mathbb{F}^L } f_L (x_L ) f_R (x_R )$$</p>
<p>where by fixing the index in the outer sum, the factors involving that very index can be taken out of the inner sum (i.e. distributive law in reverse), so</p>
<p>$$\sum\limits_{ x\in\mathbb{F}^\ell } f(x) = \sum\limits_{ x_R\in\mathbb{F}^R } f_R (x_R ) \sum\limits_{ x_L\in\mathbb{F}^L } f_L (x_L )$$</p>
<blockquote>
<p>This sort of ideas will be the ones we’ll discuss and exploit: fixing $X_R$ will allow to pre-compute sums over $X_L$ where $X_R$ is considered as a parameter: in this sense, the latter sum is pre-computed and then re-used whenever the parameter $X_R$ is invoked.</p>
</blockquote>
<p><strong>If the reader is wondering what is the name of the game: the name of the game is accumulate, accumulate, accumulate (but cleverly).</strong></p>
<h2 id="ideas-ideas">Ideas(ideas)</h2>
<p>We’re now ready to dive into the optimizations proposed by BDDT. The starting point is a sum-check protocol over a polynomial of the form $$g(X) = \tilde{eq}(w, X) \cdot p(X)$$ where $p(X)$ is itself a product of $d$ multilinear polynomials. This makes $g(X)$ a polynomial of degree $d+1$. In each round $i$ of the sum-check protocol, the prover must send a univariate polynomial $s_i (X)$, which is the sum of $g(X)$ over the remaining variables. To define this polynomial, the prover needs to compute $d + 2$ of its evaluations.</p>
<p>The authors take up on the work by Angus Gruen and take it even further. Briefly, <strong>Gruen’s key idea</strong> is to leverage the special structure of the equality polynomial, $\tilde{eq}$. This polynomial can be decomposed into a product:<br />
$$\tilde{eq}(w, (r_1 , …, r_{i - 1}, X_i, x_{i + 1}, …, x_l )) = \underbrace{\tilde{eq}(w_{[&lt;i]}, r_{[&lt;i]}) \cdot \tilde{eq}(w_i, X_i) }_ \text{ Linear part l_i(X) } \cdot \underbrace{\tilde{eq}(w_{[&gt;i]}, x’)}_ \text{Remaining part}$$</p>
<p>The effect of this decomposition is that the round polynomial, $s_i (X_i)$ originally defined as the sum over $x^\prime$ now looks like a product:</p>
<p>\begin{equation}<br />
\begin{split}<br />
s_i (X_i) &amp;=\sum\limits_{x’}g(r,X_i,x’) = \sum\limits_{x’}eq(r,X_i,x’)p(r,X_i,x’) \newline<br />
&amp;= \sum\limits_{x’}eq_{w&lt;i}(r)eq_{w_i}(X_i)eq_{w&gt;i}(x’)p(r,X_i,x’) \newline<br />
&amp;= eq_{w&lt;i}(r)eq_{w_i}(X_i)\left(\sum\limits_{x’}eq_{w&gt;i}(x’)p(r,X_i,x’)\right)<br />
\end{split}<br />
\end{equation}</p>
<p>The round polynomial now is a product of <strong>a linear factor $l_i(X_i)$}</strong> , namely</p>
<p>$$l_i(X_i) = eq_{w&lt;i} (r) eq_{w_i} (X_i)$$<br />
that depends on the challenges from previous rounds ($r_{[&lt;i]}$) and the current variable ($X_i$) and <strong>a degree-$d$ factor, $t_i(X_i)$:</strong></p>
<p>$$t_i(X_i) = \sum\limits_{x’}eq_{w&gt;i}(x’)p(r,X_i,x’)$$</p>
<p>which contains the actual summation, including the product of the $p_k$ polynomials and the remaining part of the $\tilde{eq}$ polynomial. The polynomial to be calculated by the prover at the $i-th$ round is then<br />
$$s_i(X_i) = l_i(X_i) \cdot t_i(X_i)$$</p>
<p>The reader might be asking what is the benefit of thinking of $s_i$ in this way.</p>
<blockquote>
<p>Instead of computing $d + 2$ evaluations of the complex polynomial $s_i(X)$ (degree $d + 1$), the prover now only needs to compute $d + 1$ evaluations of the simpler polynomial $t_i(X)$ (degree $d$). One of these evaluations, $t_i(1)$, can be derived from the protocol’s consistency check ($s_i(0) + s_i(1) = C_{i - 1}$), so in practice, only $d$ sums are explicitly calculated.</p>
</blockquote>
<p>In summary, Gruen reduces the degree of the polynomial that the prover must perform the most work on, saving the cost of one full evaluation in each round of the protocol. <strong>BDDT’s key idea is to re-apply the separability property of the $\tilde{eq}$ polynomial, but this time on the remaining variables being summed over ($x’$)</strong> , combined with their previous proposal of deflecting the evaluation of $p$ at the random challenges to the evaluation of Lagrange interpolation polynomials. In broad strokes, the novel work goes like</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. **Variable Splitting:** They divide the set of remaining variables $x&#39;$ into two parts of proper length, which we for now call $x_L$ (left) and $x_R$ (right).</span></span>
<span class="giallo-l"><span>    2. **Nested Summation:** Thanks to this split, the sum to compute $t_i(u)$ can be rewritten as a nested sum: $$t_i(u) = \sum_{x_R} \tilde{eq}(w_R, x_R) \cdot \left( \sum_{x_L} \tilde{eq}(w_L, x_L) \cdot \prod_{k=1}^{d} p_k(r,u,x_L,x_R) \right)$$</span></span></code></pre>
<p><strong>This rewriting is the core of the optimization. The prover can now first compute the inner sum (over $x_L$) and then use those results for the outer sum (over $x_R$).</strong></p>
<blockquote>
<p>This “sum-splitting” technique yields very significant benefits in terms of time and, above all, memory.</p>
</blockquote>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * **Drastic Memory Reduction:** The standard method would require precomputing and storing a table with the evaluations of $\tilde{eq}(w, x)$ for all $x$—a table of size $2^l$. BDDT&#39;s optimization **eliminates the need for this giant table**. Instead, the prover only needs to precompute tables for the evaluations of $\tilde{eq}$ over the halves of the variables ($x_L$ and $x_R$), which are of size $\approx 2^{l/2}$. Moving from a memory requirement of $O(2^l)$ to $O(2^{ l/2 })$ is an exponential improvement and makes much larger problems feasible.</span></span>
<span class="giallo-l"><span>    * **Reduced Computational Cost (Time):** By avoiding multiplications with the large $\tilde{eq}$ table, the prover saves a considerable number of operations. The paper estimates this optimization reduces the cost by roughly $N$ multiplications between large field elements, where $N = 2^l$ is the size of the summation domain. The sums are processed over smaller domains iteratively, which improves memory locality and computational efficiency.</span></span></code></pre>
<p>This optimization is applied during the first $l/2$ rounds of the protocol. For the remaining rounds, the benefit diminishes, and the algorithm switches back to a standard method.</p>
<h2 id="organization-beats-time">Organization beats time</h2>
<p>The fact that the authors propose a combination of Gruen’s strategy and their own ideas from <em>SmallValues</em> optimization implies that there is special care to be taken at the time of evaluating the polynomials $l_i$ and $t_i$. At round $i$ the data sent to the verifier</p>
<p>$$s_i (u) = l_i (u) t_i (u)$$</p>
<p>has a part which is more computationally demanding: the computation of $t_i(u)$ for $u$ in an appropiately large set. So far, the only definition available for this polynomial is given by</p>
<p>$$t_i(u) = \sum_{x_R} \tilde{eq}(w_R, x_R) \cdot \left( \sum_{ x_L } \tilde{eq}(w_L, x_L) \cdot \prod_{k = 1}^{d} p_k(r,u,x_L,x_R) \right)$$</p>
<p>and still needs some clarification. How are the parts of $x’$ defined? How is this sum performed? How does it relate to the SmallValues optimization the authors worked out previously?</p>
<p>It needs to be stressed that this description is conceptually sound and contains the key ideas involved in this optimization. In addition, it must me mentioned that at this level, the block partition of the remaining vectors $x’$ and the factoring of the equality polynomials is a <strong>dynamic</strong> factor: the length of $x’$ is $\ell-i$ at round $i$ and so in absolute terms, the lengths of $x_L$ and $x_R$ will vary from round to round.</p>
<p>While this is enough for a coffee table conversation, it leaves something to be desired from the algorithmic perspective, especially if some gains are to be expected.</p>
<h3 id="the-need-for-an-optimality-parameter">The need for an optimality parameter</h3>
<p>In order to maneuver between conceptual clarity and efficient computation, authors define an optimality parameter called $l_0$ - carefully chosen to minimize the prover’s total time. Its selection is based on a cost trade-off:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * **Cost of optimized rounds ($i \le l_0$)** : This cost (primarily `sl` multiplications) grows exponentially with $l_0$, as the size of the accumulators is on the order of $O((d + 1)^{l_0})$.</span></span>
<span class="giallo-l"><span>    * **Cost of standard rounds ($i &gt; l_0$)**: This cost (primarily `ll` multiplications) decreases as $l_0$ increases, because there are fewer &#39;&#39;expensive&#39;&#39; rounds to execute.</span></span></code></pre>
<p>The optimal value for $l_0$ is the one where these two costs are balanced. The paper provides a formula to estimate this optimal point for Algorithm 4, which depends on the polynomial’s structure (the number of factors, $d$) and the relative costs of hardware operations (the ratio $\kappa$ between the cost of an <code>ll</code> and an <code>ss</code> multiplication). The optimal switchover point $l_0$ can be estimated by the following formula:</p>
<p>$$l_0 = \frac{\log\left(\frac{\kappa \cdot d^2}{2(d - 1)}\right)}{\log(d + 1)}$$<br />
where:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * $d$ is the number of multilinear factors.</span></span>
<span class="giallo-l"><span>    * $\kappa$ is the factor difference in cost between a large-large (`ll`) and a small-small (`ss`) multiplication. The authors use $\kappa = 30$ for their estimations and provide a deeper background for that choice (the reader is encouraged to seek for details in the original article!)</span></span></code></pre>
<p>This parameter controls in a strict sense the regime in which the SUMCHECK protocol works at any given stage:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * **If $i \le l_0$** : You are in the &#39;&#39;optimized phase&#39;&#39;. The protocol uses the pre-computed accumulators to compute the prover&#39;s message very quickly.</span></span>
<span class="giallo-l"><span>    * **If $i &gt; l_0$**: You have crossed the threshold. The protocol switches to a more standard algorithm (like Algorithm 5) for the remaining rounds, as the benefit of the pre-computation has ended.</span></span></code></pre>
<p>Now we are able to take a further look at the block partition of $x’$. The implementation of the author’s optimization is based in a static partition of these points in terms of the optimization parameter $\ell_0$ and the number of variables $\ell$. This partition is named</p>
<p>$$x’ = (x_{in}, x_{out})$$</p>
<p>works in the same way as the dynamic one but allows for an efficient computation since lengths are now constant. They represent a fixed split of the variables that are not in the $l_0$-round prefix.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * $x_{in}$ is the set of variables over which the &#39;&#39;inner sum&#39;&#39; is calculated.</span></span>
<span class="giallo-l"><span>    * $x_{out}$ is the set of variables over which the &#39;&#39;outer sum&#39;&#39; iterates.</span></span></code></pre>
<blockquote>
<p>The $l$ total variables of the polynomial are divided into three disjoint groups whose union forms the complete set of variables:</p>
</blockquote>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. **Pre-computation Prefix $\beta$** : The first $l_0$ variables.</span></span>
<span class="giallo-l"><span>    2. **Set $x_{in}$** : The next $\lfloor l/2 \rfloor$ variables</span></span>
<span class="giallo-l"><span>    3. **Set $x_{out}$** : The final $\lfloor l/2 \rfloor - l_0$ variables</span></span></code></pre>
<p>Therefore, $x_{in}$ and $x_{out}$ <strong>together form a partition</strong> of the set of variables that do not belong to the pre-computation prefix (i.e., the pre-computation suffix). The sum of their sizes is $(\lfloor l/2 \rfloor) + (\lfloor l/2 \rfloor - l_0)$, which is approximately $l - l_0$, the total size of the pre-computation suffix.</p>
<p>Now that we have settled the notation and parameters involved, lets see how their algorithm actually computes the desires values in the round $i$.</p>
<h3 id="the-effect-of-block-description-in-the-pre-computation-phase">The effect of block description in the pre-computation phase</h3>
<p>In order to compute $t_i (u)$ - the authors make use of the SmallValue optimization - it allows to compute the evaluation at random challenges sent by the verifier of a product of multilinear polynomials. As we mentioned in an earlier post, this is done by deflecting the burden of evaluation to multivariate Lagrange polynomials defined over a grid of points with coefficients in the base field - and evaluate those polynomials. The desired evaluation is now a sum weighted by pre-computed coefficients called accumulators, which depend on the grid and the product.</p>
<p>For concreteness, recall the definition of $t_i$</p>
<p>$$t_i(u) = \sum\limits_{x’} \tilde{eq}(w_{&gt;i}, x’) \cdot \prod_{k = 1}^{d} p_k(r,u,x’)$$</p>
<p>The SmallValues optimization allows a re-writing of this as</p>
<p>$$t_i(u) = \sum\limits_{v\in G_i} \left(\sum_{x’} \tilde{eq}(w_{&gt;i}, x’) \cdot \prod_{k=1}^{d} p_k(v,u,x’)\right)\cdot L_v(r) $$</p>
<p>where</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. $G_i$ is an adequate interpolation grid of points in the base field. Specifically, if $g$ is a product of $d$ multilinear polynomials not counting the eq factor, setting $U_d = {\infty, 0, 1, \dots, d - 1}$ then $$G_i = U_d^{ i - 1 }\quad i\geq 2\quad\text{and}\quad G_1 = \emptyset$$</span></span>
<span class="giallo-l"><span>    2. The polynomials $L_v$ are the $i - 1$ variate Lagrange interpolation polynomials associated with the grid $G_i$ - it is those polynomials that end up being evaluated at the challenges $r_1,\ldots r_{ i - 1}$. For $i = 1$ we set $L_1 = 1$.</span></span>
<span class="giallo-l"><span>    3. Authors fancy to collect the $\lvert G_i\rvert$ values of the polynomials $L_v(r)$ in a single $\lvert G_i\rvert$-long vector indexed by the points in the grid, in a single challenge vector $R_i$</span></span>
<span class="giallo-l"><span>    4. The sum between parenthesis in the last line is the definition of the **accumulators $A_i(v,u)$** \- simply the coefficients needed to express, in terms of the Lagrange interpolation polynomials, the value of $t_i(u)$. Authors express this as an &#39;&#39;inner product&#39;&#39; between the challenge vector and an accumulator vector, also indexed by $v$: $$t_i(u) = \sum\limits_{ v\in G_i} R_i (v)A_i (v,u)$$</span></span></code></pre>
<p>Now is time to let the power of block partitioning shine and do its magic: the sum over $x’$ now can be take in two steps:</p>
<p>$$A_i(v, u) = \sum_{x_{out}} \tilde{eq}(w_{out}, x_{out}) \sum_{x_{in}} \tilde{eq}(w_{in}, x_{in}) \prod_{k = 1}^{d} p_k(v, u, x_{in}, x_{out})$$</p>
<p>Don’t panic, we’re there already. Consider now the prefix $\beta = (v,u)$ and call $E_{in} [x_{in}] =eq(w_{in},x_{in})$. The last inner sum is then parametrized by $\beta$ and $x_{out}$ and shall be called temporary accumulator $tA[\beta]$.</p>
<p>$$tA[\beta] = \sum_{x_{in} \in \{0,1\}^{ l/2 }} E_{in}[x_{in}] \cdot \prod_{k = 1}^{d} p_k(\beta, x_{in}, x_{out})$$</p>
<p>Now that we have baptized the proper objects, we can describe how the algorithm works.</p>
<h4 id="logic-and-algorithmic-steps">Logic and Algorithmic Steps:</h4>
<p>The core idea is a form of <strong>memoization</strong>. Instead of calculating the entire sum for each accumulator, it calculates the innermost sum once and reuses the result: really, the effecto of the block partitioning.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. **Outer Iteration over $x_{out}$** : The algorithm has a main loop that iterates over all possible assignments of the variables in the $x_{out}$ segment.</span></span>
<span class="giallo-l"><span>    2. **Inner Sum Calculation** : Inside that loop, for a fixed value of $x_{out}$, the algorithm computes the innermost sum. This sum is over all assignments of $x_{in}$ and depends on the prefix $\beta$ (which generalizes $(v,u,y)$) and the current $x_{out}$.  </span></span></code></pre>
<p>a. For each prefix $\beta$, it computes $\sum_{x_{in}} E_{in}[x_{in}] \cdot \prod p_k(\beta, x_{in}, x_{out})$.<br />
b. The result of this inner sum for each $\beta$ is stored in a <strong>temporary accumulator</strong> called $tA[\beta]$.
3. <strong>Distribution to Final Accumulators</strong> : Once all the $tA$ values have been computed for the current $x_{out}$, the algorithm distributes them to the final accumulators $A_i(v,u)$. This is done in the following way:<br />
a. It iterates over each prefix $\beta$ and its corresponding value in $tA[\beta]$.<br />
b. Using the mapping function <code>idx4</code> (defined in A.5), it determines which final accumulators $(i, v, u)$ this prefix $\beta$ contributes to.<br />
c. It adds the value of $tA[\beta]$ to the appropriate final accumulator, weighted by the outer <code>eq-poly</code> factor, $E_{out,i}$.</p>
<h3 id="classification-and-distribution-mechanism">Classification and distribution mechanism</h3>
<p>We discussed this method when we studied BDDT’s SmallValue optimization, but it is nice to refresh the reader how this is performed. The role of the <em>idx4</em> classification algorithm is to act as an intelligent <strong>’‘dispatcher’’ or ’‘router’’</strong> during the pre-computation phase. Its function is to determine which final accumulators $A_i(v,u)$, possibly from different rounds, should be updated with an intermediate result that has just been computed.</p>
<p><em>Procedure 9</em> (the pre-computation engine for Algorithm 6) is designed for high efficiency. Instead of calculating each accumulator $A_i(v,u)$ separately, it iterates over all possible prefixes $\beta$ of length $l_0$ and computes a single value for each: the temporary accumulator $tA[\beta]$.</p>
<p>The problem is that a single value $tA[\beta]$ (calculated, for example, for the prefix $\beta=(0,1,0)$) can be part of the calculation for:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * The accumulator for **Round 1** : $A_1(u=0)$.</span></span>
<span class="giallo-l"><span>    * The accumulator for **Round 2** : $A_2(v=(0), u=1)$.</span></span>
<span class="giallo-l"><span>    * The accumulator for **Round 3** : $A_3(v=(0,1), u=0)$.</span></span></code></pre>
<p>The question that <em>idx4</em> answers is: given a $\beta$, what are all the ’‘addresses’’ $(i, v, u)$ of the final accumulators to which this $tA[\beta]$ must be sent?</p>
<blockquote>
<p>Its logic consists of “decomposing” the prefix $\beta$ for each round $i$ (from 1 to $l_0$) and checking if it meets the required structure. For a prefix $\beta$ to be valid for an accumulator of round $i$, the part of the prefix corresponding to the future variables (the vector $y$) <strong>{must be binary (containing only 0s and 1s)</strong>. The fact that the polynomial $g$ has an $eq$ factor ends up greatly simplyfing this distribution step, since a very little number of precomputed products/sums are involved in the construction of the accumulators.</p>
</blockquote>
<h3 id="intuitive-example">Intuitive Example</h3>
<p>Imagine $l_0 = 3$ and the computed prefix is $\beta = (0, 1, 0)$. <em>idx4</em> would do the following:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. **Does it contribute to Round 1 ($i = 1$)?**  </span></span></code></pre>
<p>a. $u=\beta_1=0$.<br />
b. The remainder is $y = (\beta_2, \beta_3) = (1,0)$.<br />
c. Since $y$ is binary, <strong>Yes</strong>. <em>idx4</em> generates the tuple <em>$(i=1, v=(), u = 0, y = (1,0))$</em>.
2. <strong>Does it contribute to Round 2 ($i = 2$)?</strong><br />
a. $v = (\beta_1) = (0)$.<br />
b. $u = \beta_2 = 1$.<br />
c. The remainder is $y=(\beta_3)=(0)$.<br />
d. Since $y$ is binary, <strong>Yes</strong>. <em>idx4</em> generates the tuple $(i=2, v=(0), u=1, y=(0))$.
3. <strong>Does it contribute to Round 3 ($i = 3$)?</strong><br />
a. $v = (\beta_1, \beta_2) = (0,1)$.<br />
b. $u=\beta_3=0$.<br />
c. The remainder, $y$, is empty.<br />
d. <strong>Yes</strong>. <em>idx4</em> generates the tuple $(i = 3, v = (0,1), u = 0, y = ())$.</p>
<p>In contrast, if $\beta = (2, 1, 0)$, it would only contribute to Round 1. For Rounds 2 and 3, the $v$ part of the prefix would contain a <code>2</code>, which is not a binary value and thus is not part of the sum over the Boolean hypercube that defines the accumulators for those rounds.</p>
<h2 id="a-small-example-before-you-fall-off-the-chair">A small example before you fall off the chair</h2>
<p>To fix ideas, we will now walk through an example with small, concrete numbers. If you will, grab a piece of paper and some coffee and double check the computations as we move along the initial rounds.</p>
<h3 id="setup">Setup</h3>
<p>We will use a polynomial of <strong>6 variables</strong> while keeping the optimization rounds at <strong>$l_0 = 2$</strong>. This change allows us to have a non-empty $x_{out}$ in Round 2, thus showing the complete interaction between temporary and final accumulators.</p>
<p>Consider the polynomial</p>
<p>$$g(X) = \tilde{eq}(w, X) \cdot (X_1 + X_3 + X_5 + 1) \cdot (X_2 + X_4 + X_6 + 2)$$</p>
<p>and $eq$ is the equality polynomial for the vector $w = (1, 0, 1, 1, 0, 1)$. Considering $l_0 = 2$ then only rounds 1 and 2 are optimized. As the author’s choice of interpolation set, we will stick to $U_2 = \{\infty, 0, 1 \}$. The prover needs to compute $t_2(u)$ for $u \in \hat{U_2} = \{\infty, 0\}$.</p>
<h3 id="getting-the-partitioning-straight">Getting the partitioning straight</h3>
<p>Since $\ell_0=2$, the 6 variables are partitioned as follows:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * **The pre-computation prefix** $\beta = (X_1, X_2)$ and its &#39;&#39;eq&#39;&#39; companion $w_L=(w_1, w_2)=(1,0)$</span></span>
<span class="giallo-l"><span>    * **The pre-computation suffix** $(X_3, X_4, X_5, X_6)$ is then split as  </span></span></code></pre>
<p>a. <strong>$x_{in}$ (size $l/2 = 3$)</strong> : $(X_3, X_4, X_5)$. Its <code>eq</code> vector is $w_{in} = (w_3, w_4, w_5) = (1,1,0)$.<br />
b. <strong>$x_{out}$ (size $l/2 - l_0 = 1$)</strong> : $(X_6)$. Its <code>eq</code> vector is $w_{out} = (w_6) = (1)$.</p>
<h3 id="the-first-round">The first round</h3>
<p>The prover needs to compute the values of</p>
<p>$$s_1 (X_1) = l_1 (X_1) t_1 (X_1)$$</p>
<p>at $\infty$ and $0$. Remember that the linear factor $l_i (X_i)$ is defined as:<br />
$$l_i(X_i) = \underbrace{\tilde{eq}(w_{[&lt;i]}, r_{[&lt;i]})}_ {\text{past challenges}} \cdot \underbrace{\tilde{eq}(w_i, X_i)}_ {\text{current variable}}$$</p>
<p>So in round 1 $i = 1$ the set of past challenges $r_{[&lt;1]}$ is empty. By convention, a product over an empty set is 1. Therefore, the first factor of the formula is simply 1. This means that</p>
<p>$$l_1 (X_1) = 1 \cdot \tilde{eq}(w_1, X_1) = \tilde{eq}(1, X_1) = X_1$$</p>
<p>This implies that $l_1 (\infty) = 1$ and $l_1 (0) = 0$ so the good news is that we don’t need to compute $t_1 (0)$. Let’s get to work and see how the leading coefficient of $t_1$ is computed.</p>
<p>According to Algorithm 6,<br />
$$t_1(u) = \langle R_1, A_1(u) \rangle = A_1(u) \quad (\text{since } R_1=[1])$$</p>
<p>Therefore, the task reduces to calculating the final accumulator $A_1(\infty)$ and this is where the temporary accumulators come into play. Since the optimization parameter is $\ell_0 = 2$ then</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * for this first round the prefixes $\beta$ we will be interested in taking in account are $$\beta = (\infty,0)\quad\text{and}\quad \beta = (\infty,1)$$</span></span>
<span class="giallo-l"><span>    * then the **suffix** is split into $x_{in}=(X_3,X_4,X_5)$ and $x_{out}=(X_6)$ and since the **`eq` vectors** are $w_{in} = (1,1,0)$ and $w_{out} = (1)$, we have $$E_{out,1}(1,0) = 0\quad\text{and}\quad E_{out,1}(1,1) = 1$$ so we won&#39;t be computing the temporary acumulator for $x_6 = 0$ (it gets multiplied by zero).</span></span></code></pre>
<p>For completeness, we include here a small table with the precomputation in this case:</p>
<p><strong>Temporary Accumulators for $x_6 = 1$</strong></p>
<table><thead><tr><th>$u$</th><th>$y_2$</th><th>$p_1 = u + 2$</th><th>$p_2 = y_2 + 4$</th><th><strong>$tA [u,y_2]$</strong></th></tr></thead><tbody>
<tr><td>$\infty$</td><td>0</td><td>1</td><td>4</td><td>$1 \cdot 4 = 4$</td></tr>
<tr><td>$\infty$</td><td>1</td><td>1</td><td>5</td><td>$1 \cdot 5 = 5$</td></tr>
<tr><td>0</td><td>0</td><td>2</td><td>4</td><td>$2 \cdot 4 = 8$</td></tr>
<tr><td>0</td><td>1</td><td>2</td><td>5</td><td>$2 \cdot 5 = 10$</td></tr>
</tbody></table>
<p>So let’s compute the outer loop for $x_6 = 1$. Now the inner weight of the product is given by $$E_{in} (w_{in},x_{in})$$ so the only term in the inner sum is the one corresponding to $x_{in} = (1,1,0)$ and so</p>
<p>$$tA[\infty,0] = p_1 (\infty,0,1,1,0,1) \cdot p_2 (\infty,0,1,1,0,1) = 1\cdot 4 = 4$$</p>
<p>and</p>
<p>$$tA[\infty,1] = p_1(\infty,1,1,1,0,1)\cdot p_2(\infty,1,1,1,0,1) = 1\cdot 5 = 5$$</p>
<p>which implies that</p>
<p>$$A_1(\infty) = 1\cdot tA[\infty,0] + 1\cdot tA[\infty,1] = 4 + 5 = 9$$<br />
and so, the prover sends</p>
<p>$$s_1 (\infty) = 1\cdot 9 = 9\quad\text{and }\quad s_1(0) = 0$$</p>
<h3 id="the-second-round">The second round</h3>
<p>Firstly, we tackle the linear factor $l_2 (X_2)$. This factor comes from the <code>eq</code> over the prefix variables $(X_1, X_2)$ evaluated at $(r_1, X_2)$:<br />
$$l_2(X_2) = \tilde{eq}((w_1, w_2), (r_1, X_2)) = \tilde{eq}(1, r_1) \cdot \tilde{eq}(0, X_2) = r_1 \cdot (1-X_2)$$</p>
<p>and obviously</p>
<p>$$l_2(\infty) = - r_1\quad\text{and}\quad l_2(0) = r_1$$</p>
<p>Now comes the tough part of computing $t_2(X_2)$. Since this is computed via the SmallValue optimization, it involves combining the evaluations at the random challenge $r_1$ of the Lagrange interpolation polynomials using the pre-computed accumulators: this ends up being a sum of products and the authors usually show this as an inner product $$t_2(u) = \langle R_2, A_2(u) \rangle$$ where the challenge vector $R_2$ depends on $r_1$ and $U_2 = \{\infty, 0, 1\}$, and is calculated as:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * $R_2[\infty] = (r_1 - 0)(r_1 - 1) = r_1(r_1 - 1)$</span></span>
<span class="giallo-l"><span>    * $R_2[0] = \frac{r_1 - 1}{0 - 1} = 1 - r_1$</span></span>
<span class="giallo-l"><span>    * $R_2[1] = \frac{r_1 - 0}{1 - 0} = r_1$</span></span></code></pre>
<blockquote>
<p>The challenge vector is then <strong>$R_2 = (r_1 (r_1 - 1), 1 - r_1, r_1)$</strong>.</p>
</blockquote>
<p>We will now compute the values $A_2(v,u)$ for $v,u \in U_2$ by following the logic of Procedure 9, which iterates over $x_{out} = (X_6)$; again, since</p>
<p>$$E_{out,2} (1,X_6) = X_6$$</p>
<p>we only need to take in account the case $x_6 = 1$. Also the computation of temporary accumulators $tA$ in this case benefits from what we already learned in the first round: the sum still collapses for $x_{in} = (1,1,0)$ For completeness we include</p>
<p><strong>Temporary Accumulators for $x_6 = 1$</strong></p>
<table><thead><tr><th>$v$</th><th>$u$</th><th>$p_1 = v+2$</th><th>$p_2 = u+4$</th><th><strong>$tA[v,u]$</strong></th></tr></thead><tbody>
<tr><td>$\infty$</td><td>$\infty$</td><td>1</td><td>1</td><td>$1 \cdot 1 = 1$</td></tr>
<tr><td>$\infty$</td><td>0</td><td>1</td><td>4</td><td>$1 \cdot 4 = 4$</td></tr>
<tr><td>0</td><td>$\infty$</td><td>2</td><td>1</td><td>$2 \cdot 1 = 2$</td></tr>
<tr><td>0</td><td>0</td><td>2</td><td>4</td><td>$2 \cdot 4 = 8$</td></tr>
<tr><td>1</td><td>$\infty$</td><td>3</td><td>1</td><td>$3 \cdot 1 = 3$</td></tr>
<tr><td>1</td><td>0</td><td>3</td><td>4</td><td>$3 \cdot 4 = 12$</td></tr>
</tbody></table>
<p>We are now in position of constructing a table with the final accumulators involved in this round. Since the prover needs to send evaluations at $\infty$ and $0$, we only compute the accumulators</p>
<p>$$A_2(\infty,\infty),, A_2(0,\infty),, A_2(1,\infty),, A_2(\infty,0),, A_2(0,0),\text{and}, A_2(1,0)$$</p>
<p>Remember: the $E_{out,2}$ and $E_{in}$ weights eliminate most of the sums in the definition</p>
<p>$$A_2 (v,u) = \sum\limits_{x_{out}} E_{out,2} \sum\limits_{x_{in}} E_{in}[x_{in}] p_1 (v,u,x_{in},x_{out}) p_2 (v,u,x_{in},x_{out})$$</p>
<p>which reduces to</p>
<p>$$A_2(v,u) = p_1(v,u,1,1,0,1) p_2(v,u,1,1,0,1)$$</p>
<p>This drastic reduction in cases is a clear example of how this approach to computing the round polynomials works: block partitioning the eq factor collected by $t_i$ causes much of the sum to vanish and yields very few nontrivial summands contributing to the accumulators.</p>
<p>For completeness, here’s a table showing the final accumulators</p>
<h3 id="final-accumulator-values-for-round-2">Final Accumulator Values for Round 2</h3>
<table><thead><tr><th><strong>$A_2(v,u)$</strong></th><th><strong>$u=\infty$</strong></th><th><strong>$u=0$</strong></th><th><strong>$u=1$</strong></th></tr></thead><tbody>
<tr><td><strong>$v=\infty$</strong></td><td>1</td><td>4</td><td>(not needed)</td></tr>
<tr><td><strong>$v=0$</strong></td><td>2</td><td>8</td><td>(not needed)</td></tr>
<tr><td><strong>$v=1$</strong></td><td>3</td><td>12</td><td>(not needed)</td></tr>
</tbody></table>
<p>In this round, we combine the challenge vector using the accumulators as weights to produce the evaluations of $t_2(u)$:</p>
<p>\begin{itemize}</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * **Computation of $t_2(0)$:**  </span></span></code></pre>
<p>\begin{align*}<br />
t_2(0) &amp;= \sum_{v \in U_2} R_2[v] \cdot A_2(v, 0) \newline<br />
&amp;= r_1(r_1 - 1) \cdot A_2(\infty, 0)) + (1 - r_1)\cdot A_2(0, 0) + r_1 \cdot A_2(1, 0) \newline<br />
&amp;= r_1(r_1 - 1) \cdot 4 + (1 - r_1) \cdot 8 + r_1 \cdot 12<br />
\end{align*}
* <strong>Computation of $t_2(\infty)$</strong><br />
\begin{align*}<br />
t_2(\infty) &amp;= \sum_{v \in U_2} R_2[v] \cdot A_2(v, \infty) \newline<br />
&amp;= (r_1(r_1 - 1) \cdot A_2(\infty, \infty)) + ((1 - r_1)\cdot A_2(0, \infty)) + (r_1 \cdot A_2(1, \infty)) \newline<br />
&amp;= (r_1(r_1-1) \cdot 1) + ((1 - r_1) \cdot 2) + (r_1 \cdot 3)<br />
\end{align*}</p>
<p>Finally, the prover send the following values to the verifier</p>
<p>$$s_2(\infty) = l_2(\infty)\cdot t_2(\infty)\quad\text{and}\quad s_2(\infty) = l_2(\infty)\cdot t_2(\infty)$$</p>
<p>(an actual prover replaces the challenge $r_1$ and produces a numerical output to hand in to the verifier and this is it for the first two rounds)</p>
<h2 id="rounds-after-l-0">Rounds After $l_0$</h2>
<p>Once the optimized rounds using pre-computation are finished, the algorithm switches its strategy for the remainder of the protocol.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * **Transition Phase (Round $l_0 + 1$)**  </span></span></code></pre>
<p>The objective of this single round is to switch from the ’‘fast mode’’ of pre-computation to the ’‘standard’’ linear mode. The prover computes the evaluations of the polynomials $p_k$ with the first $l_0$ variables already fixed to the challenges $(r_1, \dots, r_{l_0})$. The result of this phase is the creation of the data arrays (called $P_k$) that will be used in the final rounds.
* <strong>Final Phase (Rounds $l_0+2$ to $l$)</strong><br />
From this point on, the protocol follows the standard linear sum-check algorithm (similar to Algorithm 1 or 5). In each of these rounds:<br />
i. The prover uses the current arrays $P_k$ to compute and send its message.<br />
ii. It receives a new challenge $r_i$.<br />
iii. It uses the challenge to combine pairs of entries in the arrays, <strong>halving their size</strong> and preparing everything for the next round.</p>
<p>This halving process continues until the last round, where the arrays are so small that the problem is reduced to a single final check.</p>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
