<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introducing DeMo: Decoupled Momentum Optimization for efficient distributed LLM training - LambdaClass Blog</title>
    <meta name="description" content="Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">Introducing DeMo: Decoupled Momentum Optimization for efficient distributed LLM training</h1>
        
        <div class="page-meta">
            <time datetime="2024-12-06">December 06, 2024</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <h2 id="tl-dr">TL;DR</h2>
<p>Training Large Language Models (LLM) with billions of parameters is computationally intensive and involves large communication in specialized data centers. <a rel="noopener external" target="_blank" href="https://nousresearch.com/">Nous Research</a> released DeMo, showing how to reduce these communication costs by orders of magnitude, decreasing costs and enabling training with poorer connections and less expensive hardware. This post introduces basic concepts and discusses <a rel="noopener external" target="_blank" href="https://arxiv.org/pdf/2411.19870">the paper</a>.</p>
<h2 id="introduction">Introduction</h2>
<p>The problem of machine learning consists of finding a function (or mapping) from a set of inputs, $X$, to a set of outputs, $Y$. This relationship can be quite complex, and we want to approximate it by having information on samples $(x , y)$. For example, we could be interested in the response of the length of a hanging spring to adding weight; to that end, we would measure the weight we are adding, $w$, and record the variation in length, $\Delta x$. Another example could be correlating the energy expenditure by a person based on information such as heart rate, weight, height, and amount of skeletal muscle mass. We could also want to train an agent to recognize an image. While the underlying relationships and objectives could be very different, they can be treated by some families of mathematical methods. Before diving into specifics of large language models (LLM) and artificial intelligence (AI), let us focus on simpler problems, such as measuring the spring’s elongation with weight or the current circulating in a wire due to the application of a given voltage.</p>
<p>In the case of the spring, we get some weights (for example, 25 g, 50 g, 100 g, 200 g). We measure the resulting elongation once the movement of the spring finishes, say 1, 2, 4 and 8 cm. Using empirical knowledge from Physics, as long as we are in an elastic regime, <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Hooke%27s_law">Hooke’s law</a> holds: the weight (applied force) is proportional to the elongation, $k \Delta x = w$, where $k$ is the stiffness of the spring. The relationship is not always like this because if we add too much weight, the spring is deformed significantly and loses its behavior. The problem we want to solve is, therefore,</p>
<p>Find $k$ such that $k \Delta x_i = w_i$ for $i = 0, 1, 2, … n$. This is a system of linear equations, and should there be no measurement errors and this relationship be the true mapping, then $k = w_i / \Delta x_i$.</p>
<p>Some problems we face are:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. The relation/mapping we are using may be an approximation of the true relationship.</span></span>
<span class="giallo-l"><span>    2. There are errors associated with the measurements (we can assume for the time being that these errors are random and not introduced systematically by the observer).</span></span>
<span class="giallo-l"><span>    3. We don&#39;t have lots of measurements $(\Delta x , w)$.</span></span></code></pre>
<p>This makes things quite harder. To start with, the system of equations $k \Delta x_j = w_j$ could no longer have a valid solution. For example, we could have $(1 , 25)$ and $(2.01 , 49.9)$, which translates to:<br />
$k. 1 = 25$<br />
$k. 2.01 = 49.9$<br />
The first equation yields $k = 25$, while the second gives $k = 24.82$. This system of equations has no solution, but we could still be interested in estimating $k$ from the information available (the two values are not too far apart, so maybe we can do something). We could define a new function that measures the difference between the observed output $w_j$ and the predicted output $\Delta x_j$. We call this function the <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Loss_function">loss function</a>. For example,<br />
$L(k) = (k \Delta x_0 - w_0 )^2 + (k \Delta x_1 - w_1 )^2 = (\hat{w}_0 - w_0 )^2 + (\hat{w}_1 - w_1 )^2$</p>
<p>The function measures the quadratic error between the weight predicted by Hooke’s law and our measurements. Our objective is to find $k$ such that the loss function is minimal,<br />
$\min_{k \in K} L(k)$</p>
<p>Calculus tells us that the function (assuming it is “nice”) attains an extremal value if the derivative with respect to $k$ is zero,<br />
$dL/dk = 0$</p>
<p>Using the chain rule for derivatives,<br />
$dL/dk = 2(k \Delta x_0 - w_0 )\Delta x_0 + 2(k \Delta x_1 - w_1 ) \Delta x_1 = 0$</p>
<p>This equation is linear, and we can solve it directly. Let us complicate the problem a little bit, assuming</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. We have several parameters, $k_0, k_1 , ... , k_m$</span></span>
<span class="giallo-l"><span>    2. That the equations to find the parameters are non-linear.</span></span></code></pre>
<p>The procedure can be generalized using multivariate calculus if we have several parameters. We ask for the partial derivatives with respect to each parameter to be zero:<br />
$\partial L / \partial k_0 = 0$<br />
$\partial L / \partial k_1 = 0$<br />
$\partial L / \partial k_2 = 0$<br />
$\vdots$<br />
$\partial L / \partial k_m = 0$</p>
<p>The vector containing all these partial derivatives is the gradient of $L$. We have a system of several equations with as many variables to solve.</p>
<p>What happens when the equations above are not easy to solve? We have two facts:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. The gradient should be zero at the minimum.</span></span>
<span class="giallo-l"><span>    2. The gradient&#39;s direction gives the direction of the greatest increase in a function (so following the opposite direction should give the steepest descent).</span></span></code></pre>
<p>This is the working principle of the steepest descent search. Starting for a set of parameters $k^0$, we recursively set<br />
$k^{n + 1} = k^n - \gamma \nabla L$<br />
where $\gamma$ is a parameter (called the learning rate). High values of $\gamma$ generate instability and convergence issues, whereas low values of $\gamma$ mean we move slowly toward the minimum.</p>
<p>We now face some further questions which we did not address before:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. A function can have several (local) minima, so how can we ensure that we find the true (global) minimum?</span></span>
<span class="giallo-l"><span>    2. Is there a way we can adapt the learning rate $\gamma$ so that we can achieve convergence faster?</span></span>
<span class="giallo-l"><span>    3. What happens if the number of observations $(x_i , y_i )$ is very large and the loss function has a complicated or expensive to evaluate expression?</span></span></code></pre>
<p>We will first address the third question and then try to solve the others. We have an expression of the form:<br />
$L (k) = \sum_j E_j (x_j, y_j , k)$<br />
For example, $E_j = ( f(x_j , k) - y_j )^2$ could be the quadratic error for each observation, and $f$ is the function giving the relationship between input and output. Computing the whole gradient involves the (partial) derivative of each $E_j (x_j , y_j )$ and summing over all values of $j$, making the evaluation of the gradient expensive. We could try to reduce the number of terms just by choosing one observation and approximate the true gradient by this value:<br />
$\nabla L \approx \nabla E_j$<br />
This reduces the computational burden at the expense of accuracy. We could also try to estimate the gradient using a subset of the observations or mini-batch. This is the idea of the stochastic gradient descent.</p>
<p>Since we are dealing with approximations, the learning rate may need to be readjusted and decreased at a specific rate, making it $\gamma^n$.</p>
<p>We can improve the method by introducing momentum, which keeps track of previous gradients when updating it for the next iteration. Basically,<br />
$\Delta k^n = \alpha \Delta k^{n - 1} - \gamma (\nabla L)^n$<br />
$k^{n + 1} = k^n + \Delta k^n$<br />
We can see that if $\alpha = 0$, we recover the original gradient descent. If $\alpha$ is different from zero, we accumulate the previous gradients and, considering the directions given by earlier steps. This will ensure that if we were going in a given direction for some time, we will continue going that way, avoiding sudden changes in direction.</p>
<p>Since gradients can have components with very different values, we can adjust learning rates for each variable, as in the case of the <a rel="noopener external" target="_blank" href="https://arxiv.org/pdf/1412.6980">Adam optimizer</a>.</p>
<p>The problem with local minima can be solved by means of this momentum method (which would prevent us from being trapped in shallow minima), trying different starting points and also <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Simulated_annealing">annealing methods</a>.</p>
<p>We can create or approximate more complex behaviors by using neural networks. Given the input variables $x_1, … x_m$, we can form a linear combination, using weights $w_{j0}$ and apply an activation function $f$, obtaining new values $z_{11}, … z_{1m}$ as follows:<br />
$a_{1j} = \sum_l w_{jl} x_l + w_{j0}$<br />
$z_{1j} = f(\sum_l w_{jl} x_l + w_{j0})$<br />
We can add a new layer, using the output above, by performing linear combinations and applying an activation function<br />
$z_{2j} = f(\sum_l w_{jl}^{(2)} z_{1l} + w_{j0}^{(2)})$<br />
We can similarly add other layers until we get the output of the neural network,<br />
$z_{3j} = f(\sum_l w_{jl}^{(3)} z_{2l} + w_{j0}^{(3)})$</p>
<p>Gradients can be computed efficiently using backpropagation. We will start again with our loss function as a sum of terms, each corresponding to one sample,<br />
$L (k) = \sum_j E_j (x_j, y_j , k)$<br />
We will focus on computing the derivative of one $E_j$ with respect to each of the parameters,<br />
$$\frac{\partial E_j}{ \partial w_{ji} } = \frac{\partial E_j}{\partial a_j} \frac{\partial a_j }{\partial w_{ij}}$$</p>
<p>The second partial derivative on the right-hand side is straightforward since $a_j$ is a linear combination of $w_{ij}$,<br />
$$\frac{\partial a_j }{\partial w_{ij}} = z_i$$<br />
For the other derivative, we will just call it<br />
$$\frac{\partial E_j}{\partial a_j} = \delta_j$$<br />
so that<br />
$$\frac{\partial E_j}{ \partial w_{ji} } = z_i \delta_j$$</p>
<p>The derivatives for each layer can be computed by evaluating $\delta_j$ and using the formula provided. For the hidden layers,<br />
$$\delta_j = \sum_m \frac{\partial E_j}{\partial a_m} \frac{\partial a_m}{\partial a_k}$$<br />
We can finally arrive at the backpropagation formula for $\delta_j$,<br />
$\delta_j = f^\prime (a_j ) \sum_m w_{mj} \delta_m$</p>
<p>The basic procedure to evaluate the derivatives would be to first compute the $a_j$ for all the layers and the output, evaluate $\delta_j$ for the output, and use the last formula using backpropagation to obtain each $\delta_j$ for each inner layer.</p>
<p>Many Large Language Models (LLM) are based on neural networks. They have shown good performance in different fields, such as translation and conversational AI. These can be in the order of trillions of parameters. Therefore, in order to attain reasonable training times, we need accelerators, such as GPU and TPU. We often encounter heterogeneity in GPU clusters, and interconnects are partitioned into high-bandwidth islands in each machine and low-bandwidth across machines, limiting training speeds and suboptimal hardware utilization. This also affects memory planning, and frequent memory defragmentations significantly slow training. This also translates into capital and operational costs.</p>
<p>Strategies such as Distributed Data Parallelism and Fully Sharded Data Parallelism have the accelerators split the weights and synchronize the gradients, with communication volumes proportional to the size of the model (For example, <a rel="noopener external" target="_blank" href="https://proceedings.mlr.press/v202/wang23t/wang23t.pdf">training a GPT-J-6B with 10B tokens on 4 machines would require 915 TB of data transferred!</a>. <a rel="noopener external" target="_blank" href="https://arxiv.org/pdf/2403.03507">LlaMa pre-training with 7 billion parameters uses over 58 GB of memory to store parameters, activations, and gradients</a>). This makes gradient synchronization require expensive high-speed interconnects, forcing all devices to be in the same physical space. Reducing communication costs by over an order of magnitude could not only reduce costs or training times, but also allow for the use of more distributed hardware.</p>
<p>Some techniques used to reduce memory footprint and communication costs are:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * [Sparsification and compression](https://proceedings.mlr.press/v202/wang23t/wang23t.pdf)</span></span>
<span class="giallo-l"><span>    * [Low-rank projection of gradients](https://arxiv.org/pdf/2403.03507)</span></span>
<span class="giallo-l"><span>    * [Federated averaging](https://proceedings.mlr.press/v54/mcmahan17a/mcmahan17a.pdf)</span></span></code></pre>
<p>In this blog post, we will discuss <a rel="noopener external" target="_blank" href="https://arxiv.org/pdf/2411.19870">DeMo</a>, recently released by <a rel="noopener external" target="_blank" href="https://nousresearch.com/">Nous Research</a>, which provides significant savings in communication and memory use, allowing to train LLMs with poorer connections and less powerful hardware.</p>
<h2 id="nous-research">Nous Research</h2>
<p>Nous Research is dedicated to researching human-centric language models and simulators, focusing on areas including model architecture, data synthesis, fine-tuning, and reasoning, all aimed at aligning AI systems with real-world user experiences. Four months ago, they released a preliminary report on <a rel="noopener external" target="_blank" href="https://github.com/NousResearch/DisTrO/blob/main/A_Preliminary_Report_on_DisTrO.pdf">DisTro</a>, a family of architecture-agnostic and network-agnostic optimizers, significantly reducing the communication costs by several orders of magnitude, which enables efficient distributed training of AI.</p>
<h2 id="working-hypothesis">Working hypothesis</h2>
<p>The paper shows that gradients for very large LLM exhibit both redundancy and high compressibility. This is the core insight enabling DeMo. It is based on the following three observations:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. The fast-moving components of momentum exhibit high spatial auto-correlation with a small number of principal components.</span></span>
<span class="giallo-l"><span>    2. Fast-moving momentum components show low temporal variance and should be used to update the parameters immediately. The slow-moving components exhibit high temporal variance and benefit from temporal smoothing.</span></span>
<span class="giallo-l"><span>    3. Slow-moving momentum components are crucial for long-term convergence and should be preserved rather than filtered out.</span></span></code></pre>
<p>Using these conjectures, the authors modify the SGD method with momentum to decouple momentum between the different accelerators. After updating the momentum, the fast components $q$ of momentum are extracted using a discrete cosine transform (DCT), and these components are shared with minimal communication.</p>
<h2 id="how-does-demo-work">How does DeMo work?</h2>
<p>The starting point is the Stochastic Gradient Descent (SGD) with momentum algorithm. Instead of computing the overall gradient, we will compute local gradients and use them to update the (decoupled) momentum. Then, we will extract the $k$ fastest components for each momentum and subtract them from the decoupled momentum. Finally, we will communicate and synchronize all the fast components and update the parameters using this synchronized gradient. This is the algorithm as described in the <a rel="noopener external" target="_blank" href="https://arxiv.org/pdf/2411.19870">paper</a>:<br />
<img src="/images/external/SJeEXz07ye.png" alt="Screenshot 2024-12-04 at 2.35.32 PM" /></p>
<p>The extraction of the fast components is critical for the algorithm’s performance. While the Kosambi–Karhunen–Loève Transform provides a way to achieve the decorrelation, separation, and extraction of the main components, the DCT offers an excellent approximation under the hypothesis provided above. The advantages of DCT lie in its efficient computation and high degree of parallelization. Besides, it is computed on a fixed orthogonal basis, which allows us to decode a DCT-encoded signal efficiently without additional information.</p>
<p>We can work with each momentum tensor as a d-dimensional autocorrelated signal, chunk them, and apply the DCT to each, extracting the highest $k$ values and their frequencies. This creates two tensors, one containing the frequencies (using an index) and the other keeping the amplitude (using a floating point number). In the DCT, the frequencies are given by $2\pi i/N$, so giving $i$ suffices to specify the frequency, so we would get pairs $(i, A)$ indicating the frequency and amplitude of the fastest components. We can then perform the inverse DCT with these tensors to recover the values of the components, $q_t$, and remove these values from the momentum (fourth step of the algorithm).</p>
<p>After gathering all the fastest local components, we are ready to synchronize them. The first step is to average the amplitudes over repeated frequencies (if the frequency given by the index 11, corresponding to $2\pi 11/N$, is repeated in the fastest components of a local gradient). In the second step, we perform the inverse DCT to recover the values of the fastest components of the global gradient, $Q_t$. The advantage is that if we choose the parameters appropriately, the number of fastest components we have to share is significantly smaller than the gradient.</p>
<p>The experimental results show that DeMo can reduce communication costs by at least one order of magnitude compared to AdamW, without noticeable changes in convergence.</p>
<h2 id="summary">Summary</h2>
<p>This post introduced basic concepts related to machine learning and LLM, explaining the objectives, strategies, and challenges that arise when training very large models. The need to split parameters and computation among several accelerators introduces the need for specialized connections, having all devices in the same physical place. Using empirical observations from training LLMs, Nous Research proposed DeMo, leveraging the DCT to extract the fastest components and reduce the amount of data the accelerators have to share. The experimental results show a reduction of at least an order of magnitude with respect to AdamW (depending on the choice of parameters, it can be higher), allowing for the use of networks with poorer bandwidth and heterogeneous hardware to train LLMs, reducing both capital and operational costs.</p>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
