<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fully-homomorphic encryption, zero-knowledge proofs, and multiparty computation - LambdaClass Blog</title>
    <meta name="description" content="ZKP can provide integrity of computations, FHE allows data sharing and calculation without compromising it and MPC gives the power to delegate expensive computations to other parties. In this post, we explain the basic ideas behind these primitives.">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">Fully-homomorphic encryption, zero-knowledge proofs, and multiparty computation</h1>
        
        <div class="page-meta">
            <time datetime="2022-12-16">December 16, 2022</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <h2 id="introduction">Introduction</h2>
<p>Cloud computing and storage have changed the way businesses and people use, store and manage their data. Data is securely stored in an encrypted form, typically using a <a rel="noopener external" target="_blank" href="https://www.entropy1729.com/symmetric-encryption/">symmetric key encryption scheme</a>, such as AES or ChaCha20. However, to perform data analytics, we have to either give the key to the server so that it can decrypt it or we have to download it, decrypt it, and run the calculations on our own, which can be costly, requiring lots of time or memory. Fully homomorphic encryption (FHE) allows us to delegate computations involving encrypted data to untrusted third parties, without any need to decrypt them first.</p>
<p>Even if this is a very powerful cryptographic primitive, we still face a big challenge: how do we know that the third party performed the calculation it was supposed to do? This is where zero-knowledge proofs (ZKP) come into play. ZKP allow us to prove the integrity of a given computation, without the need to re-execute it. <a rel="noopener external" target="_blank" href="https://www.entropy1729.com/the-hunting-of-the-zk-snark/">zk-SNARKs</a> (succinct non-interactive arguments of knowledge) yield short proofs which can be verified very fast and have applications in decentralized ledgers (solving both privacy and scalability issues) and <a rel="noopener external" target="_blank" href="https://www.entropy1729.com/decentralized-private-computation-zexe-and-veri-zexe/">decentralized private computations</a>. They also face some challenges: generating proofs for arbitrary computations can be expensive and users with less powerful devices may not be able to generate them. Many zk-SNARKs require trusted setups, which should be generated by an honest party to ensure that nobody can cheat and generate fake proofs.</p>
<p>Both of them can be solved by multiparty computation (MPC). In this scheme, the generation of the proof or the establishment of the trusted setup is entrusted to various parties, which could have partial access to the data. In the case of setup ceremonies, as long as one of the parties involved is honest, the setup is secure. MPC can also be used, with decentralized ledgers, to ensure that anyone can participate in setup ceremonies and prevent malicious parties from blocking honest participants, using proofs with transparent setups (such as STARKs - scalable, transparent argument of knowledge).</p>
<p>Proof generation can be carried out by multiple servers, each of them having partial information on the secret inputs. Each party can submit proof attesting to the correctness of the proof generation protocol. Multiparty computation can also be used to perform calculations among different parties, each of them having different pieces of information relevant to the problem, such as financial information between banks or health-related information for health service providers. FHE helps parties share information and make calculations without revealing it or train machine learning models without compromising sensitive data.</p>
<p>It is clear from all the above that FHE, ZKP, and MPC have many points in common and each has something to offer to the other. ZKP can provide integrity of computations, FHE allows data sharing and calculation without compromising it and MPC gives us the power to delegate expensive computations to other parties. These open the doors for many new and exciting applications in finance, health, and medical sectors, with an emphasis on data privacy and decentralization.</p>
<p>We will now explain the basic idea behind each of these primitives.</p>
<h2 id="fully-homomorphic-encryption">Fully Homomorphic encryption</h2>
<p>Fully homomorphic encryption is a form of encryption where we can perform operations with encrypted data and the result of those operations is the encrypted form of an operation involving the ciphertext. For example, in the <a rel="noopener external" target="_blank" href="https://www.entropy1729.com/how-to-create-your-own-crappy-rsa-as-a-software-developer/">RSA cryptosystem</a>, we encrypt a message <em>m</em> using the public key by taking</p>
<p><em>E(m)=m e(</em> mod _ <em>n</em>)_</p>
<p>Now suppose that we have <em>m 1</em>,<em>m 2</em> numbers and we want to compute their product <em>m 1</em>√ó <em>m 2</em>. We can see that if we perform the product and then encrypt it, we get</p>
<p><em>E(m 1</em>√ó <em>m 2</em>)=(<em>m 1</em>√ó <em>m 2</em>)e  (mod   <em>n</em>)</p>
<p>If we take the product of the encrypted forms of m1,m2, then</p>
<p><em>E(m 1)</em>√ó <em>E(m 2</em>)=<em>m e1</em>√ó <em>m e2</em>=(<em>m 1</em>√ó <em>m 2</em>)e   (mod <em>n</em>)</p>
<p>which is the same as calculating first the product and then encrypting. The operation in the encrypted space need not be the same as the one in the original. Given this property of the RSA cryptosystem, many researchers started wondering whether it could be possible to build a fully homomorphic encryption scheme. The first FHE scheme was presented in 2009 by <a rel="noopener external" target="_blank" href="https://crypto.stanford.edu/craig/craig-thesis.pdf">Craig Gentry</a>.</p>
<h3 id="math-interlude-homomorphisms">Math interlude: Homomorphisms</h3>
<p>To be more precise, a homomorphism is a function between two <a rel="noopener external" target="_blank" href="https://www.entropy1729.com/math-survival-kit-for-developers/"> algebraic structures</a> (such as two groups, two rings, two vector spaces) and preserves their structure. If you had a course on linear algebra, linear transformations are examples of homomorphisms. In the context of groups, suppose we have two groups (ùîæ1,‚ãÖ) and (ùîæ2,‚äï), each with their binary operation (it could be multiplication, addition, <a rel="noopener external" target="_blank" href="https://www.entropy1729.com/what-every-dev-needs-to-know-about-elliptic-curves/"> elliptic curve addition</a>, function composition, etc). A function <em>f</em> :ùîæ1‚Üíùîæ2 is an homomorphism if, given <em>x</em> ,<em>y</em> in ùîæ1 we have</p>
<p><em>f(x‚ãÖy)  = f(x)</em> ‚äï <em>f(y)</em></p>
<p>Note that the operation between the images <em>f(x),f(y)</em> is the operation over ùîæ2. We also saw examples of homomorphisms between rings, when we defined modular arithmetic: we have a function preserving addition and multiplication from the set of integers with the usual operations, (‚Ñ§,+,√ó) and the ring of integers modulo <em>p</em> , (‚Ñ§/<em>p</em> ‚Ñ§,‚äï,‚ãÖ) (we use different symbols for addition and multiplication to remember that these are modulo <em>p</em>). For example, if we take <em>p</em>  = 7, we have ‚Ñ§/<em>p</em> ‚Ñ§={0,1,2,3,4,5,6}. We can see that: ‚àí5+3=‚àí2. This is related to 2 ‚äï 3 ‚â° 5 (mod7), where 2 is the element corresponding to ‚àí5 in ‚Ñ§/<em>p</em> ‚Ñ§, 3 corresponds to itself and 5 is congruent to ‚àí2.‚àí3√ó4=‚àí12 which relates to 4‚ãÖ4‚â°2(mod7) in the same way as before.</p>
<p>It is important to see that homomorphisms are not necessarily one-to-one functions (the last ring homomorphism shows a clear example). If the homomorphism is a bijective function, it is called an isomorphism. The following is an example of an isomorphism from the real numbers ‚Ñù with addition to the positive real numbers equipped with multiplication, ‚Ñù +,  <em>f</em>  : ‚Ñù‚Üí‚Ñù+ , <em>f  (x)</em> = exp <em>(x)</em>  , with its inverse, <em>f ‚àí1</em> : ‚Ñù+‚Üí  ‚Ñù,  <em>f</em> ‚àí1 (<em>z</em>) = ln(<em>z</em>). You can easily check that <em>f   (x + y )=f (x) ‚ãÖ f (y)</em></p>
<p>In the context of cryptography, we would like to have encryption or commitment schemes preserving some operations. For example, the <a rel="noopener external" target="_blank" href="https://www.entropy1729.com/the-hunting-of-the-zk-snark/"> Kate-Zaverucha-Goldberg </a> (KZG) commitment scheme is additively homomorphic. The commitment takes polynomials (which we can think of as a group with ordinary polynomial addition, (‚Ñô,+)) and maps them into elliptic curve points (which also have a group structure, with elliptic curve addition, (ùîæ,‚äï)). We can verify that</p>
<p>cm(<em>p</em> 1 (<em>x</em>)  +  <em>p 2</em>(x))  =  cm(<em>p <em>1   (<em>x</em>))  ‚äï  cm(<em>p 2</em>(x))</em></em></p>
<p>This property is useful for <a rel="noopener external" target="_blank" href="https://www.entropy1729.com/proof-aggregation-schemes-snarkpack-and-aplonk/">proof aggregation</a> and <a rel="noopener external" target="_blank" href="https://www.entropy1729.com/incrementally-verifiable-computation-nova/">folding schemes</a>. Elliptic curve pairings also provide some way to compute multiplications between polynomials in committed form (using KZG).</p>
<p>To be able to construct an FHE scheme we need not only preserve operations but also have a way to decipher the result.</p>
<h2 id="fhe-fundamentals">FHE fundamentals</h2>
<p>There are many libraries for FHE nowadays, such as <a rel="noopener external" target="_blank" href="https://www.openfhe.org/">OpenFHE</a>, <a rel="noopener external" target="_blank" href="https://www.microsoft.com/en-us/research/project/microsoft-seal/">Microsoft SEAL</a>, <a rel="noopener external" target="_blank" href="https://github.com/cpeikert/Lol">Œõ‚àòŒª</a> and <a rel="noopener external" target="_blank" href="https://homomorphicencryption.org/introduction/">many more</a>. With FHE you can make private queries to search engines or pages, such as Wikipedia; see <a rel="noopener external" target="_blank" href="https://spiralwiki.com/">here</a>.</p>
<p>FHE schemes are based on lattice cryptography. A lattice is given by linear combinations with integer coefficients of some base vectors. To fix ideas, imagine we have two vectors <em>e x</em> = (1,0) and <em>e y</em> = (0,1) and we consider all possible combinations <em>p  = xex + yey</em> with <em>x</em> ,<em>y</em> in ‚Ñ§, yielding points in space (0,0),(1,0),(1,1),(‚àí1,‚àí2),‚Ä¶. A lattice looks like <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Lattice_problem#/media/File:SVP.svg"> this</a>. Ideal lattices correspond to <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Ideal_(ring_theory)">ideals in polynomial rings</a>, inheriting the natural addition and multiplication operations of the ring (Ideals generalize the idea behind certain subsets of the integers, such as even numbers. The addition of any two even numbers is always even and, whenever we multiply any integer by an even, the result is also even -an absorption property-).</p>
<p>To build an FHE scheme we could picture having a ciphertext with some small attached to it, such that the decryption works as long as the noise is below a certain threshold. If we have ways to homomorphically multiply and add ciphertexts, but at the expense of increasing the noise parameters accordingly, that is, _E(a  + b) =E (a) <em>‚äï _  E (b)</em> and <em>E(a√ób)=E(a)‚ãÖE(b)</em>. We call this a somewhat homomorphic encryption scheme (SHE). If we could add a ‚Äúrecrypt‚Äù algorithm, which can take a given ciphertext <em>E(m)</em> and reduce its noise, obtaining a new ciphertext <em>E‚Ä≤(m)</em> that also encrypts <em>m</em> , then we can obtain an FHE scheme.</p>
<p>The SHE scheme can handle circuits of a certain depth (imagine this as the number of times you can multiply or add before the noise becomes too large). The SHE can be modified to have its decryption circuit have a lower multiplicative depth, making it ‚Äúbootstrappable‚Äù and thus transforming it into an FHE scheme.</p>
<p>Some common schemes for FHE are:</p>
<ul>
<li>Brakerski-Fan-Vercauteren (BFV) and Brakerski-Gentry-Vaikuntanathan (BGV) for integer arithmetic.</li>
<li>Cheon-Kim-Kim-Song (CKKS) for real number arithmetic.</li>
<li>Ducas-Micciancio (DM) and Chillotti-Gama-Georgieva-Izabachene (CGGI) for boolean circuits and arbitrary functions using lookup tables.</li>
</ul>
<p>Many cryptographic primitives, such as public key cryptography, are based on the hardness or intractability of mathematical problems, such as <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Integer_factorization">integer factorization</a> (RSA) or the <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Discrete_logarithm">discrete logarithm problem</a> (elliptic curve cryptography). These problems cannot be solved efficiently with current computers (at least, provided that the integers involved are big enough or the groups have a large number of elements). However, quantum computers could easily handle these problems if certain conditions are met, via <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Shor%27s_algorithm">Shor‚Äôs algorithm</a>. FHE is based on the <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Lattice_problem">shortest vector problem</a> or <a rel="noopener external" target="_blank" href="http://homomorphicencryption.org/wp-content/uploads/2018/11/HomomorphicEncryptionStandardv1.1.pdf">ring learning-with-error</a> (RLWE) problem, which is an NP-hard problem that cannot be tackled with Shor‚Äôs algorithm (FHE is considered to be quantum resistant).</p>
<h2 id="zero-knowledge-proofs">Zero-knowledge proofs</h2>
<p>Zero-knowledge proofs (ZKP) have been gaining a lot of attention during the last decade, especially after the first efficient SNARK constructions. ZKP play an important role in the solution of two of the main challenges in decentralized ledgers: scalability and privacy. To validate transactions, nodes have to re-execute them, leading to bottlenecks. Besides, all the information in the ledger is public, which can leak sensitive information about individuals and organizations.</p>
<p>zk-SNARKs allow one party to prove a statement, without revealing anything other than the validity of the statement. For example, we can prove that we have a given secret key, without revealing it. We can also prove that we have executed some transaction or computation, without exposing secret or sensitive information. An important property of SNARKs is their succinctness, which means that proofs:</p>
<ul>
<li>Are short (occupy little memory, about 1 kB for some SNARKs).</li>
<li>Are fast to verify (typically, in the order of milliseconds).</li>
</ul>
<p>Ethereum has been adding zero-knowledge proof technologies recently to solve scalability issues. Zcash implemented ZKP to provide private transactions, while Aleo uses them to enable running private computations in a decentralized way.</p>
<p>How do SNARKs work under the hood? Even if there are many different constructions (such as Marlin, Plonk, Halo, and STARKs), they have a common recipe. The building blocks of SNARKs are polynomial interactive oracle proofs (PIOP) and polynomial commitment schemes (PCS). Depending on the choices made, the resulting SNARK has different properties and requirements. For example, it may be transparent (does not need a trusted setup), post-quantum secure, need special (pairing-friendly) elliptic curves, take longer times to generate proofs, have shorter proofs (less than 1 kB), allow for easy recursion, etc. A comparison between different polynomial commitment schemes is shown <a rel="noopener external" target="_blank" href="https://hackernoon.com/kzg10-ipa-fri-and-darks-analysis-of-polynomial-commitment-schemes">here</a>.</p>
<p>To be able to construct the proof, we first need to transform our computation into some SNARK-friendly format. We can prove the correctness of our execution by reducing it to some kind of NP-complete problem, such as graph coloring or circuit satisfiability. We will work with arithmetic circuits and the transformation of a program into a circuit is known as arithmetization. There are different forms or strategies for doing this transformation; an overview of the most commonly used is <a rel="noopener external" target="_blank" href="https://www.entropy1729.com/arithmetization-schemes-for-zk-snarks/">here</a>.</p>
<h2 id="multiparty-computation">Multiparty computation</h2>
<p>In a secure multiparty computation, a group of participants, <em>p 1,p2,‚Ä¶,pm</em>, each having some secret information <em>s 1,s2,‚Ä¶sm</em>, want to compute a certain function that requires the knowledge of that secret information. For example, we could have m employees wanting to know their average salary without revealing their income. One easy way to do so would be that all of them trust another party and each sends their secret information and the ‚Äútrusted‚Äù party computes the average. The drawback: the ‚Äútrusted‚Äù party learns all the information and could leverage it. Or perhaps he is honest, but he gets hacked and an attacker obtains everything.</p>
<p>Luckily, there is a useful cryptographic primitive to deal with cases like these: <a rel="noopener external" target="_blank" href="https://www.geeksforgeeks.org/additive-secret-sharing-and-share-proactivization-using-python/"> additive secret sharing</a>. Each of the participants can break their secret <em>s k</em> into <em>m</em> shares in such a way that no shareholder can, on his own, learn the secret. To be able to reconstruct the secret, all of the other parties have to collude and share their part. In the example above, each employee can break his salary, <em>s k</em> into <em>m</em> different, random shares. For example, if we have 4 employees and employee A earns 4500, he can have 4 shares, <em>s Ai</em>: -1200, 1500, 3600, 600, such that ‚àëi sAi_ = 4500. He keeps one share and distributes the rest to B, C, and D. In turn, the rest break their secret and divide it. Afterward, each participant sums all the shares he has, obtaining a partial sum, <em>s p,A</em> = ‚àëk sk,A, and then shares these partial sums to compute the final average.</p>
<p>Secret sharing is secure whenever parties knowing at most <em>m</em>  ‚àí 1 have no more information than anyone with no shares at all.</p>
<p>Now, how can we ensure that each party does what it is supposed to do? ZKP give us a way to guarantee that each participant does the computation as expected, by submitting proof that attests to the correct execution. If he cheats, the proof should fail and he could be penalized. Early MPC protocols had significant overhead; the last decade has seen many advances, making it efficient and leading to many applications.</p>
<h2 id="summary">Summary</h2>
<p>Fully homomorphic encryption, zero-knowledge proofs, and multiparty computations are important cryptographic primitives that have been gaining more and more attention in recent years, with the introduction of decentralized ledgers and increasing concern over data privacy. Each has its unique features and applications and has something to offer to the other primitives. FHE allows us to make cloud computations on encrypted data without needing to hand our key to the server, which prevents third parties from gaining access to the specific contents of the data. ZKP allow us to prove the correctness of a given computation by submitting a short proof, which can be quickly verified. This is seen as one of the greatest tools to solve the privacy and scalability issues of decentralized ledgers. Multiparty computation helps us distribute a complex computation or calculate something when all the inputs are distributed among several parties in a secure way; it has applications for voting, private auctions, bidding, etc. FHE can help us improve existing ZKP, which in turn can make multiparty computation much simpler and more secure. In turn, MPC is needed for the setup ceremonies of zk-SNARKs and can also help provers reduce their proof generation time by delegating them to untrusted powerful servers. ZKP can also help us ensure that the computations involving encrypted data are carried out correctly. All these fields have seen great advances over the last decade and each will help the others advance, leading to new interesting applications, with a greater focus on decentralization and privacy. In upcoming posts, we will cover in more depth the mathematical foundations of FHE and further applications of MPC and ZKP.</p>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
