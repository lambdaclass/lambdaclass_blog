<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mina to Ethereum ZK bridge - LambdaClass Blog</title>
    <meta name="description" content="Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">Mina to Ethereum ZK bridge</h1>
        
        <div class="page-meta">
            <time datetime="2024-02-05">February 05, 2024</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <h2 id="introduction">Introduction</h2>
<p>During the last few months, we have been developing a <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/mina_bridge">bridge between Mina and Ethereum</a>. <a rel="noopener external" target="_blank" href="https://minaprotocol.com/">Mina</a> is a layer-1 blockchain that uses zero-knowledge proofs (zk-SNARKs) to maintain its <a rel="noopener external" target="_blank" href="https://minaprotocol.com/blog/22kb-sized-blockchain-a-technical-reference">size at 22 kB</a>. The bridge serves two purposes:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. Allowing cross-chain transactions seamlessly.</span></span>
<span class="giallo-l"><span>    2. Allowing applications to leverage Mina&#39;s zero-knowledge capabilities and expand their functionalities across multiple chains.</span></span></code></pre>
<p>Due to $2$, users can simply prove things off-chain and verify them on-chain in Ethereum.</p>
<p>At its core, Mina uses a proof system called <a rel="noopener external" target="_blank" href="https://o1-labs.github.io/proof-systems/specs/kimchi.html">Kimchi</a>, which is a variant of Plonk with many optimizations and uses an inner product argument (IPA) polynomial commitment scheme. Its key optimizations are custom gates for foreign field addition and multiplication, Keccak, Poseidon, and lookup arguments. Above that, we have Pickles, which is Mina’s inductive SNARK composition, enabling a flexible way to have <a href="/incrementally-verifiable-computation-nova/">incrementally verifiable computation</a>. This construction allows us to generate a proof that attests to the validity of the transition from state $S_n$ to state $S_{n + 1}$ while checking a proof that the previous step was correct. While this helps Mina achieve its succinctness, verifying these proofs in Ethereum is very expensive.</p>
<p>Currently, pairing-based SNARKs (such as those using KZG) have cheaper verification costs in Ethereum, which makes this option attractive. To “wrap” Mina state proofs, we can generate a SNARK to verify a Mina proof obtained with IPA, using a variant of Kimchi with the KZG commitment scheme. To do so, we must first express all the verification logic of the Kimchi-IPA proof as a circuit, then use this circuit, the proof, and other public input and generate a proof using Kimchi-KZG. This is more easily said than done. First, we must express all the verification operations as an arithmetic circuit. The good thing is that we can express even complex operations such as MSM using elliptic curve gates and lookup arguments. The bad thing is that the equations are expressed over Ethereum’s BN-254 scalar field, which differs from the Pasta fields. This means we will have to do many foreign field operations, making the SNARK quite expensive.</p>
<p>This post will provide an overview of the bridge, Kimchi, and the KZG verifier. For an introduction to some of the topics, see <a href="/all-you-wanted-to-know-about-plonk/">Plonk</a>, <a href="/ipa-and-a-polynomial-commitment-scheme/">IPA</a>, and <a href="/lookups/">lookups</a>.</p>
<h2 id="the-bridge">The Bridge</h2>
<p>The bridge has the following components:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. A backend service periodically wraps and posts Mina&#39;s state proofs to an EVM chain.</span></span>
<span class="giallo-l"><span>    2. A &quot;wrapping&quot; module for Mina&#39;s proofs to make them easy to verify on the EVM.</span></span>
<span class="giallo-l"><span>    3. The solidity logic for verifying the wrapped Mina state proofs in the EVM.</span></span>
<span class="giallo-l"><span>    4. Browser utility for smart contracts.</span></span>
<span class="giallo-l"><span>    5. A solidity contract utility that smart contract developers or users can execute on an EVM chain to feed in a Mina state lookup proof that will check the state lookup against the latest posted Mina state proof to verify that this Mina state is valid.</span></span></code></pre>
<p>The flow is shown in the following picture. For more details related to the architecture, see the <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/mina_bridge/blob/main/README.md">bridge’s readme</a>.<br />
<img src="/images/external/HJ6DjwYcT.jpg" alt="flow" /></p>
<h2 id="snarks">SNARKs</h2>
<p>As mentioned, Mina’s proof system is Kimchi, a modified version of Plonk, using IPA and working over a pair of elliptic curves, Pallas and Vesta (shortened to Pasta curves). IPA and Pasta curves enable easy recursion but at the expense of longer proofs than KZG-based SNARKs. Verifying and storing these proofs in Ethereum is expensive, so we need to obtain a new type of proof that can be checked less expensively in Ethereum. Let’s dive into Kimchi, Pickes, and KZG commitments.</p>
<h2 id="kimchi"><a rel="noopener external" target="_blank" href="https://o1-labs.github.io/proof-systems/kimchi/overview.html">Kimchi</a></h2>
<p>This is a modified version of <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2019/953">Plonk</a>. There are three types of arguments:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * Custom gates.</span></span>
<span class="giallo-l"><span>    * Permutation.</span></span>
<span class="giallo-l"><span>    * Lookups.</span></span></code></pre>
<p>These arguments are translated into several polynomials, which must evaluate to zero over some set. Luckily, we can check that all the polynomials evaluate to zero over the set by doing a random linear combination. Say, for example, that $p_1 , p_2 … p_n$ all evaluate to zero over the set $S = { 1, 2, … , m}$. We can have the verifier sample $\alpha$ and obtain<br />
$p (x) = \alpha p_1 (x) + \alpha^2 p_2 (x) + \dots + \alpha^n p_n (x)$<br />
which should also evaluate to zero. To see that the polynomial has that property, we can show that $p(x)$ is divisible by the polynomial vanishing on S, $Z_S (x)$. Another way to state this is that there is some polynomial $q(x)$ such that $p(x) = Z_S (x) q(x)$. Moreover, if we decide to perform this check at just one random point $\zeta$ from a very large set, then, with high probability, we have that the previous equality holds for all the set.</p>
<p>The ingredients are the circuit specification (the gates and the connections/wirings) and the execution trace. The execution trace in Kimchi has input/output registers (7) plus advice registers (8). The circuit is known beforehand and represents a given program/computation. The execution trace depends on the particular execution of the program (for example, we can run the same program with different inputs).</p>
<p>The following tables describe the circuit:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * Gates: Generic, Poseidon, Elliptic Curve Addition, Endo Scalar, Endo Scalar Multiplication, Scalar Multiplication, Range Check, Foreign Field Addition, Foreign Field Multiplication, Rotation, and XOR.</span></span>
<span class="giallo-l"><span>    * Coefficients. These are only used in Poseidon and generic gates.</span></span>
<span class="giallo-l"><span>    * Wirings (also Permutations or Sigmas)</span></span>
<span class="giallo-l"><span>    * Lookup tables</span></span>
<span class="giallo-l"><span>    * Lookup selectors</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>pub struct CircuitGate&lt;F: PrimeField&gt; {</span></span>
<span class="giallo-l"><span>    /// type of the gate</span></span>
<span class="giallo-l"><span>    pub typ: GateType,</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    /// gate wiring (for each cell, what cell it is wired to)</span></span>
<span class="giallo-l"><span>    pub wires: GateWires,</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    /// public selector polynomials that can used as handy coefficients in gates</span></span>
<span class="giallo-l"><span>    #[serde_as(as = &quot;Vec&lt;o1_utils::serialization::SerdeAs&gt;&quot;)]</span></span>
<span class="giallo-l"><span>    pub coeffs: Vec&lt;F&gt;,</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>Kimchi contains three main algorithms:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. Setup: takes the circuit and produces the prover and verifier indexes.</span></span>
<span class="giallo-l"><span>    2. Proof creation: takes the circuit and the prover index and outputs a proof.</span></span>
<span class="giallo-l"><span>    3. Proof verification: takes the proof and the verifier index and checks the proof.</span></span></code></pre>
<p>The steps performed by the prover to obtain the proof are listed <a rel="noopener external" target="_blank" href="https://o1-labs.github.io/proof-systems/specs/kimchi.html#proof-creation">here</a>. The verification follows the steps shown <a rel="noopener external" target="_blank" href="https://o1-labs.github.io/proof-systems/specs/kimchi.html#proof-verification">here</a>.</p>
<h2 id="pickles">Pickles</h2>
<p>Pickles uses the Pasta curves to deliver incrementally verifiable computation efficiently. The Pasta curves are also known as:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * Tick/Step (Vesta), handling blocks and transactions&#39; proofs.</span></span>
<span class="giallo-l"><span>    * Tock/Wrap (Pallas), handling signatures and performing recursive verifications.</span></span></code></pre>
<p>Tock is used to prove the verification of a Tick proof and outputs a Tick proof. Tick is used to prove the verification of a Tock proof and outputs a Tock proof.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * $\mathrm{Prove_{tock} ( Verify(Tick) ) = Tick_{proof}}$</span></span>
<span class="giallo-l"><span>    * $\mathrm{Prove_{tick} (Verify(Tock) ) = Tock_{proof}}$</span></span></code></pre>
<p>Both Tick and Tock can verify at most two proofs of the opposite kind. Pickles contains two components: fast (1 - 30 ms) and slow (100 ms - 1 s) verifiers. Given a proof $\pi_1$, we first execute the fast verifier, and the update algorithm takes the previous proof state, $S_0$, and $\pi_1$ and generates the next proof state, $S_1$. If we have an incoming $\pi_2$, we do not execute the slow verifier, beginning a new cumulative phase. We run the fast verifier on $\pi_2$ and update the proof state from $S_1$ to $S_2$. If there are no more incoming proofs, we use the slow verifier to check the last state proof $S_n$.</p>
<h2 id="kzg-verifier-solidity">KZG verifier solidity</h2>
<p>The code for the verifier in solidity is <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/mina_bridge/blob/main/eth_verifier/src/Verifier.sol">here</a>. The verifier can be divided into two large parts:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * Partial verification.</span></span>
<span class="giallo-l"><span>    * Final verification.</span></span></code></pre>
<p>The first handles checks such as the correct length of evaluations and commitments regenerates the random challenges using Fiat-Shamir and uses the claimed evaluations to see whether the gate and permutation constraints are valid. The second part checks the commitments by calling the pairing check function. In a naïve KZG verification, we must compute one pairing for every evaluation we want to check. However, we can randomly combine the commitments and evaluations to perform just one pairing check.</p>
<p>The working principle behind the verification of the KZG evaluation proof is the following: we have a commitment to a polynomial, $p(x)$, an evaluation point, $\zeta$, a claimed evaluation, $v = p(\zeta)$, and the evaluation proof, $\pi = \mathrm{cm}(q)$, which is the commitment to a quotient polynomial, $q(x)$. If the evaluation is correct, then $p(x) - v$ should be divisible by $x - \zeta$, that is<br />
$p(x) - v = (x - z) q(x)$<br />
We cannot do this check directly since we have access only to the commitments and not the whole polynomials. We have $\mathrm{cm}(p) = p(s) g_1$ and $\mathrm{cm}(q) = q(s) g_1$, which are points on an elliptic curve. We could attempt to check everything at just one point, $s$, and, if the two sides match, then with overwhelming probability, the polynomial was evaluated correctly. The pairing is a function $e(x,y)$ with two properties:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. Bilinear: $e(x_1+x_2,y_1+y_2) = e(x_1 , y_1 )e(x_2 , y_2 )e(x_1 , y_2 )e(x_2 ,y_1 )$</span></span>
<span class="giallo-l"><span>    2. Non-degenerate: if $e(x,y) = 1$, then $x$ or $y$ are the point at infinity (neutral element for elliptic curve addition).</span></span></code></pre>
<p>It follows from the bilinearity property that<br />
$e( p(s) g_1 - v g_1 , g_2 ) = e(g_1 , g_2 )^{p(s) - v}$<br />
Similarly,<br />
$e( q(s) g_1 , s g_2 - \zeta g_2 ) = e(g_1 , g_2 )^{q(s)(s - \zeta)}$<br />
Since neither $g_1$ nor $g_2$ are the point at infinity (because they are generators of the whole group), $e (g_1 , g_2) \neq 1$, and therefore, if both pairings are equal, then it follows that<br />
$p(s) - v = q(s) (s - \zeta)$<br />
The EVM has a function, pairing check, which computes the product of both pairings and verifies that it is equal to one. Because of this condition, we rewrite the second pairing, negating the commitment to the quotient,<br />
$e( - q(s) g_1 , s g_2 - \zeta g_2 ) = e(g_1 , g_2 )^{ - q(s)(s - \zeta)}$</p>
<h3 id="batching-evaluation-at-point-zeta-for-several-polynomials">Batching evaluation at point $\zeta$ for several polynomials</h3>
<p>If we have several polynomials $p_1, p_2, … p_n$ and we want to check the evaluation at the same point $\zeta$, we just need to perform a random linear combination for each of these elements:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * Commitments to $p_k$: $\mathrm{cm}(p) = \sum \alpha^k \mathrm{cm}(p_k )$</span></span>
<span class="giallo-l"><span>    * Commitments to quotients $q_k$: $\mathrm{cm}(q) = \sum \alpha^k \mathrm{cm}(q_k )$</span></span>
<span class="giallo-l"><span>    * Evaluations: $v = \sum \alpha^k v_k$</span></span></code></pre><h3 id="batching-evaluations-at-several-points-zeta-k-for-one-polynomial">Batching evaluations at several points $\zeta_k$ for one polynomial</h3>
<p>If we need to check that a polynomial evaluates at $\zeta_1$ to $v_1$, at $\zeta_2$ to $v_2$, … and at $\zeta_n$ to $v_n$, we can fuse all these checks into a single one. The steps are as follows:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * Compute the polynomial of degree $n - 1$, $I(x)$, that interpolates the points $(\zeta_k , v_k )$. This means that $I( \zeta_k ) = v_k$ for $k = 1, 2, ... n$. If we have two points only, $I(x) = (v_2 - v_1 ) (\zeta_2 - \zeta_1 )^{- 1} (x - \zeta_1 ) + v_1$, which is the line passing through those two points.</span></span>
<span class="giallo-l"><span>    * The polynomial $p(x) - I(x)$ evaluates to $0$ at $\zeta_k$, which means that $p(x) - I(x)$ is divisible by the polynomial $D(x) = \prod (x - \zeta_k )$(in our two-dimensional case, this is $(x - \zeta_1 )(x - \zeta_2 )$). Compute the quotient $q(x)$ of $p(x) - I(x)$ by $D(x)$ and commit to it.</span></span></code></pre>
<p>We can combine this idea with batch verification for several polynomials and just pay for one pairing check!</p>
<h2 id="conclusions">Conclusions</h2>
<p>This post presented the bridge between the succinct blockchain Mina and Ethereum, allowing seamless cross-chain transactions and dApps to leverage Mina’s zk capabilities. One of the main challenges is related to the verification of Mina’s proofs in Ethereum since they rely on IPA, which is more expensive than those based on KZG. To deal with this, we have to create a wrapper (a program that proves the verification of Mina proofs) to obtain new proofs that can be verified in Ethereum more cost-effectively. We covered the basics of Kimchi (Mina’s proof system) and Pickles (which allows Mina to deliver incrementally verifiable computation, the key component for succinctness) and how KZG commitments work. We also discussed some of the challenges related to foreign field operations. In upcoming posts, we will discuss some of the bridge’s components and the project’s milestones and advances in more depth.</p>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
