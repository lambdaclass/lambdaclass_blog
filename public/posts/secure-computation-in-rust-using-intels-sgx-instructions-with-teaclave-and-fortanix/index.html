<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure computation in Rust: Using Intel&#x27;s SGX instructions with Teaclave and Fortanix - LambdaClass Blog</title>
    <meta name="description" content="TEEs can be thought of as processes that are running &quot;isolated&quot; from the OS and upper layers in a secure part of the CPU. The idea of this is to help to significantly reduce the attack surface. ">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">Secure computation in Rust: Using Intel&#x27;s SGX instructions with Teaclave and Fortanix</h1>
        
        <div class="page-meta">
            <time datetime="2022-05-05">May 05, 2022</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <p>If you have been following this blog you should already know that I am a distributed system and Rust zealot.<br />
I started playing with Rust 2014 since it was implemented in OCaml, a language I love, and because it had green threads similar to the ones of Erlang. At the end of 2014, start of 2015 Rust’s runtime system and green-threading model was removed. I continued using Rust because of its great community and its C + ML roots. In addition to this it is a great complement to Erlang since it is has almost opposite semantics, specially in its error handling philosophy.</p>
<p>At the end of 2017 I started working on the crypto space, mostly because I needed the money. I’ve not been very public about it since I was skeptical of the whole movement. Even if I liked working on the technical problems that appeared on the space I thought that most crypto projects were ponzi-scheme or completely useless for users.</p>
<p>In these years I’ve met great engineers and technologies that made me believe more in the movement. That is one of the reasons why we started working on the zero knowledge proof space. One of this projects we are working with requires high standards of data security and privacy. For this we need to abstract ourselves from potential OS security vulnerabilities hosted in third party servers.<br />
The following blog post follows our journey discovering Intel SGX and it’s integration in the development of Rust applications.</p>
<p>As you can already guess this is a project full of challenges, from performance ones to potential security issues. So we would like to abstract ourselves from potential OS security vulnerabilities that the host devices might have, more so when you deploy your application in the cloud. So we’ve been tasked with deploying essential parts of the project in a specific Trusted Execution Environments (or TEEs for short), Intel’s SGX.</p>
<p>The following blog post follows our journey discovering Intel SGX and its integration in the development of Rust applications.</p>
<p><em>Subscribe to our</em><a href="/#/portal/signup"> <em>newsletter</em></a> <em>to receive news and updates from Not a Monad Tutorial delivered directly to your inbox.</em></p>
<h2 id="introduction">Introduction</h2>
<p>Imagine you are building a piece of software which handles sensitive information. And that you decided to deploy your application in the cloud.</p>
<p>Since our project handles private keys used to access transactions and e-wallets, we need to ensure enhanced confidentiality and integrity, even in the presence of privileged malware at the OS, BIOS, VMM, or SMM layers.</p>
<h3 id="tees">TEEs</h3>
<p>TEEs can be thought of as processes that are running “isolated” from the OS and upper layers in a secure part of the CPU. The idea of this is to help to significantly reduce the attack surface. TEEs aim to ensure a subset of data integrity, code integrity and data privacy, which fits our sensitive data manipulation needs. Each CPU vendor has their own implementation, some of which are:</p>
<ul>
<li>Intel SGX</li>
<li>ARM TrustZone</li>
<li>AMD Secure Encrypted Virtualization</li>
<li>ZAYA TEE for RiscV</li>
</ul>
<p>From now on we’ll be focusing on Intel SGX.</p>
<h3 id="intel-sgx">Intel SGX</h3>
<p>SGX is an Intel ISA extension with TEEs support. The environments are called <strong>enclaves</strong>.</p>
<p>Some important aspects:</p>
<ul>
<li><strong>It’s not possible to read nor write the enclave’s memory space from outside the enclave</strong> , regardless of the privilege level and CPU mode.</li>
<li>In production, it’s not possible to debug enclaves by software nor hardware.</li>
<li>Entering the enclave via function calls, jumps or stack/register manipulation is not possible. To do so you have to use a specific CPU instruction which also does some safety checks ([E]call, [O]call).</li>
<li><strong>Enclave’s memory is encrypted</strong> , and the key used changes on every power cycle. It’s stored within the CPU and is not accessible.</li>
</ul>
<p><img src="/images/external/Lb332Bp.png" alt="" />Source: Microsoft Azure Confidential Computing <a rel="noopener external" target="_blank" href="https://docs.microsoft.com/en-us/azure/confidential-computing/confidential-computing-enclaves">Documentation</a></p>
<p><strong>Warning</strong> : if you are considering developing an SGX application, we’d highly suggest <a rel="noopener external" target="_blank" href="https://github.com/ayeks/SGX-hardware#desktop-cpus-affected-by-the-product-change-notification-from-2015">checking your CPU</a> and whether it has SGX support. Intel’s C++ SDK has some simulation capabilities (as we’ll see later), but those aren’t fully fleshed out. We managed to run in a Macbook Pro some sample projects using Teclave’s simulation mode… but at what cost? So, only if you like stepping on Legos for fun try running SGX in your M1.</p>
<p><img src="/images/external/hqeSchG.png" alt="" /></p>
<h2 id="sgx-rust-development">SGX Rust Development</h2>
<p>The Intel SGX’s SDK is implemented on C++, so usually you’ll implement your application using C/C++ and their <a rel="noopener external" target="_blank" href="https://www.intel.com/content/www/us/en/developer/tools/software-guard-extensions/get-started.html">toolkit</a>.<br />
As a starting point Intel gives a <a rel="noopener external" target="_blank" href="https://github.com/intel/linux-sgx/tree/master/SampleCode">couple of code examples</a> for different implementations.<br />
But, are there any developers worth their salt that want to develop a solid blockchain project in those languages when you’ve got the hip and cool option that is Rust? (in fact, yes) <em>We don’t look forward to that.</em></p>
<p><img src="/images/external/Whhj2XE.png" alt="" /> Recreation of what the Rust SDK developers may have thought</p>
<p>Since our source code is already written in Rust we looked for crates that allow us an easy and seamless integration of our code with the SGX enclaves.<br />
We found 2 alternatives for this, which use different approaches. Both are open source:</p>
<ul>
<li>Teaclave SGX SDK</li>
<li>Fortanix Enclave Development Platform</li>
</ul>
<h2 id="teaclave">Teaclave</h2>
<p>It wraps the Intel SGX’s SDK. You can check their <a rel="noopener external" target="_blank" href="https://github.com/apache/incubator-teaclave-sgx-sdk">GitHub repo</a>.</p>
<p><img src="/images/external/Bd8I1r5.png" alt="" />Source: <a rel="noopener external" target="_blank" href="https://www.trentonsystems.com/blog/what-is-intel-sgx">https://www.trentonsystems.com/blog/what-is-intel-sgx</a></p>
<p>With Teaclave SDK you will split your application into two:<br />
- Trusted, also called the <em>enclave</em>.<br />
- Untrusted, called the <em>app</em>.</p>
<p>Remember, under the hood you’re still using Intel SDK library.</p>
<p><img src="/images/external/ixchGF6.png" alt="" />Source: <a rel="noopener external" target="_blank" href="https://www.infoq.com/presentations/intel-sgx-enclave/">https://www.infoq.com/presentations/intel-sgx-enclave/</a></p>
<p>The Untrusted code is in charge of initializing and shutting down the enclave, and you have to define an interface for the app and the enclave to communicate with each other. During compilation, those interfaces get transformed into [E]calls and [O]calls. In the end you would end up with something like this:</p>
<p><img src="/images/external/rzWrjSw.png" alt="" />Source: Slide from Yu Ding’s <a rel="noopener external" target="_blank" href="https://www.infoq.com/presentations/intel-sgx-enclave/">talk</a> at infoq about Intel SGX enclaves on Rust</p>
<p>But as the saying goes, not everything that shines is gold. The enclave will run under <code>#[no_std]</code>, so keep in mind that your favorite crates might not be supported. However, the maintainers have been porting and developing a bunch of useful crates to work with and of course you can also port the ones you want as well. Among them there’s the <code>libc</code>, the <code>std</code> (or part of it), synchronization primitives (e.g. <code>SgxMutex</code>, <code>SgxRWLock</code>) and more. However, there is not support for async Rust yet.</p>
<p>The repo is populated with some sample projects, which are great to start learning how to structure the project works and some conventions you need to follow and it’s also where you can take some as templates for your own application.</p>
<h3 id="simulation-mode">Simulation Mode</h3>
<p>Since under the hood it uses Intel’s SDK, you still need to meet the necessary requirements. However, Intel also has simulation libraries (although those don’t have all the features implemented) which might come in handy to test your enclave locally despite not having an Intel processor.<br />
You also have available a docker image and you can check the details on how to run it <a rel="noopener external" target="_blank" href="https://github.com/apache/incubator-teaclave-sgx-sdk#running-without-intel-sgx-drivers">here</a>.</p>
<h2 id="fortanix-edp">Fortanix EDP</h2>
<p>Fortanix EDP is developed by a company named <em>Fortanix</em>. From their website we read:</p>
<blockquote>
<p>Fortanix secures sensitive data across public, hybrid, multicloud and private cloud environments, enabling customers to operate even the most sensitive applications in any environment.</p>
</blockquote>
<p>They came up with a different solution to running Rust code on Intel enclaves.</p>
<p><img src="/images/external/M5pt0Zd.png" alt="" />Source: Fortanix EDP <a rel="noopener external" target="_blank" href="https://edp.fortanix.com/docs/concepts/architecture/">architecture documentation</a></p>
<p>First, instead of building an <em>app</em> and an <em>enclave</em> Fortanix EDP helps you build only the enclave and the way of communicating between the app and the enclave is up to you.</p>
<p>The enclave runner is responsible for initializing and shutting down enclaves and handling via a usercall interface the enclave’s needs.</p>
<p>Since it avoids this interfacing between app and enclave, it greatly reduces a lot of bureaucracy regarding project structure and setup. This was one of the benefits considered when <a rel="noopener external" target="_blank" href="https://github.com/apache/tvm/issues/2887">TVM swapped Teaclave for Fortanix</a>. You can also see from this Fortanix <a rel="noopener external" target="_blank" href="https://github.com/fortanix/rust-sgx/tree/master/examples/mpsc-crypto-mining">example crate</a> that only a few lines were added to the <code>Cargo.toml</code>, and the rest is a standard pure Rust project.</p>
<h3 id="supported-crates-and-std-caveats">Supported crates and std Caveats</h3>
<p>Of course most of the time there’s going to be a catch. You might sometimes need to create an implementation of a crate for the SGX target. The process is <a rel="noopener external" target="_blank" href="https://edp.fortanix.com/docs/tasks/dependencies/">documented</a> as well. Also some crates have been adding SGX support for the <code>x86_64-fortanix-unknown-sgx</code> target, such as the <a rel="noopener external" target="_blank" href="https://github.com/rust-random/rand/pull/680/files">rand</a> crate.</p>
<p>This project is already a tier 2 target for the Rust compiler (more on <a rel="noopener external" target="_blank" href="https://doc.rust-lang.org/nightly/rustc/platform-support.html#tier-2">Rust tiers</a>), and that’s great news! It’s based on <code>libstd</code>, practice which may have its drawbacks since it assumes <code>time/net/env/thread/process/fs</code> are implemented. Some of those are still not implemented (<code>fs</code> for example) and will throw a runtime panic instead of a compile error, breaking the Rust’s philosophy of “if it compiles it works”. More info on <a rel="noopener external" target="_blank" href="https://edp.fortanix.com/docs/concepts/rust-std/">Rust std support</a> on Fortanix’s documentation.</p>
<h3 id="i-o">I/O</h3>
<p>The recommended way of handling input/output in the enclave is via byte streams, particularly using <a rel="noopener external" target="_blank" href="https://edp.fortanix.com/docs/concepts/rust-std/#stream-networking"><code>TcpStream</code></a> and using TLS (Transport Layer Security is a protocol used to provide secure communications to a network and mostly known for its use on <em>https</em>) on top of that is strongly suggested.<br />
There are primitives for dealing with pointers to user space as well. These primitives use Rust’s borrowing and ownership mechanism to avoid data races among other issues, and also prevent creating dangerous Rust references to user memory. Still, using <code>TcpStream</code> is preferred.</p>
<h2 id="an-example-using-both-fortanix-and-teaclave">An example using both Fortanix and Teaclave</h2>
<p>We’re going to show a simplified of the hello-world <a rel="noopener external" target="_blank" href="https://github.com/apache/incubator-teaclave-sgx-sdk/tree/master/samplecode/hello-rust">example</a> from the Teaclave repo and see how we would do a similar thing using Fortanix’s EDP.</p>
<p>We’ll be omitting some details, so if you’re interested in getting them we suggest that you check out Teaclave’s repo.</p>
<h3 id="teaclave-1">Teaclave</h3>
<p>The project structure is:</p>
<p><img src="/images/external/mm0n8rE.png" alt="" />Example of project structure using Teaclave</p>
<p>Notice that we have the <code>app/</code> and the <code>enclave/</code> directories. First let’s see the app’s code:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>extern {</span></span>
<span class="giallo-l"><span>    fn say_something(eid: sgx_enclave_id_t, retval: *mut sgx_status_t,</span></span>
<span class="giallo-l"><span>                     some_string: *const u8, len: usize) -&gt; sgx_status_t;</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>We define the function that we want to run in the enclave as an external function, notice that we are not using Rust’s <code>String</code> here, we need to pass the raw parts instead.</p>
<p>You need to initialize the enclave with a <code>SgxEnclave::create</code> call before running code on it. Remember to <strong>always initialize</strong> the enclave first.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>// Initialize the enclave - proceed on success</span></span>
<span class="giallo-l"><span>let enclave = match init_enclave() {</span></span>
<span class="giallo-l"><span>    Ok(r) =&gt; {</span></span>
<span class="giallo-l"><span>        println!(&quot;[+] Init Enclave Successful {}!&quot;, r.geteid());</span></span>
<span class="giallo-l"><span>        r</span></span>
<span class="giallo-l"><span>    },</span></span>
<span class="giallo-l"><span>    Err(x) =&gt; {</span></span>
<span class="giallo-l"><span>        println!(&quot;[-] Init Enclave Failed {}!&quot;, x.as_str());</span></span>
<span class="giallo-l"><span>        return;</span></span>
<span class="giallo-l"><span>    },</span></span>
<span class="giallo-l"><span>};</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>let input_string = String::from(&quot;This is a normal world string passed into Enclave!\n&quot;);</span></span>
<span class="giallo-l"><span>let mut retval = sgx_status_t::SGX_SUCCESS;</span></span></code></pre>
<p>Then we make the <code>[E]call</code> into the enclave. This needs to be wrapped with an unsafe block and we need to split the String into its pointer and length.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>let result = unsafe {</span></span>
<span class="giallo-l"><span>    say_something(enclave.geteid(),</span></span>
<span class="giallo-l"><span>                  &amp;mut retval,</span></span>
<span class="giallo-l"><span>                  input_string.as_ptr() as * const u8,</span></span>
<span class="giallo-l"><span>                  input_string.len())</span></span>
<span class="giallo-l"><span>};</span></span></code></pre>
<p>The <code>[E]call</code> will return with a <code>sgx_status_t</code> we can check against to see if the enclave ran successfully.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>match result {</span></span>
<span class="giallo-l"><span>    sgx_status_t::SGX_SUCCESS =&gt; {},</span></span>
<span class="giallo-l"><span>    _ =&gt; {</span></span>
<span class="giallo-l"><span>        println!(&quot;[-] ECALL Enclave Failed {}!&quot;, result.as_str());</span></span>
<span class="giallo-l"><span>        return;</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span>
<span class="giallo-l"><span>println!(&quot;[+] say_something success...&quot;);</span></span></code></pre>
<p>You have to destroy the enclave before exiting. From the documentation it reads:</p>
<blockquote>
<p>It is highly recommended that the sgx_destroy_enclave function be called after the application has finished using the enclave to avoid possible deadlocks.</p>
</blockquote>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>enclave.destroy();</span></span></code></pre>
<p>Now into the enclave’s code:</p>
<p>Each <code>[E]call</code> should follow the signature <code>#[no_mangle] pub extern "C" fn func_name(args) -&gt; sgx_status_t</code>.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>#[no_mangle]</span></span>
<span class="giallo-l"><span>pub extern &quot;C&quot; fn say_something(some_string: *const u8, some_len: usize) -&gt; sgx_status_t </span></span></code></pre>
<p>Again, we need the unsafe block to call <code>from_raw_parts</code> and we get our string slice back.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>let str_slice = unsafe { slice::from_raw_parts(some_string, some_len) };</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>// A sample &amp;&#39;static string</span></span>
<span class="giallo-l"><span>let rust_raw_string = &quot;This is a in-Enclave &quot;;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>// Construct a string from &amp;&#39;static string</span></span>
<span class="giallo-l"><span>let mut hello_string = String::from(rust_raw_string);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>// Ocall to normal world for output</span></span>
<span class="giallo-l"><span>println!(&quot;{}&quot;, &amp;hello_string);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>sgx_status_t::SGX_SUCCESS</span></span></code></pre>
<p>And there’s even more. You need to define the <code>[E]call/[O]call</code> interface in the enclave subdirectory in an <code>Enclave.edl</code> file.</p>
<p>It would look something like:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>enclave {</span></span>
<span class="giallo-l"><span>    from &quot;sgx_tstd.edl&quot; import *;</span></span>
<span class="giallo-l"><span>    // you would have other imports here</span></span>
<span class="giallo-l"><span>    </span></span>
<span class="giallo-l"><span>    trusted {</span></span>
<span class="giallo-l"><span>        /* define ECALLs here. */</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        public sgx_status_t say_something([in, size=len] const uint8_t* some_string, size_t len);</span></span>
<span class="giallo-l"><span>    };</span></span>
<span class="giallo-l"><span>    untrusted {</span></span>
<span class="giallo-l"><span>        /* define OCALLs here. */</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>};</span></span></code></pre>
<p>There are even more files we haven’t touched yet. But this is enough to show that while Teaclave might give you a lot of control of what’s going on, it’s not easy and increases the overall complexity of your project.</p>
<h3 id="same-implementation-using-fortanix-edp">Same implementation using Fortanix EDP</h3>
<p>As Fortanix’s documentation says:</p>
<blockquote>
<p>EDP applications should be thought of as providing a service to other parts of your system. An EDP application might interact with other services which themselves might be EDP applications. The service may be implemented as a gRPC server, an HTTPS server with REST APIs, or any other service protocol.</p>
</blockquote>
<p><strong>Disclaimer</strong> : we haven’t been able to get our hands into an Intel SGX capable machine, hence we weren’t able to test this example. However, we think this serves as a good illustration example and gives some credit to Teaclave and Intel for the simulation capabilities.</p>
<p>Let’s see how can we accomplish our hello world using Fortanix EDP. Our final project looks like this:</p>
<p><img src="/images/external/8Wh6Nk4.png" alt="" />Example of a project structure using Fortanix</p>
<p>Let’s look at what the <code>main.rs</code> has to offer:</p>
<p>We needed to add this two lines to the <code>.cargo/config</code> file:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>[target.x86_64-fortanix-unknown-sgx]</span></span>
<span class="giallo-l"><span>runner=&#39;ftxsgx-runner-cargo&#39;</span></span></code></pre>
<p>And that’s the only setup we needed (besides the Rust code).</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>use std::net::{TcpListener, TcpStream};</span></span>
<span class="giallo-l"><span>use std::io::Read;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>fn main() {</span></span>
<span class="giallo-l"><span>    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let (mut stream, _addr) = listener.accept().unwrap();</span></span>
<span class="giallo-l"><span>    let mut message = [0; 128];</span></span>
<span class="giallo-l"><span>    stream.read(&amp;mut message).unwrap();</span></span>
<span class="giallo-l"><span>    println!(&quot;new client: {:?}&quot;, std::str::from_utf8(&amp;message).unwrap());</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>Pretty much like good ol’ Rust code right? In fact, we’re able to compile it without the Fortanix runner and have it running.</p>
<p><img src="/images/external/GPPD8IR.png" alt="" /></p>
<p>This only constitutes the enclave, but an easy way to test it is by making the TCP request, so it should be enough to run the following command:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>echo &quot;Hello World!&quot; | nc 127.0.0.1 7878</span></span></code></pre>
<p>The way this is built means that you could call this from another language as long as you can make the TPC connection.</p>
<p><a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/sgx_with_rust_blog_post"><em>Full code here</em></a></p>
<h2 id="teaclave-vs-fortanix">Teaclave vs. Fortanix</h2>
<p>One significant difference between the two is their size: Teaclave’s repo contains ~80K lines of Rust code while Fortanix’s one has ~18K lines of code, which is about 4 times less. Some of these could be atributed to the amount of examples Teaclave has in their repo but still that doesn’t make up for the whole difference.<br />
Also, Fortanix is mostly written using Rust code, while Teaclave has another 80K more lines of non Rust code… yikes!</p>
<p>In terms of community activity we ran a comparison of both thru <a rel="noopener external" target="_blank" href="https://vesoft-inc.github.io/github-statistics/">github-statistics</a>.</p>
<p><img src="/images/external/bejTcAq.png" alt="" />Comparison between Fortanix and Teaclave repos stats</p>
<p>Teaclave seems to have more traction based on the amount of stars and forks. Nevertheless, during 2021 there is a clear increase of the activity in the Fortanix’s EDP repository. So it seems like Teaclave is more widely used but it’s development has stagnated somewhat while Fortanix is taking the lead, a dynamic that has been reinforced since attaining <a rel="noopener external" target="_blank" href="https://users.rust-lang.org/t/sgx-target-is-now-a-rust-tier-2-platform/24779">Rust tier 2 in january on 2019</a>.</p>
<h2 id="weighting-pros-and-cons">Weighting pros and cons</h2>
<h3 id="teaclave-2">Teaclave</h3>
<ul>
<li>✅ Uses Intel’s libs, and they’re supposed to be the experts on that.</li>
<li>✅ There are simulation libraries which expand the support a bit.</li>
<li>✅ Already solves connecting the app and the enclave.</li>
<li>✅ There are a few more examples available (<a rel="noopener external" target="_blank" href="https://github.com/apache/incubator-teaclave-sgx-sdk/tree/master/samplecode">Teaclave SGX SDK repo</a> and <a rel="noopener external" target="_blank" href="https://github.com/glassonion1/rust-101/tree/main/sgx-sdk">Rust 101 repo</a>).</li>
<li>❌ Uses Intel’s libs, and they’re supposed to be the experts on that. This might not be a bad thing by itself, but you could think of this as adding an extra dependency with a centralized entity such as Intel. Which is why in a decentralized environment might not be ideal (debatable).</li>
<li>❌ Integrating SGX to an existing system using this SDK is a bit tedious, since you need to restructure your application, use some Makefiles to handle linking the enclave with the application, declaring the interface connecting your applications in a separate <code>.edl</code> file with its own syntax and more.</li>
</ul>
<p><img src="/images/external/vMOMK15.png" alt="" />Enclave folder using Teaclave vs Fortanix</p>
<h3 id="fortanix">Fortanix</h3>
<ul>
<li>✅ You can write all Rust code.</li>
<li>✅ Officially target tier 2 of the Rust compiler.</li>
<li>✅ Add a few lines to your <code>Cargo.toml</code> and you are set.</li>
<li>✅ We trust the fact that it is open source and therefore audited by many users, and being included as a tier 2 target for the Rust compiler means that it has earned some respect from the Rust community as well.</li>
<li>❌ Well, sometimes it’s not that easy. Not all crates have support for SGX although you can add your own implementation for the Fortanix target.</li>
<li>❌ since it uses <code>libstd</code> it assumes that you have implementations for <code>time/net/env/thread/process/fs</code>, which SGX does not entirely support. This will generate runtime panics when used and you won’t be getting compilation errors.</li>
<li>❌ It’s easier to develop on, but that is because it hides some of the complexity away and you may ask yourself if we can trust on its security when many things are hidden away from the developer.</li>
</ul>
<h2 id="conclusions">Conclusions</h2>
<p>We don’t find a clear winner between Teaclave and Fortanix, as both have their pros and cons.</p>
<p>Having to make a choice we tend to go with Fortanix as its easier to develop in pure Rust. Also as Fortanix is endorsed as Tier 2 we can have a high confidence about its compatilibity with our software allowing for a seamless implementation. As an added bonus this level of trust from the Rust developers gives us a somewhat indirect clue that there aren’t blatant security issues hidden in the code that are meaningful enough to make us to doubt it.</p>
<h2 id="further-readings">Further readings</h2>
<ul>
<li><a rel="noopener external" target="_blank" href="https://www.intel.com/content/dam/develop/public/us/en/documents/intel-sgx-product-brief-2019.pdf">SGX product brief</a></li>
<li><a rel="noopener external" target="_blank" href="https://www.intel.com/content/www/us/en/developer/library.html?s=Newest&amp;f:@stm_10309_en=%5BIntel%C2%AE%20Software%20Guard%20Extensions%20(Intel%C2%AE%20SGX)%5D">Intel technical library - Software Guard Extensions</a></li>
<li><a rel="noopener external" target="_blank" href="https://fortanix.com/intel-sgx/">Fortanix resources</a></li>
<li><a rel="noopener external" target="_blank" href="https://teaclave.apache.org/docs/">Teaclave documentation</a></li>
</ul>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
