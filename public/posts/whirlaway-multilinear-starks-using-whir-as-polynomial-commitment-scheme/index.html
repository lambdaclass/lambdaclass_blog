<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whirlaway: Multilinear STARKs using WHIR as polynomial commitment scheme - LambdaClass Blog</title>
    <meta name="description" content="Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">Whirlaway: Multilinear STARKs using WHIR as polynomial commitment scheme</h1>
        
        <div class="page-meta">
            <time datetime="2025-08-29">August 29, 2025</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <h2 id="introduction">Introduction</h2>
<p>Ethereum has been quickly evolving to become the financial backend of the World. Research and development in zero-knowledge proofs have allowed Ethereum to scale with rollups, by batching transactions off-chain and then posting an update of the accounts together with a cryptographic proof attesting to the validity of the transactions. While progress has been impressive, there remain still some challenges related to the rise of quantum computers (which would break elliptic curve cryptography, now a core primitive in Ethereum), increasing decentralization, and simplifying the protocol to reduce attack surface and possible bugs.</p>
<p>Ethereum presented in Devcon 2024 the roadmap for <a rel="noopener external" target="_blank" href="https://leanroadmap.org/">Lean Ethereum</a> to research, define specifications, develop, test and deploy the future of Ethereum, which would allow the protocol to go on maintenance mode and avoid performing major changes. One of the key problems is related to post-quantum secure aggregatable signatures to replace the (elliptic curve-based) BLS signatures powering Ethereum’s consensus. While there are several candidates for post-quantum secure signatures, we should pay attention to those that can provide an efficient aggregation algorithm or whose verification can be proven efficiently using post-quantum secure proof systems. Hash-based signatures using SNARK (succinct, non-interactive argument of knowledge)-friendly hashes (such as Poseidon 2 or Rescue Prime Optimized) appear as promising candidates, since current state of the art provers are able to prove nearly 1,000,000 hashes per second on GPU. An important constraint is related to proof sizes, which should be as small as possible, to reduce the communication footprint between the nodes. Current security analysis shows that proof sizes targeting 128 bits of security using FRI are larger, which is why a different candidate is needed. <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2024/1586.pdf">WHIR</a> provides a good candidate, even though it may be slower in concrete terms compared to FRI. It is not surprising, then, that the roadmap contains at least 4 elements in its roadmap targeting the primitives for post-quantum secure aggregatable signatures using succinct arguments of knowledge:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * Poseidon cryptanalysis initiative.</span></span>
<span class="giallo-l"><span>    * Hash-based multisignatures</span></span>
<span class="giallo-l"><span>    * Minimal zero-knowledge virtual machines (to handle proof aggregation)</span></span>
<span class="giallo-l"><span>    * Formal verification of virtual machines and specification of proof systems.</span></span></code></pre>
<p>In this post, we will cover the basics of WHIR used to prove the execution of a virtual machine as described by means of an algebraic intermediate representation (AIR). The way to derive the non-interactive argument of knowledge will be in a standard way, first by a polynomial interactive oracle proof, instantiating the oracle proof using a polynomial commitment scheme and using the Fiat-Shamir transformation. Later posts will focus on signature schemes and virtual machines. You can see the presentation of <a rel="noopener external" target="_blank" href="https://ethresear.ch/t/whir-for-ethereum/22938">WHIR at ethresearch</a> for further references, as well as the <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2024/1586.pdf">WHIR paper</a>. For the specification of Whirlaway, see the <a rel="noopener external" target="_blank" href="https://github.com/TomWambsgans/Whirlaway/tree/master">repo</a>, as well as <a rel="noopener external" target="_blank" href="https://github.com/tcoratger/whir-p3/tree/main/src/whir/pcs">whir-p3</a>.</p>
<h2 id="multilinear-polynomials">Multilinear polynomials</h2>
<p>A polynomial in $m$-variables is called multilinear if, in every monomial, the highest power of each indeterminate, $x_i$ is at most 1.</p>
<p>Given a set of evaluations of a function $f$ over $H^m$, there is a unique multilinear polynomial $\hat{f}$ over $H^m$ such that $\hat{f} (x) = f(x)$ for every $x \in H^m$. We can represent the same multilinear polynomial using different basis, the two most common being the monomial basis ($1, x_0, x_1, x_0 x_1, x_2, x_0 x_2, …$) and the Lagrange basis over $H^m$. For simplicity, we will henceforth take $H = {0 , 1}$. These are defined as follows,<br />
$\chi_k (x) = \mathrm{eq} ( k_b , x) = \prod_i ( k_{b,i} x_i + (\left\k_{b,i} - 1)(x_i - 1))$<br />
where $k_b$ is the binary decomposition of $k$, that is $k = \sum_i k_{b,i} 2^i$. The multilinear extension, give the evaluations of $f$ over $\{0, 1\}^m$,<br />
$\hat{f} (x) = \sum_{b \in \{0,1\}^m } f(b) \mathrm{eq} (b , x) = \sum_k f_k \chi_k (x)$</p>
<p>We can easily check that we can evaluate $\hat{f} (x)$ at any point by evaluating the Lagrange polynomials $\chi_k (x)$ and performing a scalar product between the vector of evaluations of $f$ and the vector of Lagrange basis polynomials,<br />
$\hat{f} (z) = \sum_k f_k \chi_k (z) = f^t \cdot \chi$</p>
<p>We can find a way of seeing a multilinear polynomial as a univariate polynomial by a suitable transformation. Given a polynomial in the multilinear basis,<br />
$$f(x_0 , x_1 , x_2 , \dots x_{ m - 1 } ) = a_0 + a_1 x_0 + a_2 x_1 + a_3 x_0 x_1 + a_4 x_2 + a_5 x_0 x_2 + a_6 x_1 x_2 + \dots a_{ 2^m - 1 } x_0 x_1 \dots x_{m - 1}$$<br />
If we let $x_0 = x$, $x_1 = x^2$, $x_2 = x^4$, $\dots$, $x_{m - 1} = x^{ 2^{ m - 1} }$, then<br />
$$f(x) = a_0 + a_1 x + a_2 x^2 + a_3 x x^2 + a_4 x^4 + a_5 x x^4 + a_6 x^2 x^4 + \dots a_{ 2^m - 1 } x x^2 x^4 … x^{ 2^{ m - 1 } }$$</p>
<p>Doing all the products, $f( x ) = \sum_j a_j x^j$</p>
<p>WHIR will make use of this transformation from the multilinear monomial basis to the univariate monomial basis. For example, the paper defines $\mathrm{pow} (z, m) = (z , z^2 , … z^{ 2^{ m - 1 } })$ which is used to evaluate the multilinear polynomial to $f(z)$.</p>
<h2 id="sumcheck-protocol">Sumcheck protocol</h2>
<p>The sumcheck protocol is an important building block for designing efficient interactive proofs. The sumcheck protocol is applied to proving statements of the form<br />
$\sum_{x \in H^\ell} f(x) = S$<br />
where $f(x)$ is a multivariate polynomial in $\ell$ variables and $H$ is a set (typically, ${0, 1}$). In other words, we want to show that the sum of the evaluations of $f$ over all the values in $H^\ell$ is equal to $S$. While this seems a bit restrictive or convoluted, computations can be reduced to some instance of this protocol via a suitable transformation. For example, the evaluation of the multilinear extension of a function at $z$ can be written precisely in this form, when using the Lagrange basis polynomials,<br />
$\hat{f} (z) = \sum_{b \in \{0,1\}^m } f(b) \mathrm{eq} (b , z)$<br />
The protocol allows the prover to convince the verifier that the sum is $S$ by sending to the verifier $\mathcal{O} (\ell)$ elements, and having the latter perform $\mathcal{O} (\ell)$ operations, plus a single evaluation to $f$ at a random point $(r_0, r_1, … r_{ \ell - 1})$. We can then compile this to a non-interactive succinct argument of knowledge using the Fiat-Shamir transformation and using a polynomial commitment scheme (PCS) to grant oracle access to $f(r_0, r_1, … r_{ \ell - 1})$ to the verifier.</p>
<p>The sumcheck protocol can be used several times to reduce complex claims into simpler ones, such as in <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2019/550">Spartan</a>. We can also combine several sumchecks into a single one by batching them using random linear combinations. For example, say we want to prove that:<br />
$\sum_{x \in H^\ell} f_1 (x) = S_1$<br />
$\sum_{x \in H^\ell} f_2 (x) = S_2$<br />
We can have the verifier sample random scalars $\alpha_1, \alpha_2$ and we can run the sumcheck over<br />
$\sum_{x \in H^\ell} \left( \alpha_1 f_1 (x) + \alpha_2 f_2 (x) \right) = \alpha_1 S_1 + \alpha_2 S_2$<br />
This reduces the amount of elements that the prover needs to send to the verifier and the amount of work involved compared to running the two instances separately.</p>
<h2 id="overview-of-the-protocol">Overview of the protocol</h2>
<p>In AIR, we have a set of polynomial constraints, such as:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * $f_0 (x_7) = x_7 - a_k$ and which is valid for the first row. This is a boundary constraint.</span></span>
<span class="giallo-l"><span>    * $f_1 (x_0, x_1, x_2, y_0, y_1, y_2) = x_0 x_1 x_2 - y_1 y_2 y_3$ which should be valid for all consecutive rows, except the last one. This is an example of a transition constraint.</span></span>
<span class="giallo-l"><span>    * $f_2 (x_3) = x_3 (x_3 - 1)$ and valid over all rows, asserts that $x_3$ is a boolean variable. This constraint enforces a consistency condition.</span></span></code></pre>
<p>Constraints are given by a multivariate polynomial with a set over which the constraint applies. The degree of the constraint (equal to the highest degree of the monomials) is important since it provides information on the number of points where we need to evaluate in order to fully determine the composition polynomial.</p>
<p>In ordinary STARKs, we can check the validity of the constraints by</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. Interpolating the trace columns to obtain (univariate) trace polynomials.</span></span>
<span class="giallo-l"><span>    2. Composing the trace polynomials with the constraint polynomials.</span></span>
<span class="giallo-l"><span>    3. Dividing each constraint by the corresponding zerofier.</span></span>
<span class="giallo-l"><span>    4. Use FRI to show that the result is close to a low-degree polynomial.</span></span></code></pre>
<p>If we want to use multivariate polynomials, we need to perform some changes on how the protocol works. We will go step-by-step to show how everything works.</p>
<p>We will start with the trace table, $T$. We suppose that the trace has $2^n$ rows and $2^m$ columns. We can always pad tables not fulfilling this condition, or leverage the ideas of <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2025/917">jagged PCS</a> to avoid padding. The table has $2^{n + m}$ elements, which we can view as evaluations of a polynomial $f_{trace}$ over $\{0, 1\}^{n + m}$. In Whirlaway, the elements are stored in row-major order.</p>
<p>The trace is committed as a single multilinear polynomial using WHIR as a polynomial commitment scheme. We will reduce all the polynomial checks to a single evaluation of this polynomial, which we can prove thanks to the polynomial commitment scheme.</p>
<p>We can always get the columns from the trace polynomial by multiplying with a suitable polynomial, in a similar way as we could recover the column from the flattened vector using a suitable matrix-vector product. The computation is correct if we can show that each of the constraint polynomials vanishes on the corresponding set. Suppose we need to show that $f_{16} (X_3 ) = X_3 (X_3 - 1) = 0$ for all rows, where $X_3$ indicates that we need to evaluate this polynomial using column 3. We call this polynomial $c_3 (x)$, where $c_3 ( j_b ) = c_{3j}$, where $j_b$ is the binary representation of $j$, with $j = 0, 1, … 2^n - 1$. The validity of the constraint is equal to showing that $c_3 (x) (c_3 (x) - 1) = 0$ for all the valid values of $x = j_b$.</p>
<p>We apply a variant of the sumcheck protocol, called the zerocheck to show that all the evaluations are zero over the set:<br />
$$\sum_{ x \in \{0,1\}^{n}} \mathrm{eq} (\tau,x) c_3(x) (c_3 (x) - 1) = 0$$<br />
where $\tau$ is sampled at random by the verifier. Eventually, after applying the sumcheck protocol, the verifier is left with the check $\mathrm{eq} (\tau,r) c_3(r) (c_3 (r) - 1) = v_r$. The verifier can compute $\mathrm{eq} (\tau,r)$ efficiently, since it is a linear product of $n$ terms. For $c_3 (r)$, the verifier can query the oracle and he can finally carry out the multiplications. Showing that the evaluation is valid can be done using the PCS, but the problem is how does he know that $c_3 (r)$ is correct, given that the prover committed to $f_{trace} (x)$ and not to the individual columns?</p>
<p>The core idea is that we can run another instance of the sumcheck protocol, linking the trace polynomial with the columns and reducing the checks to a single point.</p>
<h3 id="small-detour-spartan">Small detour - Spartan</h3>
<p>Whirlaway is a proof system based on <a rel="noopener external" target="_blank" href="https://solvable.group/posts/super-air/#fnref:1">SuperSpartan for AIR</a>, but we can gain an intuition on how it works by looking at other multivariate proof systems, such as Spartan. While there are some differences, the core principles remain similar. We will start with R1CS, which is a common way of representing circuits, where we have matrices $A, B, C$ (from $\mathbb{F}^{n \times m}$) and a vector $z = (w, 1, u)$, where $w$ is the witness vector, and $u$ is the instance vector such that<br />
$Az \circ Bz - Cz = 0$<br />
where $\circ$ denotes the Hadamard (component-wise) product of vectors. We can transform this into an instance of the sumcheck protocol, by noting the following:<br />
$$F (x) = \left( \sum_y A(x,y) z(y)\right) \left( \sum_y B(x,y) z(y)\right) - \left( \sum_y C(x,y) z(y)\right)$$<br />
$$\sum_x \mathrm{eq} (\tau , x) F(x) = 0$$<br />
We can have the prover do the work and provide $a(x) = \sum_y A(x,y) z(y)$, $b(x) = \sum_y B(x,y) z(y)$ and $c(x) = \sum_y C(x,y) z(y)$. The zerocheck can be reduced to<br />
$$\mathrm{eq} (\tau, r_x) F(r_x) = v_x = \mathrm{eq} (\tau, r_x) (a (r_x ) b (r_x) - c( r_x ))$$<br />
The prover can then show that $a (r_x ), b (r_x ), c( r_x )$ are correct by running the following sumchecks:<br />
$$\sum_y A(r_x , y) z(y) = a (r_x )$$<br />
$$\sum_y B(r_x , y) z(y) = b (r_x )$$<br />
$$\sum_y C(r_x , y) z(y) = c (r_x )$$</p>
<p>All these can be combined into a single check by taking random linear combinations,<br />
$$\sum_y \left(\alpha A(r_x , y) + \beta B(r_x , y) + \gamma C( r_x , y ) \right) z(y) = \alpha a (r_x ) + \beta b (r_x ) + \gamma c (r_x )$$</p>
<p>This avoids working with one large sumcheck and breaks it into one working with a linear combination of the columns and another with a linear combination of the rows. This idea is exploited in Whirlaway to first perform a zerocheck with the columns and then reducing the evaluation of the columns to the evaluation of the trace polynomial.</p>
<hr />
<p><strong>Steps in the protocol:</strong></p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. Commit to the trace</span></span>
<span class="giallo-l"><span>    2. Compute the trace columns that are necessary to evaluate the transition constraints, $c_k^{up}$ and $c_k^{down}$.</span></span>
<span class="giallo-l"><span>    3. Perform a zerocheck with those columns and the polynomial constraints, which reduces the verifier&#39;s task to evaluating $c_k^{up}$ and $c_k^{down}$ at the random point $\delta$.</span></span>
<span class="giallo-l"><span>    4. Batch the evaluation claims for all the columns and perform the inner sumcheck.</span></span>
<span class="giallo-l"><span>    5. Find the multilinear extension of the columns&#39; evaluations, evaluates at $z$ and checks that this matches the opening of the commitment to the trace at the point $(z, \delta)$.</span></span></code></pre><h2 id="whir">WHIR</h2>
<p>WHIR is an interactive oracle proof of proximity to constrained Reed-Solomon codes. FRI is also an interactive oracle proof of proximity, but to Reed-Solomon codes. We can transform WHIR into a polynomial commitment scheme in the same way we transformed FRI into a PCS, via committing to the codewords using Merkle trees.</p>
<p>Before jumping into the actual protocol, we will begin with the definitions of error correcting codes.</p>
<p><strong>Definition (error-correcting code)</strong> : An error-correcting code of length $n$ over an alphabet $A$ is a subset of $A^n$. In particular, a linear code over a finite field $\mathbb{F}$ is a subspace of $\mathbb{F}^n$.</p>
<p>Linear codes are important because they allow for efficient encoding, and linear combination of codewords results in a codeword.</p>
<p><strong>Definition (interleaved code)</strong> : Given a code $C \subseteq A^n$, the $m$ -interleaved code is the code $C^m \subseteq { (A^m ) }^n$. Each element of a codeword is now an element of $A^m$.</p>
<h3 id="1-smooth-reed-solomon-codes">1. Smooth Reed-Solomon Codes</h3>
<p>Given a finite field $\mathbb{F}$, a degree $d = 2^m$ and an evaluation domain $\mathcal{L} \subseteq \mathbb{F}^\star$, that must be a multiplicative <em>coset</em> whose order $n$ is a power of two, we define<br />
$$RS \left[\mathbb{F}, \mathcal{L}, m \right] = \{ f: \mathcal{L} \to \mathbb{F} : / : \exists g \in \mathbb{F}^{ \leq d - 1} \left[X\right] : s.t. : f(x) = g(x) : \forall x \in \mathcal{L} \}.$$<br />
In other words, it represent all the evaluations that come from a polynomial of small degree. In proof systems, the prover claims that a funtion $f$ (or a its evaluations) is in $RS\left[\mathbb{F}, \mathcal{L}, m\right]$ to convince the verifier that $f$ is polynomial, showing that the function is close to a polynomial of degree $d - 1$.</p>
<blockquote>
<p>Let’s recall what is a <em>coset</em> : For example, in Stark101 we have a trace of one column of length 1023, so we define as an evaluation domain a subgroup $G \subseteq \mathbb{F}^\star$ with order $|G| = 1024$. Then we interpolate and want to extend the domain eigth times larger (blowup factor 8), creating a Reed-Solomon error correction code. We take a subgroup $H \subseteq \mathbb{F}^\star$ with $|H| = 8192$, and define as the LDE the <em>coset</em> of $H$ $$wH = \{ w \cdot h_1, \ldots, w \cdot h_{8192} \}$$ with $w$ the generator of $\mathbb{F}^\star$.</p>
</blockquote>
<h3 id="2-multilinear-reed-solomon-codes">2. Multilinear Reed-Solomon Codes:</h3>
<p>Equivalently, such Reed–Solomon codes can be viewed as evaluations of multilinear polynomials in m variables:</p>
<p>$$\begin{align*}<br />
RS\left[\mathbb{F}, \mathcal{L}, m\right] &amp;= \{ f: \mathcal{L} \to \mathbb{F} : / : \exists g \in \mathbb{F}^{ &lt; d} [X] : s.t. : f(x) = g(x) : \forall x \in \mathcal{L} \} \newline<br />
&amp;= \{ f: \mathcal{L} \to \mathbb{F} : / : \exists \hat f \in \mathbb{F}^{\leq 1} [X_0, \ldots, X_{m-1}] : s.t. : f(x) = \hat f(x^{ 2^{0} }, x^{ 2^{1} }, \ldots, x^{ 2^{ m - 1 } }) : \forall x \in \mathcal{L}\}<br />
\end{align*}$$</p>
<p><strong>Example:</strong> If $m =3$, $2^m - 1 = 7$ and $2^{m - 1} = 4$. We can represent a univariate polynomial $g$ of degree $7$ as a 3-variable polynomial $\hat f$. Indeed we just need three variables $X_0, X_1, X_2$, since $x_0 \cdot x_1 \cdot x_2 = x^1 \cdot x^2 \cdot x^4 = x^7.$ And in the other way, if we have a 3-variable polynomial $\hat f$, we can represent it as a univariate polynomial $g$ of degree $7$: The maximum degree obtained is in $x_0 \cdot x_1 \cdot x_2 = x^7.$ For example, the polynomial $$g(x) = a_0 + a_3x^3 + a_6x^6$$<br />
is equivalent to the polynomial<br />
$$\hat f(x_0, x_1, x_2) = a_0 x_0 + a_1 x_0 x_2 + a_2 x_1 x_2$$</p>
<h3 id="3-constrained-reed-solomon-code">3. Constrained Reed–Solomon Code:</h3>
<p>It is a Smooth Reed-Solomon Code with an additional constraint. Given a weight polynomial $\hat w \in \mathbb{F} \left[Z, X_1, \ldots, X_m \right]$ and a target $\sigma \in \mathbb{F}$, we additionaly ask<br />
$$ \sum_{b \in \{0, 1 \}^m} \hat w(\hat f(b), b) = \sigma.$$</p>
<p>This can help enforce a particular evaluation of the polynomial (which reduces the number of codewords that could simultaneously be close to $f$ and fulfill the condition) or show that the polynomial has zeros over some set.</p>
<h4 id="why-do-we-use-this">Why do we use this?</h4>
<p>Given an evaluation point $r = (r_1, \ldots, r_m) \in \mathbb{F}^m$, we want to additionally constrain that $$\hat f (r) = \sigma.$$<br />
So if we choose<br />
$$\hat w(Z, X_1, \ldots X_m) = Z \cdot eq( (X_1, \ldots, X_m), (r_1, \ldots, r_m)),$$<br />
then we have<br />
$$ \sigma = \sum_{b \in \{0, 1 \}^m} \hat w(\hat f(b), b) = \sum_{b \in \{0, 1 \}^m} \hat f(b) \cdot eq( b, r) = \hat f(r).$$</p>
<h2 id="whir-protocol">WHIR Protocol</h2>
<h3 id="preliminary-notations">Preliminary notations</h3>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * $\rho := \frac{ 2^m }{n}$ is the _rate of the code_ , where $n = |\mathcal{L}|$ and $m$ is the number of variables.</span></span>
<span class="giallo-l"><span>    * $\mathcal{L}^{ (i) } = \\{x^i : x \in \mathcal{L} \\}$. Since $\mathcal{L}$ is smooth, if $i$ is a power of two, then $|\mathcal{L}^{(i)}| = |\mathcal{L}| / i.$</span></span>
<span class="giallo-l"><span>    * $k &gt; 1$ is the _folding parameter_.</span></span></code></pre><h3 id="the-basic-idea">The basic idea</h3>
<p>Each WHIR iteration will reduce the task of testing<br />
$$f \in C = CRS\left[\mathbb{F}, \mathcal{L}, m, \hat w, \sigma \right]$$<br />
to the task of testing<br />
$$f \in C^\prime = CRS\left[\mathbb{F}, \mathcal{L}^{(2)}, m - k, \hat w^\prime , \sigma^\prime \right],$$<br />
where the size of the domain decreases from $n$ to $n/2$, and the number of variables decreases from $m$ to $m - k$.</p>
<p>The WHIR protocol has $M = m/k$ of these WHIR iterations, reducing the proximity test for<br />
$$C^{(0)} = C$$<br />
to a proximity test for<br />
$$C^{ (M) } = CRS\left[\mathbb{F}, \mathcal{L}^{ (2^M) }, O(1), \hat w^{ (M) }, \sigma^{ (M) } \right].$$</p>
<p><em>Obs.</em> $O(1)$: It doesn’t depend on $m$ or $k$.</p>
<h3 id="protocol-steps">Protocol Steps</h3>
<h4 id="1-sumcheck-rounds">1. Sumcheck rounds</h4>
<p>The Prover and Verifier apply $k$ rounds of the sumcheck protocol for the claim<br />
$$\sum_{b \in \{0, 1 \}^m} \hat w(\hat f(b), b) = \sigma.$$</p>
<p>The protocol starts with<br />
$$ \hat w (Z, X) = Z \cdot eq(X, r)$$<br />
where $\hat f(r) = \sigma$.</p>
<p>The Prover sends the univariate round polynomials $h_1, \ldots k_k$, by fixing in each round the first variable and summing over the rest.</p>
<p>The Verifier samples $\alpha_1, \ldots, \alpha_k \in \mathbb{F}$, and checks $h_1 (0) + h_1 (1) = \sigma$ and $h_j(0) + h_j(1) = h_{j - 1}(\alpha_{j - 1})$.</p>
<p>This reduces the intitial claim to the claim<br />
$$\sum_{b \in \{0, 1 \}^{ m - k}} \hat w^\prime (\hat f(\alpha_1, \ldots, \alpha_k, b_{k +1 }, \ldots b_m), (\alpha_1, \ldots, \alpha_k, b_{k + 1}, \ldots b_m)) = h_k(\alpha_k),$$</p>
<p>In simpler notation:<br />
$$\sum_{b \in \{0, 1 \}^{ m - k}} \hat w^\prime(\hat f(\alpha, b), \alpha, b) = h_k (\alpha_k),$$</p>
<h4 id="2-send-folded-function">2. Send folded function</h4>
<p>The Prover sends a function $g: \mathcal{L}^{(2)} \to \mathbb{F}$. In the honest case, $$\hat g(X) = \hat f(\alpha, X),$$ then $\hat g \in \mathbb{F}^{\leq 1} \left[X_1, \ldots, X_{ m - k}\right]$, and $g$ represents the evaluations of $\hat g$ on the domain<br />
$$ g(x) = \hat f(\alpha_1^{ 2^0 }, \ldots, \alpha_k^{ 2^k }, x^{ 2^{ k + 1}}, \ldots, x^{ 2^m } ) : \forall x \in \mathcal{L}^{(2)}.$$</p>
<h4 id="3-out-of-domain-sample-and-evaluation">3. Out-of-domain sample and evaluation</h4>
<p>The Verifier samples and sends $z_0 \in \mathbb{F}$. The prover evaluates and sends $y_0 = \hat g(z_0)$.</p>
<p><em>Abuse of notation:</em> We denote $\hat g(z_0) = \hat g(z_0^{ 2^0 }, z_0^{ 2^1 }, \ldots, z_0^{ 2^{ m - k - 1}})$.</p>
<p>The out-of-domain sampling essentially forces the prover to choose one of the possible polynomials within a list of polynomials associated with the oracle.</p>
<h4 id="4-shift-queries-and-combination-randomness">4. Shift queries and combination randomness</h4>
<p>The Verifier samples and sends $z_1, \ldots, z_t \in \mathcal{L}^{ (2^k) }$, where $t$ is the number required in this WHIR iteration, determined by the security parameter $\lambda$. Then for each $i \in \{1, \ldots t\}$, the Verifier queries f and obtains<br />
$$y_i = \text{Fold}(f, \alpha) (z_i)$$<br />
Then, the Verifier samples and sends $\gamma \in \mathbb{F}$.</p>
<p><strong>What is the Fold function?</strong></p>
<p>Folding of Reed–Solomon codes is a method for lowering the complexity of a code at a relatively small cost and lies at the core of IOPPs for Reed–Solomon codes.</p>
<p>Given $f: \mathcal{L} \to \mathbb{F}$ and $a \in \mathbb{F}$ we define $\text{Fold}(f, a): \mathcal{L}^{(2)} \to \mathbb{F}$ as follows: For each $z \in \mathcal{L}^{(2)}$</p>
<p>$$\text{Fold}(f, a) (z) = \frac{f(x) + f(- x)}{2} + a \cdot \frac{f(x) - f(- x)}{2x},$$</p>
<p>where $x$ is the point in $\mathcal{L}$ such that $z = x^2 = (- x)^2$.</p>
<p>Now, given a vector $\alpha = (\alpha_1, \ldots, \alpha_k) \in \mathbb{F}^k,$ we denote<br />
$$\text{Fold}(f, \alpha): \mathcal{L}^{ (2^{k}) } \to \mathbb{F}$$<br />
to the recursive folding on each of the entries in $\alpha$. That is:</p>
<p>$$\text{Fold}(f, (\alpha_j, \ldots, \alpha_k)) = \text{Fold}(\text{Fold}(f, \alpha_j), (\alpha_{j+1}, \ldots, \alpha_k))$$</p>
<p><em>Example:</em> If $k = 3$, then<br />
$$\text{Fold}(f, (\alpha_1, \alpha_2, \alpha_3)) = \text{Fold}(\text{Fold}(f, \alpha_1), (\alpha_2, \alpha_3))$$</p>
<p>Let’s say $\text{Fold}(f, \alpha_1) = f_1$. Then,</p>
<p>$$\text{Fold}(\text{Fold}(f, \alpha_1), (\alpha_2, \alpha_3)) = \text{Fold}(f_1, (\alpha_2, \alpha_3)) = \text{Fold}(\text{Fold}(f_1, \alpha_2), \alpha_3)$$</p>
<p>Let’s say $\text{Fold}(f_1, \alpha_2) = f_2$. Then,</p>
<p>$$\text{Fold}(\text{Fold}(f_1, \alpha_2), \alpha_3) = \text{Fold}(f_2, \alpha_3)$$</p>
<p>So in conclusion,<br />
$$\begin{align}<br />
\text{Fold}(f, (\alpha_1, \alpha_2, \alpha_3)) &amp;= \text{Fold}(f_2, \alpha_3) \<br />
&amp;= \text{Fold}(\text{Fold}(\text{Fold}(f, \alpha_1), \alpha_2), \alpha_3)<br />
\end{align}$$</p>
<h4 id="6-recursive-claim">6. Recursive claim</h4>
<p>Both Prover and Verifier define the new weight polynomial and target<br />
$$\hat w^\prime (Z, X) = \hat w(Z, \alpha, X) + Z \cdot \sum_{i = 0}^t \gamma^{i + 1} \cdot \text{eq}(z_i, X)$$<br />
$$\sigma’ = \hat h(\alpha_k) + \sum_{i = 0}^t \gamma^{i+1} \cdot y_i$$</p>
<p>and recurse on the claim that<br />
$$g \in CRS\left[\mathbb{F}, \mathcal{L}^{(2)}, m - k, \hat w^\prime, \sigma^\prime \right].$$</p>
<p><strong>Why this weight and this target?</strong></p>
<p>We want to see how this iteration replace the claim<br />
$$f \in C = CRS\left[\mathbb{F}, \mathcal{L}, m, \hat w, \sigma\right]$$ to the claim $$g \in C^\prime = CRS\left[\mathbb{F}, \mathcal{L}^{(2)}, m-k, \hat w^\prime, \sigma^\prime\right].$$<br />
First, note that $\hat w \in \mathbb{F} \left[Z, X_1, \ldots, X_m\right]$ and $\hat w^\prime \in \mathbb{F}\left[Z, X_1, \ldots, X_{ m - k }\right]$.</p>
<p>If the Prover is honest and $f \in C$, why does $g \in C^\prime$?</p>
<p>On one hand, $g \in RS\left[\mathbb{F}, \mathcal{L}^{(2)}, m - k\right]$ because $\hat g \in \mathbb{F}^{\leq 1} \left[X_1, \ldots, X_{ m - k }\right]$ is such that $g(x) = \hat f(\alpha_1^{ 2^0 }, \ldots, \alpha_k^{ 2^k }, x^{ 2^{ k + 1 }}, \ldots, x^{ 2^m } )$.</p>
<p>On the other hand, we need to check the sum constraint: We want to prove that<br />
$$\sum_{b \in \{0, 1 \}^{ m - k}} \hat w^\prime (\hat g(b), b) = \sigma^\prime .$$<br />
Let’s see:<br />
$$\sum_{b \in \{0, 1 \}^{ m - k}} \hat w^\prime (\hat g(b), b) = \sum_{b \in \{0, 1 \}^{ m - k}} \hat w(\hat f(\alpha, b), (\alpha, b)) + \hat f(\alpha, b) \sum_{i = 0}^t \gamma^{i + 1} \cdot eq(z_i, b)$$<br />
$$\sigma^\prime = \hat h(\alpha_k) + \sum_{i = 0}^t \gamma^{ i + 1} \cdot y_i$$</p>
<p>Since<br />
$$\hat h(\alpha_k) = \sum_{b \in \{0, 1 \}^{ m - k}} \hat w(\hat f(\alpha, b), (\alpha, b)),$$<br />
we just need to check that<br />
$$\sum_{i = 0}^t \gamma^{i+1} \cdot y_i = \sum_{b \in \{0, 1 \}^{ m - k}} \hat f(\alpha, b) \cdot \sum_{i = 0}^t \gamma^{i + 1} \cdot eq(z_i, b),$$<br />
where<br />
$$\sum_{i = 0}^t \gamma^{i + 1} \cdot y_i = \gamma \cdot \hat f(\alpha, z_0) + \sum_{i = 1}^t \gamma^{i + 1} \cdot \text{Fold}(f, \alpha)(z_i).$$</p>
<h2 id="next-steps">Next steps</h2>
<p>In upcoming posts, we will be covering several aspects related to the security of WHIR, its use as a proving backend for efficient post-quantum secure signature aggregation and possible improvements to reduce proof size and proving time.</p>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
