<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>How to code FRI from scratch - LambdaClass Blog</title>
    <meta name="description" content="Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">How to code FRI from scratch</h1>
        
        <div class="page-meta">
            <time datetime="2023-08-18">August 18, 2023</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <h2 id="introduction">Introduction</h2>
<p><a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2018/046.pdf">STARKs</a> (scalable transparent arguments of knowledge) have gained a lot of attention in recent years due to their capacity to help scale Ethereum and other L1s. They provide a way to guarantee the integrity of a computation carried out by an untrusted party via cryptographic proof. This proof can be verified much faster than the trivial check of the computation, that is, rerunning the whole computation by other parties. The key idea is that the whole computation can be expressed as a table of values and a set of polynomial constraints they must satisfy. This set of constraints can be converted into a random linear combination of quotients of polynomials of the form (we will not go into the details of this transformation. For an intro, see <a rel="noopener external" target="_blank" href="https://github.com/starkware-industries/stark101">Stark-101</a> or <a href="/diving-deep-fri/">our blog</a>)<br />
$$p_0 (x) = \sum_k \alpha_k \frac{c_k (x)}{z_k (x)}$$<br />
where $c_k (x)$ and $z_k (x)$ are polynomials. The computation is valid if $p_0 (x)$ is a polynomial (if not, it will be a rational function) and will happen if each $c_k (x)$ is <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Polynomial_long_division">divisible</a> by its corresponding $z_k (x)$. How can we convince a verifier quickly that the previous $p_0 (x)$ is a polynomial? The key ingredient is the FRI protocol, which we will cover in the following sections. The code presented is taken from the <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks_stark_platinum/tree/main">Stark Platinum Prover</a></p>
<p>If you want to learn more about the FRI protocol and its properties, we recommend you read <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2018/046.pdf">the original STARKs paper</a> and <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2022/1216.pdf">A summary on the FRI low degree test</a>. We want to thank Eli Ben-Sasson and the amazing Starkware team for helping us learn the protocol and in developing the prover.</p>
<h2 id="the-idea-behind-fri">The idea behind FRI</h2>
<p>FRI stands for Fast Reed-Solomon Interactive oracle proof of proximity. It allows us to prove that the evaluations of a given function, $p$, over a domain, $D_0$ correspond to the evaluations of a low-degree polynomial (with respect to the size of $D_0$). Why is this useful?</p>
<p>Suppose we want to convince someone that we have some polynomial, $p_0$ of degree $N$. We could pass all the values of the $N+1$ coefficients or $N+1$ evaluations of the polynomial over some set. The problem is that we must pass $N+1$ numbers (in STARKs, the degree $N$ can be large), and the proof and verification will not be short. We could do better by reducing the degree of the polynomial by some suitable transformation. We can split the polynomial into the odd and even degree powers (we will suppose that $N$ is odd, but this doesn‚Äôt matter),<br />
$p_0 (x) = p_{0,e} ( x^2 ) + x p_{0,o} (x^2 )$<br />
where<br />
$p_{0,e} ( x^2 ) = a_0 + a_2 x^2 + a_4 x^4 + ‚Ä¶ + a_{N-1} x^{N-1}$<br />
and<br />
$p_{0,o} ( x^2 ) = a_1 + a_3 x^2 + a_5 x^4 + ‚Ä¶ + a_N x^{N-1}$<br />
we can randomly fold the two parts by getting a random $\beta_0$ and create a polynomial of degree $(N - 1) / 2$,<br />
$p_1 (y) = (a_0 + \beta_0 a_1 ) + (a_2 + \beta_0 a_3 ) y + ‚Ä¶ + (a_{N-1} + \beta_0 a_N ) y^{(N - 1)/2}$<br />
We could show that we have a polynomial by passing all the $(N + 1)/2$ coefficients of $p_1 (y)$ and some evaluations of $p_0 (x)$ to show that we deduced correctly $p_1 (y)$ from $p_0 (x)$.</p>
<p>Of course, why would we stop with $(N + 1)/2$ coefficients when we could further reduce the number of coefficients by repeating the same strategy?<br />
$p_1 (y) = p_{1,e} ( y^2 ) + y p_{1,o} (y^2 )$<br />
where<br />
$p_{1,e} ( y^2 ) = b_0 + b_2 y^2 + b_4 y^4 + ‚Ä¶ + b_{M} y^{M-1}$<br />
and<br />
$p_{1,o} ( y^2 ) = b_1 + b_3 y^2 + b_5 y^4 + ‚Ä¶ + b_M y^{M-1}$<br />
Then, we sample randomly $\beta_1$ and fold<br />
$p_2 (z) = (b_0 + \beta_1 b_1 ) + (b_2 + \beta_1 b_3 ) z + ‚Ä¶ + (b_{M-1} + \beta_1 a_M ) z^{(M - 1)/2}$<br />
We can do this and reduce the degree of the polynomial by half at each step. After the $\log_2 (N)$ steps, we arrive at a constant polynomial and only need to pass that value. We could be convinced that we were given a polynomial if we could go down these foldings and arrive at the last constant value.</p>
<p>Below we give the rust code to fold a polynomial used in Lambdaworks:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub fn fold_polynomial&lt;F&gt;(</span></span>
<span class="giallo-l"><span>    poly: &amp;Polynomial&lt;FieldElement&lt;F&gt;&gt;,</span></span>
<span class="giallo-l"><span>    beta: &amp;FieldElement&lt;F&gt;,</span></span>
<span class="giallo-l"><span>) -&gt; Polynomial&lt;FieldElement&lt;F&gt;&gt;</span></span>
<span class="giallo-l"><span>where</span></span>
<span class="giallo-l"><span>    F: IsField,</span></span>
<span class="giallo-l"><span>{</span></span>
<span class="giallo-l"><span>    let coef = poly.coefficients();</span></span>
<span class="giallo-l"><span>    let even_coef: Vec&lt;FieldElement&lt;F&gt;&gt; = coef.iter().step_by(2).cloned().collect();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // odd coefficients of poly are multiplied by beta</span></span>
<span class="giallo-l"><span>    let odd_coef_mul_beta: Vec&lt;FieldElement&lt;F&gt;&gt; = coef</span></span>
<span class="giallo-l"><span>        .iter()</span></span>
<span class="giallo-l"><span>        .skip(1)</span></span>
<span class="giallo-l"><span>        .step_by(2)</span></span>
<span class="giallo-l"><span>        .map(|v| (v.clone()) * beta)</span></span>
<span class="giallo-l"><span>        .collect();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let (even_poly, odd_poly) = Polynomial::pad_with_zero_coefficients(</span></span>
<span class="giallo-l"><span>        &amp;Polynomial::new(&amp;even_coef),</span></span>
<span class="giallo-l"><span>        &amp;Polynomial::new(&amp;odd_coef_mul_beta),</span></span>
<span class="giallo-l"><span>    );</span></span>
<span class="giallo-l"><span>    even_poly + odd_poly</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>The polynomial <code>poly</code> is a variable that contains the coefficients of the polynomial as a vector of field elements. We collect the values of even degree coefficients in line 9, and we take all the odd degree coefficients and multiply them by $\beta$ in lines 12 to 17 (we could also make it more efficient by zipping the iterators and avoiding collecting the results and then iterating again over the arrays to add the values).</p>
<p>The problem is that we need to ensure that the polynomials cannot be changed to generate random values. One way to bind us to a polynomial is to build a <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle tree</a> from the evaluations of the polynomial over a suitable domain (this is the part where Reed-Solomon codes come into play). We take a domain $D_0 = { \omega, \omega g, \omega g^2 , ‚Ä¶ , \omega g^{\alpha N - 1} }$, where $g$ is a generator of the $\alpha N$ roots of unity and $\omega$ is an element outside the set generated by the powers of $g$. This way, we are forced to provide only values in the tree; the security of this scheme depends on the collision resistance of the hash function used to build the tree. For every folding step, we will have to make a layer containing the values of the evaluations of the polynomial and its corresponding Merkle tree. An advantage of using $D_0$ as a domain is that when we consider the domain $D_1$ for $y = x^2$, its size is exactly half the size of $D_0$. Therefore, the size of the tree for $p_1 (y)$ will be smaller than the size of the one corresponding to $p_0 (x)$ (this is a property of the $n$-th roots of unity, when $n$ is a power of 2. If $x_0$ is in the set, so is $- x_0$ and $x_0^2 = (- x_0)^2 = x_0^2$, so we only have $n/2$ different elements).</p>
<p>FRI is also useful for creating a commitment scheme for polynomials using Merkle trees. If we want to show someone that we have a low degree polynomial $p(x)$ such that $p(z) = v$, we can evaluate the following quotient,<br />
$$q (x) = \frac{p(x) - v}{ x - z}$$<br />
and apply the FRI protocol to that quotient to show that it is indeed a low-degree polynomial.</p>
<h2 id="creating-fri-layers">Creating FRI layers</h2>
<p>As mentioned before, we need to commit ourselves to our polynomial, and we will do that by creating a Merkle tree with the evaluations over a suitable domain. Below we provide a basic structure for a FriLayer: a vector of evaluations and a Merkle tree (we add the coset offset, $\omega$, and domain size just for convenience).</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>#[derive(Clone)]</span></span>
<span class="giallo-l"><span>pub struct FriLayer&lt;F&gt;</span></span>
<span class="giallo-l"><span>where</span></span>
<span class="giallo-l"><span>    F: IsField,</span></span>
<span class="giallo-l"><span>    FieldElement&lt;F&gt;: ByteConversion,</span></span>
<span class="giallo-l"><span>{</span></span>
<span class="giallo-l"><span>    pub evaluation: Vec&lt;FieldElement&lt;F&gt;&gt;,</span></span>
<span class="giallo-l"><span>    pub merkle_tree: FriMerkleTree&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    pub coset_offset: FieldElement&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    pub domain_size: usize,</span></span>
<span class="giallo-l"><span>}</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>impl&lt;F&gt; FriLayer&lt;F&gt;</span></span>
<span class="giallo-l"><span>where</span></span>
<span class="giallo-l"><span>    F: IsField + IsFFTField,</span></span>
<span class="giallo-l"><span>    FieldElement&lt;F&gt;: ByteConversion,</span></span>
<span class="giallo-l"><span>{</span></span>
<span class="giallo-l"><span>    pub fn new(</span></span>
<span class="giallo-l"><span>        poly: &amp;Polynomial&lt;FieldElement&lt;F&gt;&gt;,</span></span>
<span class="giallo-l"><span>        coset_offset: &amp;FieldElement&lt;F&gt;,</span></span>
<span class="giallo-l"><span>        domain_size: usize,</span></span>
<span class="giallo-l"><span>    ) -&gt; Self {</span></span>
<span class="giallo-l"><span>        let evaluation = poly</span></span>
<span class="giallo-l"><span>            .evaluate_offset_fft(1, Some(domain_size), coset_offset)</span></span>
<span class="giallo-l"><span>            .unwrap(); </span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        let merkle_tree = FriMerkleTree::build(&amp;evaluation);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        Self {</span></span>
<span class="giallo-l"><span>            evaluation,</span></span>
<span class="giallo-l"><span>            merkle_tree,</span></span>
<span class="giallo-l"><span>            coset_offset: coset_offset.clone(),</span></span>
<span class="giallo-l"><span>            domain_size,</span></span>
<span class="giallo-l"><span>        }</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>We also provide a method to create layers, given a polynomial, the domain size, and the domain offset. This will be combined later with the folding function to create new polynomials and obtain the different layers.</p>
<p>Given the polynomial, we can evaluate it efficiently using FFT (due to the particular structure we are using) and obtain a vector of field elements, as shown in line 23. In line 27, we build the Merkle tree from the vector of evaluations (if you want to learn more on how the Merkle tree works behind the scenes, see <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks/tree/main/crypto/src/merkle_tree">here</a>). In the next section, we will show how to build and commit to all the FRI layers. After this stage, we can prove we committed to a low-degree polynomial.</p>
<h2 id="fri-commitment-phase">FRI commitment phase</h2>
<p>Now that we can fold polynomials and build layers, we can commit to every layer and get the first part of the FRI protocol. The commit phase will give us a vector of layers and the final value of the FRI protocol (when we get to a degree zero polynomial). The function needs to receive the number of layers (which can be obtained from the degree of the polynomial), the polynomial in coefficient form, the transcript of the protocol (we will be appending here the roots of the Merkle trees and use this to generate the random challenges by the Fiat-Shamir transformation), the offset and domain size (we could give the domain $D_0$ instead of these last two). The domain size determines the size of the group of roots of unity, and the offset allows us to shift that group.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub fn fri_commit_phase&lt;F: IsField + IsFFTField, T: Transcript&gt;(</span></span>
<span class="giallo-l"><span>    number_layers: usize,</span></span>
<span class="giallo-l"><span>    p_0: Polynomial&lt;FieldElement&lt;F&gt;&gt;,</span></span>
<span class="giallo-l"><span>    transcript: &amp;mut T,</span></span>
<span class="giallo-l"><span>    coset_offset: &amp;FieldElement&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    domain_size: usize,</span></span>
<span class="giallo-l"><span>) -&gt; (FieldElement&lt;F&gt;, Vec&lt;FriLayer&lt;F&gt;&gt;)</span></span>
<span class="giallo-l"><span>where</span></span>
<span class="giallo-l"><span>    FieldElement&lt;F&gt;: ByteConversion,</span></span>
<span class="giallo-l"><span>{</span></span>
<span class="giallo-l"><span>    let mut domain_size = domain_size;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let mut fri_layer_list = Vec::with_capacity(number_layers);</span></span>
<span class="giallo-l"><span>    let mut current_layer = FriLayer::new(&amp;p_0, coset_offset, domain_size);</span></span>
<span class="giallo-l"><span>    fri_layer_list.push(current_layer.clone());</span></span>
<span class="giallo-l"><span>    let mut current_poly = p_0;</span></span>
<span class="giallo-l"><span>    // &gt;&gt;&gt;&gt; Send commitment: [p‚ÇÄ]</span></span>
<span class="giallo-l"><span>    transcript.append(&amp;current_layer.merkle_tree.root);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let mut coset_offset = coset_offset.clone();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    for _ in 1..number_layers {</span></span>
<span class="giallo-l"><span>        // &lt;&lt;&lt;&lt; Receive challenge ùúÅ‚Çñ‚Çã‚ÇÅ</span></span>
<span class="giallo-l"><span>        let zeta = transcript_to_field(transcript);</span></span>
<span class="giallo-l"><span>        coset_offset = coset_offset.square();</span></span>
<span class="giallo-l"><span>        domain_size /= 2;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        // Compute layer polynomial and domain</span></span>
<span class="giallo-l"><span>        current_poly = fold_polynomial(&amp;current_poly, &amp;zeta);</span></span>
<span class="giallo-l"><span>        current_layer = FriLayer::new(&amp;current_poly, &amp;coset_offset, domain_size);</span></span>
<span class="giallo-l"><span>        let new_data = &amp;current_layer.merkle_tree.root;</span></span>
<span class="giallo-l"><span>        fri_layer_list.push(current_layer.clone()); // TODO: remove this clone</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        // &gt;&gt;&gt;&gt; Send commitment: [p‚Çñ]</span></span>
<span class="giallo-l"><span>        transcript.append(new_data);</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // &lt;&lt;&lt;&lt; Receive challenge: ùúÅ‚Çô‚Çã‚ÇÅ</span></span>
<span class="giallo-l"><span>    let zeta = transcript_to_field(transcript);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let last_poly = fold_polynomial(&amp;current_poly, &amp;zeta);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let last_value = last_poly</span></span>
<span class="giallo-l"><span>        .coefficients()</span></span>
<span class="giallo-l"><span>        .get(0)</span></span>
<span class="giallo-l"><span>        .unwrap_or(&amp;FieldElement::zero())</span></span>
<span class="giallo-l"><span>        .clone();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // &gt;&gt;&gt;&gt; Send value: p‚Çô</span></span>
<span class="giallo-l"><span>    transcript.append(&amp;last_value.to_bytes_be());</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    (last_value, fri_layer_list)</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>We start by creating the layer for the first polynomial (which, in the context of a STARK prover, is the DEEP composition polynomial) at line 14. Then, we commit to the polynomial evaluations using the Merkle tree by appending the root to the transcript (line 18).</p>
<p>Afterward, we continue with the recursive part of FRI: we sample the random coefficient ($\zeta$ in the code, line 24), we square the offset and reduce the domain size (so that we can generate the next evaluation domain), and we fold the polynomial in line 29. We obtain the new layer (line 30), add the root to the transcript (so that we commit to the evaluations of the new polynomial) and add the new layer to the vector of FriLayers. After we have gone through the recursive parts, we fold one last time to arrive at the degree zero polynomial and get the final value, which we also append to the transcript (line 50).</p>
<h2 id="fri-decommitment">FRI decommitment</h2>
<p>Now that we created all the commitments, we need to generate the proof so that a verifier can check that everything was done correctly. The only things we can pass to the verifier are values that we committed to by using Merkle trees. Any evaluation in a tree can be calculated from the evaluations inside a tree in the previous layers. We can see that:<br />
$$p_{0,e} (x) = \frac{p_0 (x) + p_0( - x )}{2}$$<br />
and<br />
$$p_{0,o} (x) = \frac{p_0 (x) - p_0( - x )}{2x}$$<br />
Luckily, if $p_0 (x_0)$ is in the Merkle tree, so is $p_0 (- x_0 )$, because of how we chose the domain $D_0$ . We can see then that<br />
$$p_1 ( x_0^2 ) = \frac{p_0 ( x_0 ) + p_0( - x_0 )}{2} + \beta_0 \frac{(p_0 ( x_0 ) - p_0( - x_0 ))}{2x_0}$$<br />
Similarly,<br />
$$p_k ( w_0^2 ) = \frac{p_{k - 1} ( w_0 ) + p_{ k - 1}( - w_0 )}{2} + \beta_0 \frac{(p_{ k - 1 } ( w_0 ) - p_{ k - 1}( - w_0 ))}{2w_0}$$<br />
Therefore, we can check a value in a tree if we pass two values from the tree from the previous layer (these have to be the correct pair, which, owing to the structure of the evaluation domain, are always separated by half the length of the size of the tree).</p>
<p>We will let the verifier choose an index in the Merkle tree of $p_0 (x)$. We will provide the verifier with the values of $p_0 (x_0)$ (where $x_0$ is the point in the domain corresponding to the index chosen by the verifier) and $p_0 (-x_0)$, $p_1 ( x_0^2 )$, $p_1 ( - (x_0^2 ))$, $p_2 ( x_0^4 )$, $p_2 ( - (x_0^4 ))$ until $p_{ N - 1 } ( x_0^{ 2^{ N - 1 }} )$, $p_{ N - 1} ( - (x_0^{ 2^{ N - 1 }} ))$. This way, the verifier can go from the first polynomial to the final value and check that we did everything correctly. We must also show him that the values we passed belong to their correspondent Merkle tree. We will do this by providing him with an inclusion proof, given by the authentication paths for each value. If the inclusion proofs and calculations between the layers pass, the verifier will be convinced that we did things correctly for one point. However, passing the test for one point does not mean that the function is indeed a polynomial because FRI has a statistical nature. Of course, the verifier could choose more points, and if the test passes for all points, the verifier could be convinced with a high probability that the function is indeed a polynomial. We will call each point the verifier chooses a query (the higher the number of queries, the more likely the prover will be caught cheating).</p>
<p>To handle each query better, we will have a FriDecommitment structure containing all the evaluation pairs (<code>layers_evaluations</code> and <code>layers_evaluations_sym</code>) and authentication paths for each (<code>layers_auth_paths</code> and <code>layers_auth_paths_sym</code>).</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub struct FriDecommitment&lt;F: IsPrimeField&gt; {</span></span>
<span class="giallo-l"><span>    pub layers_auth_paths_sym: Vec&lt;Proof&lt;Commitment&gt;&gt;,</span></span>
<span class="giallo-l"><span>    pub layers_evaluations_sym: Vec&lt;FieldElement&lt;F&gt;&gt;,</span></span>
<span class="giallo-l"><span>    pub layers_auth_paths: Vec&lt;Proof&lt;Commitment&gt;&gt;,</span></span>
<span class="giallo-l"><span>    pub layers_evaluations: Vec&lt;FieldElement&lt;F&gt;&gt;,</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>We can now jump onto the query phase of the protocol and obtain the proof for the FRI protocol. Since we want the protocol to be non-interactive, we need the transcript (to simulate the verifier by Fiat-Shamir transformation), all the information from the FriLayers, and other parameters, such as the number of queries (contained here inside the air).</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub fn fri_query_phase&lt;F, A, T&gt;(</span></span>
<span class="giallo-l"><span>    air: &amp;A,</span></span>
<span class="giallo-l"><span>    domain_size: usize,</span></span>
<span class="giallo-l"><span>    fri_layers: &amp;Vec&lt;FriLayer&lt;F&gt;&gt;,</span></span>
<span class="giallo-l"><span>    transcript: &amp;mut T,</span></span>
<span class="giallo-l"><span>) -&gt; (Vec&lt;FriDecommitment&lt;F&gt;&gt;, Vec&lt;usize&gt;)</span></span>
<span class="giallo-l"><span>where</span></span>
<span class="giallo-l"><span>    F: IsFFTField,</span></span>
<span class="giallo-l"><span>    A: AIR&lt;Field = F&gt;,</span></span>
<span class="giallo-l"><span>    T: Transcript,</span></span>
<span class="giallo-l"><span>    FieldElement&lt;F&gt;: ByteConversion,</span></span>
<span class="giallo-l"><span>{</span></span>
<span class="giallo-l"><span>    if !fri_layers.is_empty() {</span></span>
<span class="giallo-l"><span>        let number_of_queries = air.options().fri_number_of_queries;</span></span>
<span class="giallo-l"><span>        let iotas = (0..number_of_queries)</span></span>
<span class="giallo-l"><span>            .map(|_| (transcript_to_u32(transcript) as usize) % domain_size)</span></span>
<span class="giallo-l"><span>            .collect::&lt;Vec&lt;usize&gt;&gt;();</span></span>
<span class="giallo-l"><span>        let query_list = iotas</span></span>
<span class="giallo-l"><span>            .iter()</span></span>
<span class="giallo-l"><span>            .map(|iota_s| {</span></span>
<span class="giallo-l"><span>                // &lt;&lt;&lt;&lt; Receive challenge ùúÑ‚Çõ (iota_s)</span></span>
<span class="giallo-l"><span>                let mut layers_auth_paths_sym = vec![];</span></span>
<span class="giallo-l"><span>                let mut layers_evaluations_sym = vec![];</span></span>
<span class="giallo-l"><span>                let mut layers_evaluations = vec![];</span></span>
<span class="giallo-l"><span>                let mut layers_auth_paths = vec![];</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>                for layer in fri_layers {</span></span>
<span class="giallo-l"><span>                    // symmetric element</span></span>
<span class="giallo-l"><span>                    let index = iota_s % layer.domain_size;</span></span>
<span class="giallo-l"><span>                    let index_sym = (iota_s + layer.domain_size / 2) % layer.domain_size;</span></span>
<span class="giallo-l"><span>                    let evaluation_sym = layer.evaluation[index_sym].clone();</span></span>
<span class="giallo-l"><span>                    let auth_path_sym = layer.merkle_tree.get_proof_by_pos(index_sym).unwrap();</span></span>
<span class="giallo-l"><span>                    let evaluation = layer.evaluation[index].clone();</span></span>
<span class="giallo-l"><span>                    let auth_path = layer.merkle_tree.get_proof_by_pos(index).unwrap();</span></span>
<span class="giallo-l"><span>                    layers_auth_paths_sym.push(auth_path_sym);</span></span>
<span class="giallo-l"><span>                    layers_evaluations_sym.push(evaluation_sym);</span></span>
<span class="giallo-l"><span>                    layers_evaluations.push(evaluation);</span></span>
<span class="giallo-l"><span>                    layers_auth_paths.push(auth_path);</span></span>
<span class="giallo-l"><span>                }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>                FriDecommitment {</span></span>
<span class="giallo-l"><span>                    layers_auth_paths_sym,</span></span>
<span class="giallo-l"><span>                    layers_evaluations_sym,</span></span>
<span class="giallo-l"><span>                    layers_evaluations,</span></span>
<span class="giallo-l"><span>                    layers_auth_paths,</span></span>
<span class="giallo-l"><span>                }</span></span>
<span class="giallo-l"><span>            })</span></span>
<span class="giallo-l"><span>            .collect();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        (query_list, iotas)</span></span>
<span class="giallo-l"><span>    } else {</span></span>
<span class="giallo-l"><span>        (vec![], vec![])</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>In line 15, we sample all the indexed to open in the Merkle tree belonging to $p_0 (x)$. We normalize by the domain size to ensure the queries fall in the range. Once we get all the indexes to query, we can iterate over them as in line 18 (in this case, we could do it in parallel). For each index, we will go through each FriLayer and get the indexes for $p_k ( u )$ and $p_k ( - u)$ (this is done by taking the remainder between the current index and the domain size for the FriLayer), as in lines 29 and 30, and then take the values of the leaves in the Merkle tree (lines 31 and 33), together with the corresponding authentication paths (lines 32 and 34). We then add each to the vectors containing the evaluations and authentication paths for each query. Finally, we get the complete list of queries and all the necessary values.</p>
<h2 id="verification">Verification</h2>
<p>If a verifier wants to check our work, he needs to perform both the inclusion proofs (to see all values belong to Merkle trees) and that each layer is obtained from the previous one until we reach degree zero. Since the protocol was done non-interactively, the verifier must replay all the random $\beta_k$. We will only focus on the FRI part, but remember that in a general STARK prover, we have more work before that:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>let merkle_roots = &amp;proof.fri_layers_merkle_roots;</span></span>
<span class="giallo-l"><span>    let zetas = merkle_roots</span></span>
<span class="giallo-l"><span>        .iter()</span></span>
<span class="giallo-l"><span>        .map(|root| {</span></span>
<span class="giallo-l"><span>            // &lt;&lt;&lt;&lt; Receive commitment: [p‚Çñ] (the first one is [p‚ÇÄ])</span></span>
<span class="giallo-l"><span>            transcript.append(root);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>            // &gt;&gt;&gt;&gt; Send challenge ùúÅ‚Çñ</span></span>
<span class="giallo-l"><span>            transcript_to_field(transcript)</span></span>
<span class="giallo-l"><span>        })</span></span>
<span class="giallo-l"><span>        .collect::&lt;Vec&lt;FieldElement&lt;F&gt;&gt;&gt;();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // &lt;&lt;&lt;&lt; Receive value: p‚Çô</span></span>
<span class="giallo-l"><span>    transcript.append(&amp;proof.fri_last_value.to_bytes_be());</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // Receive grinding value</span></span>
<span class="giallo-l"><span>    // 1) Receive challenge from the transcript</span></span>
<span class="giallo-l"><span>    let transcript_challenge = transcript.challenge();</span></span>
<span class="giallo-l"><span>    let nonce = proof.nonce;</span></span>
<span class="giallo-l"><span>    let leading_zeros_count =</span></span>
<span class="giallo-l"><span>        hash_transcript_with_int_and_get_leading_zeros(&amp;transcript_challenge, nonce);</span></span>
<span class="giallo-l"><span>    transcript.append(&amp;nonce.to_be_bytes());</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // FRI query phase</span></span>
<span class="giallo-l"><span>    // &lt;&lt;&lt;&lt; Send challenges ùúÑ‚Çõ (iota_s)</span></span>
<span class="giallo-l"><span>    let iota_max: usize = 2_usize.pow(domain.lde_root_order);</span></span>
<span class="giallo-l"><span>    let iotas: Vec&lt;usize&gt; = (0..air.options().fri_number_of_queries)</span></span>
<span class="giallo-l"><span>        .map(|_| (transcript_to_u32(transcript) as usize) % iota_max)</span></span>
<span class="giallo-l"><span>        .collect();</span></span></code></pre>
<p>The verifier appends to the transcript the roots of each Merkle tree, one at a time, and gets the value for $\beta_k$ (lines 2 to 11). Then, the verifier adds the final value of the FRI protocol (line 14); if there is proof of work, after the verifier has checked that the nonce provided is correct (done before), he adds the nonce to the transcript and samples all the indexes.</p>
<p>With this, the verifier can proceed to check all queries,</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>fn verify_fri&lt;F, A&gt;(</span></span>
<span class="giallo-l"><span>    proof: &amp;StarkProof&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    domain: &amp;Domain&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    challenges: &amp;Challenges&lt;F, A&gt;,</span></span>
<span class="giallo-l"><span>) -&gt; bool</span></span>
<span class="giallo-l"><span>where</span></span>
<span class="giallo-l"><span>    F: IsFFTField,</span></span>
<span class="giallo-l"><span>    FieldElement&lt;F&gt;: ByteConversion,</span></span>
<span class="giallo-l"><span>    A: AIR&lt;Field = F&gt;,</span></span>
<span class="giallo-l"><span>{</span></span>
<span class="giallo-l"><span>    // verify FRI</span></span>
<span class="giallo-l"><span>    let two_inv = &amp;FieldElement::from(2).inv();</span></span>
<span class="giallo-l"><span>    let mut evaluation_point_inverse = challenges</span></span>
<span class="giallo-l"><span>        .iotas</span></span>
<span class="giallo-l"><span>        .iter()</span></span>
<span class="giallo-l"><span>        .map(|iota| &amp;domain.lde_roots_of_unity_coset[*iota])</span></span>
<span class="giallo-l"><span>        .cloned()</span></span>
<span class="giallo-l"><span>        .collect::&lt;Vec&lt;FieldElement&lt;F&gt;&gt;&gt;();</span></span>
<span class="giallo-l"><span>    FieldElement::inplace_batch_inverse(&amp;mut evaluation_point_inverse);</span></span>
<span class="giallo-l"><span>    proof</span></span>
<span class="giallo-l"><span>        .query_list</span></span>
<span class="giallo-l"><span>        .iter()</span></span>
<span class="giallo-l"><span>        .zip(&amp;challenges.iotas)</span></span>
<span class="giallo-l"><span>        .zip(evaluation_point_inverse)</span></span>
<span class="giallo-l"><span>        .fold(true, |mut result, ((proof_s, iota_s), eval)| {</span></span>
<span class="giallo-l"><span>            //This is done in constant time</span></span>
<span class="giallo-l"><span>            result &amp;= verify_query_and_sym_openings(</span></span>
<span class="giallo-l"><span>                proof,</span></span>
<span class="giallo-l"><span>                &amp;challenges.zetas,</span></span>
<span class="giallo-l"><span>                *iota_s,</span></span>
<span class="giallo-l"><span>                proof_s,</span></span>
<span class="giallo-l"><span>                domain,</span></span>
<span class="giallo-l"><span>                eval,</span></span>
<span class="giallo-l"><span>                two_inv,</span></span>
<span class="giallo-l"><span>            );</span></span>
<span class="giallo-l"><span>            result</span></span>
<span class="giallo-l"><span>        })</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>In this function, the verifier receives all the FriDecommitment (contained in the StarkProof), the domain $D_0$ (which includes all evaluation points), and the challenges (indexes) sampled by replaying what the prover did. Lines 12 to 19 are just optimizations for performance, where the verifier computes the inverses of the evaluation points in batch (this is to calculate divisions more efficiently). Then, the verifier proceeds to check each query. The function <code>verify_query_and_sym_openings</code> has the following code:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>fn verify_query_and_sym_openings&lt;F: IsField + IsFFTField&gt;(</span></span>
<span class="giallo-l"><span>    proof: &amp;StarkProof&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    zetas: &amp;[FieldElement&lt;F&gt;],</span></span>
<span class="giallo-l"><span>    iota: usize,</span></span>
<span class="giallo-l"><span>    fri_decommitment: &amp;FriDecommitment&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    domain: &amp;Domain&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    evaluation_point: FieldElement&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    two_inv: &amp;FieldElement&lt;F&gt;,</span></span>
<span class="giallo-l"><span>) -&gt; bool</span></span>
<span class="giallo-l"><span>where</span></span>
<span class="giallo-l"><span>    FieldElement&lt;F&gt;: ByteConversion,</span></span>
<span class="giallo-l"><span>{</span></span>
<span class="giallo-l"><span>    let fri_layers_merkle_roots = &amp;proof.fri_layers_merkle_roots;</span></span>
<span class="giallo-l"><span>    let evaluation_point_vec: Vec&lt;FieldElement&lt;F&gt;&gt; =</span></span>
<span class="giallo-l"><span>        core::iter::successors(Some(evaluation_point), |evaluation_point| {</span></span>
<span class="giallo-l"><span>            Some(evaluation_point.square())</span></span>
<span class="giallo-l"><span>        })</span></span>
<span class="giallo-l"><span>        .take(fri_layers_merkle_roots.len())</span></span>
<span class="giallo-l"><span>        .collect();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let mut v = fri_decommitment.layers_evaluations[0].clone();</span></span>
<span class="giallo-l"><span>    // For each fri layer merkle proof check:</span></span>
<span class="giallo-l"><span>    // That each merkle path verifies</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // Sample beta with fiat shamir</span></span>
<span class="giallo-l"><span>    // Compute v = [P_i(z_i) + P_i(-z_i)] / 2 + beta * [P_i(z_i) - P_i(-z_i)] / (2 * z_i)</span></span>
<span class="giallo-l"><span>    // Where P_i is the folded polynomial of the i-th fiat shamir round</span></span>
<span class="giallo-l"><span>    // z_i is obtained from the first z (that was derived through Fiat-Shamir) through a known calculation</span></span>
<span class="giallo-l"><span>    // The calculation is, given the index, index % length_of_evaluation_domain</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // Check that v = P_{i+1}(z_i)</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // For each (merkle_root, merkle_auth_path) / fold</span></span>
<span class="giallo-l"><span>    // With the auth path containing the element that the path proves its existence</span></span>
<span class="giallo-l"><span>    fri_layers_merkle_roots</span></span>
<span class="giallo-l"><span>        .iter()</span></span>
<span class="giallo-l"><span>        .enumerate()</span></span>
<span class="giallo-l"><span>        .zip(&amp;fri_decommitment.layers_auth_paths)</span></span>
<span class="giallo-l"><span>        .zip(&amp;fri_decommitment.layers_evaluations)</span></span>
<span class="giallo-l"><span>        .zip(&amp;fri_decommitment.layers_auth_paths_sym)</span></span>
<span class="giallo-l"><span>        .zip(&amp;fri_decommitment.layers_evaluations_sym)</span></span>
<span class="giallo-l"><span>        .zip(evaluation_point_vec)</span></span>
<span class="giallo-l"><span>        .fold(</span></span>
<span class="giallo-l"><span>            true,</span></span>
<span class="giallo-l"><span>            |result,</span></span>
<span class="giallo-l"><span>             (</span></span>
<span class="giallo-l"><span>                (((((k, merkle_root), auth_path), evaluation), auth_path_sym), evaluation_sym),</span></span>
<span class="giallo-l"><span>                evaluation_point_inv,</span></span>
<span class="giallo-l"><span>            )| {</span></span>
<span class="giallo-l"><span>                let domain_length = 1 &lt;&lt; (domain.lde_root_order - k as u32);</span></span>
<span class="giallo-l"><span>                let layer_evaluation_index_sym = (iota + domain_length / 2) % domain_length;</span></span>
<span class="giallo-l"><span>                // Since we always derive the current layer from the previous layer</span></span>
<span class="giallo-l"><span>                // We start with the second one, skipping the first, so the previous layer is the first one</span></span>
<span class="giallo-l"><span>                // This is the current layer&#39;s evaluation domain length.</span></span>
<span class="giallo-l"><span>                // We need to know what the decommitment index for the current</span></span>
<span class="giallo-l"><span>                // layer is so we can check the Merkle paths at the right index.</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>                // Verify opening Open(p‚Çñ(D‚Çñ), ‚àíùúê‚Çõ^(2·µè))</span></span>
<span class="giallo-l"><span>                let auth_sym = &amp;auth_path_sym.verify::&lt;FriMerkleTreeBackend&lt;F&gt;&gt;(</span></span>
<span class="giallo-l"><span>                    merkle_root,</span></span>
<span class="giallo-l"><span>                    layer_evaluation_index_sym,</span></span>
<span class="giallo-l"><span>                    evaluation_sym,</span></span>
<span class="giallo-l"><span>                );</span></span>
<span class="giallo-l"><span>                // Verify opening Open(p‚Çñ(D‚Çñ), ùúê‚Çõ)</span></span>
<span class="giallo-l"><span>                let auth_point =</span></span>
<span class="giallo-l"><span>                    auth_path.verify::&lt;FriMerkleTreeBackend&lt;F&gt;&gt;(merkle_root, iota, evaluation);</span></span>
<span class="giallo-l"><span>                let beta = &amp;zetas[k];</span></span>
<span class="giallo-l"><span>                // v is the calculated element for the co-linearity check</span></span>
<span class="giallo-l"><span>                v = (&amp;v + evaluation_sym) * two_inv</span></span>
<span class="giallo-l"><span>                    + beta * (&amp;v - evaluation_sym) * two_inv * evaluation_point_inv;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>                // Check that the next value is given by the prover</span></span>
<span class="giallo-l"><span>                if k &lt; fri_decommitment.layers_evaluations.len() - 1 {</span></span>
<span class="giallo-l"><span>                    let next_layer_evaluation = &amp;fri_decommitment.layers_evaluations[k + 1];</span></span>
<span class="giallo-l"><span>                    result &amp; (v == *next_layer_evaluation) &amp; auth_point &amp; auth_sym</span></span>
<span class="giallo-l"><span>                } else {</span></span>
<span class="giallo-l"><span>                    result &amp; (v == proof.fri_last_value) &amp; auth_point &amp; auth_sym</span></span>
<span class="giallo-l"><span>                }</span></span>
<span class="giallo-l"><span>            },</span></span>
<span class="giallo-l"><span>        )</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>At each step, we have to divide by $x_0^{ 2^{ k } }$, which is the same as multiplying by the (multiplicative) inverse. We previously precomputed $x_0^{ - 1}$, and all the other inverses can be computed by repeatedly squaring that number (lines 14 to 19). Afterward, the verifier can go through all the FriLayers. We will use a fold iterator to have a constant time implementation (lines 35 to 43). If any check is false, then the proof will fail. The verifier samples the indexes for the current layer (line 51). Then, the verifier checks the inclusion proofs for the values (lines 59 and 65). Then, the verifier computes the value for the next layer from the current one (lines 69-70). If we are not in the last layer, the verifier checks whether this computed value is equal to the value given in the decommitment for the next layer (lines 73-75); if this does not pass, the test will fail. If it is the last layer, the verifier compares the computed value with the last value of the FRI protocol.</p>
<h2 id="security">Security</h2>
<p>The security of FRI depends on the size of the finite field, the security of the hash function, and the number of queries. Let‚Äôs dive into each aspect:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. The finite field size should be much larger than the degree of the polynomial (which in a STARK prover is related to the trace length). To achieve 128 bits of security, the field size should be at least $2^{128}$. If the maximum trace length is $2^{30}$, the field should be at least $2^{158}$. If the base field is not large enough, we can work with extensions when sampling random challenges. Some common choices are the StarkPrime 252, the prime $2^{64} - 2^{32} + 1$ (often miscalled MiniGoldilocks and using degree 3 extension fields), BabyBear or Mersenne 31 ($2^{31} - 1$, using degree 6 extension).</span></span>
<span class="giallo-l"><span>    2. The security provided by the hash function should be at least the security level we aim at. For hash functions such as SHA2, SHA3, Blake2, Blake3, and Poseidon, the security is simply the size of the digest (hash) divided by two. Therefore, using digests of 32 bytes (256 bits) achieves the desired security level. If we want to cover ourselves against Grover&#39;s algorithm from quantum computers, we need to double the digest size to 64 bytes (512 bits). This increases the size of the proof.</span></span>
<span class="giallo-l"><span>    3. The number of queries. Each query provides a certain amount of bits of security, depending on the blowup factor used. The number of queries can be reduced by introducing proof of work into the prover&#39;s protocol, incrementing the cost of generating false proofs. There is a tradeoff between the blowup factor used (which increases the prover&#39;s work and memory use) and the number of queries (which increases the proof size and verifier&#39;s work).</span></span></code></pre>
<p>For more discussion into the security of FRI, see <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2021/582">EthSTARK</a>, <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2022/1216.pdf">A summary on FRI low degree testing</a>, and <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2023/1071">Fiat-Shamir security of FRI</a>.</p>
<h2 id="summary">Summary</h2>
<p>FRI is a proximity test that allows us to show that a specific function is close to a low-degree polynomial, which is a helpful tool to build proof systems, such as STARKs or Plonky2.<br />
In this post, we covered how to code the protocol from scratch (except for the necessary Merkle trees and finite field arithmetic) and how to verify a FRI proof. The protocol consists of randomly folding a polynomial and committing to the evaluations of the polynomial over a suitable domain using Merkle trees until the resulting polynomial has degree zero. To show that the protocol was carried out correctly, the prover must supply evaluations of each polynomial and prove that those values are inside the Merkle tree. The protocol‚Äôs security relies on the properties of the hash function and depends on the size of the field, the size of the digest, and the number of queries used.</p>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
