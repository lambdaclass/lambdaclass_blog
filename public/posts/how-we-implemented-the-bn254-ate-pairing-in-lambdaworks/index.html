<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>How we implemented the BN254 Ate pairing in lambdaworks - LambdaClass Blog</title>
    <meta name="description" content="Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">How we implemented the BN254 Ate pairing in lambdaworks</h1>
        
        <div class="page-meta">
            <time datetime="2024-08-20">August 20, 2024</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <h2 id="introduction">Introduction</h2>
<p>The elliptic curve BN254 is currently the only curve with precompiled contracts on Ethereum, making it the most practical choice of a pairing-friendly curve suitable for on-chain <a href="/pinocchio-verifiable-computation-revisited/">zk-SNARK</a> verification with proof systems such as <a href="/groth16/">Groth16</a> and <a href="/all-you-wanted-to-know-about-plonk/">PlonK</a>. This work arises from the need to have our <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks/blob/main/math/src/elliptic_curve/short_weierstrass/curves/bn_254/pairing.rs">own implementation of the BN254 Ate pairing</a>. The idea of this post is to serve as a companion for our implementation, explaining the mathematical theory and algorithms needed to understand it. Several papers and articles present different algorithms for this pairing and its functions, so we thought organizing all that information into a single post would be helpful.</p>
<p>Regarding the mathematical background necessary to follow this reading, we only assume a slight notion of Groups, Finite Fields, and Elliptic Curves. If you do not feel confident in those topics we recommend reading our posts <a href="/math-survival-kit-for-developers/">Math Survival Kit for Developers</a> and <a href="/what-every-developer-needs-to-know-about-elliptic-curves/">What Every Developer Needs to Know About Elliptic Curves</a>.</p>
<h2 id="curve-parameters">Curve Parameters</h2>
<p>The BN254 (in Lambdaworks <code>BN254Curve</code>) is the Barreto-Naehrig pairing friendly elliptic curve $E$ of the form<br />
$$y^2 = x^3 + 3$$<br />
over a finite field $\mathbb{F_p}$ where:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * $p = 36x^4 + 36x^3 + 24x^2 + 6x + 1$ is the 254-bit prime number:</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>p = 21888242871839275222246405745257275088696311157297823662689037894645226208583</span></span>
<span class="giallo-l"><span>x = 4965661367192848881</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    * $t = 6x^2 + 1$ is the trace of Frobenius.</span></span>
<span class="giallo-l"><span>    * $r = 36x^4 + 36x^3 + 18x^2 + 6x + 1 = p + 1 - t$ is the number of points in the curve $E(\mathbb{F_p })$.</span></span></code></pre><h2 id="point-coordinates">Point Coordinates</h2>
<p>Since we define the elliptic curve as the set of points that satisfy the equation written above, it is natural to think of an element $P \in E(\mathbb{F_p })$ using two coordinates $P = (x, y)$. This representation is called <em>Affine Representation</em> and its coordinates are known as <em>Affine Coordinates</em>. However, many times to optimize the arithmetic, it will be convenient to use what is known as <em>Projective Coordinates</em> , which represent the points with three coordinates $x,$ $y,$ $z$, and is constructed in the following way:<br />
If $P = (x, y)$ is a point in affine coordinates, then $(x, y, 1)$ is its projective representation. And if $P = (x, y, z)$ is a point in projective coordinates, then $(\frac{x}{z}, \frac{y}{z})$ is its affine representation. You’ll see in our implementation that we use both representations depending on what we need in each case, using functions like <code>to_affine()</code>.</p>
<p>There is a third representation that we won’t use, but you may find in some papers, called <em>Jacobian Coordinates</em> : If $P = (x, y, z)$ is a point in Jacobian coordinates, then $(\frac{x}{z}, \frac{y}{z^2 }, z)$ and $(\frac{x}{z^2 }, \frac{y}{z^3 })$ are its projective and affine coordinates respectively.</p>
<h2 id="field-extension-tower">Field Extension Tower</h2>
<p>A pairing is a map $e: \mathbb{G_1 } \times \mathbb{G_2 } \to \mathbb{G_t }$, and this means that it takes as input two points, each from a group with the same number of points (or order) $r$. This number $r$ must be prime, and to guarantee security, it must be large. Also, for rather technical reasons, these two groups need to be distinct. So, to define a pairing, we need to choose these domains and codomain groups. The group $\mathbb{G_1 }$ will be the curve $E(\mathbb{F_p })$, but to define $\mathbb{G_2 }$ and $\mathbb{G_t }$ we’ll need to <em>extend</em> the field $\mathbb{F_p }$. We are not going to stop to explain in detail what field extensions are and how they are built, so if you are looking for a better understanding, we recommend reading the section <a rel="noopener external" target="_blank" href="https://hackmd.io/@benjaminion/bls12-381#Field-extensions">Field Extensions</a> from <em>BLS12-381 For the Rest of US</em>. Here, we’ll summarize the basic concepts necessary to understand our implementation and the algorithms we use.</p>
<p>Roughly speaking, our goal is to extend the field $\mathbb{F_p }$ to $\mathbb{F_{ p^{12} }}$, and we will do it in the following way. First, we extend $\mathbb{F_p }$ to $\mathbb{F_{ p^2 }}$ in the same way that the field of real numbers $\mathbb{R}$ is extended to the field of complex numbers $\mathbb{C}$: We define $$\mathbb{F_{ p^2 }} = \mathbb{F_p } [u] / (u^2 + 1).$$ That’s a lot of symbols to process. The good news is that all we need to understand is that $F_{ p^2 }$ is a finite field whose elements are polynomials of degree 1 and variable $u$; that is, they have the form $$a + bu \quad \text{ with } a, b \in \mathbb{F_p }.$$ If we think it as complex numbers, $a$ would be the real part and $b$ the imaginary one. Note that $\mathbb{F_p } \subseteq \mathbb{F_{ p^2 }}$ because we can think of the elements of the left one as elements of the right one with “imaginary part” zero or $b = 0$. So, $\mathbb{F_{ p^2 } }$ is indeed an extension of $\mathbb{F_p }.$<br />
Secondly, we extend $\mathbb{F_{ p^2 }}$ in a similar way defining $$\mathbb{F_{ p^6 }} = \mathbb{F_{ p^2 }} [v] / (v^3 - (9 + u)).$$ In this case, since $v^3 - (9 + u)$ is a polynomial of degree 3, the elements of $\mathbb{F_{ p^6 }}$ will be polynomials of degree 2 and variable $v$ of the form $$a + bv + cv^2 \quad \text{ with } a, b, c \in \mathbb{F_{ p^2 }}.$$ Finally, we extend $\mathbb{F_{ p^6 }}$ defining $$\mathbb{F_{ p^{12} }} = \mathbb{F_{ p^6 }} [w] / (w^2 - v),$$ that is, its elements are again polynomials of degree 1 with variable $w$ of the form $$a + bw \quad \text{ with } a, b \in \mathbb{F_{ p^6 } }.$$<br />
Now, in practice, using lambdaworks, we have two different ways to define an element $f = a + bw \in \mathbb{F_{ p^{12} }}$. We can use <code>new()</code>,</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>let f = Fp12E::new([a, b])</span></span></code></pre>
<p>or we can use <code>from_coefficients()</code>.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>let f = Fp12E::from_coefficients([</span></span>
<span class="giallo-l"><span>&quot;a_00&quot;, &quot;a_01&quot;, &quot;a_10&quot;, &quot;a_11&quot;, &quot;a_20&quot;, &quot;a_21&quot;, </span></span>
<span class="giallo-l"><span>&quot;b_00&quot;, &quot;b_01&quot;, &quot;b_10&quot;, &quot;b_11&quot;, &quot;b_20&quot;, &quot;b_21&quot;</span></span>
<span class="giallo-l"><span>])</span></span></code></pre>
<p>In the last case we use 12 coefficients to define $f$ because $f = a + bw$, where $a, b \in \mathbb{F_{ p^6 }}$. Then, $$a = \style{color: magenta} {a_0} + \style{color: magenta} {a_1}v + \style{color: magenta}{a_2}v^2 \quad \text{and} \quad b = \style{color: orange}{b_0} + \style{color: orange}{b_1}v + \style{color: orange}{b_2}v^2,<br />
$$ with $a_i, b_i \in \mathbb{F_{ p^2 }}$. And therefore, $$\style{color: magenta}{a_i} = a_{i0} + a_{i1} u \quad \text{and} \quad \style{color: orange}{b_i} = b_{i0} + b_{i1} u,$$ thus reaching the 12 coefficients.</p>
<p>There is another representation of the elements of $\mathbb{F_{ p^{12} }}$ that you could find in papers and algorithms that we used in our implementation. Since $v^3 = 9 + u$ and $w^2 = v$, we have that $w^6 = 9 + u$ and then, $$\mathbb{F_{ p^{12} }} = \mathbb{F_{ p^2 }} [w] / (w^6 - (9 + u)).$$ Again, you don’t have to understand the previous sentence; the important thing is that we can not only represent $f$ as a polynomial of degree 1 and as a polynomial of degree 11 but also as a polynomial of degree 5 using $a_i$ and $b_i$ in the following way:<br />
$$ f = \style{color: magenta}{a_0} + \style{color: orange}{b_0} w + \style{color: magenta}{a_1} w^2 + \style{color: orange}{b_1} w^3 + \style{color: magenta}{a_2} w^4 + \style{color: orange}{b_2} w^5.$$ So every time you see an element of $\mathbb{F_{ p^{12} }}$ represented as a polynomial of degree 5, you will know how to write it as $a + bw$, constructing $a = \style{color: magenta}{a_0} + \style{color: magenta}{a_1}v + \style{color: magenta}{a_2}v^2$ and $b = \style{color: orange}{b_0} + \style{color: orange}{b_1}v + \style{color: orange}{b_2}v^2$ using its coefficients (and vice versa). Having different representations of the same extension field will allow us to apply some optimizations when implementing the pairing (see the section <a rel="noopener external" target="_blank" href="https://hackmd.io/@Wimet/ry7z1Xj-2#Tower-of-Extension-Fields">Tower of Extension Fields</a> of <em>Computing the Optimal Ate Pairing Over the BN254 Curve</em>).</p>
<p>This may be a lot of new information, but don’t worry; you don’t need to understand it in detail. When reading the implementation, the idea is to have these equalities at hand to recognize where each variable belongs and how many coefficients it has. In lambdaworks <code>bn_254</code> you’ll find these fields $\mathbb{F_p} ,$ $\mathbb{F_{ p^2 }},$ $\mathbb{F_{ p^6 }}$ and $\mathbb{F_{ p^{12} }}$ (with their operations implemented) as <code>BN254PrimeField</code>, <code>Degree2ExtensionField</code>, <code>Degree6ExtensionField</code> and <code>Degree12ExtensionField</code>.</p>
<h2 id="twist">Twist</h2>
<p>Since doing arithmetic in $\mathbb{F_{ p^{12} }}$ is complicated and inefficient, we will use a <em>twist</em> that is like a coordinate conversion which tranforms our $E(\mathbb{F_{ p^{12} }})$ curve into the following curve $E’$ defined over $\mathbb{F_{ p^2 }}$:<br />
$$y^2 = x^3 + \frac{3}{9 + u} .$$<br />
We will call $b = \frac{3}{9 + u}$ implemented as <code>BN254TwistCurve::b()</code> .</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>b = 19485874751759354771024239261021720505790618469301721065564631296452457478373 </span></span>
<span class="giallo-l"><span>    + 266929791119991161246907387137283842545076965332900288569378510910307636690 </span></span>
<span class="giallo-l"><span>    * u</span></span></code></pre>
<p>So, in summary, we will use the following subgroups as inputs for the pairing:<br />
$$\mathbb{G_1} = E (\mathbb{F_p} ),$$<br />
$$\mathbb{G_2} \subseteq E^\prime ( \mathbb{F_{ p^2 }}) .$$<br />
And the output:<br />
$$\mathbb{G_t} \subseteq \mathbb{F_{ p^{12} } }^{\star} ,$$ where $\mathbb{F_{ p^{12} } }^{\star} = \mathbb{F_{ p^{12} } } - {0}$ (the multiplicative group of the field).</p>
<p>Knowing precisely which subgroups $\mathbb{G_2 }$ and $\mathbb{G_t }$ we should take is not relevant to understand our implementation. We will just say for those who have the mathematical background or are interested in going deeper into those topics, that $\mathbb{G_1 }$ and $\mathbb{G_2 }$ are the $r$-<em>torsion groups</em> (i.e. the set of elements of <em>order</em> $r$), while $\mathbb{G_t }$ is the set of the $r$-<em>th roots of unity</em>.</p>
<h2 id="the-pairing">The Pairing</h2>
<h3 id="what-is-a-pairing">What is a pairing?</h3>
<p>Let’s better understand it now that we have defined everything necessary to build our pairing. A pairing is a bilinear map $e: \mathbb{G_1 } \times \mathbb{G_2 } \to \mathbb{G_t }$. <em>Bilinear</em> means that it has the following property: For all points $P_1, P_2 \in \mathbb{G_1 }$ and $Q_1, Q_2 \in \mathbb{G_2 }$,<br />
$$\begin{align} e(P_1, Q_1 + Q_2) &amp;= e(P_1, Q_1) \cdot e(P_1, Q_2) \newline<br />
e(P_1 + P_2, Q_1) &amp;= e(P_1, Q_1) \cdot e(P_2, Q_1)\end{align}$$ And from this property, it can be deduced the next one: For all $n, m \in \mathbb{N}$,<br />
$$e(nP, mQ) = e(mQ, nP) = e(P, mQ)^n = e(nP, Q)^m = e(P, Q)^{nm}.$$ Recall that in general, the additive notation $+$ is used to denote the operation of the groups $\mathbb{G_1 }$ and $\mathbb{G_2 }$, and multiplicative notation $\cdot$ is used to denote the operation of $\mathbb{G_t }$.</p>
<h3 id="ate-pairing-algorithm">Ate Pairing Algorithm</h3>
<p>We will use the algorithm of the Ate pairing from <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2010/354.pdf">this paper</a> (Page 4, Algorithm 1):</p>
<hr />
<p><strong>Inputs</strong> : $P \in \mathbb{G}_1$ and $Q \in \mathbb{G}_2$<br />
<strong>Output:</strong> $f \in \mathbb{G}_t$</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. define $T \in \mathbb{G}_2$;</span></span>
<span class="giallo-l"><span>    2. $T \leftarrow Q$;</span></span>
<span class="giallo-l"><span>    3. define $f \in \mathbb{G}_t$;</span></span>
<span class="giallo-l"><span>    4. $f \leftarrow 1$;</span></span>
<span class="giallo-l"><span>    5. for $i =$ `miller_length` $- 2$ to 0 do</span></span>
<span class="giallo-l"><span>    6.      $f \leftarrow f^2$;</span></span>
<span class="giallo-l"><span>    7.      $T \leftarrow 2T$;</span></span>
<span class="giallo-l"><span>    8.      if `MILLER_CONSTANT`$[i] = -1$ then</span></span>
<span class="giallo-l"><span>    9.          $f \leftarrow f \cdot l_{T, -Q}(P)$;</span></span>
<span class="giallo-l"><span>    10.          $T \leftarrow T - Q$;</span></span>
<span class="giallo-l"><span>    11.      else if `MILLER_CONSTANT`$[i] = 1$ then</span></span>
<span class="giallo-l"><span>    12.          $f \leftarrow f \cdot l_{T, Q}(P)$;</span></span>
<span class="giallo-l"><span>    13.          $T \leftarrow T + Q$;</span></span>
<span class="giallo-l"><span>    14.      end if</span></span>
<span class="giallo-l"><span>    15. end for</span></span>
<span class="giallo-l"><span>    16. $Q_1 \leftarrow \varphi(Q)$;</span></span>
<span class="giallo-l"><span>    17. $f \leftarrow f \cdot l_{T, Q_1 }(P)$;</span></span>
<span class="giallo-l"><span>    18. $T \leftarrow T + Q_1$;</span></span>
<span class="giallo-l"><span>    19. $Q_2 \leftarrow \varphi(Q_1)$;</span></span>
<span class="giallo-l"><span>    20. $f \leftarrow f \cdot l_{T, - Q_2}(P)$;</span></span>
<span class="giallo-l"><span>    21. $f \leftarrow f^{ \frac{ p^{12} - 1 }{r}}$;</span></span>
<span class="giallo-l"><span>    22. return f;</span></span></code></pre>
<hr />
<p>where:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * The number `MILLER_CONSTANT` $=6x + 2$ with $x$ as the curve parameter we mentioned before. However, we need a particular representation of this number using powers of 2 and the coefficients $\\{- 1, 0, 1 \\}$. This representation is similar to a [NAF representation](https://en.wikipedia.org/wiki/Non-adjacent_form#:~:text=The%20non%2Dadjacent%20form%20\(NAF,8%20%E2%88%92%202%20%2B%201%20%3D%207\)), although it isn&#39;t a NAF because it has non-zero values adjacent.</span></span>
<span class="giallo-l"><span>          </span></span>
<span class="giallo-l"><span>          // MILLER_CONSTANT = 6x + 2 = 29793968203157093288 =</span></span>
<span class="giallo-l"><span>          // 2^3 + 2^5 - 2^7 + 2^10 - 2^11 + 2^14 + 2^17 + 2^18 - 2^20 + 2^23 </span></span>
<span class="giallo-l"><span>          // - 2^25 + 2^30 + 2^31 + 2^32 - 2^35 + 2^38 - 2^44 + 2^47 + 2^48 </span></span>
<span class="giallo-l"><span>          // - 2^51 + 2^55 + 2^56 - 2^58 + 2^61 + 2^63 + 2^64</span></span>
<span class="giallo-l"><span>          pub const MILLER_CONSTANT: [i32; 65] = [</span></span>
<span class="giallo-l"><span>              0, 0, 0, 1, 0, 1, 0, -1, 0, 0, 1, -1, 0, 0, 1, 0, 0, 1, 1, 0, -1, 0, 0, </span></span>
<span class="giallo-l"><span>              1, 0, -1, 0, 0, 0, 0, 1, 1, 1, 0, 0, -1, 0, 0, 1, 0, 0, 0, 0, 0, -1, 0, </span></span>
<span class="giallo-l"><span>              0, 1, 1, 0, 0, -1, 0, 0, 0, 1, 1, 0, -1, 0, 0, 1, 0, 1, 1</span></span>
<span class="giallo-l"><span>          ];</span></span>
<span class="giallo-l"><span>          </span></span>
<span class="giallo-l"><span>          </span></span>
<span class="giallo-l"><span>          let miller_length = MILLER_CONSTANT.len()</span></span>
<span class="giallo-l"><span>          </span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    * The function $l_{T, Q}(P)$ is the line that passes through $T$ and $Q$ evaluated in $P$. We&#39;ll see how to compute it later.</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    * The Frobenius morphism $\varphi: E&#39;(\mathbb{F_{ p^2 } }) \to E&#39;(\mathbb{F_{ p^2 }})$ is defined as $\varphi(x, y) = (x^p, y^p)$. We&#39;ll also see it later.</span></span></code></pre><h3 id="batch">Batch</h3>
<p>We will divide the algorithm presented into Miller Loop and Final Exponentiation to implement it. The <code>miller()</code> function does all the work from lines 1 to 20 of the algorithm, while <code>final_exponentiation()</code> computes only the last line 21 (which is a computation that requires some work). However, if we have different pairs of points $(P, Q)$ and we want to calculate each of their pairings to multiply all the results together (and see, for example, if it equals $1$), the most efficient way to do it is first to execute the Miller Loop for each pair of points, multiply the results and then apply the Final Exponentiation to the final result. The function that does this procedure is called <code>compute_batch()</code>.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>fn compute_batch(</span></span>
<span class="giallo-l"><span>    pairs: &amp;[(&amp;Self::G1Point, &amp;Self::G2Point)],</span></span>
<span class="giallo-l"><span>) -&gt; Result&lt;FieldElement&lt;Self::OutputField&gt;, PairingError&gt; {</span></span>
<span class="giallo-l"><span>    let mut result = Fp12E::one();</span></span>
<span class="giallo-l"><span>    for (p, q) in pairs {</span></span>
<span class="giallo-l"><span>        // do some checks before computing the Miller loop</span></span>
<span class="giallo-l"><span>        // ...</span></span>
<span class="giallo-l"><span>        if !p.is_neutral_element() &amp;&amp; !q.is_neutral_element() {</span></span>
<span class="giallo-l"><span>            let p = p.to_affine();</span></span>
<span class="giallo-l"><span>            let q = q.to_affine();</span></span>
<span class="giallo-l"><span>            result *= miller(&amp;p, &amp;q);</span></span>
<span class="giallo-l"><span>        }</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>    Ok(final_exponentiation(&amp;result))</span></span>
<span class="giallo-l"><span>}</span></span></code></pre><h2 id="subgroup-check">Subgroup Check</h2>
<p>Before applying the pairing to a given pair of points $(P, Q)$, it is necessary to check that the points belong to its domain. In other words, we need to see that $P \in \mathbb{G_1 }$ and $Q \in \mathbb{G_2 }$. Since $\mathbb{G_1 } = E(\mathbb{F_p })$, there is nothing to check about $P$. But, since $\mathbb{G_2 }$ is distinct from $E’(\mathbb{F_{ p^2 }})$, we need an efficient way to check that $Q$ belongs to the subgroup.</p>
<p>We’ll use <a rel="noopener external" target="_blank" href="https://hackmd.io/@Wimet/ry7z1Xj-2#Subgroup-Checks">this post</a> that states that a point $Q \in E’(\mathbb{F_{ p^2 }})$ belongs to $\mathbb{G_2 }$ if and only if<br />
$$(x + 1)Q + \varphi (xQ) + \varphi^2 (xQ) = \varphi^3 (2xQ).$$ Recall that $x$ is one of the curve’s parameters and $\varphi$ is the Frobenius Morphism mentioned before. So first, we need to implement this morphism efficiently, avoiding powering elements to $p$ (because $p$ is a very large number). For that, we’ll use two constants $\gamma_{1,2}, \gamma_{1,3} \in \mathbb{F_{ p^2 }}$ (later on, we’ll see them in more detail).</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub const GAMMA_12: Fp2E = Fp2E::const_from_raw([</span></span>
<span class="giallo-l"><span>    FpE::from_hex_unchecked(&quot;2FB347984F7911F74C0BEC3CF559B143B78CC310C2C3330C99E39557176F553D&quot;),</span></span>
<span class="giallo-l"><span>    FpE::from_hex_unchecked(&quot;16C9E55061EBAE204BA4CC8BD75A079432AE2A1D0B7C9DCE1665D51C640FCBA2&quot;),</span></span>
<span class="giallo-l"><span>]);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>pub const GAMMA_13: Fp2E = Fp2E::const_from_raw([</span></span>
<span class="giallo-l"><span>    FpE::from_hex_unchecked(&quot;63CF305489AF5DCDC5EC698B6E2F9B9DBAAE0EDA9C95998DC54014671A0135A&quot;),</span></span>
<span class="giallo-l"><span>    FpE::from_hex_unchecked(&quot;7C03CBCAC41049A0704B5A7EC796F2B21807DC98FA25BD282D37F632623B0E3&quot;),</span></span>
<span class="giallo-l"><span>]);</span></span></code></pre>
<p>Having these constants, it’s very easy to compute $\varphi$. We simply use that $$\varphi(x, y) = (\gamma_{1,2} \bar x, \gamma_{1,3} \bar y),$$ where $\bar x$ is the notation for the conjugate of $x$: If $x = a + bw \in \mathbb{F_{ p^2 }}$, then $\bar x = a - b w.$</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub fn phi(&amp;self) -&gt; Self {</span></span>
<span class="giallo-l"><span>    let [x, y, z] = self.coordinates();</span></span>
<span class="giallo-l"><span>    Self::new([</span></span>
<span class="giallo-l"><span>        x.conjugate() * GAMMA_12,</span></span>
<span class="giallo-l"><span>        y.conjugate() * GAMMA_13,</span></span>
<span class="giallo-l"><span>        z.conjugate(),</span></span>
<span class="giallo-l"><span>    ])</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>Now that we have $\varphi$, we can implement a function that determines if a certain point $Q$ of the twist curve $E’(\mathbb{F_{ p^2 }})$ belongs to the subgroup $\mathbb{G_2 }$.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub fn is_in_subgroup(&amp;self) -&gt; bool {</span></span>
<span class="giallo-l"><span>    let q_times_x = &amp;self.operate_with_self(X);</span></span>
<span class="giallo-l"><span>    let q_times_x_plus_1 = &amp;self.operate_with(q_times_x);</span></span>
<span class="giallo-l"><span>    let q_times_2x = q_times_x.double();</span></span>
<span class="giallo-l"><span>    </span></span>
<span class="giallo-l"><span>    q_times_x_plus_1.operate_with(&amp;q_times_x.phi().operate_with(&amp;q_times_x.phi().phi()))</span></span>
<span class="giallo-l"><span>        == q_times_2x.phi().phi().phi()</span></span>
<span class="giallo-l"><span>}</span></span></code></pre><h2 id="the-line">The Line</h2>
<p>Let’s see now how to implement for all $T, Q \in \mathbb{G_2 }$ and $P \in \mathbb{G_1 }$ the line $l_{T, Q}(P)$, called in lambdaworks <code>line()</code>, the fundamental function of the Miller Loop. First, we could have two cases: $T = Q$ or $T \neq Q$. In the first case, $l_{T, T} (P)$ is the tangent line of $T$ evaluated in $P$. In the second case, it is the line that passes through $T$ and $Q$ evaluated in $P.$</p>
<p>For our implementation, we relied on the algorithm proposed in <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2013/722.pdf">The Realm of the Pairings</a>. We use equation 11 on page 13 for the case $T = Q$ and the first equation on page 14 for the case $T \neq Q.$ You can also see the <a rel="noopener external" target="_blank" href="https://github.com/arkworks-rs/algebra/blob/master/ec/src/models/bn/g2.rs#L25">Arkworks implementation</a> of the same algorithm, where the function that computes the case $T=Q$ is called <code>double_in_place()</code>, and the one for the case $T \neq Q$ is called <code>add_in_place()</code>. You will see that both the paper and Arkworks define more variables than we do. That’s because those functions compute the line and $2T$ (in the first case) and $T + Q$ (in the second case), necessary values for the lines 7, 10, 13, and 18 of the Ate pairing algorithm. We didn’t have to do it that way because in those lines, to double an element or to add two elements of a group, we used the lambdaworks functions <code>operate_with_self()</code> and <code>operate_with()</code>. To simplify understanding, we kept the same variable names appearing in the paper and Arkworks. Notice that adding or duplicating points the way they do it there only requires including a couple of lines to our function <code>line()</code>, so it’s straightforward to compare both implementations and optimize ours if needed.</p>
<p>Finally, it’s helpful to remark that the paper gives the result of the line as a polynomial of degree 5, while in lambdaworks, the elements of $\mathbb{F_{ p^{12} }}$ have another representation. So, we need to use the transformation explained in the Field Extensions Towers section.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>fn line(p: &amp;G1Point, t: &amp;G2Point, q: &amp;G2Point) -&gt; Fp12E {</span></span>
<span class="giallo-l"><span>    let [x_p, y_p, _] = p.coordinates();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    if t == q {</span></span>
<span class="giallo-l"><span>        let b = t.y().square();</span></span>
<span class="giallo-l"><span>        let c = t.z().square();</span></span>
<span class="giallo-l"><span>        //Define all the variables necessary</span></span>
<span class="giallo-l"><span>        //...</span></span>
<span class="giallo-l"><span>        </span></span>
<span class="giallo-l"><span>        // We transform one representation of Fp12 into another one:</span></span>
<span class="giallo-l"><span>        Fp12E::new([</span></span>
<span class="giallo-l"><span>            Fp6E::new([y_p * (-h), Fp2E::zero(), Fp2E::zero()]),</span></span>
<span class="giallo-l"><span>            Fp6E::new([x_p * (j.double() + &amp;j), i, Fp2E::zero()]),</span></span>
<span class="giallo-l"><span>        ])</span></span>
<span class="giallo-l"><span>    } else {</span></span>
<span class="giallo-l"><span>        let [x_q, y_q, _] = q.coordinates();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        let theta = t.y() - (y_q * t.z());</span></span>
<span class="giallo-l"><span>        let lambda = t.x() - (x_q * t.z());</span></span>
<span class="giallo-l"><span>        let j = &amp;theta * x_q - (&amp;lambda * y_q);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        Fp12E::new([</span></span>
<span class="giallo-l"><span>            Fp6E::new([y_p * lambda, Fp2E::zero(), Fp2E::zero()]),</span></span>
<span class="giallo-l"><span>            Fp6E::new([x_p * (-theta), j, Fp2E::zero()]),</span></span>
<span class="giallo-l"><span>        ])</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre><h2 id="final-exponentiation">Final Exponentiation</h2>
<p>The last thing we need is to compute efficiently $f^{ \frac{ p^{12} - 1}{r}}.$ We took the final exponentiation algorithm from <a rel="noopener external" target="_blank" href="https://hackmd.io/@Wimet/ry7z1Xj-2#Final-Exponentiation">here</a>, which divides the exponent in the following way:<br />
$$\frac{ p^{12} - 1 }{r} = ( p^6 - 1) ( p^2 + 1) \frac{ p^4 - p^2 + 1}{r}$$</p>
<h3 id="the-easy-part">The Easy Part</h3>
<p>We want to compute<br />
$$f^{ ( p^6 - 1)( p^2 + 1)} = (f^{ p^6 } f^{ - 1})^{ p^2 } \cdot (f^{ p^6 } f^{- 1 }) .$$<br />
This will be easy to do using:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * $f^{ p^6 } = \bar f$ and we can calculate it using `conjugate()`. This is true because $f \in \mathbb{F_{ p^{12} }}$ and this property follows from the [Frobenius morphism as seen here](https://github.com/mratsim/constantine/blob/master/constantine%2Fmath%2Fpairings%2Fcyclotomic_subgroups.nim#L154).</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    * The function `inv()` computes $f^{ - 1}$.</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    * To compute $(f^{ p^6 } f^{ - 1})^{ p^2 }$ we can use the Frobenius squared morphism $\pi_p^2 : \mathbb{F_{ p^{12} }} \to \mathbb{F_{ p^{12} }},$ defined as $$\pi_p^2 (f) = \pi_p ( \pi_p (f)) = f^{ p^2 }.$$ In the last section, we explain how to implement it.</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>let f_easy_aux = f.conjugate() * f.inv().unwrap();</span></span>
<span class="giallo-l"><span>let f_easy = &amp;frobenius_square(&amp;f_easy_aux) * f_easy_aux;</span></span></code></pre><h3 id="the-hard-part">The Hard Part</h3>
<p>Now we need to raise the result of the easy part to the power $\frac{p^4 - p^2 + 1}{r}.$ We took the exact algorithm presented <a rel="noopener external" target="_blank" href="https://hackmd.io/@Wimet/ry7z1Xj-2#The-Hard-Part">here</a> as four steps, where <code>f_easy</code> is called there $m$. As explained in that post, this algorithm can be improved using a vectorial addition chain technique.</p>
<h2 id="frobenius-morphism">Frobenius Morphism</h2>
<p>Finally, let’s see how to implement the Frobenius morphisms $\pi_p$, $\pi_p^2$, and $\pi_p^3$ used in the Final Exponentiation.</p>
<p>You may remember that we have already implemented a Frobenius morphism $\varphi$. Although they have the same name, there is a slight difference between $\varphi$ and $\pi_p$: The function $\pi_p$ raises elements of $\mathbb{F_{ p^{12} }}$ to the power $p$, while $\varphi$ raises the coordinates of the twisted curve points to the power $p$. In other words, $\pi_p : \mathbb{F_{ p^{12} }} \to \mathbb{F_{ p^{12} }}$ while $\varphi : E’(\mathbb{F_{ p^2 }}) \to E’(\mathbb{F_{ p^2 }})$. That is why their implementations are not exactly the same.</p>
<p>To implement these morphisms we need to define for all $j = 1, \ldots 5$, the constants $$\begin{align}\gamma_{ 1 , j } &amp;= (9 + u)^{ \frac{ j ( p - 1) }{6}} \<br />
\gamma_{2,j} &amp;= \gamma_{1,j} \cdot \overline{\gamma_{1,j}} \newline<br />
\gamma_{3,j} &amp;= \gamma_{1,j} \cdot \gamma_{2,j}\end{align}$$</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub const GAMMA_11: Fp2E = Fp2E::const_from_raw([</span></span>
<span class="giallo-l"><span>    FpE::from_hex_unchecked(&quot;1284B71C2865A7DFE8B99FDD76E68B605C521E08292F2176D60B35DADCC9E470&quot;),</span></span>
<span class="giallo-l"><span>    FpE::from_hex_unchecked(&quot;246996F3B4FAE7E6A6327CFE12150B8E747992778EEEC7E5CA5CF05F80F362AC&quot;),</span></span>
<span class="giallo-l"><span>]);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>pub const GAMMA_12: Fp2E = Fp2E::const_from_raw([</span></span>
<span class="giallo-l"><span>    FpE::from_hex_unchecked(&quot;2FB347984F7911F74C0BEC3CF559B143B78CC310C2C3330C99E39557176F553D&quot;),</span></span>
<span class="giallo-l"><span>    FpE::from_hex_unchecked(&quot;16C9E55061EBAE204BA4CC8BD75A079432AE2A1D0B7C9DCE1665D51C640FCBA2&quot;),</span></span>
<span class="giallo-l"><span>]);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>// etc.</span></span></code></pre>
<p>Now, we use that if $f = a + bw$, then</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub fn frobenius(f: &amp;Fp12E) -&gt; Fp12E {</span></span>
<span class="giallo-l"><span>    let [a, b] = f.value();</span></span>
<span class="giallo-l"><span>    let [a0, a1, a2] = a.value(); </span></span>
<span class="giallo-l"><span>    let [b0, b1, b2] = b.value(); </span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let c1 = Fp6E::new([</span></span>
<span class="giallo-l"><span>        a0.conjugate(),</span></span>
<span class="giallo-l"><span>        a1.conjugate() * GAMMA_12,</span></span>
<span class="giallo-l"><span>        a2.conjugate() * GAMMA_14,</span></span>
<span class="giallo-l"><span>    ]);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let c2 = Fp6E::new([</span></span>
<span class="giallo-l"><span>        b0.conjugate() * GAMMA_11,</span></span>
<span class="giallo-l"><span>        b1.conjugate() * GAMMA_13,</span></span>
<span class="giallo-l"><span>        b2.conjugate() * GAMMA_15,</span></span>
<span class="giallo-l"><span>    ]);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    Fp12E::new([c1, c2])</span></span>
<span class="giallo-l"><span>}</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>// similarly, frobenius_square and frobenius_cube.</span></span>
<span class="giallo-l"><span>// ...</span></span></code></pre>
<p>Lastly, if we apply twelve times $\pi_p$, six times $\pi_p^2$, or four times $\pi_p^3$ to $f$, we get $f$ (i.e., they become the identity function). That’s because $f \in \mathbb{F_{ p^{12} }}$, and then $f^{ p ^{12} } = f.$ This property will help us test if we implemented these morphisms correctly.</p>
<h2 id="summary">Summary</h2>
<p>This post explored how we combined various works and papers to implement our pairing. In doing so, we successfully integrated algorithms from different implementations by making transformations between point coordinates or different representations of the same extension of fields.</p>
<h4 id="what-s-next">What’s next?</h4>
<p>Now that we have a pairing working, the next step is to know how this implementation compares with others. So, we will perform some benchmarks and make some optimizations that we are already aware of. As it’s written in <a href="/lambdas-engineering-philosophy/">Lambda’s Engineering Philosophy</a>:, “Make it work, then make it beautiful, then if you really, really have to, make it fast.”</p>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
