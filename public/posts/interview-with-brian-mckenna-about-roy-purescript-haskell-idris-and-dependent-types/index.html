<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interview with Brian McKenna about Roy, Purescript, Haskell, Idris and dependent types - LambdaClass Blog</title>
    <meta name="description" content="As promised in our last interview for This is not a Monad tutorial we interviewed Brian McKenna, creator of the Roy programming language…">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">Interview with Brian McKenna about Roy, Purescript, Haskell, Idris and dependent types</h1>
        
        <div class="page-meta">
            <time datetime="2015-08-26">August 26, 2015</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <p>As promised in our <a rel="noopener external" target="_blank" href="https://medium.com/this-is-not-a-monad-tutorial/eric-merritt-erlang-and-distributed-systems-expert-gives-his-views-on-beam-languages-hindley-a09b15f53a2f">last interview</a> for <a rel="noopener external" target="_blank" href="https://medium.com/this-is-not-a-monad-tutorial">This is not a Monad tutorial</a> we interviewed <a rel="noopener external" target="_blank" href="https://github.com/puffnfresh">Brian McKenna</a>, creator of the <a rel="noopener external" target="_blank" href="http://roy.brianmckenna.org/">Roy</a> programming language. In this interview Brian talks about Roy, its implementation, how it compares with Purescript, and also about dependent types and other interesting technologies like Morte and Unison. I highly recommend that you check <a rel="noopener external" target="_blank" href="http://brianmckenna.org/blog/">Brian’s blog</a> after you finish reading this interview.</p>
<p>In the following weeks we will be talking with the creators of <a rel="noopener external" target="_blank" href="http://www.red-lang.org/">Red programming language</a>, Robert Virding — Erlang co-inventor and <a rel="noopener external" target="_blank" href="http://lfe.io/">Lisp Flavored Erlang</a> creator — and with <a rel="noopener external" target="_blank" href="https://mirage.io/">MirageOS unikernel</a> dev team.</p>
<p><img src="/images/max/2000/1-vYf7TCGE19Gni5ssKXQaHA.png" alt="" /></p>
<p><strong>What are Roy’s main features?</strong></p>
<p>Roy featured things common to languages which are well suited to typed<br />
functional programming:</p>
<ul>
<li>Types and type inference (with row polymorphism)</li>
<li>Algebraic data types and pattern matching</li>
<li>Monadic syntax</li>
</ul>
<p><strong>Why did you create it?</strong></p>
<p>I created Roy after doing years of JavaScript work. I learned Haskell<br />
and it made a huge amount of sense to me. Functional programming with<br />
types seemed like the ideal way for me to work on software and so I<br />
wanted to bring it to web programming.</p>
<p><strong>I am tempted to say that Roy has some big similarities with</strong><a rel="noopener external" target="_blank" href="http://www.purescript.org/"><strong>Purescript</strong></a><strong>. What are the main differences between the two languages?</strong></p>
<p>Roy was first!</p>
<p>PureScript had almost the exact same goals as Roy but had a much<br />
better implementation. Quoting the PureScript wiki:</p>
<blockquote>
<p>Roy is probably the most similar language on the list, and was a<br />
large influence on the development of PureScript.</p>
</blockquote>
<p>I stopped working on Roy once PureScript got around equal in<br />
functionality. PureScript’s implementation means it’s a lot easier to<br />
work on and has much fewer bugs.</p>
<p>Originally the PureScript FFI started off being very different (i.e.<br />
it used inline JS instead of an externs file) but recently changed to<br />
being similar to the original design Roy had. That was probably the<br />
biggest difference the projects had.</p>
<p><strong>You implemented the lexer and the parser. Did you do so to learn/play or because you thought that the available tools were not good enough?</strong></p>
<p>I implemented a whitespace sensitive lexer which was passed into the<br />
Jison parser generator. It was the same approach which CoffeeScript<br />
took.</p>
<p>A custom lexer was necessary because the <a rel="noopener external" target="_blank" href="https://medium.com/this-is-not-a-monad-tutorial/interview-with-brian-mckenna-about-roy-purescript-haskell-idris-and-dependent-types-63bb1289ea3d">Jison</a> lexer generator was not<br />
capable of stateful scanning of whitespace.</p>
<p>I prefer working with parser combinators such as Parsec and Trifecta.<br />
They’re easier to work with and allow you to write reusable<br />
abstractions.</p>
<p><strong>Why did you use a whitespace sensitive grammar a la Python/Haskell in Roy?</strong></p>
<p>Just to look like Haskell. I hate thinking about syntax — I copy<br />
things as much as I can. I’m also annoyed that we’re still writing<br />
programs using text. They’re trees, not lists of characters!</p>
<p><strong>Why is it useful to have monadic sugar in a language that has unrestricted side effects?</strong></p>
<p>Roy was not designed to allow side-effects, but you could do anything<br />
with the FFI and so it was possible.</p>
<p>Scala has (pretty limited) monadic sugar and also unrestricted<br />
side-effects. People use monadic sugar for things as straight-forward<br />
as Option:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>for {</span></span>
<span class="giallo-l"><span>  name &lt;- maybeFirstName</span></span>
<span class="giallo-l"><span>  user &lt;- lookup(name)</span></span>
<span class="giallo-l"><span>  avatar &lt;- getAvatar(user)</span></span>
<span class="giallo-l"><span>} yield avatar</span></span></code></pre>
<p>Which can be easier to type than:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>maybeFirstName.flatMap { name =&gt;</span></span>
<span class="giallo-l"><span>  lookup(name).flatMap { user =&gt;</span></span>
<span class="giallo-l"><span>    getAvatar(user)</span></span>
<span class="giallo-l"><span>  }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>It doesn’t have anything to do with side-effects.</p>
<p><strong>From what we could read in the Damas-Hindley-Milner type inference algorithm source comments it is based on Robert Smallshire’s Python code. Do you have any recommendation for those who want to implement it?</strong></p>
<p>I recommend reading “Generalizing Hindley-Milner Type Inference<br />
Algorithms” which turns the algorithm into explicit separate<br />
constraint collection and constraint solving problems, which is a bit<br />
easier to work with than plain Algorithm W. It’s then possible to do<br />
tree annotation via the cofree comonad, <a rel="noopener external" target="_blank" href="http://brianmckenna.org/blog/type_annotation_cofree">which gives a pretty nice</a><br />
<a rel="noopener external" target="_blank" href="http://brianmckenna.org/blog/type_annotation_cofree">implementation</a>.</p>
<p><strong>What reading material do you recommend for implementing your first programming language?</strong></p>
<p>Source code of other languages are great resources. I think the<br />
PureScript and Idris compilers are somewhat easy to play around with.</p>
<p>Hackage has a lot of code to look at, such as reference<br />
implementations of Algorithm W:</p>
<p><a rel="noopener external" target="_blank" href="https://hackage.haskell.org/packages/">https://hackage.haskell.org/packages/</a></p>
<p><strong>What would you recommend us to read to learn about different type systems?</strong></p>
<p><a rel="noopener external" target="_blank" href="https://www.cis.upenn.edu/~bcpierce/tapl/">Types and Programming Languages</a> by Benjamin Pierce is a brilliant<br />
resource for understanding both. It’s surprised me by being a very<br />
good introduction to types and having pretty good reference<br />
implementations in OCaml for each of the discussed type-systems. Very<br />
highly recommended.</p>
<p><strong>Have you tried</strong><a rel="noopener external" target="_blank" href="http://elm-lang.org/"><strong>Elm</strong></a><strong>? What do you think of</strong><a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Functional_reactive_programming"><strong>FRP</strong></a><strong>?</strong></p>
<p>I think Functional Reactive Programming could be generalised a bit to<br />
just general stream combinator libraries and we could make it as<br />
simple as libraries such as pipes, machines and scalaz-stream. I’d<br />
like to implement one of those libraries in PureScript and try to<br />
write combinators to fill in the gaps for developing user interfaces<br />
to see how close we get to current FRP libraries.</p>
<p><strong>You recently gave a talk about</strong><a rel="noopener external" target="_blank" href="http://www.idris-lang.org/"><strong>Idris</strong></a><strong>, a language with</strong><a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Dependent_type"><strong>dependent types</strong></a><strong>. Could you explain what are dependent types?</strong></p>
<p>In non-dependently typed languages we have a way of making values<br />
depend upon other values: functions! In dependent typed languages we<br />
have those functions, but also functions which can return types.</p>
<p>Haskell has two completely separate languages: the language of values<br />
and the language of types. Recent versions of GHC give a way of<br />
promoting certain values up to types, but if you want to write a<br />
function over those values, you’ll have to write a version at the<br />
value level and separately at the type level.</p>
<p>Dependent-types remove the separation. If you write a function, you<br />
can reuse it for terms at any level.</p>
<p><strong>What are the practical benefits of using a language with dependent types?</strong></p>
<p>Since you can use values in your types, you can specify a lot more.<br />
For example, I can specify that list reversal is an involution, i.e.<br />
reversing twice is the same as not reversing at all:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>reverseInvolution : (xs : List a) -&gt; reverse (reverse xs) = r</span></span></code></pre>
<p>No need for tests — if I implement a value for that type, I have a<br />
proof for all possible values.</p>
<p>Or we can specify that a sort function will generate a list where each<br />
element is smaller than the next. The implementation of sort will only<br />
compile if we prove that to be true.</p>
<p>We can also do things like metaprogramming, since we know more about<br />
the values which are passed in, we can compute fancy types for things<br />
such as literals.</p>
<p><strong>From what we have read from your blog you have learnt Coq and Agda. What can code monkeys like us learn from programming languages like Coq and Agda?</strong></p>
<p>I know a tiny amount of Coq and Agda. They teach people what types are<br />
capable of and how they can be used to interactively prove programs<br />
correct. It’ll also show the potential of typed metaprogramming, for<br />
example allowing the type of printf to depend upon the input string or<br />
how it’s possible to write your own statically checked literal<br />
strings.</p>
<p><strong>Have you checked</strong><a rel="noopener external" target="_blank" href="http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/about/"><strong>LiquidHaskell</strong></a><strong>? What do you think about and refinement types?</strong></p>
<p>I think refinement types are interesting. It’s very exciting to just<br />
be able to add on annotations to existing programs and let proof<br />
searching do the rest but I’d prefer dependent types to be a research<br />
area for a couple of reasons:</p>
<ol>
<li>LiquidHaskell can do some dependent looking things but doesn’t have<br />
full pi-types so can’t do as much as real dependent types</li>
<li>We’re relying on an SMT solver to come up with a reasoning for why<br />
something is true, dependent types allow you to create and manipulate<br />
your own justifications — this might be solvable just via tooling,<br />
though</li>
</ol>
<p><strong>What other languages or technologies are you keeping an eye on that we should check?</strong></p>
<ul>
<li><strong>Morte</strong> by Gabriel Gonzalez is a brilliant way of talking about<br />
distributable programs. I want to work on Morte to create a database<br />
of super-optimised code, where package management is about functions,<br />
not libraries. Morte has a pretty good introduction <a rel="noopener external" target="_blank" href="https://hackage.haskell.org/package/morte-1.2.1/docs/Morte-Tutorial.html">here</a>.</li>
<li>Paul Chiusano’s <a rel="noopener external" target="_blank" href="http://unisonweb.org/"><strong>Unison</strong></a> is an attempt at removing the “list of<br />
characters” problem from programming. It’s also trying to create a<br />
better UX for functional programming.</li>
</ul>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
