<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Implementing BabySNARK in lambdaworks in our internal bootcamp - LambdaClass Blog</title>
    <meta name="description" content="Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">Implementing BabySNARK in lambdaworks in our internal bootcamp</h1>
        
        <div class="page-meta">
            <time datetime="2024-02-28">February 28, 2024</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <h2 id="introduction">Introduction</h2>
<p>We started with an internal bootcamp two weeks ago to onboard new engineers to our team. We wanted to give the basic building blocks in cryptography and also an introduction to zero-knowledge proofs (ZKP) using <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks">lambdaworks</a>. Zero-knowledge proofs are a powerful technology that could <a href="/transforming-the-future-with-zero-knowledge-proofs-fully-homomorphic-encryption-and-new-distributed-systems-algorithms/">shape the future in many different ways</a>. For an introduction and a bit of history on the topic, see our <a href="/our-highly-subjective-view-on-the-history-of-zero-knowledge-proofs/">previous blog post</a>. Modern proof systems use several tricks and optimizations for increased performance. However, this complicates the learning process since we have to separate the main logic (arithmetization, interpolation, imposing constraints, committing to polynomials) from improvements, some of which are difficult to grasp. We focused on a more straightforward construction, following <a rel="noopener external" target="_blank" href="https://github.com/initc3/babySNARK/blob/master/babysnark.py">BabySNARK</a>. During the first week, we covered the basics of finite fields, notions of groups, elliptic curves, hash functions, signatures, public key encryption, and symmetric key encryption schemes. If you are unfamiliar with some topics, we recommend you read our <a href="/math-survival-kit-for-developers/">math survival kit</a>.</p>
<p>This blog post will explain the working principle of the proof system and its implementation using lambdaworks (you can check the work in progress <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks/tree/babysnark/examples/baby-snark/src">here</a>). We hope this will help onboard new people to the fantastic field of ZKP.</p>
<h2 id="working-principle">Working principle</h2>
<h3 id="programs-as-relationships-between-polynomials">Programs as relationships between polynomials</h3>
<p>BabySNARK is based on this <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2014/718">NIZK</a> proposed in 2014. It works with square span programs, which are similar to, yet simpler than, quadratic arithmetic programs (used in <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2013/279">Pinocchio</a>). The representation of the circuit is done with a matrix $U$ (belonging to $F^{m \times n}$) and a vector $z = (1 , u , w)^t$ (containing the instance $u$ and witness $w$),<br />
$(U.z) \circ (U.z) = 1$</p>
<p>We can express any boolean circuit using these types of constraints. Let us rewrite the equations in a different form that will be convenient for later purposes:<br />
$\left(\sum_j u_{ij} z_j \right)^2 = 1$<br />
which should be valid for every $i = 0, 1, 2, …$. We can encode these equations using polynomials. Suppose that $m = 2^k$ for some $k$ and that we are working with a nice field $F$ containing a subgroup $D_i$ of size $2^k$. We can take $\omega$ as an $m$-th primitive root of unity ($\omega$ generates the whole subgroup) and find the polynomials $U_j (x)$ which satisfy<br />
$U_j (\omega^i ) = u_{ij}$<br />
By doing this, we are encoding our equations as relations over polynomials. Thus, we can replace the problem equivalently,<br />
$\left(\sum_j U_{j} (x) z_j \right)^2 - 1 = p(x)$<br />
If we evaluate the polynomials at $\omega^i$, then we get $U_j (\omega^i ) = u_{ij}$, and $p(\omega^i )$ evaluates to $0$ at every $\omega^i$. A theorem says that if $\omega^i$ is a root/zero of a polynomial $p(x)$, then $x - \omega^i$ divides $p(x)$. In other words, there is some $q (x)$ such that $p(x) = (x - \omega^i )q(x)$.</p>
<p>If the polynomial has multiple zeros, then it must be divisible by each $x - \omega^i$. Let us define $Z(x)$ as the vanishing polynomial over $D_i$<br />
$Z(x) = \prod_j (x -\omega^j ) = x^m - 1$<br />
where we used in the last equality that $\omega$ is a primitive $m$-th root of unity (this trick is also used in <a href="/diving-deep-fri/">STARKs</a>). Therefore, if all the constraints hold, we have a polynomial $q(x)$ which fulfills this equality<br />
$p(x) = Z(x) q(x)$</p>
<p>One way to show that the computation described by the system of equations is valid is by providing $p(x)$ and $q(x)$ and letting the verifier check the equality by himself. The problem is that we have to pass all the coefficients of both polynomials (which are as long as the computation) and let him compute the right-hand side and assert whether it equals the polynomial on the left-hand side. Besides, we also leak information on the witness! How can we turn this into something succinct and not leak information?</p>
<h3 id="polynomial-commitment-schemes">Polynomial commitment schemes</h3>
<p>A polynomial commitment scheme is given by four algorithms: setup, commit, open, and evaluate. The commitment allows us to bind ourselves to a given polynomial using short data and later be able to prove things about that polynomial. The commitment scheme must satisfy the following two properties:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. Hiding: the commitment does not reveal anything about the committed polynomial.</span></span>
<span class="giallo-l"><span>    2. Binding: given the commitment to $p(x)$, $\mathrm{cm} (p)$, it is infeasible to find another $q(x)$, such that $\mathrm{cm} (p) = \mathrm{cm} (q)$</span></span></code></pre>
<p>One way to build a PCS is by using a pairing-friendly elliptic curve, such as BN254 or BLS12-381. We will work here with type-3 pairings, which are functions $e: G_1 \times G_2 \rightarrow G_t$ with the following properties:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. Bilinearity: $e(a g_1 , b g_2) = e(g_1 , g_2 )^{ab}$.</span></span>
<span class="giallo-l"><span>    2. Non-degeneracy: If $e(P,Q) = 1$, then either $P = \mathcal{O}$ or $Q = \mathcal{O}$.</span></span></code></pre>
<p><a href="/mina-to-ethereum-bridge/">KZG commitment scheme</a> works in this setting, which is the tool we will use. Why are pairings useful? Because they provide us with a way of multiplying things hidden inside an elliptic curve group.</p>
<p>We pick a random $s$ (which is unknown to both the prover and verifier), and we generate the following points in the elliptic curve<br />
$\{ P_0 , P_1 , …, P_n \} = \{ g_1 , s g_1 , …, s^n g_n \}$<br />
These points contain the powers of $s$ hidden inside a group of the elliptic curve. Given any $P_k$, recovering $s$ is computationally intractable due to the hardness of the discrete log problem over elliptic curves.</p>
<p>We commit to the polynomial by computing<br />
$p(s) g_1 = \sum a_k (s^k g_1 ) = \sum a_k P_k$<br />
where $g_1$ is a generator of the group/subgroup of prime order $r$ of the elliptic curve. We could also commit using elements in $G_2$, where we have $g_2$ as a subgroup generator.</p>
<p>Using pairings, we could prove the relationship between the polynomial $p(x)$ and the quotient $q(x)$ by computing two pairings and checking their equality:<br />
$e( p(s) g_1 , g_2) = e(g_1 , g_2 )^{p(s)}$<br />
$e(q(s) g_1 , s^m g_2 - g_2) = e(g_1 , g_2 )^{ q(s)(s^m - 1)}$<br />
Since $s$ is chosen at random, if $p(s) = q(s) Z(s)$, then with overwhelming probability, we have that $p(x) = q(x) Z(x)$.</p>
<p>With this construction, we do not need to supply the verifier with the coefficients of the polynomials, only their commitments. This solves part of the problem but not everything.</p>
<h3 id="intuition-for-the-protocol">Intuition for the protocol</h3>
<p>The program/circuit that we want to prove is defined by the matrix $U$. When we define a particular instance/public input $u$ to the circuit, if $u$ is valid, we should be able to find some $w$ that solves the system of equations. To make the proof succinct, we should send much less information than the full witness (besides, if we want zero-knowledge, the witness should be kept secret).</p>
<p>We have the polynomial $p(x)$ of the problem, the vanishing polynomial $Z(x)$, and the quotient $q(x)$. In the end we want to prove that<br />
$p(x) = Z(x)q(x)$<br />
if the computation is valid. $Z(x)$ is known to both the prover and the verifier, and we could even commit to $Z(x)$ as part of the public information. We can reduce this check to just one point $x = s$ and verify this using pairings. However, this check alone would be insufficient since the prover could provide any polynomial $p(x)$. If we recall how we build $p(x)$,<br />
$\left(\sum_j U_{j} (x) z_j \right)^2 - 1 = p(x)$<br />
Some terms in the summation can be computed by the verifier (since these are public). However, the verifier does not know the witness’s terms, and we do not want to give him access to that data in total. The solution would be for the prover to give the summation, including only the values of the witness,<br />
$$V_w (x) = \sum_{j \in w} w_j U_j(x)$$<br />
Moreover, we can provide a commitment to $V_w (x)$ using the commitment scheme we had before, $V_w (s) g_1$ and $V_w (s) g_2$ (we will show why we need both soon). The verifier can then compute<br />
$$V_u (x) = \sum_{k \in u} u_j U_j(x)$$<br />
and get $V_u (s) g_1$ and $V_u (s) g_2$. The verifier can compute the pairing involving $e( p(s) g_1 , g_2)$ in an equivalent way,<br />
$$e ( V_u (s) g_1 + V_w(s) g_1 , V_u (s) g_2 + V_w(s) g_2 ) e ( g_1 , g_2 )^{ - 1 } = e( p(s) g_1 , g_2)$$<br />
This looks odd, but if we take all the scalars to the exponent, we have $(V_u (s) + V_w (s))(V_u (s) + V_w (s)) - 1$, and the verifier can get the polynomial of the circuit. So, we get the first check,<br />
$$e ( V_u (s) g_1 + V_w(s) g_1 , V_u (s) g_2 + V_w(s) g_2 ) e ( g_1 , g_2 )^{ - 1 } = e( q(s) g_1 , Z(s)g_2)$$</p>
<p>We have one problem, though. How do we know that the prover used the same $V_w (x)$ in both commitments? Luckily, we can solve this with another pairing check,<br />
$e( V_w (s) g_1 , g_2 ) = e( g_1 , V_w(s) g_2 )$</p>
<p>We got another check. Finally, how do we know that the verifier computed $V_w (x)$ correctly and did not do some random linear combination that will cancel out with the public input and yield something nice?</p>
<p>We could force the prover to provide the same linear combination, but with the points all shifted by some constant $\beta$, unknown to the parties. We define<br />
$B_w (x) = \sum \beta w_j U_j (x) = \beta V_w (x)$<br />
We can do one final check for this relationship using pairings,<br />
$e( B_w (s) g_1 , \gamma g_2 ) = e( \gamma \beta g_1 , V_w (s) g_2 )$<br />
where $\gamma$ is also unknown to the parties. This makes it impossible for the prover to build fake polynomials for $V_w (x)$. We can see that if this condition did not exist, we could create any $V_w (x) = C Z(x) - V_u (x) + 1$, which would pass all the other checks for any $C$ of our choice. In fact,<br />
$V_w (x) + V_u (x) = C Z(x) + 1$<br />
But $p(x) = (V_w (x) + V_u (x))^2 - 1$, so<br />
$p(x) = C^2 Z(x)Z(x) + C Z(x) = Z(x) (C^2 Z(x) + C)$<br />
and we find that $q(x) = (C^2 Z(x) + C)$, even though we do not know the witness.</p>
<p>The proof $\pi$ will consist of:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. The commitment to $V_w (x)$ using $g_1$.</span></span>
<span class="giallo-l"><span>    2. The commitment to $V_w (x)$ using $g_2$.</span></span>
<span class="giallo-l"><span>    3. The commitment to the quotient polynomial $q(x)$ using $g_1$.</span></span>
<span class="giallo-l"><span>    4. The commitment to $B_w (x)$ using $g_1$</span></span></code></pre>
<p>The verification involves six pairings (the pairing $e(g_1 , g_2)^{ - 1}$ can be precomputed since it is a constant), to check the three conditions we mentioned.</p>
<p>To compute the commitments, we need parameters $s , \beta , \gamma$ to be unknown to both parties (hence, they are toxic waste). We need to generate a reference string, which will be circuit dependent (that is because we need to provide $\beta U_j(s) g_1$). With all this, we can jump into the implementation.</p>
<h2 id="implementation">Implementation</h2>
<h3 id="setup">Setup</h3>
<p>Prover and verifier agree on a pairing-friendly elliptic curve and generators of the groups $G_1$ and $G_2$, denoted by $g_1$ and $g_2$, respectively. In our case, we choose BLS12-381. The proving key consists of the following:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. $\\{s^k g_1 \\}$ for $k = 0, 1, 2 , ... m$</span></span>
<span class="giallo-l"><span>    2. $\\{U_j (s) g_1 \\}$ for $j = l , l + 1 , ... m$ ($l$ being the number of public inputs).</span></span>
<span class="giallo-l"><span>    3. $\\{U_j (s) g_2 \\}$ for $j = l , l + 1 , ... m$</span></span>
<span class="giallo-l"><span>    4. $\\{\beta U_j (s) g_1 \\}$ for $j = l , l + 1 , ... m$</span></span></code></pre>
<p>The verifying key consists of the following:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. $\\{U_j (s) g_1 \\}$ for $j = 0 , 1 , ... l - 1$</span></span>
<span class="giallo-l"><span>    2. $\\{U_j (s) g_2 \\}$ for $j = 0 , 1 , ... l - 1$</span></span>
<span class="giallo-l"><span>    3. $[Z^\prime ] = (s^m - 1)g_2$ (commitment to the vanishing polynomial)</span></span>
<span class="giallo-l"><span>    4. $e(g_1 , g_2)^{ - 1}$</span></span>
<span class="giallo-l"><span>    5. $\beta \gamma g_1$</span></span>
<span class="giallo-l"><span>    6. $\gamma g_2$</span></span></code></pre><h3 id="prove">Prove</h3>
<p>The steps for the prover are as follows:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. Compute $[V_w ] = V_w (s) g_1$, $[V_w^\prime ] = V_w (s) g_2$, and $[B_w ] = B_w (s) g_1$ using the proving key.</span></span>
<span class="giallo-l"><span>    2. Compute the polynomial quotient polynomial $q(x)$ from the zerofier $Z(x)$, the vector of witness and instance, and the polynomials describing the circuit $U_j (x)$.</span></span>
<span class="giallo-l"><span>    3. Compute $[q ] = q(s) g_1$ using the proving key.</span></span>
<span class="giallo-l"><span>    4. Produce the proof $\pi = ( [q] , [V_w ] , [V_w^\prime ] , [B_w ])$</span></span></code></pre><h3 id="verify">Verify</h3>
<p>The verifier has the following steps:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. Parse the proof $\pi$ as $[q] , [V_w ] , [V_w^\prime ] , [B_w ]$.</span></span>
<span class="giallo-l"><span>    2. Check $e( [V_w ] , g_2 ) = e( g_1 , [V_w^\prime ])$</span></span>
<span class="giallo-l"><span>    3. Check $e( [B_w] , \gamma g_2) = e( \beta \gamma g_1 , [V_w^\prime ])$</span></span>
<span class="giallo-l"><span>    4. Compute $[V_u ] = V_u (s) g_1$, and $[V_u^\prime ] = V_u (s) g_2$ using the verifying key.</span></span>
<span class="giallo-l"><span>    5. Check $e([V_u ] + [V_w ] , [V_u^\prime ] + [V_w^\prime ])e(g_1 , g_2)^{ - 1} = e( [q] , [Z^\prime])$</span></span></code></pre>
<p>If all checks pass, the proof is valid.</p>
<h3 id="optimizations">Optimizations</h3>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. Interpolation is done using the Fast Fourier Transform (FFT). This is possible because BLS12-381&#39;s scalar field has $2^{32}$ as one of its factors.</span></span>
<span class="giallo-l"><span>    2. The quotient is calculated in evaluation form, using the FFT. We need to evaluate the polynomials at $\mu \omega^k$, where $\mu$ is the offset (we want to evaluate on cosets because if we evaluate directly over $D_i$, we get $0/0$).</span></span>
<span class="giallo-l"><span>    3. The evaluation of the vanishing polynomial is straightforward: $Z(\mu \omega^k ) = (\mu \omega^k )^m - 1 = \mu^m - 1$, because $\omega$ has order $m$.</span></span>
<span class="giallo-l"><span>    4. Compute multiscalar multiplications using Pippenger&#39;s algorithm.</span></span></code></pre><h3 id="turning-the-snark-into-a-zk-snark">Turning the SNARK into a zk-SNARK.</h3>
<p>The protocol above is not zero-knowledge since $V_w (x)$ can be distinguished from a random-looking $V (x)$. To make it zero-knowledge, the prover has to sample a random value $\delta$ and make the following changes to the polynomials:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. The polynomial $p(x) = \left(\sum_k z_j U_j(x) + \delta Z(x) \right)^2 - 1$. Note that adding $Z(x)$ does not change the main condition, which is that the constraints are satisfied if and only if $p(x)$ is divisible by $Z(x)$.</span></span>
<span class="giallo-l"><span>    2. Compute $[V_w ] = (V_w (s) + \delta Z(s)) g_1$, $[V_w^\prime ] = (V_w (s) + \delta Z(s)) g_2$, and $[B_w ] = (B_w (s) + \beta \delta Z(s)) g_1$.</span></span></code></pre>
<p>The verifier’s steps are unchanged.</p>
<h2 id="summary">Summary</h2>
<p>This post covered implementing a simple SNARK based on square span problems. We gave an intuition on how the protocol works and why we need different checks to achieve security. We hope this will enable newcomers to learn some of the basic concepts and workflow for ZKPs.</p>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
