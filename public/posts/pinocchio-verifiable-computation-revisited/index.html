<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pinocchio: verifiable computation revisited - LambdaClass Blog</title>
    <meta name="description" content="Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">Pinocchio: verifiable computation revisited</h1>
        
        <div class="page-meta">
            <time datetime="2024-07-31">July 31, 2024</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <h2 id="1-introduction">1. Introduction</h2>
<h3 id="1-1-motivation">1.1 Motivation</h3>
<p>Imagine you want to do a complex computation, that you cannot carry out in your computer, or you need to get the results from a computer that you don’t trust. How can you be sure it was done correctly without redoing it yourself or understanding the intricate details? Introduced in 2013, <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2013/279.pdf">Pinocchio</a> provides a solution using SNARKs. This technology enables a prover to demonstrate the correctness of their computations succinctly and be able to verify them, without revealing the details. Although Pinocchio itself has evolved and is no longer used in its original form, understanding it helps us appreciate the SNARKs that power today’s blockchain technologies, including ZK Rollups, enhancing scalability and privacy.</p>
<h3 id="1-2-what-is-a-snark">1.2 What is a SNARK?</h3>
<p>So, Pinocchio is a SNARK protocol, but what is a SNARK? SNARK stands for Succinct, Non-Interactive Argument of Knowledge. <em>Succinct</em> , because we will have small proofs which are easy to verify. <em>Non-Interactive</em> , because the proof generated can be used to convince any number of verifiers without requiring direct interactions with the prover. <em>Arguments of Knowledge</em> , because we know with very high probability that the prover is not cheating. Essentially, SNARK protocols offer us a method to “compress” a complex computation into a small, easy-to-verify proof.</p>
<h3 id="1-3-why-do-we-need-snarks">1.3 Why do we need SNARKs?</h3>
<p>It sounds cool to be able to prove the validity of a computation without having to give its code, but what are the applications in the real world? Where is it used?</p>
<p>A prime example are <a rel="noopener external" target="_blank" href="https://ethereum.org/es/developers/docs/scaling/zk-rollups/">ZK Rollups</a>. Blockchains are verifiable computers; they achieve this verifiability by having each node re-execute every transaction and reach a consensus. The problem is that the weakest devices become the bottleneck. Adding more hardware does not make them faster, contrary to what happens in web2: the system becomes more robust and reliable, but the weakest devices continue limiting it. Using SNARKs, we can replace the re-execution with the verification of a proof, which is significantly faster (increasing throughput). Moreover, we can create proofs containing entire blocks of transactions, leading to effective scaling. In summary, we can move the execution off-chain to rollups and verify their proofs on-chain, allowing the system to scale.</p>
<h2 id="2-protocol-s-preliminaries-from-code-to-qap">2. Protocol’s Preliminaries: From code to QAP</h2>
<h3 id="2-1-arithmetic-circuits">2.1 Arithmetic Circuits</h3>
<p>The first thing we must do to be able to use any SNARK protocol is to find an efficient and systematic way to represent a computational code. And that’s what arithmetic circuits do: An arithmetic circuit is a computational model used to represent arithmetic operations in a structured way. It provides a systematic way to describe and compute complex mathematical functions. To learn more about arithmetic circuits you can see our post <a href="/how-to-transform-code-into-arithmetic-circuits/">How to transform code into arithmetic circuits</a>.</p>
<p>Now, if the prover wanted to demonstrate that given specific inputs, a particular code returns certain outputs, she could simply send the corresponding arithmetic circuit to the verifier, without any other protocol needed. The problem is that such a test would not be succinct at all, in fact it would practically be like sending the inputs and the code completely. That is why, in order to achieve a succinct proof, we will have to convert the arithmetic circuit to what we call a R1CS and then transform the R1CS obtained into a QAP.</p>
<p>Below we will broadly explain what R1CSs and QAPs are. Note that it may be constructive to accompany this explanation with its respective implementations that can be found in <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks/pull/884">Pinocchio from Lambdaworks library</a>.</p>
<h3 id="2-2-r1cs">2.2 R1CS</h3>
<p>R1CS stands for Rank-1 Constraint System. It allows us to express relationships between the circuit’s variables in a structured way using <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Matrix_(mathematics)">matrix</a> equations. More specifically, given an arithmetic circuit with a valid solution $c$, our goal will be to create a system of equations of the form $Ac \odot Bc = Cc$ with $A$, $B$ and $C$ matrices:</p>
<p>To fully understand what R1CS are and how to build them, we recommend reading <a rel="noopener external" target="_blank" href="https://www.rareskills.io/post/rank-1-constraint-system">this article</a>. Nevertheless, we enumerate here the steps to transform an arithmetic circuit into an R1CS.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. Identify all the variables used in the circuit. Let&#39;s call them $c = (1, c_1 , \ldots, c_N , c_{N + 1}, \ldots, c_m)$ where $\\{ c_1, \ldots, c_N \\}$ are the public variables and $\\{c_{ N + 1}, \ldots, c_m \\}$ are the intermediate and private variables of the circuit.</span></span>
<span class="giallo-l"><span>    2. Represent the circuit as a system of equations with variables $\\{ c_i \\}_{i = 1}^{m}$ and just one multiplication per equation. We will call each equation a _constraint_ and $n$ the number of constraints.</span></span>
<span class="giallo-l"><span>    3. Construct matrix $A \in { \mathbb{F_p} }^{n \times m}$ in the following way: $a_{ik}$ is the coefficient of the variable $c_k$ at the left entry of the constraint $i$.  </span></span></code></pre>
<p>(If you don’t know what ${ \mathbb{F_p} }^{n \times m}$ means, don’t worry you could think it as ${\mathbb{R}}^{n \times m}$, so $A$ is just a matrix of numbers).
4. Analogously, construct matrix $B$ whose rows represent the right side of the multiplication of each constraint.
5. Construct matrix $C$ whose rows represent the result value of each constraint.
6. Finally, $c$ is a solution of the arithmetic circuit if and only if $Ac \odot Bc = Cc$, where $\odot$ represents the <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Hadamard_product_(matrices)">Hadamard Product</a>.</p>
<h3 id="2-3-qap">2.3 QAP</h3>
<p>So now we know that programs can be represented as arithmetic circuits and further converted into an R1CS. However, directly evaluating R1CS for verification purposes still isn’t succinct due to the large number of operations required, especially for complex computations. Quadratic Arithmetic Programs (QAPs) address this issue by providing a more efficient representation.</p>
<p>QAPs encode the constraints of an R1CS into sets of <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Polynomial">polynomials</a>. This allows multiple constraints to be batched into a single polynomial equation. But why does using polynomials make the proof succinct? It’s all thanks to the mathematical result known as the <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Schwartz%E2%80%93Zippel_lemma">Schwartz-Zippel Lemma</a>. To see in detail why this lemma makes the proof succinct and how we transform an R1CS into a QAP we recommend reading <a rel="noopener external" target="_blank" href="https://www.rareskills.io/post/quadratic-arithmetic-program">this chapter</a> of The RareSkills Book of ZK. Our goal is to be able to test the validity of a solution of the R1CS, checking that a certain polynomial has a given property. We leave here the steps with the notation that we will use below in the protocol:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. Recieve the R1CS: $Ac \odot Bc = Cc$ where $A, B, C \in {\mathbb{F }_p }^{n \times m}$ and $c \in {\mathbb{F }_p }^m$.</span></span>
<span class="giallo-l"><span>    2. Transform each column of $A$, $B$ and $C$ into polynomials:  </span></span></code></pre>
<p>For each $k \in {1, \ldots, m}$, interpolate $(1, \ldots, n)$ with $(a_{1k} , \ldots , a_{nk} )$ the column $k$ of $A$. We will call the resulting polynomial $v_k(x)$.<br />
Analogously, $w_k(x)$ and $y_k(x)$ interpolate the columns of $B$ and $C$ respectively.
3. Define the polynomials $$\begin{align}<br />
p(x) &amp;= \left(\sum_{k = 1 }^m c_k v_k(x) \right) \left(\sum_{k = 1 }^m c_k w_k(x) \right) - \sum_{k = 1 }^m c_k y_k(x), \ \newline<br />
t(x) &amp;= (x - 1)( x - 2)\ldots( x - n).<br />
\end{align}$$We will call $t(x)$ the <em>vanishing polynomial</em>.
4. Finally, $c$ is a solution of the R1SC if and only if there exists a polynomial $h$ such that $p(x) = h(x)t(x)$. This can be checked by choosing a random $s$ and verifying that $p(s) = h(s)t(s)$.</p>
<h2 id="3-pinocchio-s-protocol">3. Pinocchio’s Protocol</h2>
<h3 id="3-1-the-idea-behind">3.1 The idea behind</h3>
<p>Now we are ready to understand the protocol. It starts with a one-time setup, where two keys are generated for proving and verifying these computations. The prover, who performs the computation, uses her key to create a proof that is small and constant in size, regardless of the computation’s complexity. This proof is then verified efficiently through mathematical checks that ensure the computation was done correctly. The system not only supports public verification, allowing anyone with the verification key to check the proof, but it can also be extended to provide privacy-protecting zero-knowledge proofs.</p>
<h3 id="3-2-math-prelimenaries">3.2 Math Prelimenaries</h3>
<p>Understanding Pinocchio’s protocol requires familiarity with key mathematical concepts, primarily elliptic curves, finite fields, and group theory. These form the foundation of the cryptographic operations and security proofs in Pinocchio (and SNARK protocols in general). For a detailed exploration of elliptic curves, refer to our <a href="/what-every-developer-needs-to-know-about-elliptic-curves/">post</a> where we talk about them. For a primer on fundamental structures like groups and fields, see our <a href="/math-survival-kit-for-developers/">Math Survival Kit for Developers</a>. These resources provide the necessary background to appreciate Pinocchio’s intricate design.</p>
<h3 id="3-3-some-observations-to-understand-the-protocol">3.3 Some observations to understand the protocol</h3>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * The prover and verifier agree on a pairing-friendly elliptic curve and generators of the groups $G_1$ and $G_2$ denoted by $g_1$ and $g_2$, respectively. In our case, we choose BLS12-381.</span></span>
<span class="giallo-l"><span>    * Technically, it is not necessary to work with two groups to implement the protocol. That is, the entire implementation can be interpreted using $G_1 = G_2 = G$ and $g_1 = g_2 = g$. In fact in the original Pinocchio&#39;s Paper you can find it that way. However, Type I pairings (that is, those whose domain is of the form $G \times G$) are very inefficient. Furthermore, BLS12-381 and BN254 are curves that have relevance for Ethereum and that is why we choose to work on them in general.</span></span>
<span class="giallo-l"><span>    * We are using $+$ to denote the operation of the groups $G_1$ and $G_2$. For example, $\alpha_v \cdot g_2 = \underbrace{g_2 + \ldots + g_2}_{\alpha_v \text{ times}}$.</span></span></code></pre><h3 id="3-4-the-protocol">3.4 The protocol</h3>
<p>In the following section we present the protocol with some code snipets from the <a href="https://blog.lambdaclass.com/posts/pinocchio-verifiable-computation-revisited/link-here">implementation</a> we made using the Lambdaworks library.</p>
<h4 id="setup">Setup</h4>
<p>Select eight private random elements $s$, $\alpha_v$, $\alpha_w$, $\alpha_y$, $\beta$, $r_v$, $r_w$, $\gamma$ from $\mathbb{F_p}$, and set $r_y = r_v \cdot r_w$. This set of elements are called <em>toxic waste</em> and should be discarded and wholly forgotten once the keys have been generated.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub struct ToxicWaste {</span></span>
<span class="giallo-l"><span>    rv: FE,</span></span>
<span class="giallo-l"><span>    rw: FE,</span></span>
<span class="giallo-l"><span>    s: FE,</span></span>
<span class="giallo-l"><span>    // .... (other elements)</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>impl ToxicWaste {</span></span>
<span class="giallo-l"><span>    pub fn sample() -&gt; Self {</span></span>
<span class="giallo-l"><span>        Self {</span></span>
<span class="giallo-l"><span>            s: sample_fr_elem(),</span></span>
<span class="giallo-l"><span>            alpha_v: sample_fr_elem(),</span></span>
<span class="giallo-l"><span>            // ... (other elements)</span></span>
<span class="giallo-l"><span>        }</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>    </span></span>
<span class="giallo-l"><span>    pub fn ry(&amp;self) -&gt; FE {</span></span>
<span class="giallo-l"><span>        &amp;self.rv * &amp;self.rw</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>Two public keys are generated in the Setup: the evaluation key, that is sent to the prover and the verification key, that is send to the verifier.</p>
<h5 id="the-verification-key">The verification key</h5>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. $g_2$</span></span>
<span class="giallo-l"><span>    2. $\alpha_v \cdot g_2$</span></span>
<span class="giallo-l"><span>    3. $\alpha_w \cdot g_2$</span></span>
<span class="giallo-l"><span>    4. $\alpha_y \cdot g_2$</span></span>
<span class="giallo-l"><span>    5. $\gamma \cdot g_2$</span></span>
<span class="giallo-l"><span>    6. $\beta \gamma \cdot g_2$</span></span>
<span class="giallo-l"><span>    7. $r_y t(s) \cdot g_1$</span></span>
<span class="giallo-l"><span>    8. $\\{r_v v_k(s) \cdot g_1 \\}_{k \in \\{0,\ldots, N \\} }$</span></span>
<span class="giallo-l"><span>    9. $\\{r_w w_k(s) \cdot g_2 \\}_{k \in \\{0,\ldots, N \\} }$</span></span>
<span class="giallo-l"><span>    10. $\\{r_y y_k(s) \cdot g_1 \\}_{k \in \\{0,\ldots, N \\} }$</span></span></code></pre>
<p>To implement this in rust, we first need to create a struct VerificationKey with each element and then generate it.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub struct VerificationKey {</span></span>
<span class="giallo-l"><span>    pub g2: G2Point,</span></span>
<span class="giallo-l"><span>    pub g2_alpha_v: G2Point,</span></span>
<span class="giallo-l"><span>    pub g2_alpha_w: G2Point,</span></span>
<span class="giallo-l"><span>    // ...</span></span>
<span class="giallo-l"><span>}</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>pub fn generate_verification_key(</span></span>
<span class="giallo-l"><span>    qap: QuadraticArithmeticProgram,</span></span>
<span class="giallo-l"><span>    toxic_waste: &amp;ToxicWaste,</span></span>
<span class="giallo-l"><span>) -&gt; VerificationKey {</span></span>
<span class="giallo-l"><span>    let g1: G1Point = Curve::generator();</span></span>
<span class="giallo-l"><span>    let g2: G2Point = TwistedCurve::generator();</span></span>
<span class="giallo-l"><span>    </span></span>
<span class="giallo-l"><span>    // declare the rest of the variables needed</span></span>
<span class="giallo-l"><span>    // ...</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    VerificationKey {</span></span>
<span class="giallo-l"><span>        g2: g2.clone(),</span></span>
<span class="giallo-l"><span>        g2_alpha_v: g2.operate_with_self(toxic_waste.alpha_v.representative()),</span></span>
<span class="giallo-l"><span>        // ... </span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre><h5 id="the-evaluation-key">The evaluation key</h5>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. $\\{r_v v_k(s) \cdot g_1 \\}_{k \in \\{N + 1, \ldots, m \\}}$</span></span>
<span class="giallo-l"><span>    2. $\\{r_w w_k(s) \cdot g_1 \\}_{k \in \\{N + 1, \ldots, m \\}}$</span></span>
<span class="giallo-l"><span>    3. $\\{r_w w_k(s) \cdot g_2 \\}_{k \in \\{N + 1, \ldots, m \\}}$</span></span>
<span class="giallo-l"><span>    4. $\\{r_y y_k(s) \cdot g_1 \\}_{k \in \\{N + 1, \ldots, m \\}}$</span></span>
<span class="giallo-l"><span>    5. $\\{r_v \alpha_v v_k(s) \cdot g_1 \\}_{k \in \\{N + 1, \ldots, m \\}}$</span></span>
<span class="giallo-l"><span>    6. $\\{r_w \alpha_w w_k(s) \cdot g_1 \\}_{k \in \\{N + 1, \ldots, m \\}}$</span></span>
<span class="giallo-l"><span>    7. $\\{r_y \alpha_y y_k(s) \cdot g_1 \\}_{k \in \\{N + 1, \ldots, m \\}}$</span></span>
<span class="giallo-l"><span>    8. $(r_v \beta v_k(s) + r_w \beta w_k(s) + r_y \beta y_k(s)) \cdot g_1$</span></span>
<span class="giallo-l"><span>    9. $\\{ s^i \cdot g_2 \\}_{i \in \\{ 1,\ldots,d \\} }$ where $d$ is the degree of $t(x) = (x - 1) \ldots (x - n)$. That is, $d = n$ the number of raws of the R1SC matrices (i.e. the number of constraints).</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>pub struct EvaluationKey {</span></span>
<span class="giallo-l"><span>    pub g1_vk: Vec&lt;G1Point&gt;,</span></span>
<span class="giallo-l"><span>    pub g1_wk: Vec&lt;G1Point&gt;,</span></span>
<span class="giallo-l"><span>    pub g2_wk: Vec&lt;G2Point&gt;,</span></span>
<span class="giallo-l"><span>    // ... </span></span>
<span class="giallo-l"><span>}</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>pub fn generate_evaluation_key(</span></span>
<span class="giallo-l"><span>    qap: &amp;QuadraticArithmeticProgram,</span></span>
<span class="giallo-l"><span>    toxic_waste: &amp;ToxicWaste,</span></span>
<span class="giallo-l"><span>) -&gt; EvaluationKey {</span></span>
<span class="giallo-l"><span>    let g1: G1Point = Curve::generator();</span></span>
<span class="giallo-l"><span>    let g2: G2Point = TwistedCurve::generator();</span></span>
<span class="giallo-l"><span>    let (v_mid, w_mid, y_mid) = (qap.v_mid(), qap.w_mid(), qap.y_mid());</span></span>
<span class="giallo-l"><span>    </span></span>
<span class="giallo-l"><span>    // declare the rest of the variables needed</span></span>
<span class="giallo-l"><span>    // ...</span></span>
<span class="giallo-l"><span>    </span></span>
<span class="giallo-l"><span>    EvaluationKey {</span></span>
<span class="giallo-l"><span>        g1_vk: vs_mid.iter()</span></span>
<span class="giallo-l"><span>            .map(|vk| g.operate_with_self((rv * vk.evaluate(&amp;s))</span></span>
<span class="giallo-l"><span>            .representative()))</span></span>
<span class="giallo-l"><span>            .collect(),</span></span>
<span class="giallo-l"><span>,</span></span>
<span class="giallo-l"><span>        // ... </span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>Having EvaluationKey and VeifiationKey, we can then implement the setup:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub fn setup(</span></span>
<span class="giallo-l"><span>    qap: &amp;QuadraticArithmeticProgram,</span></span>
<span class="giallo-l"><span>    toxic_waste: ToxicWaste,</span></span>
<span class="giallo-l"><span>) -&gt; (EvaluationKey, VerificationKey) {</span></span>
<span class="giallo-l"><span>    (generate_evaluation_key(&amp;qap, &amp;toxic_waste),</span></span>
<span class="giallo-l"><span>     generate_verification_key(qap.clone(), &amp;toxic_waste))</span></span>
<span class="giallo-l"><span>}</span></span></code></pre><h4 id="prove">Prove</h4>
<p>The steps for the prover are as follows:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. Evaluate the circuit with the input values and obtain ${c_{N + 1}, \ldots, c_m }$ the intermediate values.</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    2. Compute the polynomial $$p(x) = \left(\sum_{k = 1}^m c_k v_k(x) \right) \left(\sum_{k = 1}^m c_k w_k(x) \right) - \sum_{k = 1}^m c_k y_k(x).$$</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    3. Calculate the polynomial $h(x) = \frac{p(x)}{t(x)}$.</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    4. Produce the proof $$\pi = (V, W_1, W_2, Y, V&#39;, W&#39;, Y&#39;, Z, H),$$ computing its elements:</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>       * $V = \sum\limits_{k = N + 1}^m c_k \cdot \underbrace{\style{color: olive;}{r_v v_k(s) \cdot g_1}}_{\style{color: olive;}{\begin{array}{c} \text{From the} \ \text{evaluation key} \end{array}}}$</span></span>
<span class="giallo-l"><span>       * $W_1 = \sum\limits_{k = N + 1}^m c_k \cdot \style{color: olive;}{r_w w_k(s) \cdot g_1}$</span></span>
<span class="giallo-l"><span>       * $W_2 = \sum\limits_{k = N + 1}^m c_k \cdot \style{color: olive;}{r_w w_k(s) \cdot g_2}$</span></span>
<span class="giallo-l"><span>       * $Y = \sum\limits_{k = N + 1}^m c_k \cdot \style{color: olive;}{r_y y_k(s) \cdot g_1}$</span></span>
<span class="giallo-l"><span>       * $V&#39; = \sum\limits_{k = N + 1}^m c_k \cdot \style{color: olive;}{r_v \alpha_v v_k(s) \cdot g_1}$</span></span>
<span class="giallo-l"><span>       * $W&#39; = \sum\limits_{k = N + 1}^m c_k \cdot \style{color: olive;}{r_w \alpha_w w_k(s) \cdot g_1}$</span></span>
<span class="giallo-l"><span>       * $Y&#39; = \sum\limits_{k = N + 1}^m c_k \cdot \style{color: olive;}{r_y \alpha_y y_k(s) \cdot g_1}$</span></span>
<span class="giallo-l"><span>       * $Z = \sum\limits_{k = N + 1}^m c_k \cdot \style{color: olive;}{(r_v \beta v_k(s) + r_w \beta w_k(s) + r_y \beta y_k(s)) \cdot g_1}$</span></span>
<span class="giallo-l"><span>       * $H = h(s) \cdot g_2 = \sum\limits_{i = 1 }^d h_i \cdot \style{color: olive;} {s^i \cdot g_2}$</span></span>
<span class="giallo-l"><span>    5. Send the public values $(c_1, \ldots, c_N)$ and the proof $\pi$.</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>pub fn generate_proof(</span></span>
<span class="giallo-l"><span>    evaluation_key: &amp;EvaluationKey,</span></span>
<span class="giallo-l"><span>    qap: &amp;QuadraticArithmeticProgram,</span></span>
<span class="giallo-l"><span>    qap_c_coefficients: &amp;[FE],</span></span>
<span class="giallo-l"><span>) -&gt; Proof {</span></span>
<span class="giallo-l"><span>    // We will call {c_{N+1}, ... , c_m} cmid.</span></span>
<span class="giallo-l"><span>    let cmid = &amp;qap_c_coefficients[qap.number_of_inputs</span></span>
<span class="giallo-l"><span>    ..qap_c_coefficients.len() - qap.number_of_outputs];</span></span>
<span class="giallo-l"><span>    </span></span>
<span class="giallo-l"><span>    // We transform each FieldElement of the cmid into an UnsignedInteger so we can multiply them to g1.</span></span>
<span class="giallo-l"><span>    let c_mid = cmid</span></span>
<span class="giallo-l"><span>        .iter()</span></span>
<span class="giallo-l"><span>        .map(|elem| elem.representative())</span></span>
<span class="giallo-l"><span>        .collect::&lt;Vec&lt;_&gt;&gt;();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let h_polynomial = qap.h_polynomial(qap_c_coefficients);</span></span>
<span class="giallo-l"><span>    let h_coefficients = h_polynomial.coefficients</span></span>
<span class="giallo-l"><span>        .iter()</span></span>
<span class="giallo-l"><span>        .map(|elem| elem.representative())</span></span>
<span class="giallo-l"><span>        .collect::&lt;Vec&lt;_&gt;&gt;();</span></span>
<span class="giallo-l"><span>    let h_degree = h_polynomial.degree();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    Proof {</span></span>
<span class="giallo-l"><span>        v: msm(&amp;c_mid, &amp;evaluation_key.g2_vk_s).unwrap(),</span></span>
<span class="giallo-l"><span>        w1: msm(&amp;c_mid, &amp;evaluation_key.g2w_wk).unwrap(),</span></span>
<span class="giallo-l"><span>        w2: msm(&amp;c_mid, &amp;evaluation_key.g2w_wk).unwrap(),</span></span>
<span class="giallo-l"><span>        //...</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre><h4 id="verify">Verify</h4>
<p>So that no malicious prover deceives the verifier, he has to ensure two things: Firstly, that the requested condition (number 4) of the QAP’s polynomial is satisfied; and secondly, that the proof’s elements have been generated from the QAP correctly. To achieve this, the verifier will do three checks. The first check will ensure the validity of the QAP and the other two checks, the correct construction of the proof’s elements.</p>
<p>We will denote $e$ to the pairing whose first argument is a point from $G_1,$ and the second from $G_2$.</p>
<p><strong>Check 1: Correctness of the QAP</strong><br />
To be sure that the provided proof corresponds to a valid solution of the QAP, and thus a correct computation result, the verifier needs to be convinced that $p(s) = h(s)t(s)$. To achieve this he can simply check $$e(V_{io} + V, W_{io} + W_2 ) = e( \style{color: teal}{r_y t(s) \cdot g_1} , H ) e(Y_{io} + Y, \style{color: teal}{g_2} ),$$ where to simplify the notation we call</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * $V_{io} = \style{color: teal}{r_v v_0(s) \cdot g_1} + \sum\limits_{k=1}^N c_k \style{color: teal} {r_v v_k(s) \cdot g_1}$</span></span>
<span class="giallo-l"><span>    * $W_{io} = \style{color: teal}{r_w w_0(s) \cdot g_2} + \sum\limits_{k=1}^N c_k \style{color: teal} {r_w w_k(s) \cdot g_2}$</span></span>
<span class="giallo-l"><span>    * $Y_{io} = \style{color: teal}{r_y y_0(s) \cdot g_1} + \sum\limits_{k=1}^N c_k \style{color: teal} {r_y y_k(s) \cdot g_1}$</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>pub fn check_divisibility(</span></span>
<span class="giallo-l"><span>    verification_key: &amp;VerificationKey,</span></span>
<span class="giallo-l"><span>    proof: &amp;Proof,</span></span>
<span class="giallo-l"><span>    c_io: &amp;[FE],</span></span>
<span class="giallo-l"><span>) -&gt; bool {</span></span>
<span class="giallo-l"><span>    // We will use hiding_v, hiding_w and hiding_y as arguments of the pairings.</span></span>
<span class="giallo-l"><span>    </span></span>
<span class="giallo-l"><span>    // We transform the c_io into UnsignedIntegers.</span></span>
<span class="giallo-l"><span>    let c_io = c_io</span></span>
<span class="giallo-l"><span>    .iter()</span></span>
<span class="giallo-l"><span>    .map(|elem| elem.representative())</span></span>
<span class="giallo-l"><span>    .collect::&lt;Vec&lt;_&gt;&gt;();</span></span>
<span class="giallo-l"><span>    </span></span>
<span class="giallo-l"><span>    let v_io = verification_key.g1_vk[0]</span></span>
<span class="giallo-l"><span>        .operate_with(&amp;msm(&amp;c_io, &amp;verification_key.g1_vk[1..]).unwrap());</span></span>
<span class="giallo-l"><span>        </span></span>
<span class="giallo-l"><span>    // The same with w_io and y_io.</span></span>
<span class="giallo-l"><span>    //...</span></span>
<span class="giallo-l"><span>    </span></span>
<span class="giallo-l"><span>    Pairing::compute(</span></span>
<span class="giallo-l"><span>        &amp;v_io.operate_with(proof.v), </span></span>
<span class="giallo-l"><span>        &amp;w_io.operate_with(proof.w)</span></span>
<span class="giallo-l"><span>    ).unwrap()</span></span>
<span class="giallo-l"><span>    == Pairing::compute( ... , ...).unwrap() </span></span>
<span class="giallo-l"><span>    * Pairing::compute( ... , ...).unwrap()</span></span>
<span class="giallo-l"><span>    </span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p><strong>Correct construction of $V$, $W$ and $Y$:</strong></p>
<p><strong>Check 2:</strong> The veifier checks that the prover used the polynomials of the QAP to construct $V$, $W$ and $Y$, and that he didn’t provide arbitrary values that simply pass the previous check.</p>
<p>So, in this check the goal is to verify that $V$ is $g_1$ multiplied by some linear combination of ${v_k(s)}_{k \in {1,\ldots,m}}$, and analogously, with $W$ and $Y$:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * $e(V&#39;, \style{color: teal} {g_2}) = e(V, \style{color: teal} {\alpha_v \cdot g_2})$</span></span>
<span class="giallo-l"><span>    * $e(W&#39;, \style{color: teal} {g_2}) = e(W, \style{color: teal} {\alpha_w \cdot g_2})$</span></span>
<span class="giallo-l"><span>    * $e(Y&#39;, \style{color: teal} {g_2}) = e(Y, \style{color: teal} {\alpha_y \cdot g_2})$</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>pub fn check_appropriate_spans(</span></span>
<span class="giallo-l"><span>    verification_key: &amp;VerificationKey,</span></span>
<span class="giallo-l"><span>    proof: &amp;Proof</span></span>
<span class="giallo-l"><span>) -&gt; bool {</span></span>
<span class="giallo-l"><span>    let b1 = Pairing::compute(&amp;proof.v_prime, &amp;verification_key.g2) </span></span>
<span class="giallo-l"><span>        == Pairing::compute(&amp;proof.v, &amp;verification_key.g2_alpha_v);</span></span>
<span class="giallo-l"><span>    let b2 = Pairing::compute( ... , ... ) </span></span>
<span class="giallo-l"><span>        == Pairing::compute(... , ... );</span></span>
<span class="giallo-l"><span>    let b3 = // ...</span></span>
<span class="giallo-l"><span>    </span></span>
<span class="giallo-l"><span>    b1 &amp;&amp; b2 &amp;&amp; b3</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>Why does this work?</p>
<p>If this check passes, the verifier can be sure that, for example, $V’ = \alpha_v V$. Looking at the evaluation key, he sees that the prover doesn’t know the raw value of $\alpha_v$. So the only way the prover could have constructed $V$ and $V’$ such that they satisfy this equality is using a linear combination of ${v_k(s)}_{k \in {1,\ldots,m }}$. Similarly, he can be convinced that $W$ and $Y$ were constructed that way.</p>
<p><strong>Check 3:</strong> The previous check is not enough to ensure that the proof elements were constructed correctly. We also need to verify that the prover used the same set of coefficients ${c_1,\ldots,c_m}$ in each linear combination $V$, $W$ and $Y$ of the previous check.</p>
<p>$$e(Z, \style{color: teal} {\gamma \cdot g_2}) = e(V+W+ Y, \style{color: teal} {\beta \gamma \cdot g_2}) $$</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub fn check_same_linear_combinations(</span></span>
<span class="giallo-l"><span>    verification_key: &amp;VerificationKey,</span></span>
<span class="giallo-l"><span>    proof: &amp;Proof</span></span>
<span class="giallo-l"><span>) -&gt; bool {</span></span>
<span class="giallo-l"><span>    Pairing::compute(&amp;proof.z, &amp;verification_key.g2_gamma)</span></span>
<span class="giallo-l"><span>    == Pairing::compute(</span></span>
<span class="giallo-l"><span>        &amp;proof.v</span></span>
<span class="giallo-l"><span>            .operate_with(&amp;proof.w)</span></span>
<span class="giallo-l"><span>            .operate_with(&amp;proof.y),</span></span>
<span class="giallo-l"><span>        &amp;verification_key.g2_beta_gamma</span></span>
<span class="giallo-l"><span>    )</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>Putting it all together</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub fn verify(verification_key:&amp;VerificationKey,</span></span>
<span class="giallo-l"><span>    proof: &amp;Proof,</span></span>
<span class="giallo-l"><span>    c_inputs_outputs: &amp;[FE]</span></span>
<span class="giallo-l"><span>) -&gt; bool {</span></span>
<span class="giallo-l"><span>    let b1 = check_divisibility(verification_key, proof, c_inputs_outputs);</span></span>
<span class="giallo-l"><span>    let b2 = check_appropriate_spans(verification_key, proof);</span></span>
<span class="giallo-l"><span>    let b3 = check_same_linear_combinations(verification_key, proof);</span></span>
<span class="giallo-l"><span>    </span></span>
<span class="giallo-l"><span>    b1 &amp;&amp; b2 &amp;&amp; b3</span></span>
<span class="giallo-l"><span>}</span></span></code></pre><h2 id="6-turning-a-snark-into-a-zk-snark">6. Turning a SNARK into a ZK-SNARK</h2>
<p>What does it mean zero-knowledge? We would like to be impossible for the verifier to gain any information from the proof, as it appears indistinguishable from random data.</p>
<p>To make it zero-knowledge, the prover has to sample some random values $\delta_v,\delta_w,\delta_y$ and make the following changes to the polynomials:</p>
<p>$v_{mid}(x) + \delta_v t(x), v(x) + \delta_v t(x),w(x) + \delta_w t(x) \text{ and } y(x) + \delta_y t(x).$</p>
<p>You can see in detail the zk adaptation of the protocol in the <a rel="noopener external" target="_blank" href="https://arxiv.org/abs/1906.07221">Chapter 4.13</a> of <em>Why and How zk-SNARK Works</em>.</p>
<h2 id="7-summary">7. Summary</h2>
<p>In this post we covered the main ideas behind Pinocchio’s protocol and our implementation using Lambdaworks library. We first saw the steps to transform code into a QAP. Then, we presented the actual protocol explaining how it works and why we need each different check to achieve security. Finally, we observed that while its primary objective is to achieve verifiable computation, it can incorporate zero-knowledge properties with minimal additional effort.</p>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
