<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>How to create your own crappy RSA as a software developer - LambdaClass Blog</title>
    <meta name="description" content="Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">How to create your own crappy RSA as a software developer</h1>
        
        <div class="page-meta">
            <time datetime="2022-08-26">August 26, 2022</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <h2 id="introduction">Introduction</h2>
<p>One of the key developments in cryptography was the introduction of public key (or asymmetric) cryptosystems. These rely on pairs of keys: one of them is the public key (known to everybody) and the other is the private key (known only to the specific user). The public key is used to encrypt messages (anybody can do this since it is public), while the private key is used to decrypt the messages. This contrasts with symmetric encryption, where there is one key that can perform both operations (and was the only method available before the 1970s). This meant that a secure channel was needed to exchange/decide on the key, so that only certain priviledged parties were able to do cryptography. The real-time cryptography and the internet as we know it was enabled by public key cryptography. Depending on the method used, the keys could be numbers -for example, (RSA) or, in the case of elliptic curve cryptography (ECC), a number and a point of an elliptic curve. The algorithm of encryption and decryption is also publicly known, so the security of the whole system depends on never revealing the private key (this is known as <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Kerckhoffs%27s_principle">Kerckhoff’s principle</a>). Asymmetric cryptography plays a fundamental role in many applications and protocols, offering confidentiality, authenticity, and non-repudiability of data and electronic communications. Internet standards, such as TLS, SSH, and PGP rely on this cryptographic primitive.</p>
<p>RSA (named after Rivest, Shamir, and Adleman) is one of the first public key cryptosystems, the most widely used, and one of the simplest to understand and implement (1). We will discuss today how RSA works, how to implement its basic structure, and what are some of the pitfalls and weaknesses of this system (which have led to its losing ground against ECC).</p>
<p>We will be using some math and cryptography concepts below; you may want to review our math <a href="/math-survival-kit-for-developers/">survival kit</a> first.</p>
<h2 id="how-rsa-works">How RSA works</h2>
<h3 id="non-rigorous-mathematical-idea">Non-rigorous mathematical idea</h3>
<p>RSA relies on four key steps: key generation, key distribution, encryption, and decryption. Instead of describing each of them in sequence, we will give an overview of the whole process and then go into the details. The basic idea is the following: given a number $n$ (public), there are two numbers $e$ (public key, used for encryption) and $d$ (private key, used for decryption), which are multiplicative inverses (that is, $d\times e=1$, so $e=d^{-1}$). Given a message $M$, expressed as a number between $0$ and $n-1$, the encryption $E(M)$ is done by taking the $e$-th power of $M$,<br />
$E(M)=M^e$<br />
Decryption is done similarly by taking the $d$-th power of the encrypted message,<br />
${E(M)}d=(M{e})d=M{d\times e}=M$<br />
Of course, if you think in terms of high-school math, there are several problems, starting with the obvious fact that knowing $e$ allows you to calculate $d$ and that the encrypted message can grow into a very large number (and take a lot of space). This is where number theory and modular arithmetic come to our rescue.</p>
<h3 id="steps">Steps</h3>
<p>Let’s now look in more detail at each of the steps and how we can get something that is very difficult to crack unless you know the secret key.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. Key generation:</span></span>
<span class="giallo-l"><span>    * Pick large random prime numbers $p$ and $q$ and keep them secret (2).</span></span>
<span class="giallo-l"><span>    * Calculate $n=p\times q$. $n$ is released as part of the public key parameters.</span></span>
<span class="giallo-l"><span>    * Compute the value of [Euler&#39;s totient function](https://en.wikipedia.org/wiki/Euler%27s_totient_function) $\phi(n)=(p-1)\times (q-1)$ and keep it secret (3).</span></span>
<span class="giallo-l"><span>    * Choose an integer $1&lt;e&lt;\phi(n)$ which is coprime to $\phi (n)$ (that is, their only common divisor is 1). $65537=2^{16}+1$ is a typical choice since it offers rather fast encryption and security. Another popular choice is $3$, but it is known that this leads to insecure encryption in many settings.</span></span>
<span class="giallo-l"><span>    * Calculate $d=e^{-1} \mod{\phi(n)}$, that is, $d$ is the multiplicative inverse of $e$ modulo $\phi(n)$ (4). This can be done via taking powers of $e$ or in a faster way using the [extended Euclidean algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm).</span></span>
<span class="giallo-l"><span>    2. Key distribution: If two people Alice and Bob want to communicate, each sends the other their public parameters $(e_A,n_A)$ and $(e_B,n_B)$. Of course, an obvious question arises, how do Bob and Alice know that they got each other&#39;s public parameters and not someone else&#39;s (the infamous man-in-the-middle)?</span></span>
<span class="giallo-l"><span>    3. Encryption:</span></span>
<span class="giallo-l"><span>    * Convert the message $P$ into an integer $1&lt;m&lt;n$ by using an agreed padding scheme.</span></span>
<span class="giallo-l"><span>    * $E(m)$ is calculated $E(m)\equiv m^e \pmod{n}$.</span></span>
<span class="giallo-l"><span>    4. Decryption:</span></span>
<span class="giallo-l"><span>    * Compute the message $m$ by doing ${E(m)}^d\equiv m \pmod{n}$.</span></span>
<span class="giallo-l"><span>    * Reverse the first step of encryption to convert $m$ to $P$.</span></span></code></pre><h3 id="example-of-the-calculations">Example of the calculations</h3>
<p>Let’s pick a toy model to illustrate how the calculations are done (of course, no real model uses these simple numbers, because it is rather easy to break, even by brute force attempts).</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. We choose two random primes 17 and 19.</span></span>
<span class="giallo-l"><span>    2. $n=17\times 19=323$</span></span>
<span class="giallo-l"><span>    3. We evaluate $\phi(323)=288$ or $\lambda(323)=144=lcm(16,18)$.</span></span>
<span class="giallo-l"><span>    4. We pick $e=5$ (remember, a small $e$ is not a good choice). We cannot pick $3$ because $3$ is not coprime to $\phi(n)=288=2^5 \times 3^2$.</span></span>
<span class="giallo-l"><span>    5. $d=5^{11}\equiv 29 \pmod{144}$. (We use Carmichael&#39;s totient function since it is faster). Let&#39;s check we did right: $5\times 29=145\equiv 1 \pmod{144}$, since $145=1\times 144+1$. An even faster alternative would be using the extended Euclidean algorithm.</span></span>
<span class="giallo-l"><span>    6. Our message is $11$. Therefore $E(11)=11^5\equiv 197\pmod{323}$.</span></span>
<span class="giallo-l"><span>    7. We now attempt to decrypt $197^{29}\equiv 11 \pmod{323}$</span></span></code></pre><h3 id="the-math-behind-the-scenes">The math behind the scenes</h3>
<p>The trick works because we have two numbers $d$ and $e$, such that $d\times e \equiv 1 \pmod{\phi(n)}$. In other words, $d\times e=k\phi(n)+1$. If we perform encryption, followed by decryption, we get<br />
${(me)}d=m^{e\times d}=m^{1+k\phi(n)}=m\times (m{\phi(n)})k \equiv m \pmod{n}$<br />
The last step is a consequence of Euler’s theorem, since<br />
$a^{\phi(n)}\equiv 1 \pmod{n}$, given $a$ and $n$ are coprime.</p>
<h3 id="security-issues">Security issues</h3>
<p>There are several issues with RSA, especially when it is not implemented properly. When generating random prime numbers, these must be truly random (therefore, always use a pseudorandom generator that works for cryptographic applications). Many attacks depend on getting to the factorization of the public parameter $n$. If we can find $p$ or $q$, then we get the other and we can calculate $\lambda (n)$ or $\phi(n)$, the multiplicative inverse of $e$, which is none other than the private key. For example, if $p$ and $q$ are very similar in length, we know $p \approx q \approx \sqrt{n}$ and Fermat’s factorization as two squares $n=a2-b2$ is possible. It is easy to see that $a2-b2=(a+b)\times (a-b)$ and so we have both numbers. If we know many different $n$, we can try breaking the factorization by finding the least common divisor. For example, say we know for two people $n_1$ and $n_2$ and that they share a common factor $p$. Then we have $p=gcd(n_1,n_2)$ and the gcd can be found extremely fast (in polynomial time) thanks to Euclid’s algorithm. This way, we break the security of both accounts.</p>
<p>Other methods work even if the factorization is not known. In the case of low exponents $e$ (such as $3$), it may happen that $M^3$ does not exceed the modulus $n$ and so it may be easily broken by taking the cubic root. On the other hand, if the private key is small, you can use <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Wiener%27s_attack">Wiener’s</a> or <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2020/1214.pdf">Boneh-Durfree’s attacks</a> and get the key. A collection of several strategies is on the following <a rel="noopener external" target="_blank" href="https://github.com/RsaCtfTool/RsaCtfTool">link</a>. You can build your own factorization methods or try using open source tools such as <a rel="noopener external" target="_blank" href="https://www.sagemath.org/">SageMath</a> to try and see how easy is to perform the factorization of a composite number.</p>
<h2 id="implementing-some-of-the-key-functions">Implementing some of the key functions</h2>
<p>To be able to perform operations with RSA, we need to implement first some of the arithmetic operations and define field elements. We will show how to implement some of these in Rust.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>use::std::ops::{Add, Sub, Mul, Div};</span></span>
<span class="giallo-l"><span>pub struct FieldPoint {</span></span>
<span class="giallo-l"><span>    num: u128,</span></span>
<span class="giallo-l"><span>    prime: u128,</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>The first line imports the standard library (in particular, the operations of addition, subtraction, multiplication, and division) which will allow us to override these operators with the expressions we need to use in modular arithmetic.</p>
<p>In the second line, we define a public structure named <code>FieldPoint</code>, which has two fields: <code>num</code> (a number in the range 0 to prime) and <code>prime</code> (this will give us the size and we will perform all operations modulo prime). For practical applications, we need to replace the unsigned integers <code>u128</code> with appropriate variables that allow us to store large integers.</p>
<p>We can now instantiate some methods over <code>FieldPoint</code>, such as how to create one or how to multiply or divide field elements.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>impl FieldPoint {</span></span>
<span class="giallo-l"><span>    pub fn new(num: u128, prime: u128) -&gt; FieldPoint {</span></span>
<span class="giallo-l"><span>        if num &gt; prime {</span></span>
<span class="giallo-l"><span>            panic!(&quot;Not a valid input for a field point, num should be nonnegative and less than prime, obtained {}&quot;, num);</span></span>
<span class="giallo-l"><span>        } else {</span></span>
<span class="giallo-l"><span>            FieldPoint {num:num, prime:prime}</span></span>
<span class="giallo-l"><span>        }</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>Methods are defined following the keyword <code>impl</code> and the name of the <code>struct</code>. We have a constructor for the <code>FieldPoint</code>, which takes two unsigned <code>u128</code> integers.</p>
<p>To define addition, we can implement the trait <code>Add</code> for <code>FieldPoint</code> in this way</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>impl Add for FieldPoint {</span></span>
<span class="giallo-l"><span>    type Output = Self;</span></span>
<span class="giallo-l"><span>    fn add(self, other: Self) -&gt; Self {</span></span>
<span class="giallo-l"><span>        if self.prime == other.prime {</span></span>
<span class="giallo-l"><span>            FieldPoint {num: (self.num + other.num).rem_euclid(self.prime), prime: self.prime}</span></span>
<span class="giallo-l"><span>        } else {</span></span>
<span class="giallo-l"><span>            panic!(&quot;Cannot add these field points, different prime values {},{}&quot;,self.prime,other.prime);</span></span>
<span class="giallo-l"><span>        }</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>The addition is simply adding the <code>num</code> fields and if the result exceeds the modulus <code>prime</code>, we take the remainder of the Euclidean division between the sum and the modulus.</p>
<p>Multiplication works in a similar way</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>impl Mul for FieldPoint {</span></span>
<span class="giallo-l"><span>    type Output = Self;</span></span>
<span class="giallo-l"><span>    fn mul(self, other: Self) -&gt; Self {</span></span>
<span class="giallo-l"><span>        if self.prime == other.prime {</span></span>
<span class="giallo-l"><span>            FieldPoint {num: (self.num*other.num).rem_euclid(self.prime), prime: self.prime}</span></span>
<span class="giallo-l"><span>        } else {</span></span>
<span class="giallo-l"><span>            panic!(&quot;Cannot multiply these field points, different prime values, {},{}&quot;,self.prime,other.prime);</span></span>
<span class="giallo-l"><span>        }</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>We need to define the powers of <code>FieldElement</code>. We can do this in a rather efficient way by squaring and taking the remainder:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub fn power(&amp;self,index: u128) -&gt; Self {</span></span>
<span class="giallo-l"><span>        if index == 0 {</span></span>
<span class="giallo-l"><span>            FieldPoint {num: 1u128, prime: self.prime}</span></span>
<span class="giallo-l"><span>        } else {</span></span>
<span class="giallo-l"><span>            let mut aux=index.rem_euclid(self.prime-1u128);</span></span>
<span class="giallo-l"><span>            let mut acc: u128 = 1;</span></span>
<span class="giallo-l"><span>            let mut base: u128 =self.num;</span></span>
<span class="giallo-l"><span>            while aux &gt;0{</span></span>
<span class="giallo-l"><span>                if aux%2 == 0 {</span></span>
<span class="giallo-l"><span>                    base = (base*base).rem_euclid(self.prime);</span></span>
<span class="giallo-l"><span>                    aux=aux/2u128;</span></span>
<span class="giallo-l"><span>                } else {</span></span>
<span class="giallo-l"><span>                    acc = (acc*base).rem_euclid(self.prime);</span></span>
<span class="giallo-l"><span>                    aux=aux-1u128; </span></span>
<span class="giallo-l"><span>                }</span></span>
<span class="giallo-l"><span>            }</span></span>
<span class="giallo-l"><span>            FieldPoint {num: acc, prime: self.prime}</span></span>
<span class="giallo-l"><span>        }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    }</span></span></code></pre>
<p>The power function takes a <code>FieldElement</code> and <code>index</code>, a <code>u128</code>. If the index is $0$, the result is trivial and we output a <code>FieldElement</code> with <code>num</code> equal to $1$. In any other case, we first reduce <code>index</code> (if <code>index</code> exceeds <code>prime</code>, we can take the remainder of <code>index</code> by <code>prime-1</code> -this works when the modulus is prime since Euler’s theorem says that $a^{p-1}\equiv 1 \pmod{p}$-. A better version would reduce <code>index</code> by $\phi(n)$) and store it in <code>aux</code>. We also define a variable to calculate the result <code>acc</code> and <code>base</code>, where we will repeatedly square and take the remainder of the <code>num</code>.</p>
<p>We now focus on the squaring and the updating of the result:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>while aux &gt;0{</span></span>
<span class="giallo-l"><span>    if aux%2 == 0 {</span></span>
<span class="giallo-l"><span>        base = (base*base).rem_euclid(self.prime);</span></span>
<span class="giallo-l"><span>        aux=aux/2u128;</span></span>
<span class="giallo-l"><span>    } else {</span></span>
<span class="giallo-l"><span>        acc = (acc*base).rem_euclid(self.prime);</span></span>
<span class="giallo-l"><span>        aux=aux-1u128; </span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>We will go decreasing the index stored in <code>aux</code>: if it is even (the first condition -this could be checked much faster, by inspecting the last bit of <code>aux</code>-), we divide <code>aux</code> by two and update <code>base</code> to the remainder of its square. If it is odd, then we proceed to update the result in <code>acc</code> and decrease <code>aux</code> by one (which means that in the next step it will be even).</p>
<p>To convince ourselves, let’s take a short numerical example, while we follow the instructions. Let’s take <code>prime</code> as 11, <code>num</code> as 4, and <code>index</code> as 39.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. We set `aux` equal to the remainder of 39 and 10 (which is also $\phi(11)$). We get `aux=9`.</span></span>
<span class="giallo-l"><span>    2. Since $9&gt;0$, we go inside the while loop. $9$ is odd, so `acc=9` and `aux=8`.</span></span>
<span class="giallo-l"><span>    3. `aux` is even, so `base=4*4=16`; we have to reduce the number by taking the remainder by $11$, so `base=5` and `aux=4`.</span></span>
<span class="giallo-l"><span>    4. `aux` is even, so `base=5*5=25` and we get `base=3` and `aux=2`.</span></span>
<span class="giallo-l"><span>    5. `aux` is once again even, `base=9` and `aux=1`.</span></span>
<span class="giallo-l"><span>    6. `aux` is odd, we get `acc=9*4=36-&gt;3` and `aux=0`.</span></span>
<span class="giallo-l"><span>    7. Since `aux=0`, we jump outside the while loop and the function returns the `FieldPoint` (`num`=3,`prime`=11).</span></span></code></pre>
<p>Another function that we need is the greatest common divisor. A very simple form of the algorithm looks like this</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub fn gcd(a: u128,b: u128) -&gt; u128 {</span></span>
<span class="giallo-l"><span>    let mut r0: u128=b;</span></span>
<span class="giallo-l"><span>    let mut r1: u128=a;</span></span>
<span class="giallo-l"><span>    if a&gt;b {</span></span>
<span class="giallo-l"><span>        r0 = b;</span></span>
<span class="giallo-l"><span>        r1 = a;</span></span>
<span class="giallo-l"><span>    } </span></span>
<span class="giallo-l"><span>    let mut r2: u128 = 1;</span></span>
<span class="giallo-l"><span>    while r2 &gt;0 {</span></span>
<span class="giallo-l"><span>        r2=r1.rem_euclid(r0);</span></span>
<span class="giallo-l"><span>        r1=r0;</span></span>
<span class="giallo-l"><span>        r0=r2;</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>    r1</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>We take two numbers $a$ and $b$ and we output their greatest common divisor. If $a$ is smaller than $b$ we initialize the dividend as $b$ and the divisor as $a$ (this makes us chop the larger number by the smaller one); otherwise we invert the selection. Next, we begin by reducing $r_1$ by $r_0$ and we change the roles (since $r_2$ is smaller then $r_0$). A numerical example helps illustrate the points:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. Take a=12, b=8 (we can immediately see that the right answer is 4, but this helps us see how the algorithm finds it).</span></span>
<span class="giallo-l"><span>    2. $r_0=8$, $r_1=12$, $r_2=1$ so we immediately enter the while loop.</span></span>
<span class="giallo-l"><span>    3. $r_2=4$ since the remainder of $12$ divided by $8$ is 4.</span></span>
<span class="giallo-l"><span>    4. $r_1=8$ and $r_0=4$.</span></span>
<span class="giallo-l"><span>    5. Since $r_2$ is not zero, we keep it inside the loop.</span></span>
<span class="giallo-l"><span>    6. $r_2=0$ (since $8$ is divisible by $4$), $r_1=4$ and $r_0=0$.</span></span>
<span class="giallo-l"><span>    7. Now $r_2=0$ so we exit the loop and the function outputs $gcd=4$.</span></span></code></pre>
<p>Carmichael’s totient function can be easily calculated with the help from the previous function:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub fn lambda(p: u128,q: u128) -&gt; u128 {</span></span>
<span class="giallo-l"><span>    let greatest_div: u128=gcd(p-1,q-1);</span></span>
<span class="giallo-l"><span>    (p-1)*(q-1)/greatest_div</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>Inverses can be easily calculated with help from the extended Euclidean algorithm:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub fn inversion(a:i128,b:i128) -&gt; i128 {</span></span>
<span class="giallo-l"><span>    let mut t=0i128;</span></span>
<span class="giallo-l"><span>    let mut r=b;</span></span>
<span class="giallo-l"><span>    let mut t1=1i128;</span></span>
<span class="giallo-l"><span>    let mut r1=a;</span></span>
<span class="giallo-l"><span>    while r1 != 0i128 {</span></span>
<span class="giallo-l"><span>        let q=r.div_euclid(r1);</span></span>
<span class="giallo-l"><span>        (t,t1)=(t1,t-q*t1);</span></span>
<span class="giallo-l"><span>        (r,r1)=(r1,r-q*r1);</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>    if r != 1i128 {</span></span>
<span class="giallo-l"><span>        return 0i128;</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>    if t&lt;0{</span></span>
<span class="giallo-l"><span>        t=t+b;</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>    t</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>Let’s see how it works for a simple case: $a=3$, $b=5$; the inverse of $3$ (modulo 5) is $2$. The algorithm begins:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. $t=0$, $t_1=1$, $r=5$, $r_1=3$.</span></span>
<span class="giallo-l"><span>    2. Since $r_1=3 \neq 0$ we loop: $q=1$, $t=1$, $t_1=0-1\times 1=-1$, $r=3$, $r_1=2$.</span></span>
<span class="giallo-l"><span>    3. $r_1 \neq 0$, $q=1$, $t=-1$, $t_1=1-1\times (-1)=2$, $r=2$, $r_1=1$.</span></span>
<span class="giallo-l"><span>    4. $r_1 \neq 0$, $q=2$, $t=2$, $t_1=-1-2\times 2=-5$, $r=1$ and $r_1=0$.</span></span>
<span class="giallo-l"><span>    5. $r_1 = 0$, so the function outputs $t=2$, which is the correct answer.</span></span></code></pre>
<p>We can test primality using the <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test">Miller-Rabin test</a>. Given an odd number $n$, we can write it as $n=2^r\times d +1$, for some $r&gt; 0$ and $d$ an odd number. If $d$ is prime, then:<br />
$a^d \equiv 1 \pmod{n}$<br />
$a{2r \times d}\equiv -1 \pmod{n}$<br />
If $n$ is prime, then it satisfies Fermat’s little theorem and the only square roots of $1$ are $-1$ and $1$. If any of these conditions is not fulfilled, $n$ is not prime (if it passes, it could be composite, depending on the choice of $a$, known as the witness). Checking several $a$ allows us to make sure that the test passed for a composite number. The decomposition is easy to do:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub fn decompose(n: u128) -&gt; (u128,u128) {</span></span>
<span class="giallo-l"><span>        let mut d: u128=n-1;</span></span>
<span class="giallo-l"><span>        let mut r: u128=0;</span></span>
<span class="giallo-l"><span>        while d%2 == 0 {</span></span>
<span class="giallo-l"><span>            d /= 2;</span></span>
<span class="giallo-l"><span>            r += 1;</span></span>
<span class="giallo-l"><span>        }</span></span>
<span class="giallo-l"><span>        (d,r)</span></span>
<span class="giallo-l"><span>    }</span></span></code></pre>
<p>Since $n-1$ is even, we can take factors of $2$ repeatedly, until $d$ is no longer divisible by $2$. The condition can be checked faster by looking at the last bit of $n-1$.</p>
<p>The core of the Miller-Rabin test is (it yields true if it is probably prime):</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>fn miller_rabin(a: u128, n: u128, d: u128, r: u128) -&gt; bool {</span></span>
<span class="giallo-l"><span>        let n_minus_one: u128 = n - 1u128;</span></span>
<span class="giallo-l"><span>        let field=FieldPoint::new(a,n);</span></span>
<span class="giallo-l"><span>        let mut x = field.power(d);</span></span>
<span class="giallo-l"><span>        let mut count: u128 =1;</span></span>
<span class="giallo-l"><span>        if x.num == 1 || x.num == n_minus_one {</span></span>
<span class="giallo-l"><span>            return true;</span></span>
<span class="giallo-l"><span>        }</span></span>
<span class="giallo-l"><span>        while count &lt; r {</span></span>
<span class="giallo-l"><span>            x = x.power(2u128);</span></span>
<span class="giallo-l"><span>            if x.num == n_minus_one {</span></span>
<span class="giallo-l"><span>                return true;</span></span>
<span class="giallo-l"><span>            }</span></span>
<span class="giallo-l"><span>            count += 1u128;</span></span>
<span class="giallo-l"><span>        }</span></span>
<span class="giallo-l"><span>        false</span></span>
<span class="giallo-l"><span>    }</span></span></code></pre>
<p>If you have a composite number and try several witnesses, it is very likely it will fail at least one (and stop at the first one) and so we can discard the number.</p>
<h2 id="summary">Summary</h2>
<p>We covered the basics of RSA and discussed its mathematical foundations. We also gave some of the attacks it may subjected to, especially when the implementation is not done properly. Finally, we gave some of the basic functions to build RSA (such as modular powers, calculating inverses and checking for primality via the Rabin-Miller test). Even if you could build your own RSA from scratch, it is not advisable, since it could be vulnerable to several attacks (unless it is very well implemented, of course).</p>
<h2 id="notes">Notes</h2>
<p>(1) Even if you can code it very fast, there is no guarantee that your implementation is useful for real-life. There are several things to check and one should try to follow the standards. Besides, you should know cryptography and understand some of the underlying math).<br />
(2) For security reasons, $p$ and $q$ should have different number of digits (unless you want your system to be vulnerable to <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Fermat%27s_factorization_method">Fermat’s factorization</a>) and the selection should be truly random (careful with pseudorandom generators which are not meant for cryptographic applications, they are part of the recipe for disaster).<br />
(3) If you want something better, compute <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Carmichael_function">Carmichael’s totient function</a> $\lambda (n)=lcm(q-1,p-1)$, where $lcm$ stands for least common multiple of $q-1$ and $p-1$. Whenever $\phi$ shows up, you can replace it with $\lambda$.<br />
(4) This is the same as saying that $d\times e-1$ is divisible by $\phi(n)$ or $d\times e=k\phi(n)+1$ for some integer $k$. <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Euler%27s_theorem">Euler’s theorem</a> states that $a^{\phi(m)}\equiv 1 \pmod{m}$ if $a$ and $n$ are coprime.<br />
If we take $m=\phi(n)$ and $a=e$ we see that $e\times e^{\phi(\phi(n))-1}\equiv 1 \pmod{\phi(n)}$, $d=e^{\phi(\phi(n))-1}$, which means that $d$ can be calculated by performing powers of $e$.</p>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
