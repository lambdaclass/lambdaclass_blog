<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A walkthrough on the open source Aleo VM implemented with Arkworks and blockchain implemented with Tendermint - LambdaClass Blog</title>
    <meta name="description" content="Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">A walkthrough on the open source Aleo VM implemented with Arkworks and blockchain implemented with Tendermint</h1>
        
        <div class="page-meta">
            <time datetime="2023-02-03">February 03, 2023</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <h2 id="introduction">Introduction</h2>
<p>For the last 12 weeks, at LambdaClass, we have been developing an alternative implementation of the Aleo Blockchain. We want to thank Alex Pruden and Howard Wu from Aleo for their support throughout the process.</p>
<p>At a high level, the project consists of a Consensus Layer using Tendermint and a Zero-Knowledge Virtual Machine targeting Aleo instructions implemented with the arkworks framework.</p>
<p>You can check out the code:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * [Tendermint Blockchain implementation](https://github.com/lambdaclass/aleo_lambda_blockchain)</span></span>
<span class="giallo-l"><span>    * [Virtual Machine implemented with Arkworks](https://github.com/lambdaclass/aleo_lambda_vm)</span></span></code></pre>
<p>The key features of this blockchain revolve around the fact that it is designed to be a fully-private platform for users to develop applications that can then be built and executed off-chain, generating a proof of execution which is then sent to the blockchain nodes for verification and storage.</p>
<hr />
<p>If you’re in need of a team of engineers and researchers who’ve been working together for a decade in areas like distributed systems, machine learning, compilers, and cryptography, we’re your guys. Wanna chat more about it? Book a meeting with us by sending us an <a rel="noopener external" target="_blank" href="https://calendly.com/federicocarrone">email</a></p>
<hr />
<h2 id="consensus-layer">Consensus Layer</h2>
<p>The consensus layer is in charge of validating incoming transactions which perform state changes and replicating these transactions (and the order in which they were performed) on an arbitrary number of nodes.</p>
<p>To achieve this, we decided to utilize <a rel="noopener external" target="_blank" href="https://github.com/tendermint/tendermint">Tendermint Core</a>, an implementation of a consensus mechanism written in Go. Alongside the Tendermint Core binaries, you need to run your implementation of an <em>Application Blockchain Interface</em> (or <em>ABCI</em> for short). This ABCI needs to implement specific hooks that Tendermint Core calls through a socket whenever required. For example, when receiving a transaction, it will call <code>CheckTx</code>, which is supposed to validate the transaction before entering it into the mempool and relaying it to other nodes. This flexible approach allows for the ABCI to be written in any language as long as it responds to the calls appropriately. We decided to write our implementation in Rust.</p>
<p>You can see the code for this implementation <a rel="noopener external" target="_blank" href="https://github.com/AleoHQ/aleo_lambda_blockchain">here</a>. The repository also contains a CLI application to compile, deploy and execute programs and send these transactions to the blockchain easily. It also has several other features related to accounts, such as retrieving a user’s balance or seeing which <em>records</em> the account possesses. We will explain the motivation behind records in the integration section of this post, but they are essentially a way to encapsulate state and ownership functionality in the blockchain.</p>
<h3 id="design-considerations">Design considerations</h3>
<p><img src="/images/external/architecture.png?raw=true" alt="" /></p>
<p>Considering the VM implementation and the requirements from the blockchain, we had to make several design decisions on the consensus layer. Here’s a general overview of how Tendermint Core was implemented:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * The Tendermint Core and the ABCI need to run side by side in the same node and are coupled by the interface defined by the protocol&#39;s hooks.</span></span>
<span class="giallo-l"><span>    * All code executed on the ABCI needs to be deterministic and isolated from external services since we want to ensure all transactions perform deterministic state changes on every node in the network.</span></span>
<span class="giallo-l"><span>    * The ABCI implements two databases to maintain the current state of the blockchain: The program store and the record store. </span></span>
<span class="giallo-l"><span>      * The program store keeps track of every deployed program&#39;s verifying keys and uses. The store contains the `credits` program&#39;s keys as a built-in default. This program defines credit records. It is essentially a native Aleo program that has functions for managing credit records.</span></span>
<span class="giallo-l"><span>      * The record store encapsulates functionality related to validating whether the records utilized in incoming transactions have already been spent. </span></span>
<span class="giallo-l"><span>        * The privacy requirements imply that we cannot disclose what records have been spent and which have not. Due to this, any record in the blockchain (i.e., it was output from the execution of a program) is stored separately from records that have been spent, of which we only store serial numbers.</span></span>
<span class="giallo-l"><span>    * The genesis block needs to be provided to Tendermint on startup and is done through a JSON file. We have written a particular binary to generate it for any number of nodes and give each of them a fixed amount of starting credits.</span></span>
<span class="giallo-l"><span>    * To make testing simple, we have created several `make` targets to initialize and start multiple validators that can run locally or on a remote network.</span></span>
<span class="giallo-l"><span>    * Both the CLI and the consensus layer support Aleo&#39;s SnarkVM and our own LambdaVM and are currently interchangeable through a compiler flag</span></span></code></pre><h3 id="staking">Staking</h3>
<p>Tendermint supports adding new nodes to the network. In general, nodes in the network can work in two different modes:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * Non-validator: The node catches up with the blockchain by performing every transaction but does not have voting power to validate and commit blocks.</span></span>
<span class="giallo-l"><span>    * Validator: The node is part of the network and can vote and sign blocks.</span></span></code></pre>
<p>To add a non-validator, the node needs to have the same Genesis block and point to persistent peers (IP addresses acting as fixed nodes in the network). To transform a node into a validator, the ABCI needs to implement functionality to update the voting power of a Tendermint node.</p>
<p>For this, we implemented a <code>stake</code> command to “freeze” credits by exchanging them for staking records (and increase the voting power of a validator), which you can, in turn, <code>unstake</code> whenever you desire (decreasing the voting power accordingly).</p>
<p>When a node is a validator, it gets rewards on each block commit where it was involved.</p>
<h2 id="virtual-machine">Virtual Machine</h2>
<p>At a high level, our VM provides an API to take an Aleo program that looks like this:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>program main.aleo;</span></span>
<span class="giallo-l"><span>        </span></span>
<span class="giallo-l"><span>function add:</span></span>
<span class="giallo-l"><span>    input r0 as u16.public;</span></span>
<span class="giallo-l"><span>    input r1 as u16.private;</span></span>
<span class="giallo-l"><span>    add r0 r1 into r2;</span></span>
<span class="giallo-l"><span>    output r2 as u16.public;</span></span></code></pre>
<p>And generate a pair of proving and verifying keys for it (this is usually called <em>building</em> or <em>synthesizing</em> the program), allowing anyone to execute the program and provide proof of it or verify said proof. The consensus layer uses this to deploy programs (i.e., upload their verifying key along with the code), execute them, and verify them.</p>
<p>Internally, this VM uses <a rel="noopener external" target="_blank" href="https://github.com/arkworks-rs">Arkworks</a> as a backend. Programs are turned into a Rank One Constraint System (<code>R1CS</code>), which is then passed on to the <a rel="noopener external" target="_blank" href="https://github.com/arkworks-rs/marlin">Marlin</a> prover for execution. As we started using Arkworks, we noticed some aspects of the API and its genericity were becoming a burden for developers, so we created a thin wrapper around it called <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/simpleworks">Simpleworks</a>, along with <a rel="noopener external" target="_blank" href="https://lambdaclass.github.io/simpleworks/overview.html">some basic documentation</a>.</p>
<h3 id="example">Example</h3>
<p>Given the following Aleo program</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>program foo.aleo;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>function main:</span></span>
<span class="giallo-l"><span>    input r0 as u64.public;</span></span>
<span class="giallo-l"><span>    input r1 as u64.public;</span></span>
<span class="giallo-l"><span>    add r0 r1 into r2;</span></span>
<span class="giallo-l"><span>    output r2 as u64.public;</span></span></code></pre>
<p>Executing the function <code>main</code> would look like this:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>use lambdavm::jaleo::UserInputValueType::U16;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>fn main() {</span></span>
<span class="giallo-l"><span>    use lambdavm::{build_program, execute_function};</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // Parse the program</span></span>
<span class="giallo-l"><span>    let program_string = std::fs::read_to_string(&quot;./programs/add/main.aleo&quot;).unwrap();</span></span>
<span class="giallo-l"><span>    let (program, build) = build_program(&amp;program_string).unwrap();</span></span>
<span class="giallo-l"><span>    let function = String::from(&quot;main&quot;);</span></span>
<span class="giallo-l"><span>    // Declare the inputs (it is the same for public or private)</span></span>
<span class="giallo-l"><span>    let user_inputs = vec![U16(1), U16(1)];</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // Execute the function</span></span>
<span class="giallo-l"><span>    let (_execution_trace, proof) = execute_function(&amp;program, &amp;function, &amp;user_inputs).unwrap();</span></span>
<span class="giallo-l"><span>    let (_proving_key, verifying_key) = build.get(&amp;function).unwrap();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    assert!(lambdavm::verify_proof(verifying_key.clone(), &amp;user_inputs, &amp;proof).unwrap())</span></span>
<span class="giallo-l"><span>}</span></span></code></pre><h3 id="internals">Internals</h3>
<p>The most significant task our VM has to perform is turning the program into an arithmetic circuit, as the rest of the work, namely generating the proof and verifying it, is pretty straightforward with the Arkworks API.</p>
<p>Before continuing, you should have at least a basic understanding of arithmetic circuits and how Arkworks lets you work with them. You can read about it <a rel="noopener external" target="_blank" href="https://lambdaclass.github.io/simpleworks/overview.html">here</a>.</p>
<p>To generate the circuit, we go through the following steps:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * Take the program&#39;s source code and parse it into a `Program` containing all the relevant information about it (a list of all input and output instructions, whether they are public or private, a list of all regular instructions like add and its operands, etc.). We currently rely on SnarkVM&#39;s parser but plan to write our own.</span></span>
<span class="giallo-l"><span>    * Instantiate an Arkworks `ConstraintSystem`, which will hold all our circuit&#39;s constraints by the end.</span></span>
<span class="giallo-l"><span>    * For every input instruction, instantiate its corresponding `Gadget`. You can think of a gadget as the equivalent of a native type (like `u8`) inside an arithmetic circuit. If the input is public, the gadget is made public; otherwise, it&#39;s made a `witness`, i.e., private. In our example, the first instruction `input r0 as u16.public` becomes a call to `UInt16Gadget.new_input(...)` and the second instruction becomes `UInt16Gadget.new_witness(...)`.</span></span>
<span class="giallo-l"><span>    * For every regular instruction, we use the gadget&#39;s associated function to perform the operation and generate its constraints inside our `ConstraintSystem`. In our example, when we encounter the `add r0 r1 into r2;` instruction, we call `UInt16Gadget.addmany(...)`. This is an arkworks provided function that will take a list of `UInt16&#39;s, add them, implicitly mutate the `ConstraintSystem` with all the associated constraints, then return the value of the sum. Not all instructions have a corresponding arkworks function implemented, so for those, we had to roll our own.</span></span>
<span class="giallo-l"><span>    * For every output instruction, assign to the register the computed value.</span></span></code></pre>
<p>Because a program can have multiple registers interacting with each other, to do the above, we have to keep track of each register and its value as we go. For this, we keep an internal hash table throughout execution.</p>
<p>Additionally, we ran some benchmarks comparing our VM with Aleo’s <code>SnarkVM</code>, and our results show we are a few times faster than it; details will be published in a separate post. The code for benchmarks is in <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/aleo_lambda_vm">our VM Repo</a>.</p>
<h2 id="vm-consensus-integration-layer">VM-Consensus Integration Layer</h2>
<p>Above, we discussed how the VM allows running arbitrary Aleo programs that can be deployed, executed locally, and then verified on the Aleo blockchain. Each Aleo transaction is either the deployment or the proof of execution of a program (this is technically inaccurate, as there can be multiple of these per transaction, but we’ll ignore that for simplicity). In the case of executions, nodes use the program’s verifying key to verify the correct execution before committing transactions to a block.</p>
<p>After we got a basic VM version working, we realized that getting a fully functional Aleo blockchain required more work than just the above. Transactions would be of very little use if they proved that some computation was done correctly. To be useful, they also need to <em>modify the state</em>. In Aleo, the state is managed through <em>records</em> in what is essentially a <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Unspent_transaction_output">UTXO</a> model similar to Bitcoin. Typically, when a user sends a transaction, they will spend some records they own to create new ones in their place.</p>
<p>Because Aleo is entirely private, a transaction can’t just publish the records it wants to spend along with a signature; it has to <em>prove</em> ownership and existence of records in zero knowledge, then <em>encrypt</em> the records so only its owner can decrypt on-chain.</p>
<p>This means that, to integrate with the consensus layer and get a fully functional blockchain, we need a bit more. The VM can prove the correct execution of programs, but the Zero-Knowledge proof that comes with a transaction also needs to include the following:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * A signature in Zero-Knowledge, proof that the signature provided is the correct one. Remember, we can&#39;t just show the user&#39;s address sending the transaction.</span></span>
<span class="giallo-l"><span>    * A proof that the caller of the transaction actually _owns_ the record they&#39;re spending.</span></span>
<span class="giallo-l"><span>    * A proof that the records being spent are on-chain. This is essentially verifying a Merkle path in Zero-Knowledge.</span></span>
<span class="giallo-l"><span>    * A proof that the input records have not been spent. This is a bit involved as it requires deriving a record&#39;s `serial number` (think of it as the `nullifier` if you know ZCash) in Zero-Knowledge.</span></span></code></pre>
<p>We also talked about how records should be stored encrypted on-chain so that only someone possessing the record owner’s view key can decrypt them (in Aleo, the <code>view key</code> is just another key tied to an account that allows record decryption).</p>
<p>There’s a catch here, though. When, for instance, user A wants to send money to user B, they have to create a record owned by B and encrypt it so that only B can decrypt it. But <code>A</code> does not necessarily have <code>B</code>’s view key, only their address. This means the encryption scheme used by Aleo cannot be symmetric, as that would require user <code>A</code> to have <code>B</code>’s view key to send them money, not just their address.</p>
<p>To accomplish this, records are encrypted using a scheme called <code>ECIES</code> (Elliptic Curve Integrated Encryption Scheme). We’re not going to go into detail about how it works, but it’s a combination of a Diffie-Hellman key exchange with a symmetric encryption scheme.</p>
<p>We introduced a middle layer between our VM and the Consensus Layer to solve all the problems discussed above. This middle layer handles everything related to records, their encryption, and the snarks required for the state transition proofs.</p>
<p>In the original SnarkVM implementation, this middle layer does not really exist, as it’s part of the VM itself, but we found it more beneficial to separate these two concerns.</p>
<h2 id="work-in-progress">Work in Progress</h2>
<p>This project is still in active development, and a few things are being worked on. They include:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * Support for some data types and instructions on the VM, including the `group` data type (elliptic curve elements) and things like `BHP` commitments. You can check out a complete list on [the README](https://github.com/lambdaclass/aleo_lambda_vm).</span></span>
<span class="giallo-l"><span>    * Some of the circuits mentioned above prove the correctness of state transitions.</span></span>
<span class="giallo-l"><span>    * The generation of the proof that input records exist on-chain.</span></span>
<span class="giallo-l"><span>    * Due to how we store record information on the blockchain and considering the privacy requirements of the blockchain, asking for a user balance or unspent records from the CLI is currently not trivial: We need to ask for all records that have ever existed in addition to all serial numbers from records that have been spent and attempt to decrypt them on the user&#39;s side. Some strategies to optimize this process include keeping track of records locally and only adding newly-created ones as the blockchain grows.</span></span></code></pre>
<p>We plan to finish these tasks in the next four weeks. While many things could be improved, the project is already production ready.</p>
<p>We have many ideas and comments about improving the SnarkVM and Aleo in general, but we will leave that for another series of posts.</p>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
