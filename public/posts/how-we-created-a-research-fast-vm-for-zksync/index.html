<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>How we created a research fast VM for ZKsync - LambdaClass Blog</title>
    <meta name="description" content="Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">How we created a research fast VM for ZKsync</h1>
        
        <div class="page-meta">
            <time datetime="2024-08-05">August 05, 2024</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <p>For the past few weeks we have been working on a reimplementation of ZKsync’s (out of circuit) EraVM. The goal is to improve on its current performance and explore the possibility of adding parallel execution through BlockSTM. For that, we first had to make a deep dive into how the EraVM works and how it differs from the EVM.</p>
<p>We want to thank Anthony Rose and the Matter Labs team for all their help on this project, especially their <a rel="noopener external" target="_blank" href="https://github.com/matter-labs/vm2">new fastVM implementation</a> which we used a lot as a reference.</p>
<p>You can follow our progress on <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/era_vm">our EraVM repository</a>.</p>
<h2 id="development-process">Development Process</h2>
<p>It’s important to state our methodology: even though the main goal here is improving performance, our goal starting out is different: we want a simple implementation working.</p>
<p>We do not care about benchmarks <strong>at first</strong>. We know our initial implementation will be slow, but that’s not the point: the point is to get something simple working to understand all the moving parts. Only after that’s in place we shift our focus to benchmarks and performance.</p>
<p>When we started out we knew very little about the EraVM. We knew it was different from the EVM, and had indirectly used <code>zksolc</code> to compile and deploy contracts to the network, but had not looked much into the underlyings of it.</p>
<p>The first thing we did to get into a working flow was to inspect the VM’s bytecode. We compiled simple contracts into EraVM assembly and started getting familiar with it. The goal when starting out on an unfamiliar VM is to setup a simple <code>fetch-&gt;decode-&gt;execute</code> loop that looks something like this:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>fn run(</span></span>
<span class="giallo-l"><span>    vm: VM,</span></span>
<span class="giallo-l"><span>) {</span></span>
<span class="giallo-l"><span>    loop {</span></span>
<span class="giallo-l"><span>        let opcode = vm.get_opcode(&amp;opcode_table)?;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        match opcode {</span></span>
<span class="giallo-l"><span>                Opcode::Add =&gt; todo!(),</span></span>
<span class="giallo-l"><span>                Opcode::Sub =&gt; todo!(),</span></span>
<span class="giallo-l"><span>                Opcode::Jump =&gt; todo!(),</span></span>
<span class="giallo-l"><span>                Opcode::Mul =&gt; todo!(),</span></span>
<span class="giallo-l"><span>                Opcode::Div =&gt; todo!(),</span></span>
<span class="giallo-l"><span>                ... =&gt; ...</span></span>
<span class="giallo-l"><span>        }</span></span>
<span class="giallo-l"><span>        vm.pc += 1;</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>    ...</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>and then progressively implement all the opcodes. When we started looking at the assembly generated on contracts we realized the EraVM was a lot more complex than the EVM in terms of opcodes; fortunately, Matter Labs has a <a rel="noopener external" target="_blank" href="https://github.com/matter-labs/zksync-era/blob/main/docs/specs/zk_evm/vm_specification/zkSync_era_virtual_machine_primer.md">very good primer on them</a> and a <a rel="noopener external" target="_blank" href="https://matter-labs.github.io/eravm-spec/spec.html">full formal specification</a>.</p>
<p>After reading those and reading their own implementations, we stumbled into their own repo <a rel="noopener external" target="_blank" href="https://github.com/matter-labs/era-zkevm_opcode_defs">defining all the VM opcodes</a>, and from there we could setup a proper loop like the above.</p>
<p>With it, we started writing our own simple EraVM assembly programs testing all the different opcodes as we implemented them. Eventually, after getting the basic functionality in place, these simple assembly programs we wrote started becoming insufficient to test complex interactions like contracts calling other contracts, gas management, etc; we needed a proper test suite.</p>
<p>That proper test suite is the <a rel="noopener external" target="_blank" href="https://github.com/matter-labs/era-compiler-tester">era-compiler-tester</a>, a full test suite for the VM written by Matter Labs (technically this is also a test suite for the <code>zksolc</code> compiler itself, but we care about VM testing here). To get a fully working VM, we realized we needed to make these tests pass.</p>
<p>Before going into detail about them, let’s do a quick overview of the VM we set to reimplement.</p>
<h2 id="eravm-overview">EraVM Overview</h2>
<p>ZKsync is a zk-Rollup meant to be EVM compatible. In practice, this can mean a number of different things. For ZKsync, it means that it’s compatible at the programming language level; this is done through <code>zksolc</code>, an LLVM based compiler written by Matter Labs that takes any Solidity, Yul or Vyper contract and compiles it down to the EraVM bytecode.</p>
<p>This might seem like full compatibility, but it’s not. The EraVM has a completely different architecture than the EVM, and some of these differences cannot be fully abstracted away.</p>
<p>As an example, the following Solidity contract:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>contract Test {</span></span>
<span class="giallo-l"><span>    function main(uint256 a, uint256 b) external pure returns(uint256 result) {</span></span>
<span class="giallo-l"><span>        result = a + b;</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>compiles to an EVM assembly that looks like this:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>PUSH1 0x80</span></span>
<span class="giallo-l"><span>PUSH1 0x40</span></span>
<span class="giallo-l"><span>MSTORE</span></span>
<span class="giallo-l"><span>CALLVALUE</span></span>
<span class="giallo-l"><span>DUP1</span></span>
<span class="giallo-l"><span>ISZERO</span></span>
<span class="giallo-l"><span>PUSH1 0xE</span></span>
<span class="giallo-l"><span>JUMPI</span></span>
<span class="giallo-l"><span>...</span></span></code></pre>
<p>and an EraVM assembly that looks like this:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>add	 128, r0, r3</span></span>
<span class="giallo-l"><span>st.1	 64, r3</span></span>
<span class="giallo-l"><span>and!	1, r2, r0</span></span>
<span class="giallo-l"><span>jump.ne	@.BB0_1</span></span>
<span class="giallo-l"><span>add	 r1, r0, r2</span></span>
<span class="giallo-l"><span>shr.s	96, r2, r2</span></span>
<span class="giallo-l"><span>and	 @CPI0_0[0], r2, r2</span></span>
<span class="giallo-l"><span>sub.s!	4, r2, r0</span></span>
<span class="giallo-l"><span>jump.lt	@.BB0_2</span></span>
<span class="giallo-l"><span>ld	r1, r3</span></span>
<span class="giallo-l"><span>...</span></span></code></pre>
<p>Clearly these are very different VMs. This requires getting used to these two different architectures when working at the VM level on ZKsync. A lot of operations that are opcodes on the <code>EVM</code> are not on the <code>EraVM</code>.</p>
<p>For instance, the EVM has a <code>returndatacopy</code> opcode, which copies the output data from a previous contract call into memory. On the <code>EraVM</code> there is no such thing; a call to <code>returndatacopy</code> on a Yul contract will compile to a block of code that looks like this:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>.BB0_19:</span></span>
<span class="giallo-l"><span>  ld.inc	r5, r7, r5</span></span>
<span class="giallo-l"><span>  st.1.inc	r6, r7, r6</span></span>
<span class="giallo-l"><span>  sub!	r6, r4, r0</span></span>
<span class="giallo-l"><span>  jump.ne	@.BB0_19</span></span></code></pre>
<p>We omitted some context, but this is essentially just a loop that will continously load (<code>ld</code>) a word from the called contract’s memory and then store it (<code>st</code>) on the caller contract’s memory, then conditionally jump back (<code>jump.ne</code>) to the loop if the copying is not done yet (i.e. if the <code>sub!</code> instruction does not yield zero).</p>
<p>This is just one example: most complex EVM opcodes work in in a similar fashion on the EraVM.</p>
<h2 id="era-compiler-test-suite">Era Compiler Test suite</h2>
<p>There are millions of tests on the <code>era-compiler-tester</code> repo, but they all follow the same structure. Each test is a Solidity, Yul or Vyper contract that is compiled with <code>zksolc</code> and run with certain inputs, in turn expecting certain outputs. As an example, the <a rel="noopener external" target="_blank" href="https://github.com/matter-labs/era-compiler-tests/blob/fe7d0e86d06130ee266f82b04a549918da615521/solidity/simple/default.sol">default.sol</a> test looks like this:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>//! { &quot;cases&quot;: [ {</span></span>
<span class="giallo-l"><span>//!     &quot;name&quot;: &quot;first&quot;,</span></span>
<span class="giallo-l"><span>//!     &quot;inputs&quot;: [</span></span>
<span class="giallo-l"><span>//!         {</span></span>
<span class="giallo-l"><span>//!             &quot;method&quot;: &quot;first&quot;,</span></span>
<span class="giallo-l"><span>//!             &quot;calldata&quot;: [</span></span>
<span class="giallo-l"><span>//!             ]</span></span>
<span class="giallo-l"><span>//!         }</span></span>
<span class="giallo-l"><span>//!     ],</span></span>
<span class="giallo-l"><span>//!     &quot;expected&quot;: [</span></span>
<span class="giallo-l"><span>//!         &quot;42&quot;</span></span>
<span class="giallo-l"><span>//!     ]</span></span>
<span class="giallo-l"><span>//! }, {</span></span>
<span class="giallo-l"><span>//!     &quot;name&quot;: &quot;second&quot;,</span></span>
<span class="giallo-l"><span>//!     &quot;inputs&quot;: [</span></span>
<span class="giallo-l"><span>//!         {</span></span>
<span class="giallo-l"><span>//!             &quot;method&quot;: &quot;second&quot;,</span></span>
<span class="giallo-l"><span>//!             &quot;calldata&quot;: [</span></span>
<span class="giallo-l"><span>//!             ]</span></span>
<span class="giallo-l"><span>//!         }</span></span>
<span class="giallo-l"><span>//!     ],</span></span>
<span class="giallo-l"><span>//!     &quot;expected&quot;: [</span></span>
<span class="giallo-l"><span>//!         &quot;99&quot;</span></span>
<span class="giallo-l"><span>//!     ]</span></span>
<span class="giallo-l"><span>//! } ] }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>// SPDX-License-Identifier: MIT</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>pragma solidity &gt;=0.4.16;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>contract Test {</span></span>
<span class="giallo-l"><span>    function first() public pure returns(uint64) {</span></span>
<span class="giallo-l"><span>        uint64 result = 42;</span></span>
<span class="giallo-l"><span>        return result;</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    function second() public pure returns(uint256) {</span></span>
<span class="giallo-l"><span>        uint256 result = 99;</span></span>
<span class="giallo-l"><span>        return result;</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>The comment above it specifies what the test should run and what it expects. In this case, there are two tests, which should run the methods <code>first</code> and <code>second</code> and then get <code>42</code> and <code>99</code> as a result respectively. Most tests have a lot of comments specifying different runs, testing different functions with different inputs/outputs and so on.</p>
<h2 id="deep-dive-into-a-zksync-era-contract">Deep dive into a ZKsync Era contract</h2>
<p>Let’s compile the <code>default.sol</code> program above and see what it’s doing under the hood. Running</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>zksolc default.sol --asm -o default --optimization 3 --overwrite</span></span></code></pre>
<p>will place a <code>default.zasm</code> file under the <code>default</code> directory. This is the EraVM assembly for the contract:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>	.text</span></span>
<span class="giallo-l"><span>	.file	&quot;default.sol:Test&quot;</span></span>
<span class="giallo-l"><span>	.globl	__entry</span></span>
<span class="giallo-l"><span>__entry:</span></span>
<span class="giallo-l"><span>.func_begin0:</span></span>
<span class="giallo-l"><span>	add	128, r0, r3</span></span>
<span class="giallo-l"><span>	st.1	64, r3</span></span>
<span class="giallo-l"><span>	and!	1, r2, r0</span></span>
<span class="giallo-l"><span>	jump.ne	@.BB0_1</span></span>
<span class="giallo-l"><span>	add	r1, r0, r2</span></span>
<span class="giallo-l"><span>	and!	@CPI0_1[0], r2, r0</span></span>
<span class="giallo-l"><span>	jump.eq	@.BB0_2</span></span>
<span class="giallo-l"><span>	ld	r1, r1</span></span>
<span class="giallo-l"><span>	shr.s	224, r1, r1</span></span>
<span class="giallo-l"><span>	sub.s!	@CPI0_2[0], r1, r0</span></span>
<span class="giallo-l"><span>	jump.eq	@.BB0_10</span></span>
<span class="giallo-l"><span>	sub.s!	@CPI0_3[0], r1, r0</span></span>
<span class="giallo-l"><span>	jump.ne	@.BB0_2</span></span>
<span class="giallo-l"><span>	context.get_context_u128	r1</span></span>
<span class="giallo-l"><span>	sub!	r1, r0, r0</span></span>
<span class="giallo-l"><span>	jump.ne	@.BB0_2</span></span>
<span class="giallo-l"><span>	add	42, r0, r1</span></span>
<span class="giallo-l"><span>	st.1	128, r1</span></span>
<span class="giallo-l"><span>	add	@CPI0_4[0], r0, r1</span></span>
<span class="giallo-l"><span>	ret.ok.to_label	r1, @DEFAULT_FAR_RETURN</span></span>
<span class="giallo-l"><span>.BB0_1:</span></span>
<span class="giallo-l"><span>	context.get_context_u128	r1</span></span>
<span class="giallo-l"><span>	sub!	r1, r0, r0</span></span>
<span class="giallo-l"><span>	jump.ne	@.BB0_2</span></span>
<span class="giallo-l"><span>	add	32, r0, r1</span></span>
<span class="giallo-l"><span>	st.2	256, r1</span></span>
<span class="giallo-l"><span>	st.2	288, r0</span></span>
<span class="giallo-l"><span>	add	@CPI0_0[0], r0, r1</span></span>
<span class="giallo-l"><span>	ret.ok.to_label	r1, @DEFAULT_FAR_RETURN</span></span>
<span class="giallo-l"><span>.BB0_10:</span></span>
<span class="giallo-l"><span>	context.get_context_u128	r1</span></span>
<span class="giallo-l"><span>	sub!	r1, r0, r0</span></span>
<span class="giallo-l"><span>	jump.ne	@.BB0_2</span></span>
<span class="giallo-l"><span>	add	99, r0, r1</span></span>
<span class="giallo-l"><span>	st.1	128, r1</span></span>
<span class="giallo-l"><span>	add	@CPI0_4[0], r0, r1</span></span>
<span class="giallo-l"><span>	ret.ok.to_label	r1, @DEFAULT_FAR_RETURN</span></span>
<span class="giallo-l"><span>.BB0_2:</span></span>
<span class="giallo-l"><span>	add	r0, r0, r1</span></span>
<span class="giallo-l"><span>	ret.revert.to_label	r1, @DEFAULT_FAR_REVERT</span></span>
<span class="giallo-l"><span>.func_end0:</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>	.note.GNU-stack</span></span>
<span class="giallo-l"><span>	.rodata</span></span>
<span class="giallo-l"><span>CPI0_0:</span></span>
<span class="giallo-l"><span>	.cell	53919893334301279589334030174039261352344891250716429051063678533632</span></span>
<span class="giallo-l"><span>CPI0_1:</span></span>
<span class="giallo-l"><span>	.cell	340282366604025813406317257057592410112</span></span>
<span class="giallo-l"><span>CPI0_2:</span></span>
<span class="giallo-l"><span>	.cell	1519042605</span></span>
<span class="giallo-l"><span>CPI0_3:</span></span>
<span class="giallo-l"><span>	.cell	1039457780</span></span>
<span class="giallo-l"><span>CPI0_4:</span></span>
<span class="giallo-l"><span>	.cell	2535301202817642044428229017600</span></span></code></pre>
<p>A few things you need to know about the EraVM before diving in:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * The native word is a `U256` (256 bit unsigned integer).</span></span>
<span class="giallo-l"><span>    * There are 16 registers, `r0` through `r15`.</span></span>
<span class="giallo-l"><span>      * `r0` is the zero register: writing to it does nothing, reading from it yields zero.</span></span>
<span class="giallo-l"><span>      * `r1` is used as a pointer to the calldata (i.e. function arguments) when calling other contracts, and to the returndata when returning from calls.</span></span>
<span class="giallo-l"><span>      * `r2` usually stores information about whether the current call is a constructor call, a regular function call, or a system call (a call to a system contract with special privileges).</span></span>
<span class="giallo-l"><span>    * Every contract call gets its own stack and heap memory.</span></span></code></pre><h3 id="step-by-step">Step by Step</h3>
<p>Let’s do a step by step overview of this assembly.</p>
<p>When someone calls this contract, execution always begins from the <code>__entry</code> symbol. The first two instructions are doing some setup we don’t care much for, storing the value <code>128</code> onto the <code>r3</code> register:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>add	128, r0, r3</span></span>
<span class="giallo-l"><span>st.1 64, r3</span></span></code></pre>
<p>In more detail, <code>add 128, r0, r3</code> adds <code>128</code> to the value in <code>r0</code> and stores it in <code>r3</code>. Because <code>r0</code> is the zero register, this is essentially storing <code>128</code> in <code>r3</code> (this the way <code>mov</code>s to registers are always done in the EraVM).<br />
<code>st.1</code> then stores the value in <code>r3</code> to memory address <code>64</code> (if you’re wondering what the <code>1</code> is in <code>st.1</code>, it’s the type of heap to use; the EraVM has both a regular and a special <em>auxiliary</em> heap).</p>
<p>Then, there’s a check on the <code>r2</code> register and a conditional jump:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>and! 1, r2, r0</span></span>
<span class="giallo-l"><span>jump.ne	@.BB0_1</span></span></code></pre>
<p>The <code>and!</code> instruction is doing a bitwise <code>and</code> between <code>1</code> and <code>r2</code>, storing it to <code>r0</code>, then setting the zero flag accordingly. This is storing to <code>r0</code> because we don’t care about the result. We are just checking whether the <code>r2</code> register is 1 or not. If it is, then this is a constructor call, and we should jump to block <code>@.BB0_1</code>, which contains the constructor logic; if it’s not we should continue.</p>
<p>If the call is not a constructor call, the code will then do</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>add	r1, r0, r2</span></span>
<span class="giallo-l"><span>and!	@CPI0_1[0], r2, r0</span></span>
<span class="giallo-l"><span>jump.eq	@.BB0_2</span></span></code></pre>
<p>This puts the <code>calldata</code> pointer that’s in <code>r1</code> into <code>r2</code>, then does an <code>and</code> instruction and a conditional jump to make sure it’s not pointing to an invalid address. If it is, then execution jumps to block <code>@.BB0_2</code>, which contains the revert logic:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>.BB0_2:</span></span>
<span class="giallo-l"><span>  add	r0, r0, r1</span></span>
<span class="giallo-l"><span>  ret.revert.to_label	r1, @DEFAULT_FAR_REVERT</span></span></code></pre>
<p>If the address is valid, the code follows like this:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>ld	r1, r1</span></span>
<span class="giallo-l"><span>shr.s	224, r1, r1</span></span></code></pre>
<p>This is loading the first 32 bytes the calldata pointer points to through an <code>ld</code> instruction, storing it in <code>r1</code>, then shifting it <code>224</code> bits to the right to keep only its first 4 bytes (<code>256</code>- <code>224</code> = <code>32</code> bits = 4 bytes).</p>
<p>These 4 bytes are the <em>function selector</em> of this contract call. This <code>default.sol</code> contract has two functions</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>function first() public pure returns(uint64)</span></span>
<span class="giallo-l"><span>function second() public pure returns(uint256)</span></span></code></pre>
<p>The selector for the first one is <code>0x3df4ddf4</code>, while for the second one it’s <code>0x5a8ac02d</code> (you can check them yourself <a rel="noopener external" target="_blank" href="https://www.evm-function-selector.click/">here</a>). If you convert these values to decimal, you’ll see these are the values for the labels <code>CPI0_3</code> and <code>CPI0_2</code> respectively in the assembly. That’s why the code does a <code>sub.s!</code> instruction, comparing the result of this selector in <code>r1</code> against <code>CPIO_2</code></p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>sub.s!	@CPI0_2[0], r1, r0</span></span>
<span class="giallo-l"><span>jump.eq	@.BB0_10</span></span></code></pre>
<p>If the value matches, execution jumps to block <code>.BB0_10</code>, containing the logic for the <code>second</code> function that just returns <code>99</code>:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>.BB0_10:</span></span>
<span class="giallo-l"><span>  context.get_context_u128	r1</span></span>
<span class="giallo-l"><span>  sub!	r1, r0, r0</span></span>
<span class="giallo-l"><span>  jump.ne	@.BB0_2</span></span>
<span class="giallo-l"><span>  add	99, r0, r1</span></span>
<span class="giallo-l"><span>  st.1	128, r1</span></span>
<span class="giallo-l"><span>  add	@CPI0_4[0], r0, r1</span></span>
<span class="giallo-l"><span>  ret.ok.to_label	r1, @DEFAULT_FAR_RETURN</span></span></code></pre>
<p>You can see the <code>add 99, r0, r1</code> followed by <code>st.1 128, r1</code> to store the return value into memory. The code before it is just checking whether the caller passed any <code>wei</code> using the <code>context.get_context_u128 r1</code> instruction, and reverting if so (this function is not payable).</p>
<p>If the selector did not match <code>CPI0_2</code> (the selector for the <code>second()</code> function), then the code checks against the <code>first()</code> selector (label <code>CPIO_3</code>):</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>sub.s!	@CPI0_3[0], r1, r0</span></span>
<span class="giallo-l"><span>jump.ne	@.BB0_2</span></span></code></pre>
<p>In this case, because it’s the last valid function selector for the contract, if the value does not match we just go to the revert block <code>BB0_2</code>. If it does match we continue with the logic for the <code>first()</code> function, doing the same but returning <code>42</code> instead of <code>99</code>:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>context.get_context_u128	r1</span></span>
<span class="giallo-l"><span>sub!	r1, r0, r0</span></span>
<span class="giallo-l"><span>jump.ne	@.BB0_2</span></span>
<span class="giallo-l"><span>add	42, r0, r1</span></span>
<span class="giallo-l"><span>st.1	128, r1</span></span>
<span class="giallo-l"><span>add	@CPI0_4[0], r0, r1</span></span>
<span class="giallo-l"><span>ret.ok.to_label	r1, @DEFAULT_FAR_RETURN</span></span></code></pre>
<p>And that’s it, that’s the entire EraVM assembly code for this contract. To summarize, the code is organized as follows:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * The `__entry` block is the entrypoint for any call to this contract.</span></span>
<span class="giallo-l"><span>    * Block `BB0_1` contains the contract&#39;s constructor logic (the default one in this case, since we didn&#39;t write one ourselves).</span></span>
<span class="giallo-l"><span>    * Block `BB0_10` contains the code for the `second()` function.</span></span>
<span class="giallo-l"><span>    * Block `BB0_2` just has the revert logic.</span></span>
<span class="giallo-l"><span>    * When someone calls this contract the code will do, in order, the following:</span></span>
<span class="giallo-l"><span>      * Check whether this is a constructor call and jump to `BB0_10` if so.</span></span>
<span class="giallo-l"><span>      * Read from the `calldata` pointer, revert by jumping to `BB0_2` if the address it points to is invalid.</span></span>
<span class="giallo-l"><span>      * Get the first 4 bytes of calldata to obtain the function selector.</span></span>
<span class="giallo-l"><span>      * Check the provided selector against the `second()` selector stored in `CPI0_2`. Jump to block `BB0_10` if it matches.</span></span>
<span class="giallo-l"><span>      * Check whether the selector matches `first()`. Revert if it does not, run the code for `first()` otherwise.</span></span></code></pre><h2 id="current-status-and-next-steps">Current status and next steps</h2>
<p>We are working on the last stretch of fixes to make all tests pass. Once that’s done, our focus will shift entirely to benchmarking the VM and start making optimizations. In anticipation for this, we started integrating with the <a rel="noopener external" target="_blank" href="https://github.com/matter-labs/zksync-era/tree/main/core/tests/vm-benchmark">ZKsync Era benchmarks</a>. This work requires <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/zksync-era/pull/225">integrating the VM with the <code>bootloader</code></a>, the contract in ZKsync that executes blocks (essentially the network’s main execution entrypoint).</p>
<p>This bootloader integration will also allow us to get our VM plugged into a ZKsync operator and start playing around with optimistic parallel execution ideas. Actually, getting parallel execution will probably involve modifying the bootloader or getting rid of it altogether when executing on the operator, but that’s a topic for another post.</p>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
