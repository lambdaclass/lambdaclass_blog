<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lambdaworks as a drop-in replacement for Winterfell to prove the Miden-VM - LambdaClass Blog</title>
    <meta name="description" content="Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">Lambdaworks as a drop-in replacement for Winterfell to prove the Miden-VM</h1>
        
        <div class="page-meta">
            <time datetime="2023-12-27">December 27, 2023</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <h2 id="introduction">Introduction</h2>
<p><a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks">Lambdaworks</a> is our library for finite fields, elliptic curves, and proof systems. Among them, we have a <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks/tree/main/provers/stark">STARK</a>, <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks/tree/main/provers/plonk">Plonk</a>, <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks/tree/main/provers/groth16">Groth 16</a> provers and we are on the way to having a fully compatible <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks/tree/main/provers/cairo">Cairo prover using STARKs</a>. We want to continue adding new proof systems and polynomial commitment schemes so that users have a library suited to their particular needs and where experimentation is easy.</p>
<p>During the last months, we have been working towards compatibility with <a rel="noopener external" target="_blank" href="https://github.com/facebook/winterfell/tree/main">Winterfell</a>, a popular general-purpose STARK prover. Polygon uses Winterfell to prove the execution of the <a rel="noopener external" target="_blank" href="https://github.com/0xPolygonMiden/miden-vm">Miden-VM</a>, which is a ZK-friendly VM to enable features and benefits that EVM-based L1s and L2s do not currently offer.</p>
<p>Even though the main components are the same, such as execution trace, auxiliary trace, using Merkle trees for commitments, and the FRI protocol, there are some parts where it was not straightforward to use Lambdaworks as a drop-in replacement for Winterfell. One obstacle is related to the field backend. Miden was designed to work over the prime $2^{64} - 2^{32} + 1$ (known by some as Mini-Goldilocks) and has to deal with extension fields to achieve cryptographic security, whereas our STARK prover worked with a 252-bit field. In this first part, we focused purely on compatibility and left behind optimizations that we could add to improve the performance.</p>
<p>In this post, we will cover the major work we have been doing toward compatibility with Winterfell so that you can replace it in your project if needed. This adds redundancy and robustness since we have different provers with different design choices and can help detect bugs.</p>
<h2 id="fields-and-traces">Fields and Traces</h2>
<p>To work with Winterfell, we implemented the field trait from Lambdaworks to the native fields of Winterfell. In other words, we are running our STARK prover with Winterfell fields.</p>
<p>Since Miden works with mini-Goldilocks, the auxiliary trace and the random challenges drawn from the verifier belong to a field extension. One easy way to deal with this is by having all the elements belong to the extension field, which would add overhead to the elements of the main trace (since they live in the smaller base field).</p>
<p>To solve this issue, we split the trace in two, with one part belonging to the main trace and using the small field and the extension belonging to the larger field.</p>
<p>Moreover, we added some useful generalizations. Since, a lot of times, elements from the extension field are multiplied by elements belonging to the base field, the operation can be improved. This is similar to what we do, for example, in the complex numbers when we multiply it by a real. If we want to compute $2\times (1 + i)$, we distribute and do two multiplications instead of doing a naive multiplication with the formula $(2 + 0i) \times (1 + i)$).</p>
<p>To handle this case, we implemented the <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks/pull/709">subfield logic</a>. This allows us to define the operations between field elements and exceptional cases for when a subfield element operates with its parent field element. And since it’s just a matter of picking the correct operation in compilation time, there is no overhead. All this extra logic adds no overhead to the fields, as it can be measured in our benchmarks.</p>
<p>Along with the changes in the fields, we also introduced changes to the <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks/pull/711">FFT so that it works over extension fields</a>. Now, the interpolation of the auxiliary trace and computation of the composition polynomial has to work over larger fields.</p>
<h2 id="winterfell-adapter">Winterfell adapter</h2>
<p>The Winterfell Adapter transforms a Winterfell AIR (algebraic intermediate representation) into a Lambdaworks AIR.</p>
<p>Internally, it creates a new implementation of the Air trait, using all the configurations from Winterfell. One detail is that the evaluation of constraints is delegated here to the implementation in Winterfell to avoid a redefinition that would take longer for someone who already has the Air defined in Winterfell.</p>
<p>To see it working, we can check the following link, which contains an example of how to generate proof for the <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks/tree/main/winterfell_adapter">Fibonacci AIR</a>. Let’s check it.</p>
<h3 id="code-and-examples">Code and Examples</h3>
<p>Let’s see how the Winterfell adapter is used with a simple Air.</p>
<h4 id="fibonacci-air">Fibonacci Air</h4>
<p>Suppose you want to run Lambdaworks prover with a <code>WinterfellFibonacciAIR.</code></p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>use winterfell::Air;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>struct WinterfellFibonacciAIR {</span></span>
<span class="giallo-l"><span>    /// ...</span></span>
<span class="giallo-l"><span>}</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>impl Air for WinterfellFibonacciAIR {</span></span>
<span class="giallo-l"><span>    /// ...</span></span>
<span class="giallo-l"><span>}</span></span></code></pre><h5 id="step-1-convert-your-winterfell-trace-table">Step 1: Convert your Winterfell trace table</h5>
<p>Use the Lambdaworks <code>AirAdapter</code> to convert your Winterfell trace:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>let trace = &amp;AirAdapter::convert_winterfell_trace_table(winterfell_trace)</span></span></code></pre><h5 id="step-2-convert-your-public-inputs">Step 2: Convert your public inputs</h5>
<p>Create the <code>AirAdapterPublicInputs</code> by supplying your <code>winterfell_public_inputs</code> and the additional parameters required by the Lambdaworks prover:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>let pub_inputs = AirAdapterPublicInputs {</span></span>
<span class="giallo-l"><span>    winterfell_public_inputs: AdapterFieldElement(trace.columns()[1][7]),</span></span>
<span class="giallo-l"><span>    transition_degrees: vec![1, 1],    /// The degrees of each transition</span></span>
<span class="giallo-l"><span>    transition_exemptions: vec![1, 1], /// The steps at the end where the transitions do not apply.</span></span>
<span class="giallo-l"><span>    transition_offsets: vec![0, 1],    /// The size of the frame. This is probably [0, 1] for every Winterfell AIR.</span></span>
<span class="giallo-l"><span>    composition_poly_degree_bound: 8,  /// A bound over the composition degree polynomial is used for choosing the number of parts for H(x).</span></span>
<span class="giallo-l"><span>    trace_info: TraceInfo::new(2, 8),  /// Your winterfell trace info.</span></span>
<span class="giallo-l"><span>};</span></span></code></pre>
<p>Note that you might have to also convert your field elements to <code>AdapterFieldElement,</code> as in this case.</p>
<h5 id="step-3-make-the-proof">Step 3: Make the proof</h5>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>let proof = Prover::prove::&lt;AirAdapter&lt;FibonacciAIR, TraceTable&lt;_&gt;&gt;&gt;(</span></span>
<span class="giallo-l"><span>    &amp;trace,</span></span>
<span class="giallo-l"><span>    &amp;pub_inputs, /// Public inputs</span></span>
<span class="giallo-l"><span>    &amp;proof_options,</span></span>
<span class="giallo-l"><span>    StoneProverTranscript::new(&amp;[]),</span></span>
<span class="giallo-l"><span>);</span></span></code></pre>
<p><code>TraceTable</code> is the Winterfell type that represents your trace table. You can see the <code>examples</code> folder inside this crate to check more examples.</p>
<h3 id="miden-air">Miden Air</h3>
<p>Let’s see how it is used with an actual Miden AIR and program.</p>
<p>First, we must compile and run the code to generate a trace. This is done in the same manner as Miden does it.</p>
<p>The whole code is a bit long, but it starts like this:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>let fibonacci_number = 16;</span></span>
<span class="giallo-l"><span>        let program = format!(</span></span>
<span class="giallo-l"><span>            &quot;begin</span></span>
<span class="giallo-l"><span>                repeat.{}</span></span>
<span class="giallo-l"><span>                    swap dup.1 add</span></span>
<span class="giallo-l"><span>                end</span></span>
<span class="giallo-l"><span>            end&quot;,</span></span>
<span class="giallo-l"><span>            fibonacci_number - 1</span></span>
<span class="giallo-l"><span>        );</span></span>
<span class="giallo-l"><span>let program = Assembler::default().compile(program).unwrap();</span></span>
<span class="giallo-l"><span>... </span></span>
<span class="giallo-l"><span>// Some more code goes in the middle until we generate the trace</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>let winter_trace = processor::execute(</span></span>
<span class="giallo-l"><span>    &amp;program,</span></span>
<span class="giallo-l"><span>    stack_inputs.clone(),</span></span>
<span class="giallo-l"><span>    DefaultHost::default(),</span></span>
<span class="giallo-l"><span>    *ProvingOptions::default().execution_options(),)</span></span></code></pre>
<p>After generating the trace from Miden, the real work for the prover starts. But the code is not that different from the Fibonacci case; it just has a more complex AIR, but the user is abstracted from that.</p>
<p>To generate the proof, we run the following code:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>let pub_inputs = AirAdapterPublicInputs {</span></span>
<span class="giallo-l"><span>    winterfell_public_inputs: pub_inputs,</span></span>
<span class="giallo-l"><span>    transition_exemptions: vec![2; 182],</span></span>
<span class="giallo-l"><span>    transition_offsets: vec![0, 1],</span></span>
<span class="giallo-l"><span>    trace_info: winter_trace.get_info(),</span></span>
<span class="giallo-l"><span>    metadata: winter_trace.clone().into(),</span></span>
<span class="giallo-l"><span>};</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>let trace =</span></span>
<span class="giallo-l"><span>    MidenVMQuadFeltAir::convert_winterfell_trace_table(winter_trace.main_segment().clone());</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>let proof = Prover::&lt;MidenVMQuadFeltAir&gt;::prove(</span></span>
<span class="giallo-l"><span>    &amp;trace,</span></span>
<span class="giallo-l"><span>    &amp;pub_inputs,</span></span>
<span class="giallo-l"><span>    &amp;lambda_proof_options,</span></span>
<span class="giallo-l"><span>    QuadFeltTranscript::new(&amp;[]),</span></span>
<span class="giallo-l"><span>)</span></span>
<span class="giallo-l"><span>.unwrap();</span></span></code></pre>
<p>Finally, to verify it, it is enough to call the verify function with the proof and the public inputs:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>Verifier::&lt;MidenVMQuadFeltAir&gt;::verify(</span></span>
<span class="giallo-l"><span>            &amp;proof,</span></span>
<span class="giallo-l"><span>            &amp;pub_inputs,</span></span>
<span class="giallo-l"><span>            &amp;lambda_proof_options,</span></span>
<span class="giallo-l"><span>            QuadFeltTranscript::new(&amp;[]),</span></span>
<span class="giallo-l"><span>        )</span></span></code></pre><h3 id="benchmarks">Benchmarks</h3>
<p>To run the Fibonacci Miden benchmark run:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>cargo bench</span></span></code></pre>
<p>To run it with parallelization, run:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>cargo bench --features stark-platinum-prover/parallel,winter-prover/concurrent</span></span></code></pre>
<p>Several PRs added support for extension fields for the prover and verifier (<a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks/pull/716">716</a>, <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks/pull/717">717</a> and <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks/pull/724">724</a>). These allow us to represent the trace in the base field (which has faster operations and less memory use) and have a different frame for the auxiliary trace over the extension. There were some modifications in the constraint calculations, such as being able to use different fields.</p>
<p>There is also a <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks/blob/main/winterfell_adapter/src/examples/miden_vm.rs">Miden adapter</a> containing some example tests, such as Fibonacci and readme example.</p>
<h2 id="adding-periodic-columns">Adding periodic columns</h2>
<p>Winterfell also uses periodic columns, so we had to add them and test their use in this <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks/pull/685/files">PR</a>. These have uses for hash function calculations or supporting constants that we need.</p>
<h2 id="conclusions">Conclusions</h2>
<p>Lambdaworks has been growing over the last year. We have added several proof systems and commitment schemes to give users an easy-to-use library to experiment with and build applications. We have also been working to make the provers compatible with our libraries, giving the users a drop-in replacement. We decided to work towards compatibility with Winterfell/Miden VM since we like many design choices and the work done to generalize AIRs in <a rel="noopener external" target="_blank" href="https://github.com/0xPolygonMiden/air-script">AIRscript</a>. We will continue improving the performance of our provers and supporting new proof systems as part of our roadmap.</p>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
