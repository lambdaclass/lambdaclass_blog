<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LogUp lookup argument and its implementation using Lambdaworks for continuous read-only memory - LambdaClass Blog</title>
    <meta name="description" content="Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">LogUp lookup argument and its implementation using Lambdaworks for continuous read-only memory</h1>
        
        <div class="page-meta">
            <time datetime="2024-12-27">December 27, 2024</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <h2 id="introduction">Introduction</h2>
<p>In a <a href="/continuous-read-only-memory-constraints-an-implementation-using-lambdaworks/">previous post</a>, we explained how to define constraints for a <strong>continuous read-only memory</strong> , presenting it as an example to understand how constraints are defined in general. This time, we will continue digging into this example to introduce the <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2022/1530">LogUp</a> construction, adapted to univariate polynomials, and explain how we implemented it.</p>
<p>In what follows, we will assume that you have a notion of the concepts of constraints, a continuous read-only memory, and an idea of how they are implemented. To go deeper into these topics, we recommend reading the previously mentioned post, as this one will be its continuation.</p>
<h2 id="what-is-logup">What is LogUp?</h2>
<p>LogUp is a case of a <strong>Lookup Argument</strong>. But what exactly are lookup arguments? They serve as a tool that allows us to prove efficiently that a specific value $v$ belongs to a table of values $T$ without revealing the entire table. This concept is handy for improving the efficiency of arguments for statements that are otherwise quite expensive to arithmetize.</p>
<p>In essence, a lookup argument enables the prover to convince the verifier that every element of a given set $A$ (often represented as a column of a trace table) is contained within another set $T$ (the lookup table). In this way, instead of having to arithmetize many constraints to ensure that $A$ satisfies certain conditions and is in a certain way, we precompute all the valid values that $A$ can have, write them in the table $T$ and then use a lookup argument to prove that all the elements of $A$ belong to $T$ (i.e., they are valid elements). In other words, we achieve to verify the relationship between data while preserving privacy or optimizing computation.</p>
<p>An example of a Lookup argument can be found in the <a href="/continuous-read-only-memory-constraints-an-implementation-using-lambdaworks/">post mentioned above</a>. Let’s quickly check what we did there: given two columns, $a$ (addresses) and $v$ (values), we needed to create their corresponding sorted columns $a’$ and $v’$. We used a Lookup argument known as <strong>Grand Product</strong> to prove that they were permutations of the original ones.<br />
Using two random elements $z$ and $\alpha$, sampled from an extension of $\mathbb{F}$, we constructed an auxiliary column $p$ using:</p>
<p>$$p_{i + 1} = p_i \cdot \frac {z - (a_{i + 1} + \alpha v_{i + 1})} {z - (a^\prime_{i + 1} + \alpha v^\prime_{i + 1})},$$</p>
<p>The goal was to verify that the last element of this column equals one:</p>
<p>$$p_{n - 1} = \prod_{i = 0}^{n - 1} \frac {z - (a_i + \alpha v_i)} {z - (a^\prime_i + \alpha v^\prime_i)} = 1.$$</p>
<p>This guarantees that $a’$ and $v’$ are permutations of $a$ and $v$, ensuring the correctness of the table.</p>
<p>The idea behind <strong>LogUp</strong> is to replace these products with their <strong>logarithmic derivatives</strong> , or more simply, to transform the product into a sum of fractions. This approach reduces the computational effort for both the prover and the verifier. The method gets its name because the logarithmic derivative converts products like $\prod_{i = 1}^n X - y_i$ into sums:</p>
<p>$$\sum_{i = 1}^n \frac{1}{X - y_i}.$$</p>
<p>So, suppose we have a column $a = (a_0, \ldots, a_n)$ from the main trace containing repeated elements and a column $t = (t_0, \ldots, t_m)$ from the lookup table without duplicates, and we want to demonstrate that all the elements of $a$ belong to $t$. In that case, it is enough to prove the equality:</p>
<p>$$\sum_{i = 0}^n \frac{1}{\alpha - a_i} = \sum_{i = 0}^m \frac{m_i}{\alpha - t_i}$$</p>
<p>where $\alpha$ is a random element, and $m_i$ is the multiplicity of $t_i$ in $a$, that is, the number of times $t_i$ appears in $a$.</p>
<p>A natural question might arise at this point: is it still more efficient to replace products with sums, mainly since doing so introduces fractions? We won’t work directly with these fractions, as we’ll see later. Instead, we’ll multiply both sides of the equation by the common denominator.</p>
<h2 id="continuous-read-only-memory-example">Continuous read-only memory example</h2>
<p>To understand how the constraints of a LogUp argument are written, let’s go back to our example of a continuous read-only memory. To follow this example, we recommend accompanying it with the corresponding <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks/blob/logup-mem-example/provers/stark/src/examples/read_only_memory_logup.rs">implementation made in Lambdaworks</a>.</p>
<h3 id="main-trace">Main Trace</h3>
<p>First of all, we need to understand how the columns of the main trace are defined in the case of wanting to use a LogUp argument. We will proceed similarly to what we did in the first post. Given the address column $a$ and the value column $v$ of our memory, we will add three additional columns to the main trace: $a’,$ $v’$, and $m$. The $a’$ and $v’$ columns will contain the same values as $a$ and $v$ but will be sorted in ascending order without duplicating values. The column $m$ will represent the multiplicity of these values in the original columns. Since these columns do not have duplicates, they will be smaller. To ensure all columns have the same length and fit into a single table, we will pad $a’$ and $v’$ by repeating their last value and assigning a multiplicity of $0$ to these padded rows in the $m$ column.</p>
<p>Let’s see an example. If our original table was:</p>
<table><thead><tr><th>$a$</th><th>$v$</th></tr></thead><tbody>
<tr><td>3</td><td>30</td></tr>
<tr><td>2</td><td>20</td></tr>
<tr><td>2</td><td>40</td></tr>
<tr><td>3</td><td>30</td></tr>
<tr><td>1</td><td>10</td></tr>
<tr><td>3</td><td>30</td></tr>
</tbody></table>
<p>The main trace would become:</p>
<table><thead><tr><th>$a$</th><th>$v$</th><th>$a’$</th><th>$v’$</th><th>$m$</th></tr></thead><tbody>
<tr><td>3</td><td>30</td><td>1</td><td>10</td><td>2</td></tr>
<tr><td>2</td><td>20</td><td>2</td><td>20</td><td>1</td></tr>
<tr><td>2</td><td>40</td><td>2</td><td>40</td><td>1</td></tr>
<tr><td>3</td><td>30</td><td>3</td><td>30</td><td>2</td></tr>
<tr><td>1</td><td>10</td><td>3</td><td>30</td><td>0</td></tr>
<tr><td>1</td><td>10</td><td>3</td><td>30</td><td>0</td></tr>
</tbody></table>
<p>Notice that the original table does not represent a valid read-only memory (since address 2 has two different values, 20 and 40), we can still construct the main trace. Later, the <code>SingleValueConstraint</code> transition constraint will ensure that such tables are invalid.</p>
<p>In our implementation, the function <code>read_only_logup_trace()</code> handles the construction of the main trace. It returns a <code>TraceTable</code> containing the five main columns described above and an auxiliary column initially filled with zeros, which will later be replaced with the appropriate values.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>/// Return a trace table with an auxiliary column full of zeros (that will be then replaced with the correct values by the air) and</span></span>
<span class="giallo-l"><span>/// and the following five main columns: </span></span>
<span class="giallo-l"><span>/// The original addresses and values, the sorted addresses and values without duplicates, and</span></span>
<span class="giallo-l"><span>/// the multiplicities of each sorted address and value in the original ones (i.e., how many times they appear in the original address and value columns).</span></span>
<span class="giallo-l"><span>pub fn read_only_logup_trace&lt;</span></span>
<span class="giallo-l"><span>    F: IsPrimeField + IsFFTField + IsSubFieldOf&lt;E&gt; + Send + Sync,</span></span>
<span class="giallo-l"><span>    E: IsField + Send + Sync,</span></span>
<span class="giallo-l"><span>&gt;(</span></span>
<span class="giallo-l"><span>    addresses: Vec&lt;FieldElement&lt;F&gt;&gt;,</span></span>
<span class="giallo-l"><span>    values: Vec&lt;FieldElement&lt;F&gt;&gt;,</span></span>
<span class="giallo-l"><span>) -&gt; TraceTable&lt;F, E&gt; {</span></span>
<span class="giallo-l"><span>    // We order the addresses and values.</span></span>
<span class="giallo-l"><span>    let mut address_value_pairs: Vec&lt;_&gt; = addresses.iter().zip(values.iter()).collect();</span></span>
<span class="giallo-l"><span>    address_value_pairs.sort_by_key(|(addr, _)| addr.representative());</span></span>
<span class="giallo-l"><span>    </span></span>
<span class="giallo-l"><span>    //We define the main columns that will be added to the original ones </span></span>
<span class="giallo-l"><span>    let mut multiplicities = Vec::new();</span></span>
<span class="giallo-l"><span>    let mut sorted_addresses = Vec::new();</span></span>
<span class="giallo-l"><span>    let mut sorted_values = Vec::new();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    for (key, group) in &amp;address_value_pairs.into_iter().group_by(|&amp;(a, v)| (a, v)) {</span></span>
<span class="giallo-l"><span>        let group_vec: Vec&lt;_&gt; = group.collect();</span></span>
<span class="giallo-l"><span>        multiplicities.push(FieldElement::&lt;F&gt;::from(group_vec.len() as u64));</span></span>
<span class="giallo-l"><span>        sorted_addresses.push(key.0.clone());</span></span>
<span class="giallo-l"><span>        sorted_values.push(key.1.clone());</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // We resize the sorted addresses and values with the last value of each one so they have the</span></span>
<span class="giallo-l"><span>    // same number of rows as the original addresses and values. However, their multiplicity should be zero.</span></span>
<span class="giallo-l"><span>    sorted_addresses.resize(addresses.len(), sorted_addresses.last().unwrap().clone());</span></span>
<span class="giallo-l"><span>    sorted_values.resize(addresses.len(), sorted_values.last().unwrap().clone());</span></span>
<span class="giallo-l"><span>    multiplicities.resize(addresses.len(), FieldElement::&lt;F&gt;::zero());</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let main_columns = vec![</span></span>
<span class="giallo-l"><span>        addresses.clone(),</span></span>
<span class="giallo-l"><span>        values.clone(),</span></span>
<span class="giallo-l"><span>        sorted_addresses,</span></span>
<span class="giallo-l"><span>        sorted_values,</span></span>
<span class="giallo-l"><span>        multiplicities,</span></span>
<span class="giallo-l"><span>    ];</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // We create a vector of the same length as the main columns full with zeros from de field extension and place it as the auxiliary column.</span></span>
<span class="giallo-l"><span>    let zero_vec = vec![FieldElement::&lt;E&gt;::zero(); main_columns[0].len()];</span></span>
<span class="giallo-l"><span>    TraceTable::from_columns(main_columns, vec![zero_vec], 1)</span></span>
<span class="giallo-l"><span>}</span></span></code></pre><h3 id="auxiliary-trace">Auxiliary Trace</h3>
<p>Now, let’s see how to construct the auxiliary column. The auxiliary column, which we’ll call $s$, should accumulate the sums of the fractions corresponding to each row of the main table as follows:</p>
<p>$$ \begin{align} s_0 &amp;= \frac {m_0} {z - (a^\prime_0 + \alpha v^\prime_0)} - \frac {1} {z - (a_0 + \alpha v_0)},<br />
\ \newline<br />
s_1 &amp;= s_0 + \frac { m_1 } {z - (a^\prime_1 + \alpha v^\prime_1)} - \frac {1} {z - (a_1 + \alpha v_1)} \end{align}$$</p>
<p>And so on, obtaining:</p>
<p>$$s_{i + 1} = s_i + \frac {m_{i + 1}} {z - (a^\prime_{i + 1} + \alpha v^\prime_{i + 1})} - \frac {1} {z - (a_{i + 1} + \alpha v_{i + 1})} \text{ with } i \in {0, \ldots, n - 2}.$$</p>
<p>As an example, if our main trace was:</p>
<table><thead><tr><th>$a$</th><th>$v$</th><th>$a’$</th><th>$v’$</th><th>$m$</th></tr></thead><tbody>
<tr><td>3</td><td>30</td><td>1</td><td>10</td><td>1</td></tr>
<tr><td>1</td><td>10</td><td>2</td><td>20</td><td>2</td></tr>
<tr><td>2</td><td>20</td><td>3</td><td>30</td><td>1</td></tr>
<tr><td>2</td><td>20</td><td>3</td><td>30</td><td>0</td></tr>
</tbody></table>
<p>Then, our auxiliary column trace $s$ would look like this:</p>
<table><thead><tr><th>$a$</th><th>$v$</th><th>$a’$</th><th>$v’$</th><th>$m$</th><th>$s$</th></tr></thead><tbody>
<tr><td>3</td><td>30</td><td>1</td><td>10</td><td>1</td><td>$\frac {1} {z - (1 + \alpha 10)} - \frac {1} {z - (3 + \alpha 30)}$</td></tr>
<tr><td>1</td><td>10</td><td>2</td><td>20</td><td>2</td><td>$s_0 + \frac {2} {z - (2 + \alpha 20)} - \frac {1} {z - (1 + \alpha 10)}$</td></tr>
<tr><td>2</td><td>20</td><td>3</td><td>30</td><td>1</td><td>$s_1 + \frac {1} {z - (3 + \alpha 30)} - \frac {1} {z - (2 + \alpha 20)}$</td></tr>
<tr><td>2</td><td>20</td><td>3</td><td>30</td><td>0</td><td>$s_2 + \frac {0} {z - (3 + \alpha 30)} - \frac {1} {z - (2 + \alpha 20)}$</td></tr>
</tbody></table>
<p>Observe that if the main trace indeed represents a permutation with multiplicities, then the last element of $s$ (that is $s_{n - 1}$) should reflect the accumulation of all sums, canceling each other out and resulting in $0$ (i.e. $s_{n - 1} = 0$). This is analogous to what happens with the Grand Product, where we verify that the final product cancels out and results in 1 (i.e. $p_{n - 1} = 1$). Let’s see this in the context of the example from the table above:</p>
<p>$$ \begin{align}<br />
s_{n - 1} &amp;= {\style{color: orange} {\frac {1} {z - (1 + \alpha 10)}}} - \style{color: cyan} {\frac {1} {z - (3 + \alpha 30)}}<br />
\newline<br />
&amp;+ \style{color: magenta} {\frac {2} {z - (2 + \alpha 20)}} - {\style{color: orange} {\frac {1} {z - (1 + \alpha 10)}}}<br />
\newline<br />
&amp;+ \style{color: cyan} {\frac {1} {z - (3 + \alpha 30)}} - \style{color: magenta} {\frac {1} {z - (2 + \alpha 20)}}<br />
\newline<br />
&amp;+ \frac {0} {z - (3 + \alpha 30)} - \style{color: magenta} {\frac {1} {z - (2 + \alpha 20)}}<br />
\ \newline<br />
&amp;= 0<br />
\end{align}<br />
$$</p>
<p>Now, let’s see how this is implemented in our code. In Lambdaworks, the construction of the auxiliary trace is handled within the AIR implementation. Specifically, in the implementation of <code>LogReadOnlyRAP</code>, you can find the following function <code>build_auxiliary_trace()</code>:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>fn build_auxiliary_trace(</span></span>
<span class="giallo-l"><span>    &amp;self,</span></span>
<span class="giallo-l"><span>    trace: &amp;mut TraceTable&lt;Self::Field, Self::FieldExtension&gt;,</span></span>
<span class="giallo-l"><span>    challenges: &amp;[FieldElement&lt;E&gt;],</span></span>
<span class="giallo-l"><span>) where</span></span>
<span class="giallo-l"><span>    Self::FieldExtension: IsFFTField,</span></span>
<span class="giallo-l"><span>{</span></span>
<span class="giallo-l"><span>    // Main table</span></span>
<span class="giallo-l"><span>    let main_segment_cols = trace.columns_main();</span></span>
<span class="giallo-l"><span>    let a = &amp;main_segment_cols[0];</span></span>
<span class="giallo-l"><span>    let v = &amp;main_segment_cols[1];</span></span>
<span class="giallo-l"><span>    let a_sorted = &amp;main_segment_cols[2];</span></span>
<span class="giallo-l"><span>    let v_sorted = &amp;main_segment_cols[3];</span></span>
<span class="giallo-l"><span>    let m = &amp;main_segment_cols[4];</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // Challenges</span></span>
<span class="giallo-l"><span>    let z = &amp;challenges[0];</span></span>
<span class="giallo-l"><span>    let alpha = &amp;challenges[1];</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let trace_len = trace.num_rows();</span></span>
<span class="giallo-l"><span>    let mut aux_col = Vec::new();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // s_0 = m_0/(z - (a&#39;_0 + α * v&#39;_0) - 1/(z - (a_0 + α * v_0)</span></span>
<span class="giallo-l"><span>    let unsorted_term = (-(&amp;a[0] + &amp;v[0] * alpha) + z).inv().unwrap();</span></span>
<span class="giallo-l"><span>    let sorted_term = (-(&amp;a_sorted[0] + &amp;v_sorted[0] * alpha) + z).inv().unwrap();</span></span>
<span class="giallo-l"><span>    aux_col.push(&amp;m[0] * sorted_term - unsorted_term);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // Apply the same equation given in the permutation transition constraint to the rest of the trace.</span></span>
<span class="giallo-l"><span>    // s_{i+1} = s_i + m_{i+1}/(z - (a&#39;_{i+1} + α * v&#39;_{i+1}) - 1/(z - (a_{i+1} + α * v_{i+1})</span></span>
<span class="giallo-l"><span>    for i in 0..trace_len - 1 {</span></span>
<span class="giallo-l"><span>        let unsorted_term = (-(&amp;a[i + 1] + &amp;v[i + 1] * alpha) + z).inv().unwrap();</span></span>
<span class="giallo-l"><span>        let sorted_term = (-(&amp;a_sorted[i + 1] + &amp;v_sorted[i + 1] * alpha) + z)</span></span>
<span class="giallo-l"><span>            .inv()</span></span>
<span class="giallo-l"><span>            .unwrap();</span></span>
<span class="giallo-l"><span>        aux_col.push(&amp;aux_col[i] + &amp;m[i + 1] * sorted_term - unsorted_term);</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    for (i, aux_elem) in aux_col.iter().enumerate().take(trace.num_rows()) {</span></span>
<span class="giallo-l"><span>        trace.set_aux(i, 0, aux_elem.clone())</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre><h3 id="transition-constraints">Transition constraints</h3>
<p>Now, let’s look at how we should define the transition constraints for a continuous read-only memory using LogUp. The first two transition constraints explained in the previous post remain unchanged. That is, we don’t need to make any modifications to <code>ContinuityConstraint</code> and <code>SingleValueConstraint</code>, as the method for verifying that the memory is read-only and continuous using the $a’$ and $v’$ columns remains the same.</p>
<p>However, modifying the third constraint, called <code>PermutationConstraint</code> is essential. This constraint ensures that the auxiliary column $s$ is constructed correctly. It must be checked that $s_i$ satisfies the equation mentioned before:</p>
<p>$$s_{i+1} = s_i + \frac {m_{i+1}} {z - (a^\prime_{i + 1} + \alpha v^\prime_{i + 1})} - \frac {1} {z - (a_{i+1} + \alpha v_{i+1})} \text{ with } i \in {0, \ldots, n - 2}.$$</p>
<p>Since constraints must be expressed without division, we will multiply both sides of the equality by the common denominator. This transforms the constraint into the following form:</p>
<p>$$\begin{align}s_{i+1} &amp;\cdot (z - (a^\prime_{i+1} + \alpha v^\prime_{i+1})) \cdot (z - (a_{i+1} + \alpha v_{i+1})) =<br />
\ \newline<br />
&amp;=s_i \cdot (z - (a^\prime_{i+1} + \alpha v^\prime_{i+1})) \cdot (z - (a_{i+1} + \alpha v_{i+1}))<br />
\ \newline<br />
&amp;+ m_{i+1} \cdot (z - (a_{i+1} + \alpha v_{i+1}))<br />
\ \newline<br />
&amp;- (z - (a^\prime_{i+1} + \alpha v^\prime_{i+1}))<br />
\end{align}$$</p>
<p>Additionally, we will move the left-hand side of the equality to the right, subtracting it so that it can be interpreted as a polynomial in the variables $s$, $a$, $a’$, $v$ and $v’$ that is equal to zero:</p>
<p>$$\begin{align} 0 &amp;=s_i \cdot (z - (a^\prime_{i+1} + \alpha v^\prime_{i+1})) \cdot (z - (a_{i+1} + \alpha v_{i+1}))<br />
\ \newline<br />
&amp;+ m_{i+1} \cdot (z - (a_{i+1} + \alpha v_{i+1}))<br />
\ \newline<br />
&amp;- (z - (a^\prime_{i+1} + \alpha v^\prime_{i+1}))<br />
\ \newline<br />
&amp;- s_{i+1} \cdot (z - (a^\prime_{i+1} + \alpha v^\prime_{i+1})) \cdot (z - (a_{i+1} + \alpha v_{i+1}))<br />
\end{align}$$</p>
<p>This equation can be found inside the function <code>evaluate()</code> in the implementation of <code>PermutationConstraint</code>. It is worth mentioning that both the prover and verifier must evaluate the polynomial constraint in the same way. However, we are forced to separate this evaluation into two cases because the <code>frames</code> used by each one are of different types.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>fn evaluate(</span></span>
<span class="giallo-l"><span>    &amp;self,</span></span>
<span class="giallo-l"><span>    evaluation_context: &amp;TransitionEvaluationContext&lt;F, E&gt;,</span></span>
<span class="giallo-l"><span>    transition_evaluations: &amp;mut [FieldElement&lt;E&gt;],</span></span>
<span class="giallo-l"><span>) {</span></span>
<span class="giallo-l"><span>    // In both evaluation contexts, Prover and Verfier will evaluate the transition polynomial in the same way.</span></span>
<span class="giallo-l"><span>    // The only difference is that the Prover&#39;s Frame has base field and field extension elements,</span></span>
<span class="giallo-l"><span>    // while the Verfier&#39;s Frame has only field extension elements.</span></span>
<span class="giallo-l"><span>    match evaluation_context {</span></span>
<span class="giallo-l"><span>        TransitionEvaluationContext::Prover {</span></span>
<span class="giallo-l"><span>            frame,</span></span>
<span class="giallo-l"><span>            periodic_values: _periodic_values,</span></span>
<span class="giallo-l"><span>            rap_challenges,</span></span>
<span class="giallo-l"><span>        } =&gt; {</span></span>
<span class="giallo-l"><span>            let first_step = frame.get_evaluation_step(0);</span></span>
<span class="giallo-l"><span>            let second_step = frame.get_evaluation_step(1);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>            // Auxiliary frame elements</span></span>
<span class="giallo-l"><span>            let s0 = first_step.get_aux_evaluation_element(0, 0);</span></span>
<span class="giallo-l"><span>            let s1 = second_step.get_aux_evaluation_element(0, 0);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>            // Challenges</span></span>
<span class="giallo-l"><span>            let z = &amp;rap_challenges[0];</span></span>
<span class="giallo-l"><span>            let alpha = &amp;rap_challenges[1];</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>            // Main frame elements</span></span>
<span class="giallo-l"><span>            let a1 = second_step.get_main_evaluation_element(0, 0);</span></span>
<span class="giallo-l"><span>            let v1 = second_step.get_main_evaluation_element(0, 1);</span></span>
<span class="giallo-l"><span>            let a_sorted_1 = second_step.get_main_evaluation_element(0, 2);</span></span>
<span class="giallo-l"><span>            let v_sorted_1 = second_step.get_main_evaluation_element(0, 3);</span></span>
<span class="giallo-l"><span>            let m = second_step.get_main_evaluation_element(0, 4);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>            let unsorted_term = -(a1 + v1 * alpha) + z;</span></span>
<span class="giallo-l"><span>            let sorted_term = -(a_sorted_1 + v_sorted_1 * alpha) + z;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>            // We are using the following LogUp equation:</span></span>
<span class="giallo-l"><span>            // s1 = s0 + m / sorted_term - 1/unsorted_term.</span></span>
<span class="giallo-l"><span>            // Since constraints must be expressed without division, we multiply each term by sorted_term * unsorted_term:</span></span>
<span class="giallo-l"><span>            let res = s0 * &amp;unsorted_term * &amp;sorted_term + m * &amp;unsorted_term</span></span>
<span class="giallo-l"><span>                - &amp;sorted_term</span></span>
<span class="giallo-l"><span>                - s1 * unsorted_term * sorted_term;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>            // The eval always exists, except if the constraint idx was incorrectly defined.</span></span>
<span class="giallo-l"><span>            if let Some(eval) = transition_evaluations.get_mut(self.constraint_idx()) {</span></span>
<span class="giallo-l"><span>                *eval = res;</span></span>
<span class="giallo-l"><span>            }</span></span>
<span class="giallo-l"><span>        }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        TransitionEvaluationContext::Verifier {</span></span>
<span class="giallo-l"><span>            frame,</span></span>
<span class="giallo-l"><span>            periodic_values: _periodic_values,</span></span>
<span class="giallo-l"><span>            rap_challenges,</span></span>
<span class="giallo-l"><span>        } =&gt; {</span></span>
<span class="giallo-l"><span>            let first_step = frame.get_evaluation_step(0);</span></span>
<span class="giallo-l"><span>            let second_step = frame.get_evaluation_step(1);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>            // Auxiliary frame elements</span></span>
<span class="giallo-l"><span>            let s0 = first_step.get_aux_evaluation_element(0, 0);</span></span>
<span class="giallo-l"><span>            let s1 = second_step.get_aux_evaluation_element(0, 0);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>            // Challenges</span></span>
<span class="giallo-l"><span>            let z = &amp;rap_challenges[0];</span></span>
<span class="giallo-l"><span>            let alpha = &amp;rap_challenges[1];</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>            // Main frame elements</span></span>
<span class="giallo-l"><span>            let a1 = second_step.get_main_evaluation_element(0, 0);</span></span>
<span class="giallo-l"><span>            let v1 = second_step.get_main_evaluation_element(0, 1);</span></span>
<span class="giallo-l"><span>            let a_sorted_1 = second_step.get_main_evaluation_element(0, 2);</span></span>
<span class="giallo-l"><span>            let v_sorted_1 = second_step.get_main_evaluation_element(0, 3);</span></span>
<span class="giallo-l"><span>            let m = second_step.get_main_evaluation_element(0, 4);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>            let unsorted_term = z - (a1 + alpha * v1);</span></span>
<span class="giallo-l"><span>            let sorted_term = z - (a_sorted_1 + alpha * v_sorted_1);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>            // We are using the following LogUp equation:</span></span>
<span class="giallo-l"><span>            // s1 = s0 + m / sorted_term - 1/unsorted_term.</span></span>
<span class="giallo-l"><span>            // Since constraints must be expressed without division, we multiply each term by sorted_term * unsorted_term:</span></span>
<span class="giallo-l"><span>            let res = s0 * &amp;unsorted_term * &amp;sorted_term + m * &amp;unsorted_term</span></span>
<span class="giallo-l"><span>                - &amp;sorted_term</span></span>
<span class="giallo-l"><span>                - s1 * unsorted_term * sorted_term;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>            // The eval always exists, except if the constraint idx was incorrectly defined.</span></span>
<span class="giallo-l"><span>            if let Some(eval) = transition_evaluations.get_mut(self.constraint_idx()) {</span></span>
<span class="giallo-l"><span>                *eval = res;</span></span>
<span class="giallo-l"><span>            }</span></span>
<span class="giallo-l"><span>        }</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>Another noteworthy change is that the polynomial associated with this constraint is now of degree 3. This is easy to understand if we observe that in the zero-equality equation mentioned earlier, there are terms containing the product of three factors, resulting in three variables multiplied together.</p>
<p>It’s worth highlighting that, up until now, both in the previous post and in the other two transition constraints, we had only worked with polynomials of degree 2. This change is reflected in the code in two places. First, we must specify the degree of a transition constraint when defining it:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>impl&lt;F, E&gt; TransitionConstraint&lt;F, E&gt; for PermutationConstraint&lt;F, E&gt;</span></span>
<span class="giallo-l"><span>where</span></span>
<span class="giallo-l"><span>    F: IsSubFieldOf&lt;E&gt; + IsFFTField + Send + Sync,</span></span>
<span class="giallo-l"><span>    E: IsField + Send + Sync,</span></span>
<span class="giallo-l"><span>{</span></span>
<span class="giallo-l"><span>    fn degree(&amp;self) -&gt; usize {</span></span>
<span class="giallo-l"><span>        3</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>    </span></span>
<span class="giallo-l"><span>    // ...</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>In the second place, when implementing the AIR, we must specify the degree bound of the composition polynomial. In previous implementations, this number was set equal to the length of the trace. However, it is important to make it twice as large in this case. This ensures that when the prover defines the composition polynomial, she can split it into two parts. If we didn’t do this, the prover and verifier would work with the entire composition polynomial without splitting it, increasing the number of FRI rounds (optimization)</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>fn composition_poly_degree_bound(&amp;self) -&gt; usize {</span></span>
<span class="giallo-l"><span>    self.trace_length() * 2</span></span>
<span class="giallo-l"><span>}</span></span></code></pre><h3 id="boundary-constraints">Boundary Constraints</h3>
<p>Finally, let’s discuss how to define the boundary constraints. All boundary constraints related to the main trace will remain the same: we need to ensure that $a_0$, $a^\prime_0$, $v_0$, and $v^\prime_0$ match the values specified in the public inputs. Additionally, we need to include one more constraint to verify that $m_0$ is correctly defined according to the value described in the public input.</p>
<p>Now, the constraints on the auxiliary trace will change slightly compared to those used in the Grand Product. Following the same logic as we did that time, we must ensure, on one hand, that the first element of the auxiliary column $s$ is correctly constructed—that is, $s_0$ satisfies the equation described earlier in the <em>Auxiliary Trace</em> section. On the other hand, we need to check that the last element $s_{n-1}$ equals zero, ensuring that all terms cancel out and verifying that the trace corresponds to a permutation.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>fn boundary_constraints(</span></span>
<span class="giallo-l"><span>    &amp;self,</span></span>
<span class="giallo-l"><span>    rap_challenges: &amp;[FieldElement&lt;Self::FieldExtension&gt;],</span></span>
<span class="giallo-l"><span>) -&gt; BoundaryConstraints&lt;Self::FieldExtension&gt; {</span></span>
<span class="giallo-l"><span>    let a0 = &amp;self.pub_inputs.a0;</span></span>
<span class="giallo-l"><span>    let v0 = &amp;self.pub_inputs.v0;</span></span>
<span class="giallo-l"><span>    let a_sorted_0 = &amp;self.pub_inputs.a_sorted_0;</span></span>
<span class="giallo-l"><span>    let v_sorted_0 = &amp;self.pub_inputs.v_sorted_0;</span></span>
<span class="giallo-l"><span>    let m0 = &amp;self.pub_inputs.m0;</span></span>
<span class="giallo-l"><span>    let z = &amp;rap_challenges[0];</span></span>
<span class="giallo-l"><span>    let alpha = &amp;rap_challenges[1];</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // Main boundary constraints</span></span>
<span class="giallo-l"><span>    let c1 = BoundaryConstraint::new_main(0, 0, a0.clone().to_extension());</span></span>
<span class="giallo-l"><span>    let c2 = BoundaryConstraint::new_main(1, 0, v0.clone().to_extension());</span></span>
<span class="giallo-l"><span>    let c3 = BoundaryConstraint::new_main(2, 0, a_sorted_0.clone().to_extension());</span></span>
<span class="giallo-l"><span>    let c4 = BoundaryConstraint::new_main(3, 0, v_sorted_0.clone().to_extension());</span></span>
<span class="giallo-l"><span>    let c5 = BoundaryConstraint::new_main(4, 0, m0.clone().to_extension());</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // Auxiliary boundary constraints</span></span>
<span class="giallo-l"><span>    let unsorted_term = (-(a0 + v0 * alpha) + z).inv().unwrap();</span></span>
<span class="giallo-l"><span>    let sorted_term = (-(a_sorted_0 + v_sorted_0 * alpha) + z).inv().unwrap();</span></span>
<span class="giallo-l"><span>    let p0_value = m0 * sorted_term - unsorted_term;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let c_aux1 = BoundaryConstraint::new_aux(0, 0, p0_value);</span></span>
<span class="giallo-l"><span>    let c_aux2 = BoundaryConstraint::new_aux(</span></span>
<span class="giallo-l"><span>        0,</span></span>
<span class="giallo-l"><span>        self.trace_length - 1,</span></span>
<span class="giallo-l"><span>        FieldElement::&lt;Self::FieldExtension&gt;::zero(),</span></span>
<span class="giallo-l"><span>    );</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    BoundaryConstraints::from_constraints(vec![c1, c2, c3, c4, c5, c_aux1, c_aux2])</span></span>
<span class="giallo-l"><span>}</span></span></code></pre><h2 id="summary">Summary</h2>
<p>In this post, we explore the lookup argument method LogUp, using the example of a continuous read-only memory explained in a previous post. By changing the construction of some columns of the trace table, the permutation transition constraint, and some other small details, we adapted the implementation we already had for that same example using this new method.</p>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
