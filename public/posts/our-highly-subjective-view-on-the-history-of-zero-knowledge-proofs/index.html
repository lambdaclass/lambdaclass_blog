<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Our highly subjective view on the history of Zero-Knowledge Proofs - LambdaClass Blog</title>
    <meta name="description" content="Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">Our highly subjective view on the history of Zero-Knowledge Proofs</h1>
        
        <div class="page-meta">
            <time datetime="2024-02-17">February 17, 2024</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <p>Zero-knowledge, Succinct, Non-interactive ARguments of Knowledge (zk-SNARKs) are powerful cryptographic primitives that allow one party, the prover, to convince another party, the verifier, that a given statement is true without revealing anything else other than the validity of the statement. They have gained widespread attention due to their applications in verifiable private computation, providing proof of the correctness of the execution of computer programs and helping scale blockchains. We think SNARKs will have a significant impact in shaping our world, as we describe in our <a href="/transforming-the-future-with-zero-knowledge-proofs-fully-homomorphic-encryption-and-new-distributed-systems-algorithms/">post</a>. SNARKs acts as an umbrella for different types of proof systems, using different polynomial commitment schemes (PCS), arithmetization schemes, interactive oracle proofs (IOP) or probabilistically checkable proofs (PCP). However, the basic ideas and concepts date back to the mid-1980’s. The development significantly accelerated after the introduction of Bitcoin and Ethereum, which proved to be an exciting and powerful use case since you can scale them by using Zero-Knowledge proofs (generally called Validity Proofs for this particular usecase). SNARKs are an essential tool for blockchain scalability. As Ben-Sasson describes, the last years have seen a <a rel="noopener external" target="_blank" href="https://medium.com/starkware/cambrian-explosion-of-cryptographic-proofs-5740a41cdbd2">cambrian explosion of cryptographic proofs</a>. Each proof system offers advantages and disadvantages and was designed with certain tradeoffs in mind. Advances in hardware, better algorithms, new arguments, and gadgets result in enhanced performance and the birth of new systems. Many of them are used in production, and we keep pushing the boundaries. Will we have a general proof system for all applications or several systems suited for different needs? We think that it is unlikely that one proof system will rule them all because:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. The diversity of applications.</span></span>
<span class="giallo-l"><span>    2. The types of constraints we have (regarding memory, verification times, proving times).</span></span>
<span class="giallo-l"><span>    3. The need for robustness (if one proof system gets broken, we still have others).</span></span></code></pre>
<p>Even if proof systems change a lot, they all offer a significant property: proofs can be verified quickly. Having a layer that verifies proofs and can be easily adapted to handle new proof systems solves the difficulties associated with changing the base layer, such as Ethereum. To give an overview of the different characteristics of SNARKs:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * Cryptographic assumptions: collision-resistant hash functions, discrete log problem over elliptic curves, knowledge of exponent.</span></span>
<span class="giallo-l"><span>    * Transparent vs trusted setup.</span></span>
<span class="giallo-l"><span>    * Prover time: linear vs superlinear.</span></span>
<span class="giallo-l"><span>    * Verifier time: constant time, logarithmic, sublinear, linear.</span></span>
<span class="giallo-l"><span>    * Proof size.</span></span>
<span class="giallo-l"><span>    * Ease of recursion.</span></span>
<span class="giallo-l"><span>    * Arithmetization scheme.</span></span>
<span class="giallo-l"><span>    * Univariate vs multivariate polynomials.</span></span></code></pre>
<p>This post will look into the origins of SNARKs, some fundamental building blocks, and the rise (and fall) of different proof systems. The post does not intend to be an exhaustive analysis of proof systems. We focus instead on those that had an impact on us. Of course, these developments were only possible with the great work and ideas of the pioneers of this field.</p>
<h2 id="fundamentals">Fundamentals</h2>
<p>As we mentioned, zero-knowledge proofs are not new. The definitions, foundations, important theorems, and even important protocols were established from mid-1980s. Some of the key ideas and protocols that we use to build modern SNARKs were proposed in 1990s (the sumcheck protocol) or even before the advent of Bitcoin (GKR in 2007). The main problems with its adoption were related to the lack of a powerful usecase (internet was not as developed in the 1990s), and the amount of computational power needed.</p>
<h3 id="zero-knowledge-proofs-the-origins-1985-1989">Zero-knowledge proofs: the origins (1985/1989)</h3>
<p>The field of zero-knowledge proofs made its appearance in academic literature with the paper by <a rel="noopener external" target="_blank" href="https://people.csail.mit.edu/silvio/Selected%20Scientific%20Papers/Proof%20Systems/The_Knowledge_Complexity_Of_Interactive_Proof_Systems.pdf">Goldwasser, Micali and Rackoff</a>. For a discussion on the origins, you can see the <a rel="noopener external" target="_blank" href="https://www.youtube.com/watch?v=uchjTIlPzFo">following video</a>. The paper introduced the notions of completeness, soundness, and zero-knowledge, providing constructions for quadratic residuosity and quadratic non-residuosity.</p>
<h3 id="sumcheck-protocol-1992">Sumcheck protocol (1992)</h3>
<p>The <a href="/have-you-checked-your-sums/">sumcheck protocol</a> was proposed by <a rel="noopener external" target="_blank" href="https://dl.acm.org/doi/pdf/10.1145/146585.146605">Lund, Fortnow, Karloff, and Nisan</a> in 1992. It is one of the most important building blocks for succinct interactive proofs. It helps us reduce a claim over the sum of a multivariate polynomial’s evaluations to a single evaluation at a randomly chosen point.</p>
<h3 id="goldwasser-kalai-rothblum-gkr-2007">Goldwasser-Kalai-Rothblum (GKR) (2007)</h3>
<p>The <a rel="noopener external" target="_blank" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/12/2008-DelegatingComputation.pdf">GKR protocol</a> is an interactive protocol that has a prover that runs linearly in the number of gates of a circuit, while the verifier runs sublinearly in the size of the circuit. In the protocol, the prover and verifier agree on an arithmetic circuit of fan-in-two over a finite field of depth $d$, with layer $d$ corresponding to the input layer and layer $0$ being the output layer. The protocol starts with a claim regarding the output of the circuit, which is reduced to a claim over the values of the previous layer. Using recursion, we can turn this into a claim over the circuit’s inputs, which can be checked easily. These reductions are achieved via the sumcheck protocol.</p>
<h3 id="kzg-polynomial-commitment-scheme-2010">KZG polynomial commitment scheme (2010)</h3>
<p><a rel="noopener external" target="_blank" href="https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf">Kate, Zaverucha, and Goldberg</a> introduced in 2010 a commitment scheme for polynomials using a bilinear pairing group. The commitment consists of a single group element, and the committer can efficiently open the commitment to any correct evaluation of the polynomial. Moreover, due to batching techniques, the opening can be done to several evaluations. KZG commitments provided one of the basic building blocks for several efficient SNARKs, such as Pinocchio, Groth16, and Plonk. It is also at the heart of the <a rel="noopener external" target="_blank" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md">EIP-4844</a>. To get an intuition on batching techniques, you can see our post on the <a href="/mina-to-ethereum-bridge/">Mina-Ethereum bridge</a>.</p>
<h2 id="practical-snarks-using-elliptic-curves">Practical SNARKs using elliptic curves</h2>
<p>The first practical constructions for SNARKs appeared in 2013. These required a preprocessing step to generate the proving and verifying keys, and were program/circuit specific. These keys could be quite large, and depended on secret parameters which should remain unknown to the parties; otherwise, they could forge proofs. Transforming code into something that could be proven required compiling the code to a system of polynomial constraints. At first, this had to be done in a manual way, which is time-consuming and error-prone. The advances in this area tried to remove some of the main problems:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. Have more efficient provers.</span></span>
<span class="giallo-l"><span>    2. Reduce the amount of preprocessing.</span></span>
<span class="giallo-l"><span>    3. Having universal rather than circuit specific setups.</span></span>
<span class="giallo-l"><span>    4. Avoid having trusted setups.</span></span>
<span class="giallo-l"><span>    5. Developing ways to describe circuits using a high-level language, instead of writing the polynomial constraints manually.</span></span></code></pre><h3 id="pinocchio-2013">Pinocchio (2013)</h3>
<p><a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2013/279">Pinocchio</a> is the first practical, usable zk-SNARK. The SNARK is based on quadratic arithmetic programs (QAP). The proof size was originally 288 bytes. Pinocchio’s toolchain provided a compiler from C code to arithmetic circuits, which was further transformed into a QAP. The protocol required that the verifier generate the keys, which are circuit-specific. It used elliptic curve pairings to check the equations. The asymptotics for proof generation and key setup were linear in the computation size, and the verification time was linear in the size of the public inputs and outputs.</p>
<h3 id="groth-16-2016">Groth 16 (2016)</h3>
<p><a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2016/260.pdf">Groth</a> introduced a <a href="/groth16/">new argument of knowledge with increased performance</a> for problems described by an R1CS. It has the smallest proof size (only three group elements) and fast verification involving three pairings. It also involves a preprocessing step to obtain the structured reference string. The main drawback is that it requires a different trusted setup per program that we want to prove, which is inconvenient. Groth16 was used in ZCash.</p>
<h3 id="bulletproofs-ipa-2016">Bulletproofs &amp; IPA (2016)</h3>
<p>One of the weak points of the KZG PCS is that it requires a trusted setup. <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2016/263">Bootle et al.</a> introduced an efficient zero-knowledge argument system of openings of Pedersen commitments that satisfy an inner product relation. The inner product argument has a linear prover, with logarithmic communication and interaction, but with linear time verification. They also developed a polynomial commitment scheme that does not require a trusted setup. PCS using these ideas are used by Halo 2 and Kimchi.</p>
<h3 id="sonic-marlin-and-plonk-2019">Sonic, Marlin, and Plonk (2019)</h3>
<p><a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2019/099">Sonic</a>, <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2019/953">Plonk</a>, and <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2019/1047">Marlin</a> solve the problem of the trusted setup per program that we had in Groth16, by introducing universal and updatable structured reference strings. Marlin provides a proof system based on R1CS and is at the core of Aleo.</p>
<p><a href="/all-you-wanted-to-know-about-plonk/">Plonk</a> introduced a new arithmetization scheme (later called Plonkish) and the use of the grand-product check for the copy constraints. Plonkish also allowed the introduction of specialized gates for certain operations, the so-called custom gates. Several projects have customized versions of Plonk, including Aztec, zkSync, Polygon ZKEVM, Mina’s Kimchi, Plonky2, Halo 2, and Scroll, among others.</p>
<h3 id="lookups-2018-2020">Lookups (2018/2020)</h3>
<p>Gabizon and Williamson introduced <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2020/315">plookup</a> in 2020, using the grand product check to prove that a value is included in a precomputed value table. Though lookup arguments were previously presented in <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2018/380">Arya</a>, the construction required the determination of the multiplicities for the lookups, which makes the construction less efficient. The <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2022/086">PlonkUp</a> paper showed how to introduce the plookup argument into Plonk. The problem with these lookup arguments was that they forced the prover to pay the price for the whole table, independently of his number of lookups. This implies a considerable cost for large tables, and a lot of effort has been devoted to reducing the cost of the prover to just the number of lookups he uses.<br />
Haböck introduced <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2022/1530">LogUp</a>, which uses the logarithmic derivative to turn the grand-product check into a sum of reciprocals. LogUp is crucial for performance in the <a rel="noopener external" target="_blank" href="https://toposware.medium.com/beyond-limits-pushing-the-boundaries-of-zk-evm-9dd0c5ec9fca">Polygon ZKEVM</a>, where they need to split the whole table into several STARK modules. These modules have to be linked correctly, and cross-table lookups enforce this. The introduction of <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2023/1284">LogUp-GKR</a> uses the GKR protocol to increase the performance of LogUp. <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2022/621">Caulk</a> was the first scheme with prover time sublinear in the table size by using preprocessing time $\mathcal{O}(N \log N)$ and storage $\mathcal{O}(N)$, where $N$ is the table size. Several other schemes followed, such as <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2022/1565">Baloo</a>, <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2022/1447">flookup</a>, <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2022/1763">cq</a> and <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2022/957">caulk+</a>. <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2023/1216">Lasso</a> presents several improvements, avoiding committing to the table if it has a given structure. Besides, Lasso’s prover only pays for table entries accessed by the lookup operations. <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2023/1217">Jolt</a> leverages Lasso to prove the execution of a virtual machine via lookups</p>
<h3 id="spartan-2019">Spartan (2019)</h3>
<p><a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2019/550">Spartan</a> provides an IOP for circuits described using R1CS, leveraging the properties of multivariate polynomials and the sumcheck protocol. Using a suitable polynomial commitment scheme, it results in a transparent SNARK with a linear time prover.</p>
<h3 id="hyperplonk-2022">HyperPlonk (2022)</h3>
<p><a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2022/1355.pdf">HyperPlonk</a> builds on the ideas of Plonk using multivariate polynomials. Instead of quotients to check the constraints’ enforcement, it relies on the sumcheck protocol. It also supports constraints of a high degree without harming the running time of the prover. Since it relies on multivariate polynomials, there is no need to carry out FFTs, and the prover’s running time is linear in the circuit size. HyperPlonk introduces a new permutation IOP suitable for smaller fields and a sum check-based batch opening protocol, which reduces the prover’s work, proof size, and the verifier’s time.</p>
<h3 id="folding-schemes-2008-2021">Folding schemes (2008/2021)</h3>
<p><a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2021/370">Nova</a> introduces the idea of a folding scheme, which is a new approach to achieve incrementally verifiable computation (IVC). The concept of IVC dates back to <a rel="noopener external" target="_blank" href="https://https://iacr.org/archive/tcc2008/49480001/49480001.pdf">Valiant</a> who showed how to merge two proofs of length $k$ into a single proof of length $k$. The idea is that we can prove any long-running computation by recursively proving that the execution from step $i$ to step $ I + 1$ is correct and verifying a proof that shows that the transition from step $i - 1$ to step $i$ was correct. Nova deals well with uniform computations; it was later extended to handle different types of circuits with the introduction of <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2022/1758">Supernova</a>. Nova uses a relaxed version of R1CS and works over amicable elliptic curves. Working with amicable cycles of curves (for example, the Pasta curves) to achieve IVC is also used in Pickles, Mina’s main building block to achieve a succinct state. However, the idea of folding differs from recursive SNARK verification. The accumulator idea is more deeply connected to the concept of batching proofs. <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2019/1021.pdf">Halo</a> introduced the notion of accumulation as an alternative to recursive proof composition. <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2023/620">Protostar</a> provides a non-uniform IVC scheme for Plonk that supports high-degree gates and vector lookups.</p>
<h2 id="using-collision-resistant-hash-functions">Using collision-resistant hash functions</h2>
<p>Around the same time that Pinocchio was developed, there were some ideas to generate circuits/arithmetization schemes that could prove the correctness of the execution of a virtual machine. Even though developing the arithmetization of a virtual machine could be more complex or less efficient than writing dedicated circuits for some programs, it offered the advantage that any program, no matter how complicated, could be proven by showing that it was executed correctly in the virtual machine. The ideas in TinyRAM were later improved with the design of the Cairo vm, and subsequent virtual machines (such as zk-evms or general purpose zkvms). The use of collision-resistant hash functions removed the need for trusted setups or use of elliptic curve operations, at the expense of longer proofs.</p>
<h3 id="tinyram-2013">TinyRAM (2013)</h3>
<p>In <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2013/507">SNARKs for C</a>, they developed a SNARK based on a PCP to prove the correctness of the execution of a C program, which is compiled to TinyRAM, a reduced instruction set computer. The computer used a Harvard architecture with byte-level addressable random-access memory. Leveraging nondeterminism, the circuit’s size is quasilinear in the size of the computation, efficiently handling arbitrary and data-dependent loops, control flow, and memory accesses.</p>
<h3 id="starks-2018">STARKs (2018)</h3>
<p><a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2018/046">STARKs</a> were introduced by Ben Sasson et al. in 2018. They achieve $\mathcal{O}(\log^2 n )$ proof sizes, with fast prover and verifier, do not require a trusted setup, and are conjectured to be post-quantum secure. They were first used by Starkware/Starknet, together with the Cairo vm. Among its key introductions are the algebraic intermediate representation (AIR) and the <a href="/how-to-code-fri-from-scratch/">FRI protocol</a> (Fast Reed-Solomon Interactive Oracle Proof of Proximity). It is also used by other projects (Polygon Miden, Risc0, Winterfell, Neptune) or has seen adaptations of some components (zkSync’s Boojum, Plonky2, Starky).</p>
<h3 id="ligero-2017">Ligero (2017)</h3>
<p><a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2022/1608">Ligero</a> introduces a proof system that achieves proofs whose size is $\mathcal{O}(\sqrt{n})$, where $n$ is the size of the circuit. It arranges the polynomial coefficients in matrix form and uses linear codes.<br />
<a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2021/1043">Brakedown</a> builds on Ligero and introduces the idea of field-agnostic polynomial commitment schemes.</p>
<h2 id="some-new-developments">Some new developments</h2>
<p>The use of different proof systems in production showed the merits of each of the approaches, and led to new developments. For example, plonkish arithmetization offers a simple way to include custom gates and lookup arguments; FRI has shown great performance as PCS, leading to Plonky. Similarly, the use of the grand product check in AIR (leading to randomized AIR with preprocessing) improved its performance and simplified memory access arguments. Commitments based on hash functions have gained popularity, based on the speed of hash functions in hardware or the introduction of new SNARK-friendly hash functions.</p>
<h3 id="new-polynomial-commitment-schemes-2023">New polynomial commitment schemes (2023)</h3>
<p>With the advent of efficient SNARKs based on multivariate polynomials, such as Spartan or HyperPlonk, there has been an increased interest in new commitment schemes suited for this kind of polynomials. <a href="/snarks-on-binary-fields-binius/">Binius</a>, <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2023/917">Zeromorph</a>, and <a href="/how-does-basefold-polynomial-commitment-scheme-generalize-fri/">Basefold</a> all propose new forms to commit to multilinear polynomials. Binius offers the advantage of having zero overhead to represent data types (whereas many proof systems use at least 32-bit field elements to represent single bits) and works over binary fields. The commitment adapts brakedown, which was designed to be field agnostic. Basefold generalizes FRI to codes other than Reed-Solomon, leading to a field-agnostic PCS.</p>
<h3 id="customizable-constraint-systems-2023">Customizable Constraint Systems (2023)</h3>
<p><a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2023/552">CCS</a> generalizes R1CS while capturing R1CS, Plonkish, and AIR arithmetization without overheads. Using CCS with Spartan IOP yields SuperSpartan, which supports high-degree constraints without having the prover to incur cryptographic costs that scale with the degree of the constraint. In particular, SuperSpartan yields a SNARK for AIR with a linear time prover.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This post describes the advances of SNARKs since their introduction in the mid-1980s. Advances in computer science, mathematics, and hardware, together with the introduction of blockchain, have led to new and more efficient SNARKs, opening the door for many applications that could transform our society. Researchers and engineers have proposed improvements and adaptations to SNARKs according to their needs, focusing on proof size, memory use, transparent setup, post-quantum security, prover time, and verifier time. While there were originally two main lines (SNARKs vs STARKs), the boundary between both has begun to fade, trying to combine the advantages of the different proof systems. For example, combining different arithmetization schemes with new polynomial commitment schemes. We can expect that new proof systems will continue to rise, with increased performance, and it will be hard for some systems that require some time to adapt to keep up with these developments unless we can easily use these tools without having to change some core infrastructure.</p>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
