<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>First Lambda-Ingo ZK CTF: ZK challenges using LambdaWorks - LambdaClass Blog</title>
    <meta name="description" content="Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">First Lambda-Ingo ZK CTF: ZK challenges using LambdaWorks</h1>
        
        <div class="page-meta">
            <time datetime="2023-07-30">July 30, 2023</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <h1 id="introduction">Introduction</h1>
<p>From July 14th to 16th, we organized, together with <a rel="noopener external" target="_blank" href="https://www.ingonyama.com/">Ingonyama</a>, the <a rel="noopener external" target="_blank" href="https://ctf.ingonyama.com/">first Lambda-Ingo ZK capture the flag</a> (CTF), where more than 60 teams and 160 people participated. The CTF involved several challenges related to zero-knowledge proofs (using <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks">Lambdaworks</a>) and fully-homomorphic encryption. We are thrilled with the whole experience, especially our second collaboration with Ingonyama and all the sponsors of the Lambda ZK week in Paris.</p>
<p>The challenges were meant as example exercises to learn how to use Lambdaworks (especially the <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/starknet_stack_prover_lambdaworks">Starknet Stack</a> and <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks_plonk_prover">Plonk</a> provers) and get an intuition of different vulnerabilities and bugs that can arise in those systems. If you want to know more about the development of the library or wish to contribute, join our <a rel="noopener external" target="_blank" href="https://t.me/+98Whlzql7Hs0MDZh">telegram group</a>.</p>
<p>This post will present the challenges we submitted for the CTF and explain how they can be solved.</p>
<h1 id="plonk-challenges">Plonk challenges</h1>
<p>There were two challenges related to Plonk and possible vulnerabilities: <a rel="noopener external" target="_blank" href="https://blog.trailofbits.com/2022/04/18/the-frozen-heart-vulnerability-in-plonk/">frozen heart</a> and lack of blinding polynomials.</p>
<h2 id="obi-wan-s-search">Obi-Wan‚Äôs search</h2>
<h3 id="challenge">Challenge</h3>
<p>In his quest to stop the Sith‚Äôs menace, Obi-Wan Kenobi finds a (Sith) holocron, giving a zero-knowledge proof of the existence of the Sith‚Äôs galactic foundry (using galactic Plonk).</p>
<p>This place is rumored to contain several artifacts that could aid the Galactic Republic in its war efforts. The position, given by $(x , h , y)$, satisfies the equation $y = x \times h + b$.</p>
<p>After some study, Obi-Wan finds the values of $y$ and $b$ (which belong to Sith lore). The only problem is that, even with this knowledge, it may take him quite long to find the mysterious planet, and the situation in the Republic is desperate.</p>
<p>He also finds, together with the Holocron, a second item containing the SRS used to generate the proof, the prover, and a description of the circuit used.</p>
<p>Will he be able to find the position of the foundry before it is too late?</p>
<p>All the additional information is in this <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/obi_wan_search">repo</a>.</p>
<p>FLAG FORMAT: XXXX‚Ä¶‚Ä¶..XXXX The flag consists of the x and h concatenated and written in hex (for example, x=0x123, h=0x789, the FLAG=123789)</p>
<h3 id="solution">Solution</h3>
<p>The challenge is finding the witness variables $x$ and $h$, given the values $y$ and $b$. Usually, we could not get access to these values, given the zero-knowledge property the Plonk system has. However, in this case, there is one fault in the prover: there are no blinding polynomials, and we can exploit this vulnerability to recover the unknowns.</p>
<p>The first round of PLONK reads as follows:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>Compute polynomials a&#39;,b&#39;,c&#39; as the interpolation polynomials of the columns of T at the domain H.</span></span>
<span class="giallo-l"><span>Sample random b_1, b_2, b_3, b_4, b_5, b_6</span></span>
<span class="giallo-l"><span>Let</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>a := (b_1X + b_2)Z_H + a&#39;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>b := (b_3X + b_4)Z_H + b&#39;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>c := (b_5X + b_6)Z_H + c&#39;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>Compute [a]_1, [b]_1, [c]_1 and add them to the transcript.</span></span></code></pre>
<p>The multiples of $Z_H$ added to $ a‚Äô, b‚Äô, c‚Äô$ are called the blindings. In subsequent rounds, the polynomials $a, b, c$ are opened at the verifier‚Äôs chosen point.</p>
<p>The polynomials $Z_H$ are the vanishing polynomials over the interpolation domain; they are equal to zero at each point in the set $H$. Therefore, adding that polynomial (or any combination) will not change the value of the $a^\prime$, $b^\prime$, and $c^\prime$ polynomials, which must satisfy the circuit equations. However, at any other point, they will add some randomness and help conceal the values.</p>
<p>By checking the code of the challenge, the participants can find the following in <code>circuit.rs.</code></p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>/// Witness generator for the circuit `ASSERT y == x * h + b`</span></span>
<span class="giallo-l"><span>pub fn circuit_witness(</span></span>
<span class="giallo-l"><span>    b: &amp;FrElement,</span></span>
<span class="giallo-l"><span>    y: &amp;FrElement,</span></span>
<span class="giallo-l"><span>    h: &amp;FrElement,</span></span>
<span class="giallo-l"><span>    x: &amp;FrElement,</span></span>
<span class="giallo-l"><span>) -&gt; Witness&lt;FrField&gt; {</span></span>
<span class="giallo-l"><span>    let z = x * h;</span></span>
<span class="giallo-l"><span>    let w = &amp;z + b;</span></span>
<span class="giallo-l"><span>    let empty = b.clone();</span></span>
<span class="giallo-l"><span>    Witness {</span></span>
<span class="giallo-l"><span>        a: vec![</span></span>
<span class="giallo-l"><span>            b.clone(),</span></span>
<span class="giallo-l"><span>            y.clone(),</span></span>
<span class="giallo-l"><span>            x.clone(),</span></span>
<span class="giallo-l"><span>            b.clone(),</span></span>
<span class="giallo-l"><span>            w.clone(),</span></span>
<span class="giallo-l"><span>            empty.clone(),</span></span>
<span class="giallo-l"><span>            empty.clone(),</span></span>
<span class="giallo-l"><span>            empty.clone(),</span></span>
<span class="giallo-l"><span>        ],</span></span>
<span class="giallo-l"><span>        ...</span></span></code></pre>
<p>This code reveals that the way prover constructs the $V$ matrix is</p>
<table><thead><tr><th>A</th><th>B</th><th>C</th></tr></thead><tbody>
<tr><td>b</td><td>-</td><td>-</td></tr>
<tr><td>y</td><td>-</td><td>-</td></tr>
<tr><td>x</td><td>h</td><td>z</td></tr>
<tr><td>b</td><td>z</td><td>w</td></tr>
<tr><td>w</td><td>y</td><td>-</td></tr>
</tbody></table>
<ul>
<li>| - | -</li>
<li>| - | -</li>
<li>| - | -</li>
</ul>
<p>Where <code>-</code> are empty values. The PLONK implementation of <code>lambdaworks-plonk</code> requires the empty values to be filled in with the first public input. So, in this case, the values <code>-</code> will be replaced by $b$. This can be seen directly from the code of the challenge.</p>
<p>Therefore, the polynomial $a‚Äô$, being the interpolation of the column <code>A</code> is</p>
<p>$$a‚Äô = b L_1 + y L_2 + x L_3 + b L_4 + w L_5 + b L_6 + b L_7 + b L_8,$$</p>
<p>where $L_i$ is the $i$-th polynomial of the Lagrange basis. Also, the value $w$ is equal to $y$. That can be seen from the code and the fact that the last row of the $V$ matrix corresponds to the assertion that the actual output of the circuit is equal to the claimed output $y$.</p>
<p>During the proof, the verifier sends a challenge $\zeta$ and the prover opens, among other things, the polynomial $a$ at $\zeta$. Since the implementation of the challenge omits blindings, $a(\zeta) = a‚Äô (\zeta)$, and we get</p>
<p>$$a(\zeta) = b L_1(\zeta) + y L_2(\zeta) + x L_3(\zeta) + b L_4(\zeta) + y L_5(\zeta) + b L_6(\zeta) + b L_7(\zeta) + b L_8(\zeta).$$</p>
<p>All the terms in this expression are known to the participants except for $x$, which can be cleared from the equation. To do so, the participants need to know how to recover the challenges to get $\zeta$ and how to compute the Lagrange polynomials evaluated at it.</p>
<p>The second private input $h$ can be computed as $h = (y - b) / x$. The following piece of code recovers the challenge $\zeta$, computes the Lagrange polynomials at $\zeta$ and recovers $x$ and $h$:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>fn compute_private_input&lt;F, CS&gt;(</span></span>
<span class="giallo-l"><span>    proof: &amp;Proof&lt;F, CS&gt;,</span></span>
<span class="giallo-l"><span>    vk: &amp;VerificationKey&lt;CS::Commitment&gt;,</span></span>
<span class="giallo-l"><span>    public_input: &amp;[FieldElement&lt;F&gt;],</span></span>
<span class="giallo-l"><span>    common_preprocessed_input: &amp;CommonPreprocessedInput&lt;F&gt;,</span></span>
<span class="giallo-l"><span>) -&gt; (FieldElement&lt;F&gt;, FieldElement&lt;F&gt;)</span></span>
<span class="giallo-l"><span>where</span></span>
<span class="giallo-l"><span>    F: IsField,</span></span>
<span class="giallo-l"><span>    CS: IsCommitmentScheme&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    CS::Commitment: Serializable,</span></span>
<span class="giallo-l"><span>    FieldElement&lt;F&gt;: ByteConversion,</span></span>
<span class="giallo-l"><span>{</span></span>
<span class="giallo-l"><span>    // Replay interactions to recover challenges. We are only interested in \zeta</span></span>
<span class="giallo-l"><span>    let mut transcript = new_strong_fiat_shamir_transcript::&lt;F, CS&gt;(vk, public_input);</span></span>
<span class="giallo-l"><span>    transcript.append(&amp;proof.a_1.serialize());</span></span>
<span class="giallo-l"><span>    transcript.append(&amp;proof.b_1.serialize());</span></span>
<span class="giallo-l"><span>    transcript.append(&amp;proof.c_1.serialize());</span></span>
<span class="giallo-l"><span>    let _beta = FieldElement::from_bytes_be(&amp;transcript.challenge()).unwrap();</span></span>
<span class="giallo-l"><span>    let _gamma = FieldElement::from_bytes_be(&amp;transcript.challenge()).unwrap();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    transcript.append(&amp;proof.z_1.serialize());</span></span>
<span class="giallo-l"><span>    let _alpha = FieldElement::from_bytes_be(&amp;transcript.challenge()).unwrap();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    transcript.append(&amp;proof.t_lo_1.serialize());</span></span>
<span class="giallo-l"><span>    transcript.append(&amp;proof.t_mid_1.serialize());</span></span>
<span class="giallo-l"><span>    transcript.append(&amp;proof.t_hi_1.serialize());</span></span>
<span class="giallo-l"><span>    let zeta = FieldElement::from_bytes_be(&amp;transcript.challenge()).unwrap();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // Compute `x` and `h`</span></span>
<span class="giallo-l"><span>    let [b, y] = [&amp;public_input[0], &amp;public_input[1]];</span></span>
<span class="giallo-l"><span>    let n = common_preprocessed_input.n as u64;</span></span>
<span class="giallo-l"><span>    let omega = &amp;common_preprocessed_input.omega;</span></span>
<span class="giallo-l"><span>    let domain = &amp;common_preprocessed_input.domain;</span></span>
<span class="giallo-l"><span>    // Compute L_1(\zeta). This polynomial is equal to zero at</span></span>
<span class="giallo-l"><span>    //each point in the domain, except for the first one</span></span>
<span class="giallo-l"><span>    //where it is equal to unity</span></span>
<span class="giallo-l"><span>    let l1_zeta =</span></span>
<span class="giallo-l"><span>        (zeta.pow(n) - FieldElement::one()) / (&amp;zeta - FieldElement::one()) / FieldElement::from(n);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let mut li_zeta = l1_zeta;</span></span>
<span class="giallo-l"><span>    let mut lagrange_basis_zeta = Vec::new();</span></span>
<span class="giallo-l"><span>    lagrange_basis_zeta.push(li_zeta.clone());</span></span>
<span class="giallo-l"><span>    // Compute all other Lagrange polynomials using</span></span>
<span class="giallo-l"><span>    // the relationship among them</span></span>
<span class="giallo-l"><span>    for i in 1..domain.len() {</span></span>
<span class="giallo-l"><span>        li_zeta = omega * &amp;li_zeta * ((&amp;zeta - &amp;domain[i - 1]) / (&amp;zeta - &amp;domain[i]));</span></span>
<span class="giallo-l"><span>        lagrange_basis_zeta.push(li_zeta.clone());</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>    // Recover x by relating a at \zeta and the public inputs</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let x = (&amp;proof.a_zeta</span></span>
<span class="giallo-l"><span>        - b * &amp;lagrange_basis_zeta[3]</span></span>
<span class="giallo-l"><span>        - y * &amp;lagrange_basis_zeta[4]</span></span>
<span class="giallo-l"><span>        - b * &amp;lagrange_basis_zeta[0]</span></span>
<span class="giallo-l"><span>        - y * &amp;lagrange_basis_zeta[1]</span></span>
<span class="giallo-l"><span>        - b * &amp;lagrange_basis_zeta[5]</span></span>
<span class="giallo-l"><span>        - b * &amp;lagrange_basis_zeta[6]</span></span>
<span class="giallo-l"><span>        - b * &amp;lagrange_basis_zeta[7])</span></span>
<span class="giallo-l"><span>        / &amp;lagrange_basis_zeta[2];</span></span>
<span class="giallo-l"><span>    // Recover h given that x is known    </span></span>
<span class="giallo-l"><span>    let h = (y - b) / &amp;x;</span></span>
<span class="giallo-l"><span>    (x, h)</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>The solution for the coordinates is:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. `x: &quot;2194826651b32ca1055614fc6e2f2de86eab941d2c55bd467268e9&quot;`,</span></span>
<span class="giallo-l"><span>    2. `h: &quot;432904cca36659420aac29f8dc5e5bd0dd57283a58ab7a8ce4d1ca&quot;`.</span></span></code></pre>
<p>The flag is the concatenation of the two: <code>FLAG: 2194826651b32ca1055614fc6e2f2de86eab941d2c55bd467268e9432904cca36659420aac29f8dc5e5bd0dd57283a58ab7a8ce4d1ca</code></p>
<h2 id="loki-s-trapdoor">Loki‚Äôs trapdoor</h2>
<h3 id="challenge-1">Challenge</h3>
<p>After successfully breaking into Loki‚Äôs vault and getting access to some of his finest treasures and weapons, you spot a small trapdoor under a carpet.</p>
<p>The trapdoor is locked and contains a device with a PLONK prover. It says: Prove that the point $( 1 , y)$ belongs to the elliptic curve $y^2 = x^3 + 4$.</p>
<p>You see that, in order to prove this, you need that $y^2 ‚àí x^3 ‚àí 4$ is equal to zero, which corresponds to the circuit for the prover provided by Loki.</p>
<p>Can you open the trapdoor?</p>
<p>nc 44.203.113.160 4000</p>
<p>Additional information is in this <a rel="noopener external" target="_blank" href="https://github.com/ingonyama-zk/ZKCTF-lokis-trapdoor">repo</a>.</p>
<p>FLAG FORMAT: ZKCTF{XXX‚Ä¶XXX}</p>
<h3 id="solution-1">Solution</h3>
<p>This challenge exploits the frozen heart vulnerability, which arises when the Fiat-Shamir transformation is not implemented correctly. The main problem is that $(1,y)$ is not a point belonging to the BLS12-381 elliptic curve. If so, $y^2 = 1^3 + 4 = 5$ but $5$ is not a quadratic residue modulo the BLS12-381 prime. Therefore, the way to solve the challenge must be by creating a false proof.</p>
<p>The circuit is:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>PUBLIC INPUT: x</span></span>
<span class="giallo-l"><span>PUBLIC INPUT: y</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>ASSERT 0 == y^2 - x^3 - 4</span></span></code></pre>
<p>And it instantiated over the <code>BLS12 381</code> scalar field.</p>
<p>The vulnerability stems from a bug in the implementation of strong Fiat-Shamir. A correct implementation should add, among other things, all the public inputs to the transcript at initialization. If a public input is not added to the transcript and is in control of the attacker, they can forge a fake proof. Fixing <code>x=1</code> leaves <code>y</code> under the user‚Äôs control. We can see that the Fiat-Shamir transcript does not incorporate the public input, as shown <a rel="noopener external" target="_blank" href="https://github.com/ingonyama-zk/ZKCTF-lokis-trapdoor/blob/69eba0d41d56a7831b4532d5adc2c21720764885/lambdaworks_plonk_prover/src/setup.rs#L70C1-L73C23">here</a></p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub fn new_strong_fiat_shamir_transcript&lt;F, CS&gt;(</span></span>
<span class="giallo-l"><span>    vk: &amp;VerificationKey&lt;CS::Commitment&gt;,</span></span>
<span class="giallo-l"><span>    _public_input: &amp;[FieldElement&lt;F&gt;],</span></span>
<span class="giallo-l"><span>) -&gt; DefaultTranscript</span></span></code></pre>
<p>The attack is described in Section V of <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2023/691.pdf">Weak Fiat-Shamir Attacks on Modern Proof Systems</a>.</p>
<p>Here is a summary of the attack:</p>
<p><img src="/images/external/B10en9A93.png" alt="" /></p>
<p>Instead of taking random polynomials (steps (1) to (7)), the current solution takes a valid proof for the pair <code>x=0</code>, <code>y=2</code> and uses it to forge a <code>y</code> for <code>x=1</code> that‚Äôs compatible with the original proof.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>#[allow(unused)]</span></span>
<span class="giallo-l"><span>fn forge_y_for_valid_proof&lt;F: IsField, CS: IsCommitmentScheme&lt;F&gt;&gt;(</span></span>
<span class="giallo-l"><span>    proof: &amp;Proof&lt;F, CS&gt;,</span></span>
<span class="giallo-l"><span>    vk: &amp;VerificationKey&lt;CS::Commitment&gt;,</span></span>
<span class="giallo-l"><span>    common_preprocessed_input: CommonPreprocessedInput&lt;F&gt;,</span></span>
<span class="giallo-l"><span>) -&gt; FieldElement&lt;F&gt;</span></span>
<span class="giallo-l"><span>where</span></span>
<span class="giallo-l"><span>    CS::Commitment: Serializable,</span></span>
<span class="giallo-l"><span>    FieldElement&lt;F&gt;: ByteConversion,</span></span>
<span class="giallo-l"><span>{</span></span>
<span class="giallo-l"><span>    // Replay interactions like the verifier</span></span>
<span class="giallo-l"><span>    let mut transcript = new_strong_fiat_shamir_transcript::&lt;F, CS&gt;(vk, &amp;[]);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    transcript.append(&amp;proof.a_1.serialize());</span></span>
<span class="giallo-l"><span>    transcript.append(&amp;proof.b_1.serialize());</span></span>
<span class="giallo-l"><span>    transcript.append(&amp;proof.c_1.serialize());</span></span>
<span class="giallo-l"><span>    let beta = FieldElement::from_bytes_be(&amp;transcript.challenge()).unwrap();</span></span>
<span class="giallo-l"><span>    let gamma = FieldElement::from_bytes_be(&amp;transcript.challenge()).unwrap();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    transcript.append(&amp;proof.z_1.serialize());</span></span>
<span class="giallo-l"><span>    let alpha = FieldElement::from_bytes_be(&amp;transcript.challenge()).unwrap();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    transcript.append(&amp;proof.t_lo_1.serialize());</span></span>
<span class="giallo-l"><span>    transcript.append(&amp;proof.t_mid_1.serialize());</span></span>
<span class="giallo-l"><span>    transcript.append(&amp;proof.t_hi_1.serialize());</span></span>
<span class="giallo-l"><span>    let zeta = &amp;FieldElement::from_bytes_be(&amp;transcript.challenge()).unwrap();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // Forge public input</span></span>
<span class="giallo-l"><span>    let zh_zeta = zeta.pow(common_preprocessed_input.n) - FieldElement::one();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let omega = &amp;common_preprocessed_input.omega;</span></span>
<span class="giallo-l"><span>    let n = common_preprocessed_input.n as u64;</span></span>
<span class="giallo-l"><span>    let one = &amp;FieldElement::one();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let l1_zeta = ((zeta.pow(n) - one) / (zeta - one)) / FieldElement::from(n);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let l2_zeta = omega * &amp;l1_zeta * (zeta - one) / (zeta - omega);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let mut p_constant_zeta = &amp;alpha</span></span>
<span class="giallo-l"><span>        * &amp;proof.z_zeta_omega</span></span>
<span class="giallo-l"><span>        * (&amp;proof.c_zeta + &amp;gamma)</span></span>
<span class="giallo-l"><span>        * (&amp;proof.a_zeta + &amp;beta * &amp;proof.s1_zeta + &amp;gamma)</span></span>
<span class="giallo-l"><span>        * (&amp;proof.b_zeta + &amp;beta * &amp;proof.s2_zeta + &amp;gamma);</span></span>
<span class="giallo-l"><span>    p_constant_zeta = p_constant_zeta - &amp;l1_zeta * &amp;alpha * &amp;alpha;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let p_zeta = p_constant_zeta + &amp;proof.p_non_constant_zeta;</span></span>
<span class="giallo-l"><span>    -(p_zeta + l1_zeta * one - (&amp;zh_zeta * &amp;proof.t_zeta)) / l2_zeta</span></span>
<span class="giallo-l"><span>}</span></span></code></pre><h1 id="starks-challenge">STARKs challenge</h1>
<h2 id="challenge-2">Challenge</h2>
<p>Good morning hacker.</p>
<p>If you are reading this, the date should be July 7th, 2023, and you should be checking the Lambda-Ingoyama CTF challenges site.</p>
<p>Hopefully, we managed to hijack the site, and you are reading this now. We are not allowed to say much, but you must know it‚Äôs of utmost importance that you win this challenge.</p>
<p>So, we have decided to help. Don‚Äôt worry; it should be easy. We have found the right exploit to solve and are forwarding the solution to you.</p>
<p>If something goes wrong, we leave some additional data we have collected. We don‚Äôt know if it‚Äôs helpful, but we hope it can help.</p>
<p>It‚Äôs now up to you to take the flag. We wish you good luck.</p>
<p><a rel="noopener external" target="_blank" href="https://github.com/ingonyama-zk/ZKCTF-ch3-client">https://github.com/ingonyama-zk/ZKCTF-ch3-client</a></p>
<p>FLAG FORMAT: ZKCTF{XXX‚Ä¶XXX}</p>
<h2 id="solution-2">Solution</h2>
<p>The key point here is that the STARK prover does only one query, which makes the soundness error significant. This vulnerability was present in an early implementation of Lambdaworks (see this <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/starknet_stack_prover_lambdaworks/pull/66">PR</a>) and was discovered by <a rel="noopener external" target="_blank" href="https://github.com/mcarilli">Michael Carilli</a> (to whom we are really grateful).</p>
<p>The first step is to send the data to an endpoint of the server, which should reply with something like ‚ÄúExpired proof.‚Äù After that, the next step is to inspect the proof. Most of the data will not be relevant. Counting the number of queries, we realize there is only 1. Now it remains to see how to exploit it.</p>
<p>Some additional data needs to be used, such as the offset, the constraints, and the blowup factor. Offsets and constraints are hinted at in the data. The blowup factor can be guessed or hinted at.</p>
<p>We can now move to break the STARK protocol, taking advantage of the FRI soundness error, which is quite large for one query. We must first pass the consistency check at the out-of-domain point $z$ between the composition polynomial and the trace polynomials. The verifier performs this check in <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/starknet_stack_prover_lambdaworks/blob/23eb9df082ec4de4f1d44c6760be4b7a13ea24b1/src/starks/verifier.rs#L208">step 2</a>. We can pass this test automatically if we calculate the value of the polynomial directly from the trace polynomials:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub fn composition_poly_ood_evaluation_exact_from_trace&lt;F: IsFFTField, A: AIR&lt;Field = F&gt;&gt;(</span></span>
<span class="giallo-l"><span>    air: &amp;A,</span></span>
<span class="giallo-l"><span>    trace_ood_frame_evaluations: &amp;Frame&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    domain: &amp;Domain&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    z: &amp;FieldElement&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    rap_challenges: &amp;A::RAPChallenges,</span></span>
<span class="giallo-l"><span>    boundary_coeffs: &amp;[(FieldElement&lt;F&gt;, FieldElement&lt;F&gt;)],</span></span>
<span class="giallo-l"><span>    transition_coeffs: &amp;[(FieldElement&lt;F&gt;, FieldElement&lt;F&gt;)],</span></span>
<span class="giallo-l"><span>) -&gt; FieldElement&lt;F&gt; {</span></span>
<span class="giallo-l"><span>    let _public_input = air.pub_inputs();</span></span>
<span class="giallo-l"><span>    let boundary_constraints = air.boundary_constraints(rap_challenges);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let n_trace_cols = air.context().trace_columns;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let boundary_constraint_domains =</span></span>
<span class="giallo-l"><span>        boundary_constraints.generate_roots_of_unity(&amp;domain.trace_primitive_root, &amp;[n_trace_cols]);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let values = boundary_constraints.values(&amp;[n_trace_cols]);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // Following naming conventions from https://www.notamonadtutorial.com/diving-deep-fri/</span></span>
<span class="giallo-l"><span>    let mut boundary_c_i_evaluations = Vec::with_capacity(n_trace_cols);</span></span>
<span class="giallo-l"><span>    let mut boundary_quotient_degrees = Vec::with_capacity(n_trace_cols);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    for trace_idx in 0..n_trace_cols {</span></span>
<span class="giallo-l"><span>        let trace_evaluation = &amp;trace_ood_frame_evaluations.get_row(0)[trace_idx];</span></span>
<span class="giallo-l"><span>        let boundary_constraints_domain = &amp;boundary_constraint_domains[trace_idx];</span></span>
<span class="giallo-l"><span>        let boundary_interpolating_polynomial =</span></span>
<span class="giallo-l"><span>            &amp;Polynomial::interpolate(boundary_constraints_domain, &amp;values[trace_idx])</span></span>
<span class="giallo-l"><span>                .expect(&quot;xs and ys have equal length and xs are unique&quot;);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        let boundary_zerofier =</span></span>
<span class="giallo-l"><span>            boundary_constraints.compute_zerofier(&amp;domain.trace_primitive_root, trace_idx);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        let boundary_quotient_ood_evaluation = (trace_evaluation</span></span>
<span class="giallo-l"><span>            - boundary_interpolating_polynomial.evaluate(z))</span></span>
<span class="giallo-l"><span>            / boundary_zerofier.evaluate(z);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        let boundary_quotient_degree = air.trace_length() - boundary_zerofier.degree() - 1;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        boundary_c_i_evaluations.push(boundary_quotient_ood_evaluation);</span></span>
<span class="giallo-l"><span>        boundary_quotient_degrees.push(boundary_quotient_degree);</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let trace_length = air.trace_length();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let boundary_term_degree_adjustment = air.composition_poly_degree_bound() - trace_length;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let boundary_quotient_ood_evaluations: Vec&lt;FieldElement&lt;F&gt;&gt; = boundary_c_i_evaluations</span></span>
<span class="giallo-l"><span>        .iter()</span></span>
<span class="giallo-l"><span>        .zip(boundary_coeffs)</span></span>
<span class="giallo-l"><span>        .map(|(poly_eval, (alpha, beta))| {</span></span>
<span class="giallo-l"><span>            poly_eval * (alpha * &amp;z.pow(boundary_term_degree_adjustment) + beta)</span></span>
<span class="giallo-l"><span>        })</span></span>
<span class="giallo-l"><span>        .collect();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let boundary_quotient_ood_evaluation = boundary_quotient_ood_evaluations</span></span>
<span class="giallo-l"><span>        .iter()</span></span>
<span class="giallo-l"><span>        .fold(FieldElement::&lt;F&gt;::zero(), |acc, x| acc + x);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let transition_ood_frame_evaluations =</span></span>
<span class="giallo-l"><span>        air.compute_transition(trace_ood_frame_evaluations, rap_challenges);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let transition_exemptions = air.transition_exemptions();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let x_n = Polynomial::new_monomial(FieldElement::&lt;F&gt;::one(), trace_length);</span></span>
<span class="giallo-l"><span>    let x_n_1 = x_n - FieldElement::&lt;F&gt;::one();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let divisors = transition_exemptions</span></span>
<span class="giallo-l"><span>        .into_iter()</span></span>
<span class="giallo-l"><span>        .map(|exemption| x_n_1.clone() / exemption)</span></span>
<span class="giallo-l"><span>        .collect::&lt;Vec&lt;Polynomial&lt;FieldElement&lt;F&gt;&gt;&gt;&gt;();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let mut denominators = Vec::with_capacity(divisors.len());</span></span>
<span class="giallo-l"><span>    for divisor in divisors.iter() {</span></span>
<span class="giallo-l"><span>        denominators.push(divisor.evaluate(z));</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>    FieldElement::inplace_batch_inverse(&amp;mut denominators);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let mut degree_adjustments = Vec::with_capacity(divisors.len());</span></span>
<span class="giallo-l"><span>    for transition_degree in air.context().transition_degrees().iter() {</span></span>
<span class="giallo-l"><span>        let degree_adjustment =</span></span>
<span class="giallo-l"><span>            air.composition_poly_degree_bound() - (air.trace_length() * (transition_degree - 1));</span></span>
<span class="giallo-l"><span>        degree_adjustments.push(z.pow(degree_adjustment));</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>    let transition_c_i_evaluations_sum =</span></span>
<span class="giallo-l"><span>        ConstraintEvaluator::&lt;F, A&gt;::compute_constraint_composition_poly_evaluations_sum(</span></span>
<span class="giallo-l"><span>            &amp;transition_ood_frame_evaluations,</span></span>
<span class="giallo-l"><span>            &amp;denominators,</span></span>
<span class="giallo-l"><span>            &amp;degree_adjustments,</span></span>
<span class="giallo-l"><span>            transition_coeffs,</span></span>
<span class="giallo-l"><span>        );</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    &amp;boundary_quotient_ood_evaluation + transition_c_i_evaluations_sum</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>The prover splits the composition polynomial between even and odd terms, $H_1 (z^2 )$ and $H_2 (z^2 )$. The verifier has to compute $H(z)$ from the trace polynomials and then check that<br />
$H(z) = H_1 (z^2 ) + z H_2 (z^2 )$<br />
We can enforce this check by making sure that the verifier gets $H_1 (z^2 ) = H(z)$ and $H_2 (z^2 ) = 0$. Of course, this will generate some issues at other parts of the verifier, such as the DEEP composition polynomial. The DEEP composition polynomial allows us to check that all polynomials have been appropriately evaluated at $z$,<br />
$P_0 (x) = \sum_j \gamma_j \frac{t_j (x) - t_j (z)}{x - z} + \sum_j \gamma^\prime_j \frac{t_j (x) - t_j (g z)}{x - gz} + \gamma \frac{H_1 (x) - H_1 (z^2 )}{x - z^2} + \gamma^\prime \frac{H_2 (x) - H_2 (z^2 )}{x - z^2}$</p>
<p>Of course, if we send false evaluations of the polynomials $H_1(x^2 )$ and $H_2 (x^2 )$, the last terms will not be low-degree polynomials and should not satisfy FRI testing. However, we can evaluate exactly the values of $(H_k (\omega_j) - H_k(z^2 ))/( \omega_j - z^2 )$ and create a polynomial which passes through as many evaluations as the low-degree test allows us (which is the trace length) by interpolation. The following function computes the DEEP composition polynomial</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>fn compute_deep_composition_poly_evil&lt;A: AIR, F: IsFFTField&gt;(</span></span>
<span class="giallo-l"><span>    air: &amp;A,</span></span>
<span class="giallo-l"><span>    domain: &amp;Domain&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    trace_polys: &amp;[Polynomial&lt;FieldElement&lt;F&gt;&gt;],</span></span>
<span class="giallo-l"><span>    round_2_result: &amp;Round2&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    round_3_result: &amp;Round3&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    z: &amp;FieldElement&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    primitive_root: &amp;FieldElement&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    composition_poly_gammas: &amp;[FieldElement&lt;F&gt;; 2],</span></span>
<span class="giallo-l"><span>    trace_terms_gammas: &amp;[FieldElement&lt;F&gt;],</span></span>
<span class="giallo-l"><span>) -&gt; Polynomial&lt;FieldElement&lt;F&gt;&gt;</span></span>
<span class="giallo-l"><span>where</span></span>
<span class="giallo-l"><span>    lambdaworks_math::field::element::FieldElement&lt;F&gt;: lambdaworks_math::traits::ByteConversion,</span></span>
<span class="giallo-l"><span>{</span></span>
<span class="giallo-l"><span>    // Compute composition polynomial terms of the deep composition polynomial.</span></span>
<span class="giallo-l"><span>    let h_1 = &amp;round_2_result.composition_poly_even;</span></span>
<span class="giallo-l"><span>    let h_1_z2 = &amp;round_3_result.composition_poly_even_ood_evaluation;</span></span>
<span class="giallo-l"><span>    let h_2 = &amp;round_2_result.composition_poly_odd;</span></span>
<span class="giallo-l"><span>    let h_2_z2 = &amp;round_3_result.composition_poly_odd_ood_evaluation;</span></span>
<span class="giallo-l"><span>    let gamma = &amp;composition_poly_gammas[0];</span></span>
<span class="giallo-l"><span>    let gamma_p = &amp;composition_poly_gammas[1];</span></span>
<span class="giallo-l"><span>    let z_squared = z.square();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // ùõæ ( H‚ÇÅ ‚àí H‚ÇÅ(z¬≤) ) / ( X ‚àí z¬≤ )</span></span>
<span class="giallo-l"><span>    let h_1_term = {</span></span>
<span class="giallo-l"><span>        let x = Polynomial::new_monomial(FieldElement::one(), 1);</span></span>
<span class="giallo-l"><span>        let h_1_num = gamma * (h_1 - h_1_z2);</span></span>
<span class="giallo-l"><span>        let h_1_denom = &amp;x - &amp;z_squared;</span></span>
<span class="giallo-l"><span>        interp_from_num_denom(&amp;h_1_num, &amp;h_1_denom, domain)</span></span>
<span class="giallo-l"><span>    };</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // ùõæ&#39; ( H‚ÇÇ ‚àí H‚ÇÇ(z¬≤) ) / ( X ‚àí z¬≤ )</span></span>
<span class="giallo-l"><span>    let h_2_term = {</span></span>
<span class="giallo-l"><span>        let x = Polynomial::new_monomial(FieldElement::one(), 1);</span></span>
<span class="giallo-l"><span>        let h_2_num = gamma_p * (h_2 - h_2_z2);</span></span>
<span class="giallo-l"><span>        let h_2_denom = &amp;x - &amp;z_squared;</span></span>
<span class="giallo-l"><span>        interp_from_num_denom(&amp;h_2_num, &amp;h_2_denom, domain)</span></span>
<span class="giallo-l"><span>    };</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // Get trace evaluations needed for the trace terms of the deep composition polynomial</span></span>
<span class="giallo-l"><span>    let transition_offsets = &amp;air.context().transition_offsets;</span></span>
<span class="giallo-l"><span>    let trace_frame_evaluations = &amp;round_3_result.trace_ood_evaluations;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // Compute the sum of all the deep composition polynomial trace terms.</span></span>
<span class="giallo-l"><span>    // There is one term for every trace polynomial and every row in the frame.</span></span>
<span class="giallo-l"><span>    // ‚àë ‚±º‚Çñ [ ùõæ‚Çñ ( t‚±º ‚àí t‚±º(z) ) / ( X ‚àí zg·µè )]</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let mut trace_terms = Polynomial::zero();</span></span>
<span class="giallo-l"><span>    for (i, t_j) in trace_polys.iter().enumerate() {</span></span>
<span class="giallo-l"><span>        let i_times_trace_frame_evaluation = i * trace_frame_evaluations.len();</span></span>
<span class="giallo-l"><span>        let iter_trace_gammas = trace_terms_gammas</span></span>
<span class="giallo-l"><span>            .iter()</span></span>
<span class="giallo-l"><span>            .skip(i_times_trace_frame_evaluation);</span></span>
<span class="giallo-l"><span>        for ((evaluations, offset), elemen_trace_gamma) in trace_frame_evaluations</span></span>
<span class="giallo-l"><span>            .iter()</span></span>
<span class="giallo-l"><span>            .zip(transition_offsets)</span></span>
<span class="giallo-l"><span>            .zip(iter_trace_gammas)</span></span>
<span class="giallo-l"><span>        {</span></span>
<span class="giallo-l"><span>            </span></span>
<span class="giallo-l"><span>            let t_j_z = evaluations[i].clone();</span></span>
<span class="giallo-l"><span>            </span></span>
<span class="giallo-l"><span>            let z_shifted = z * primitive_root.pow(*offset);</span></span>
<span class="giallo-l"><span>            </span></span>
<span class="giallo-l"><span>            let mut poly = t_j - t_j_z;</span></span>
<span class="giallo-l"><span>            poly.ruffini_division_inplace(&amp;z_shifted);</span></span>
<span class="giallo-l"><span>            trace_terms = trace_terms + poly * elemen_trace_gamma;</span></span>
<span class="giallo-l"><span>        }</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    h_1_term + h_2_term + trace_terms</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>which uses the following function to interpolate</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub fn interp_from_num_denom&lt;F: IsFFTField&gt;(</span></span>
<span class="giallo-l"><span>    num: &amp;Polynomial&lt;FieldElement&lt;F&gt;&gt;,</span></span>
<span class="giallo-l"><span>    denom: &amp;Polynomial&lt;FieldElement&lt;F&gt;&gt;,</span></span>
<span class="giallo-l"><span>    domain: &amp;Domain&lt;F&gt;,</span></span>
<span class="giallo-l"><span>) -&gt; Polynomial&lt;FieldElement&lt;F&gt;&gt; {</span></span>
<span class="giallo-l"><span>    let target_deg = domain.lde_roots_of_unity_coset.len() / domain.blowup_factor;</span></span>
<span class="giallo-l"><span>    let num_evals = evaluate_polynomial_on_lde_domain(</span></span>
<span class="giallo-l"><span>        num,</span></span>
<span class="giallo-l"><span>        domain.blowup_factor,</span></span>
<span class="giallo-l"><span>        domain.interpolation_domain_size,</span></span>
<span class="giallo-l"><span>        &amp;domain.coset_offset,</span></span>
<span class="giallo-l"><span>    )</span></span>
<span class="giallo-l"><span>    .unwrap();</span></span>
<span class="giallo-l"><span>    let denom_evals = evaluate_polynomial_on_lde_domain(</span></span>
<span class="giallo-l"><span>        denom,</span></span>
<span class="giallo-l"><span>        domain.blowup_factor,</span></span>
<span class="giallo-l"><span>        domain.interpolation_domain_size,</span></span>
<span class="giallo-l"><span>        &amp;domain.coset_offset,</span></span>
<span class="giallo-l"><span>    )</span></span>
<span class="giallo-l"><span>    .unwrap();</span></span>
<span class="giallo-l"><span>    let evals: Vec&lt;_&gt; = num_evals</span></span>
<span class="giallo-l"><span>        .iter()</span></span>
<span class="giallo-l"><span>        .zip(denom_evals)</span></span>
<span class="giallo-l"><span>        .map(|(num, denom)| num / denom)</span></span>
<span class="giallo-l"><span>        .collect();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    Polynomial::interpolate(</span></span>
<span class="giallo-l"><span>        &amp;domain.lde_roots_of_unity_coset[..target_deg],</span></span>
<span class="giallo-l"><span>        &amp;evals[..target_deg],</span></span>
<span class="giallo-l"><span>    )</span></span>
<span class="giallo-l"><span>    .unwrap()</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>This way, we can choose $n$ points where the fake DEEP composition polynomial will pass all the tests. Since the verifier can choose among $\beta n$ points, the prover gets a $1/\beta$ chance to pass the test.</p>
<p>We can now create a malicious prover that will likely pass the verifier‚Äôs checks, even if he uses false execution traces. Step_2 is modified to calculate the exact composition polynomial:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>fn step_2_evil_eval&lt;F: IsFFTField, A: AIR&lt;Field = F&gt;&gt;(</span></span>
<span class="giallo-l"><span>    air: &amp;A,</span></span>
<span class="giallo-l"><span>    domain: &amp;Domain&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    transition_coeffs: &amp;[(FieldElement&lt;F&gt;, FieldElement&lt;F&gt;)],</span></span>
<span class="giallo-l"><span>    boundary_coeffs: &amp;[(FieldElement&lt;F&gt;, FieldElement&lt;F&gt;)],</span></span>
<span class="giallo-l"><span>    rap_challenges: &amp;A::RAPChallenges,</span></span>
<span class="giallo-l"><span>    z: &amp;FieldElement&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    trace_ood_frame_evaluations: &amp;Frame&lt;F&gt;,</span></span>
<span class="giallo-l"><span>) -&gt; FieldElement&lt;F&gt; {</span></span>
<span class="giallo-l"><span>    // BEGIN TRACE &lt;-&gt; Composition poly consistency evaluation check</span></span>
<span class="giallo-l"><span>    // These are H_1(z^2) and H_2(z^2)</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let boundary_constraints = air.boundary_constraints(rap_challenges);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    //let n_trace_cols = air.context().trace_columns;</span></span>
<span class="giallo-l"><span>    // special cases.</span></span>
<span class="giallo-l"><span>    let trace_length = air.trace_length();</span></span>
<span class="giallo-l"><span>    let composition_poly_degree_bound = air.composition_poly_degree_bound();</span></span>
<span class="giallo-l"><span>    let boundary_term_degree_adjustment = composition_poly_degree_bound - trace_length;</span></span>
<span class="giallo-l"><span>    let number_of_b_constraints = boundary_constraints.constraints.len();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // Following naming conventions from https://www.notamonadtutorial.com/diving-deep-fri/</span></span>
<span class="giallo-l"><span>    let (boundary_c_i_evaluations_num, mut boundary_c_i_evaluations_den): (</span></span>
<span class="giallo-l"><span>        Vec&lt;FieldElement&lt;F&gt;&gt;,</span></span>
<span class="giallo-l"><span>        Vec&lt;FieldElement&lt;F&gt;&gt;,</span></span>
<span class="giallo-l"><span>    ) = (0..number_of_b_constraints)</span></span>
<span class="giallo-l"><span>        .map(|index| {</span></span>
<span class="giallo-l"><span>            let step = boundary_constraints.constraints[index].step;</span></span>
<span class="giallo-l"><span>            let point = &amp;domain.trace_primitive_root.pow(step as u64);</span></span>
<span class="giallo-l"><span>            let trace_idx = boundary_constraints.constraints[index].col;</span></span>
<span class="giallo-l"><span>            let trace_evaluation = &amp;trace_ood_frame_evaluations.get_row(0)[trace_idx];</span></span>
<span class="giallo-l"><span>            let boundary_zerofier_challenges_z_den = z - point;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>            let boundary_quotient_ood_evaluation_num =</span></span>
<span class="giallo-l"><span>                trace_evaluation - &amp;boundary_constraints.constraints[index].value;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>            (</span></span>
<span class="giallo-l"><span>                boundary_quotient_ood_evaluation_num,</span></span>
<span class="giallo-l"><span>                boundary_zerofier_challenges_z_den,</span></span>
<span class="giallo-l"><span>            )</span></span>
<span class="giallo-l"><span>        })</span></span>
<span class="giallo-l"><span>        .collect::&lt;Vec&lt;_&gt;&gt;()</span></span>
<span class="giallo-l"><span>        .into_iter()</span></span>
<span class="giallo-l"><span>        .unzip();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    FieldElement::inplace_batch_inverse(&amp;mut boundary_c_i_evaluations_den);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let boundary_degree_z = z.pow(boundary_term_degree_adjustment);</span></span>
<span class="giallo-l"><span>    let boundary_quotient_ood_evaluation: FieldElement&lt;F&gt; = boundary_c_i_evaluations_num</span></span>
<span class="giallo-l"><span>        .iter()</span></span>
<span class="giallo-l"><span>        .zip(&amp;boundary_c_i_evaluations_den)</span></span>
<span class="giallo-l"><span>        .zip(boundary_coeffs)</span></span>
<span class="giallo-l"><span>        .map(|((num, den), (alpha, beta))| num * den * (alpha * &amp;boundary_degree_z + beta))</span></span>
<span class="giallo-l"><span>        .fold(FieldElement::&lt;F&gt;::zero(), |acc, x| acc + x);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let transition_ood_frame_evaluations =</span></span>
<span class="giallo-l"><span>        air.compute_transition(trace_ood_frame_evaluations, rap_challenges);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let divisor_x_n = (z.pow(trace_length) - FieldElement::&lt;F&gt;::one()).inv();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let denominators = air</span></span>
<span class="giallo-l"><span>        .transition_exemptions_verifier()</span></span>
<span class="giallo-l"><span>        .iter()</span></span>
<span class="giallo-l"><span>        .map(|poly| poly.evaluate(z) * &amp;divisor_x_n)</span></span>
<span class="giallo-l"><span>        .collect::&lt;Vec&lt;FieldElement&lt;F&gt;&gt;&gt;();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let degree_adjustments = air</span></span>
<span class="giallo-l"><span>        .context()</span></span>
<span class="giallo-l"><span>        .transition_degrees()</span></span>
<span class="giallo-l"><span>        .iter()</span></span>
<span class="giallo-l"><span>        .map(|transition_degree| {</span></span>
<span class="giallo-l"><span>            let degree_adjustment =</span></span>
<span class="giallo-l"><span>                composition_poly_degree_bound - (trace_length * (transition_degree - 1));</span></span>
<span class="giallo-l"><span>            z.pow(degree_adjustment)</span></span>
<span class="giallo-l"><span>        })</span></span>
<span class="giallo-l"><span>        .collect::&lt;Vec&lt;FieldElement&lt;F&gt;&gt;&gt;();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let transition_c_i_evaluations_sum =</span></span>
<span class="giallo-l"><span>        ConstraintEvaluator::&lt;F, A&gt;::compute_constraint_composition_poly_evaluations_sum(</span></span>
<span class="giallo-l"><span>            &amp;transition_ood_frame_evaluations,</span></span>
<span class="giallo-l"><span>            &amp;denominators,</span></span>
<span class="giallo-l"><span>            &amp;degree_adjustments,</span></span>
<span class="giallo-l"><span>            transition_coeffs,</span></span>
<span class="giallo-l"><span>        );</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    &amp;boundary_quotient_ood_evaluation + transition_c_i_evaluations_sum</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>Then, step_3 is changed to</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>fn round_3_evil&lt;F: IsFFTField, A: AIR&lt;Field = F&gt;&gt;(</span></span>
<span class="giallo-l"><span>    air: &amp;A,</span></span>
<span class="giallo-l"><span>    domain: &amp;Domain&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    round_1_result: &amp;Round1&lt;F, A&gt;,</span></span>
<span class="giallo-l"><span>    z: &amp;FieldElement&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    boundary_coeffs: &amp;[(FieldElement&lt;F&gt;, FieldElement&lt;F&gt;)],</span></span>
<span class="giallo-l"><span>    transition_coeffs: &amp;[(FieldElement&lt;F&gt;, FieldElement&lt;F&gt;)],</span></span>
<span class="giallo-l"><span>) -&gt; Round3&lt;F&gt;</span></span>
<span class="giallo-l"><span>where</span></span>
<span class="giallo-l"><span>    FieldElement&lt;F&gt;: ByteConversion,</span></span>
<span class="giallo-l"><span>{</span></span>
<span class="giallo-l"><span>    let trace_ood_evaluations = Frame::get_trace_evaluations(</span></span>
<span class="giallo-l"><span>        &amp;round_1_result.trace_polys,</span></span>
<span class="giallo-l"><span>        z,</span></span>
<span class="giallo-l"><span>        &amp;air.context().transition_offsets,</span></span>
<span class="giallo-l"><span>        &amp;domain.trace_primitive_root,</span></span>
<span class="giallo-l"><span>    );</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let (composition_poly_even_ood_evaluation, composition_poly_odd_ood_evaluation) = {</span></span>
<span class="giallo-l"><span>        let trace_ood_frame_evaluations = Frame::new(</span></span>
<span class="giallo-l"><span>            trace_ood_evaluations.iter().flatten().cloned().collect(),</span></span>
<span class="giallo-l"><span>            round_1_result.trace_polys.len(),</span></span>
<span class="giallo-l"><span>        );</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        let hz_exact_from_trace = step_2_evil_eval(</span></span>
<span class="giallo-l"><span>            air,</span></span>
<span class="giallo-l"><span>            domain,</span></span>
<span class="giallo-l"><span>            transition_coeffs,</span></span>
<span class="giallo-l"><span>            boundary_coeffs,</span></span>
<span class="giallo-l"><span>            &amp;round_1_result.rap_challenges,</span></span>
<span class="giallo-l"><span>            z,</span></span>
<span class="giallo-l"><span>            &amp;trace_ood_frame_evaluations,</span></span>
<span class="giallo-l"><span>        );</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        (hz_exact_from_trace, FieldElement::&lt;F&gt;::from(0))</span></span>
<span class="giallo-l"><span>    };</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    Round3 {</span></span>
<span class="giallo-l"><span>        trace_ood_evaluations,</span></span>
<span class="giallo-l"><span>        composition_poly_even_ood_evaluation,</span></span>
<span class="giallo-l"><span>        composition_poly_odd_ood_evaluation,</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>Finally, round_4 is</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>fn round_4_evil&lt;F: IsFFTField, A: AIR&lt;Field = F&gt;, T: Transcript&gt;(</span></span>
<span class="giallo-l"><span>    air: &amp;A,</span></span>
<span class="giallo-l"><span>    domain: &amp;Domain&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    round_1_result: &amp;Round1&lt;F, A&gt;,</span></span>
<span class="giallo-l"><span>    round_2_result: &amp;Round2&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    round_3_result: &amp;Round3&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    z: &amp;FieldElement&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    transcript: &amp;mut T,</span></span>
<span class="giallo-l"><span>) -&gt; Round4&lt;F&gt;</span></span>
<span class="giallo-l"><span>where</span></span>
<span class="giallo-l"><span>    FieldElement&lt;F&gt;: ByteConversion,</span></span>
<span class="giallo-l"><span>{</span></span>
<span class="giallo-l"><span>    let coset_offset_u64 = air.context().proof_options.coset_offset;</span></span>
<span class="giallo-l"><span>    let coset_offset = FieldElement::&lt;F&gt;::from(coset_offset_u64);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // &lt;&lt;&lt;&lt; Receive challenges: ùõæ, ùõæ&#39;</span></span>
<span class="giallo-l"><span>    let composition_poly_coeffients = [</span></span>
<span class="giallo-l"><span>        transcript_to_field(transcript),</span></span>
<span class="giallo-l"><span>        transcript_to_field(transcript),</span></span>
<span class="giallo-l"><span>    ];</span></span>
<span class="giallo-l"><span>    // &lt;&lt;&lt;&lt; Receive challenges: ùõæ‚±º, ùõæ‚±º&#39;</span></span>
<span class="giallo-l"><span>    let trace_poly_coeffients = batch_sample_challenges::&lt;F, T&gt;(</span></span>
<span class="giallo-l"><span>        air.context().transition_offsets.len() * air.context().trace_columns,</span></span>
<span class="giallo-l"><span>        transcript,</span></span>
<span class="giallo-l"><span>    );</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // Compute p‚ÇÄ (deep composition polynomial)</span></span>
<span class="giallo-l"><span>    let deep_composition_poly = compute_deep_composition_poly_evil(</span></span>
<span class="giallo-l"><span>        air,</span></span>
<span class="giallo-l"><span>        domain,</span></span>
<span class="giallo-l"><span>        &amp;round_1_result.trace_polys,</span></span>
<span class="giallo-l"><span>        round_2_result,</span></span>
<span class="giallo-l"><span>        round_3_result,</span></span>
<span class="giallo-l"><span>        z,</span></span>
<span class="giallo-l"><span>        &amp;domain.trace_primitive_root,</span></span>
<span class="giallo-l"><span>        &amp;composition_poly_coeffients,</span></span>
<span class="giallo-l"><span>        &amp;trace_poly_coeffients,</span></span>
<span class="giallo-l"><span>    );</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let domain_size = domain.lde_roots_of_unity_coset.len();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // FRI commit and query phases</span></span>
<span class="giallo-l"><span>    let (fri_last_value, fri_layers) = fri_commit_phase(</span></span>
<span class="giallo-l"><span>        domain.root_order as usize,</span></span>
<span class="giallo-l"><span>        deep_composition_poly,</span></span>
<span class="giallo-l"><span>        transcript,</span></span>
<span class="giallo-l"><span>        &amp;coset_offset,</span></span>
<span class="giallo-l"><span>        domain_size,</span></span>
<span class="giallo-l"><span>    );</span></span>
<span class="giallo-l"><span>    let (query_list, iotas) = fri_query_phase(air, domain_size, &amp;fri_layers, transcript);</span></span>
<span class="giallo-l"><span>    let fri_layers_merkle_roots: Vec&lt;_&gt; = fri_layers</span></span>
<span class="giallo-l"><span>        .iter()</span></span>
<span class="giallo-l"><span>        .map(|layer| layer.merkle_tree.root)</span></span>
<span class="giallo-l"><span>        .collect();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let deep_poly_openings =</span></span>
<span class="giallo-l"><span>        open_deep_composition_poly(domain, round_1_result, round_2_result, &amp;iotas);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // grinding: generate nonce and append it to the transcript</span></span>
<span class="giallo-l"><span>    let grinding_factor = air.context().proof_options.grinding_factor;</span></span>
<span class="giallo-l"><span>    let transcript_challenge = transcript.challenge();</span></span>
<span class="giallo-l"><span>    let nonce = generate_nonce_with_grinding(&amp;transcript_challenge, grinding_factor)</span></span>
<span class="giallo-l"><span>        .expect(&quot;nonce not found&quot;);</span></span>
<span class="giallo-l"><span>    transcript.append(&amp;nonce.to_be_bytes());</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    Round4 {</span></span>
<span class="giallo-l"><span>        fri_last_value,</span></span>
<span class="giallo-l"><span>        fri_layers_merkle_roots,</span></span>
<span class="giallo-l"><span>        deep_poly_openings,</span></span>
<span class="giallo-l"><span>        query_list,</span></span>
<span class="giallo-l"><span>        nonce,</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>This way, we generate a proof that will always pass the out-of-domain point consistency check and will have a high probability of passing the low-degree test.</p>
<h1 id="summary">Summary</h1>
<p>This post covered the challenges we presented at the first Lambda-Ingo ZK CTF and their solutions. The challenges involved some common attacks on Plonk (frozen heart and lack of blinding polynomials) and FRI to generate fake proofs or recover information from the witnesses. We will be adding more exercises and case studies to the <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks_exercises/tree/main">Lambdaworks exercises repo</a> so that anyone can learn how to build a proving system and some common pitfalls and vulnerabilities that may arise in their implementation. We would like to thank Ingonyama again for their fantastic work and all the sponsors at LambdaZK week in Paris. Stay tuned for more challenges on ZK!</p>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
