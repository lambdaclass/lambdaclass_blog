<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>What every developer needs to know about elliptic curves - LambdaClass Blog</title>
    <meta name="description" content="Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">What every developer needs to know about elliptic curves</h1>
        
        <div class="page-meta">
            <time datetime="2022-08-06">August 06, 2022</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <p>Elliptic curves (EC) have become one of the most useful tools for modern cryptography. They were proposed in the 1980s and became widespread used after 2004. Its main advantage is that it offers smaller key sizes to attain the same level of security of other methods, resulting in smaller storage and transmission requirements. For example, EC cryptography (ECC) needs 256-bit keys to attain the same level of security as a 3000-bit key using RSA (another public-key cryptographic system, born in the late 70s). ECC and RSA work by hiding things inside a certain mathematical structure known as a finite cyclic group (we will explain this soon). The hiding is done rather in plain sight: you could break the system if you could reverse the math trick (spoiler alert: if done properly, it would take you several lifetimes). It is as if you put $1.000.000 inside an unbreakable glass box and anyone could take it if they could break it.</p>
<p>In order to understand these objects and why they work, we need to go backstage and look at the math principles (we won’t enter into the hard details or proofs, but rather focus on the concepts or ideas). We will start by explaining finite fields and groups and then jump onto the elliptic curves (over finite fields) and see whether all curves were created equal for crypto purposes.</p>
<h2 id="finite-fields">Finite fields</h2>
<p>We know examples of fields from elementary math. The rational, real and complex numbers with the usual notions of sum and multiplication are examples of fields (these are not finite though).</p>
<p>A finite field is a set equipped with two operations, which we will call + and ×. These operations need to have certain properties in order for this to be a field:</p>
<ol>
<li>If <em>a</em> and <em>b</em> are in the set, then <em>c=a+b</em> and <em>d=a×b</em> should also be in the set. This is what is mathematically called a closed set under the operations +, ×.</li>
<li>There is a zero element, 0, such that <em>a</em> +0=<em>a</em> for any a in the set. This element is called the additive identity.</li>
<li>There is an element, 1, such that 1× <em>a</em> =<em>a</em> for any a in the set. This element is the multiplicative identity.</li>
<li>If a is in the set, there is an element <em>b</em> , such that <em>a+b</em> =0. We call this element the additive inverse and we usually write it as <em>−a</em>.</li>
<li>If <em>a</em> is in the set, there is an element <em>c</em> such that <em>a×c=1</em>. This element is called the multiplicative inverse and we write is as <em>a</em> −1.</li>
</ol>
<p>Before we can talk about examples of finite fields, we need to introduce the modulo arithmetic.</p>
<p>We learned that given a natural number or zero, <em>a</em> and a non-zero number <em>b</em> , we could write out a in the following way <em>a=q×b+r</em> where <em>q</em> is the quotient and <em>r</em> is the remainder of the division of <em>a/b</em>. This <em>r</em> can take values 0,1,2,…,b−1 We know that if <em>r</em> is zero, then a is a multiple of <em>b</em>. It may not seem new, but this gives us a very useful tool to work with numbers. For example, if <em>b</em> =2 then <em>r</em> =0,1. When it is 0, <em>a</em> is even (it is divisible by 2) and when it is 1, <em>a</em> is odd. A simple way to rephrase this (due to Gauss):</p>
<p>a≡1(mod2)</p>
<p>if <em>a</em> is odd and</p>
<p>a≡0(mod2)</p>
<p>if <em>a</em> is even. We can see that if we sum two odd numbers <em>a1</em> and <em>a2</em> ,</p>
<p>a1+a2≡1+1≡0(mod2)</p>
<p>This shows us that, if we want to know whether a sum is even or not, we can simply sum the remainders of their division by 2 (an application of this is that in order to check divisibility by two, we should only look at the last bit of the binary representation).</p>
<p>Another situation where this arises every day is with time. If we are on Monday at 10 am and we have 36 hours till the deadline of a project, we have to submit everything by Tuesday 10 pm. That is because 12 fits exactly 3 times in 36, leading to Mon-10 pm, Tue-10 am, Tue-10 pm. If we had 39 hours, we jump to Wed-1 am.</p>
<p>An easy way to look at this relation (formally known as congruence modulo p) is that if <em>a≡b</em>(mod <em>p</em>), then <em>p</em> divides <em>a−b</em> , or <em>a=k×p+b</em> for an integer <em>k</em>.</p>
<p>More informally, we see that operating (mod <em>p</em>) wraps around the results of certain calculations, giving always numbers in a bounded range by <em>p</em> −1.</p>
<p>We can see that if a1≡b1(modp) and a2≡b2(modp), then a1+a2≡b1+b2(mod <em>p</em>) (if b1+b2&gt;p we can wrap around the result). Similar results apply when using subtraction and multiplication. Division presents some difficulties, but we can change things a little bit and make it work this way: instead of thinking of dividing <em>a÷b</em> we can calculate <em>a×b−1</em> , where <em>b</em> −1 is the multiplicative inverse of <em>b</em> (remember <em>b×b −1</em>=1). Consider <em>p</em> =5, so the elements of the group are 0,1,2,3,4.</p>
<p>We can see that 1 is its own multiplicative inverse, since 1×1=1≡1  (mod5). If we take 2 and 3, then 2×3=6≡1  (mod5) (so 3 is the multiplicative inverse of 2) and 4×4=16≡1 (mod5). The set and the operations defined satisfy the conditions for a field.</p>
<p>We can also define integer powers of field elements in a simple way. If we want to square a number <em>a</em> , it is just doing <em>a×a</em> and take mod <em>p</em>. If we want a cube, we do <em>a×a×a</em> and take mod <em>p</em>. RSA uses exponentiation to perform encryption. It is easy to see that if the exponent is rather large (or the base is very large, or both), numbers get really big. For example, we want to evalute 265536(mod <em>p</em>). When we reach a 1000, we get numbers with over 300 digits and we are still a long way to go. We can do this calculation much simpler realizing that 65536=216 and squaring the number and taking the remainder every time. We end up doing only 16 operations like this, instead of the original 65536! thus avoiding huge numbers. A similar strategy will be used when we work with ECs!</p>
<h2 id="groups">Groups</h2>
<p>We saw that whenever we add two even integers, we get another one. Besides, as 0 is even and if we sum <em>a</em> and <em>−a</em> we get 0, which is the identity element for the sum. Many different objects have a similar behavior when equipped with a certain operation. For example, the multiplication of two invertible matrices results in an invertible matrix. If we consider the set of invertible matrices of <em>N</em> × <em>N</em> equipped with the multiplication, we can see that if <em>A</em> is in the set, <em>A −1</em> is in the set; the identity matrix is in the set (and it plays the role of identity element with respect to multiplication). In other words, some sets equipped with a certain operation share some properties and we can take advantage of the knowledge of this structure. The set, together with the operation, forms a group. Formally, a group is a set <em>G</em> equipped with a binary operation × such that:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span> 1. The operation is associative, that is, _(a×b)×c=a×(b×c)_.</span></span>
<span class="giallo-l"><span> 2. There is an identity element, _e: e×a=a_ and _a×e=a_. </span></span>
<span class="giallo-l"><span> 3. For every element _a_ in the set, there is an element _b_ in the set such that _a×b=e_ and _b×a=e_. We denote _b=a−1_ for simplicity.</span></span></code></pre>
<p>We can easily see that any field is, in particular, a group with respect to each one of its two operations (conditions 1, 2 and 4 for the field indicate it is also a group with respect to the sum and 1, 3 and 5 for multiplication). If the operation is commutative (that is, <em>a×b=b×a</em>) the group is known as an abelian (or commutative) group. For example, the invertible matrices of <em>N×N</em> form a group, but it is not abelian, since <em>A×B≠B×A</em> for some matrices <em>A</em> and <em>B</em>.</p>
<p>We will be interested in finite groups (those where the set contains a finite number of elements) and, in particular, cyclic groups. These are groups which can be generated by repeatedly applying the operation over an element <em>g</em> , the generator of the group. The <em>n</em> -th roots of unity in the complex numbers form an example of a cyclic group under multiplication; this is the set of solutions of <em>x n</em>=1, which are of the form exp(2 <em>πik/n</em>), with <em>k</em> =0,1,2…,<em>n</em> −1. This group can be generated by taking integer powers of exp(2 <em>πi/n</em>). The roots of unity play an important role in the calculation of the fast Fourier transform (FFT), which has many applications.</p>
<h2 id="elliptic-curves-in-a-nutshell">Elliptic curves in a nutshell</h2>
<p>Elliptic curves are very useful objects because they allow us to obtain a group structure with interesting properties. Given a field <em>F</em> , an elliptic curve is the set of points <em>(x,y)</em> which satisfy the following equation:</p>
<p>_y 2+a1xy+a3y=x3+a2x2+a4x+a6 _</p>
<p>This is known as the general Weierstrass equation. In many cases, this can be written in the simpler form</p>
<p><em>y 2=x3+ax+b</em></p>
<p>which is the (Weierstrass) short-form. Depending on the choice of the parameters a and b and the field, the curve can have some desired properties or not. If _4a 3+27b2≠0 _, the curve is non-singular.</p>
<p>We can define an operation which allows us to sum elements belonging to the elliptic curve and obtain a group. This is done using a geometric construction, the chord-and-tangent rule. Given two points on the curve <em>P1=(x 1,y1)</em> and <em>P 2=(x2,y2)</em>, we can draw a line connecting them. That line intersects the curve on a third point <em>P 3=(x3,y3)</em>. We set the sum of <em>P 1</em> and <em>P 2</em> as <em>(x 3,−y3)</em>, that is, point <em>P 3</em> flipped around the <em>x</em> -axis. The formulae are:  <img src="/images/2022/12/imagen-1.png" alt="" /></p>
<p>We can easily see that we have a problem if we try to sum <em>P 1=(x1,y1)</em> and <em>P 2=(x1,−y1)</em>. We need to add an additional point to the system, which we call the point at infinity <em>O</em>. This inclusion is necessary to be able to define the group structure and works as the identity element for the group operation.</p>
<p>Another problem appears when we want to sum <em>P 1</em> and <em>P 1</em> to get to <em>P 3=2P1</em>. But, if we draw the tangent line to the curve on P1, we see that it intersects the curve at another point. If we want to perform this operation, we need to find the slope of the tangent line and find the intersection:</p>
<p>$$s=\frac{3x21+a}{2y1}$$<br />
$$x3=s2−2x1$$<br />
$$y3=s(x1−x3)−y1$$</p>
<p><img src="/images/2022/12/imagen-5.png" alt="" /></p>
<p>It takes a little bit of work, but we can prove that the elliptic curve with this operation has the properties of a group. We will use finite fields to work with these curves and the groups that we will obtain are finite cyclic groups, that is, groups which can be generated by repeteadly using the operation on a generator, <em>g: g,2g,3g,4g,5g,….</em> <img src="/images/2022/12/imagen-3.png" alt="" /></p>
<p>If we plot the collection of points onto a graph, we see that the points are distributed in a rather “random” fashion. For example, <em>2 g</em> could be very far from <em>3 g</em> which in turn are very far from <em>4 g</em>. If we wanted to know how many times <em>k</em> we have to add the generator to arrive at a certain point <em>P</em> (that is solving the equation <em>kg=P</em>) we see that we don’t have an easy strategy and we are forced to perform a brute search over all possible <em>k</em>. This problem is known as the (elliptic curve) discrete logarithm (log for friends) problem (other friends prefer ECDLP).</p>
<p>On the other hand, if we know <em>k</em> , we can compute in a very fast way <em>P=kg</em>. This offers us a way to hide (in plain sight) things inside the group. Of course, if you could break the DLP, you could get k, but it is rather infeasible. If we want to calculate 65536 <em>g</em> , we can do it by realizing that <em>g+g=2 g, 2g+2g=4g, 4g+4g=8</em>…until <em>32768 g+32768g=65535g</em>, so we narrowed the operations 65536 to 16. There are many useful algorithms that allow us to speed up the operations over elliptic curves, allowing us to avoid expensive calculations such as inversions, which appear when we want to calculate the slope.</p>
<h2 id="are-all-elliptic-curves-useful-for-crypto">Are all elliptic curves useful for crypto?</h2>
<p>The strength of elliptic curve cryptography lies on the hardness to solve the discrete logarithm problem. This is related to the number of elements (the order of the set) making the cyclic group. If the number is a very large prime, or it contains a very large prime in its factorization (that is, the number is a multiple of a large prime), then the problem becomes infeasible. However, if the order is made up of small primes, it is possible to search over the subgroups and reconstruct the answer with help from the <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Chinese_remainder_theorem">Chinese Remainder Theorem</a>. This is because the difficulty depends on the size of the largest prime involved.</p>
<p>Some curves have desired properties and have been given names. For example, Bitcoin uses secp256k1, which has the following parameters:</p>
<p><em>a=0</em><br />
<em>b</em> =7 <em>p</em> =2256−232−977 <em>g x</em>=<em>0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798</em> <em>g y=0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8</em> <em>r=0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141</em></p>
<p>To get an idea on the number of elements of the group, they’re about <em>r</em> ≈1077. Even if we had 1012 supercomputers performing over 1017 search points per second for a hundred million years we wouldn’t even get close to inspecting all the possibilities.</p>
<p>To be able to guarantee 128-bits of security, ECs need group orders near 256-bits (that is, orders with prime factors around 1077). This is because there are algorithms which can solve the problem doing operations around √r. If the largest prime is less than 94-bits long, it can be broken with help from a desktop computer. Of course, even if your group is large enough, nothing can save you from a poor implementation.</p>
<p>The question arises: how can we know the number of elements of our EC? Luckily, math comes once again to our aid like the Hasse bound, Schoof’s algorithm and how to test whether a number is prime or not. Next time we will continue revealing the math principles behind useful tools in cryptography.</p>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
