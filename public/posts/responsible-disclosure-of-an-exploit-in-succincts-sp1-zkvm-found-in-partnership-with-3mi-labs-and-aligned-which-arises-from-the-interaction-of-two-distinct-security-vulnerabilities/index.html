<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsible  disclosure of an exploit in Succinct&#x27;s SP1 zkVM, found in partnership with 3MI Labs and Aligned, which arises from the interaction of two distinct security vulnerabilities. - LambdaClass Blog</title>
    <meta name="description" content="Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">Responsible  disclosure of an exploit in Succinct&#x27;s SP1 zkVM, found in partnership with 3MI Labs and Aligned, which arises from the interaction of two distinct security vulnerabilities.</h1>
        
        <div class="page-meta">
            <time datetime="2025-01-26">January 26, 2025</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <p><strong>TL;DR</strong> : We found two security bugs that can be combined to perform an exploit in Succinct’s SP1 zkVM, which allows you to generate false proofs. In severe cases, this could lead to loss of funds. This was found thanks to a collaboration between the top notch research <a rel="noopener external" target="_blank" href="https://www.3milabs.tech/">3MI Labs</a>, <a rel="noopener external" target="_blank" href="https://alignedlayer.com/">Aligned</a>, and <a rel="noopener external" target="_blank" href="https://lambdaclass.com/">LambdaClass</a>. This is a different security bug from the one we informed <a href="/the-future-of-zk-is-in-risc-v-zkvms-but-the-industry-must-be-careful-how-succincts-sp1s-departure-from-standards-causes-bugs/">previously in our blog</a> and it highlights the importance of having multiple teams paying attention to security and working towards having simpler codebases. For a PoC of the exploit, see the <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/PoC-exploit-SP1">following repo</a></p>
<p>LambdaClass and Fuzzing Labs will invest in further investigating critical security bugs in zkVMs. We believe that codebases have become too complex and over-engineered and this gives rise to lots of bugs. We think that the industry is at risk if we do not invest, add more eyes and simplify codebases. The industry has become complacent when it comes to security and is being pushed by business decisions to rush into production use, leaving aside these security issues, which could lead to very serious consequences. In this post, we analyze the case of SP1, but we think that all zkVM’s codebases need to be simplified and follow the standards, lowering the attack surface. As mentioned, we will conduct a more thourough research on different zkVMs.</p>
<h2 id="introduction">Introduction</h2>
<p>We have seen in several engineering projects the development of long and complex codebases, with too many fearures and poor documentation and testing. Some people believe that having such codebases shows that you are smart, have excellent coding skills and given a lot of thought on everything. We think it otherwise: the proof of mastery lies in simplicity. Bugs will always happen in any project, but the chance of having critical bugs increases with codebase complexity and length in a nonlinear way: the longer and more complex, the more bugs and hard to predict behaviors you can have. During our analysis of zk virtual machines and proof systems, we found two security bugs that can be combined to produce an exploit allowing a malicious party to prove false statements. Basically, you could generate false proofs for programs and modify some public inputs, which, in a world were computation is to be verified on chain using this technology, could lead to several exploits and loss of funds.</p>
<p>From our point of view, these exploits arise from the complexity of the codebase, having many files with different constraints and the addition of several features and optimizations that bloat the codebase. We also believe that business decisions are trying to rush these systems into production, when we should still focus on improving their security and auditability. We think that more care needs to be taken when designing, developing and testing zk virtual machines that could be used in real world applications, especially when funds are at risk.</p>
<h2 id="description-of-the-exploits">Description of the exploits</h2>
<p>Two bugs were identified in the <a rel="noopener external" target="_blank" href="https://crates.io/crates/sp1-sdk"><code>sp1-sdk</code></a> crate at version 3.4.0, the most recently published version at the time we started our analysis. We were able to exploit them to generate valid SP1 proofs of incorrect execution of an arbitrary program, which results in universal forgeries of proofs for arbitrary statements, even incorrect ones.</p>
<h2 id="bug-descriptions">Bug Descriptions</h2>
<p>This report describes two bugs:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * SP1-2.1: Unconstrained `committed_value_digest` without `COMMIT` syscalls</span></span>
<span class="giallo-l"><span>    * SP1-2.2: Unchecked `next_pc` Condition in First Layer of Recursion Tree</span></span></code></pre><h3 id="sp1-2-1-unconstrained-committed-value-digest-without-commit-syscalls">SP1-2.1: Unconstrained <code>committed_value_digest</code> without <code>COMMIT</code> syscalls</h3>
<p>When an SP1 executor executes a guest program, the <code>COMMIT</code> syscalls(<code>0x00_00_00_10</code>) resulting from calls to <code>sp1_zkvm::io::commit()</code> are delayed to the end of the execution and emitted only when the <code>main</code> function <em>returns</em>.<br />
Since these syscalls are the only events that generate constraints on the <code>committed_value_digest</code> of the <code>ExecutionRecord</code>, this implies that if the execution of the program is halted before the return point of <code>main()</code>, then the <code>COMMIT</code> syscalls are never issued. As a result, the <code>committed_value_digest</code> remains initialised to the all-zero value and is not constrained during proof generation.</p>
<p>This absence of constraints on the digest of committed values during the execution of the program raises further questions on the compatibility of the verifier code of <code>sp1-sdk</code> with proofs of “arbitrary” program, but exploring this falls outside of the scope of this report.</p>
<h3 id="sp1-2-2-unchecked-next-pc-condition-in-first-layer-of-recursion-tree">SP1-2.2: Unchecked <code>next_pc</code> Condition in First Layer of Recursion Tree</h3>
<p>In the verifying code for the first layer of the recursion tree, the condition <code>next_pc == 0</code> is not checked if a shard is indicated as containing a “complete” execution. However, this check is present in other recursion constraints (e.g., two-to-one proof compression, field-switch wrapping, proof-system switching).</p>
<p>Other checks exist that are performed on other code paths when <code>is_complete</code> is asserted but are missing from the first layer of the recursion tree; these may be critical to proof soundness, but were not used in our exploit. These can be found in <code>sp1_recursion_circuit::machine::complete::assert_complete</code> (for the recursive constraints) and <code>sp1_prover::verify::verify</code> (for the plain, uncompressed verification). These checks include whether:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * at least one execution shard is present</span></span>
<span class="giallo-l"><span>    * (execution) shard numbering is consecutive, and starts at one,</span></span>
<span class="giallo-l"><span>    * the leaf challenger and the final reconstruct challenger match</span></span>
<span class="giallo-l"><span>    * the deferred proof digests are consistent, and</span></span>
<span class="giallo-l"><span>    * the cumulative sum is consistent.</span></span></code></pre><h2 id="exploit-description">Exploit Description</h2>
<p>Initially, an attempt to exploit SP1-2.1 was made by making an explicit <code>HALT</code> (<code>0x00_00_00_00</code>) syscall within <code>main()</code>.<br />
While this is not the methodology that was ultimately used, we note that making such explicit <code>HALT</code> syscalls within main might reasonably be passed off as an optimization within the guest program, e.g., by arguing that an early halt within main is a way to shorten a program’s execution trace and therefore reduce its proof computation time. This would seem innocent enough, but SP1-2.1 would then imply that the digest of public values produced before the syscall would remain unconstrained.</p>
<p>However, it suffices to instead create a malicious SP1 executor which stops executing the guest program at an arbitrary <code>pc</code> value. As long as the chosen <code>pc</code> value happens before the return point of <code>main()</code>, no <code>COMMIT</code> syscall will have been produced by the virtual machine. In the exploit presented here, the proof forgery was produced by stopping execution as soon as the program reached the start of the <code>main</code> function.</p>
<p>Before returning the resulting <code>ExecutionRecord</code>, the malicious executor is then free to replace the <code>committed_value_digest</code> of the <code>public_values: PublicValues</code> field with the digest of an arbitrary value. This makes it seem as if the guest program had committed to it during its execution.</p>
<p>Then, an honest <code>CoreProver</code> (<code>sp1_prover::components::SP1ProverComponents::CoreProver</code>) is run to generate an <code>SP1CoreProof</code> (<code>sp1_prover::types::SP1CoreProof</code>) with the maliciously crafted <code>ExecutionRecord</code>. Since there are no <code>COMMIT</code> syscalls contained within the record, the altered <code>committed_value_digest</code>, which does not match the digest of the values committed to by the program, does not cause the proof generation to fail. The <code>CoreProver</code> therefore successfully creates an <code>SP1CoreProof</code> containing two shards <code>s1</code> and <code>s2</code>.</p>
<p>Finally, a malicious <code>SP1Prover</code> (<code>sp1_prover::SP1Prover</code>) is created with the following two modifications:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. The second shard `s2` of the `SP1CoreProof` is discarded.</span></span>
<span class="giallo-l"><span>    2. The `is_complete` flag is set to `true` in the `SP1RecursionWitnessValues` created from the remaining first shard `s1`. This recursion witness is then used when generating the recursion program for compressing the `SP1CoreProof` with a `CompressProver`.</span></span></code></pre>
<p>Because the malicious executor stopped the guest program with a <code>next_pc</code> value pointing to the start of main, the first shard <code>s1</code> has a non-zero <code>next_pc</code> value. However, since the <code>is_complete</code> flag is <code>true</code>, SP1-2.2 implies that the <code>CompressProver</code> does not constrain the equality <code>next_pc ==0</code>, resulting in an <code>SP1ReduceProof</code> proof generated without errors. When de-serialized by an honest prover and submitted for verification, this <code>SP1ReduceProof</code> then passes <em>honest</em> verification for the guest program.</p>
<h3 id="exploit-demonstration">Exploit demonstration</h3>
<p>We accompanied the bug report with two artefacts that demonstrate how the two bugs can be exploited to provide valid proofs of invalid execution of arbitrary programs. See the <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/PoC-exploit-SP1">repo for the code</a>.</p>
<p>The is-prime directory contains the source files and compiled ELF version of a program(<code>./is-prime/program</code>) which checks primality of a number read from <code>sp1_zkvm::io</code>, together with a script(<code>./is-prime/script</code>) which demonstrates that <code>42-is-prime.proof</code>(<code>./is-prime/script/42-is-prime.proof</code>) is a valid proof that executing the program results in 42 being verified as a prime number.</p>
<p>The i-am-satoshi(<code>./i-am-satoshi/</code>) directory contains a example of the transferability of this technique. Here, the guest program uses the independent <code>bitcoin</code> crate to compute the Bitcoin address corresponding to the secret key given as input, and then commits to the resulting address with <code>sp1_zkvm::io::commit()</code>. Running the corresponding <code>verifier program</code>(<code>./i-am-satoshi/script/src/main.rs</code>) reveals that the proof demonstrates knowledge of the secret key behind the “genesis Satoshi address” <code>1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa</code>.</p>
<p>This proof of concept illustrates arbitrary statement proving for the SP1 verifier, by verifying knowledge of the secret key to the reward address in the bitcoin genesis block. To perform these exploits, the prover client needs to be modified locally.</p>
<h2 id="consequences-and-limitations">Consequences and Limitations</h2>
<p>While the first program presented in this exploit is innocent enough (42 is obviously not prime), the second one exemplifies more serious consequences.<br />
Proof of ownership of any address on any blockchain can be forged and would be accepted by a naïve verifier. We draw the attention to the fact that the program itself <em>was not modified</em>. All of the modifications to create the proof forgery were performed <strong>locally to the proving client</strong> which implies that this forgery methodology is generalizable to arbitrary guest programs.</p>
<p>We note that SP1-2.2 is a bug that is restricted to the first layer of the recursion tree, and that subsequent recursive proving of the proof would fail, because the <code>ShrinkProver</code> properly constrains the <code>next_pc == 0</code> check when <code>is_complete == true</code>.<br />
Nonetheless, the honest verifier code(<code>./is-prime/script/src/bin/verifier.rs</code>) is <em>agnostic</em> to the kind of proof that it deserializes which implies that the malicious prover is not forced to further reduce or wrap the forged proof before submitting it for verification to a system that runs the Rust verifier from the <code>sp1-sdk</code> crate.</p>
<h2 id="possible-mitigations">Possible Mitigations</h2>
<h3 id="mitigating-sp1-2-1">Mitigating SP1-2.1</h3>
<p>Mitigating SP1-2.1 requires making sure that the <code>committed_value_digest</code> is constrained within the proof system, even if no <code>COMMIT</code> syscalls are made.</p>
<p>Any implementation of this mitigation would conflict with the current implementation which assumes that <code>committed_value_digest</code> is written to only once. A concrete proposal requires further exploration of the possibilities which is outside of the scope of this report.</p>
<h3 id="mitigating-sp1-2-2">Mitigating SP1-2.2</h3>
<p>Ultimately, the code for the recursion program should be patched so that the <code>next_pc == 0</code> constraint (and the other related constraints for complete programs) is applied by the <code>CompressProver</code> in the first layer of the recursion tree, just like it is in the other recursion programs.</p>
<p>As a hot fix which would not be a breaking change to currently accepted verification keys, since the <code>next_pc</code> value is accessible as part of a proof’s<br />
public values, the Rust code of the verifier should check that it is <code>0</code>, even if this isn’t constrained within the proof system. This hot fix would further enable existing verifiers to check whether this bug was triggered by proofs that are still in storage.</p>
<h2 id="summary">Summary</h2>
<p>Together with 3MI Labs and Aligned, we found two security bugs in Succinct’s SP1 zkVM, and showed how to use them to perform an exploit to generate false proofs that an honest verifier would accept. Since these exploits do not require to change the code of the program and are done locally, they could be used without naïve verifiers even suspecting it is a malicious proof. We think that the complexity and length of the codebase, as well as unclear documentation contribute to the proliferation of bugs, and that we should be working harder on simplifying the codebases and on security, instead of rushing into production due to business concerns, especially when funds could be at risk.</p>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
