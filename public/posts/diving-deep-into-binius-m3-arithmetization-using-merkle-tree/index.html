<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diving deep into Binius M3 arithmetization using Merkle tree inclusion as an example - LambdaClass Blog</title>
    <meta name="description" content="Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">Diving deep into Binius M3 arithmetization using Merkle tree inclusion as an example</h1>
        
        <div class="page-meta">
            <time datetime="2025-06-23">June 23, 2025</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <h2 id="introduction">Introduction</h2>
<p>At the heart of any Zero-Knowledge Proof (ZKP) system lies the concept of arithmetization, the process of transforming a computational problem into a mathematical problem that can be expressed and verified within a specific algebraic structure, such as polynomials or arithmetic circuits. Within the Binius framework, this arithmetization is managed through the <strong>Multi-Multiset Matching (M3)</strong> system, which introduces significant changes and improvements compared to more commonly used arithmetizations.</p>
<p>While previous posts focused on the mathematical foundations used by Binius—such as <a href="/the-fields-powering-binius/">binary fields</a> and <a href="/additive-fft-background/">additive FFT</a>—this post aims to explore how Binius M3 system is implemented. To do so, we take a deep dive into a specific gadget: the <a rel="noopener external" target="_blank" href="https://github.com/IrreducibleOSS/binius/tree/main/crates/m3/src/gadgets/merkle_tree">Merkle tree</a>. By walking through this example in detail, we aim to understand how constraint systems, tables, and channels are represented and handled in code.</p>
<p>To gain a more general intuition about why the tables and arithmetization techniques we explain in detail here actually work, we strongly recommend reading <a rel="noopener external" target="_blank" href="https://www.binius.xyz/basics/arithmetization/m3">Binius M3 documentation</a>. It’s very clear and presents toy examples that help illustrate the core ideas.</p>
<h2 id="m3-general-idea">M3 General Idea</h2>
<p>Unlike traditional arithmetizations that often rely on a sequential main execution trace, M3 distinguishes itself by not requiring a main trace or for its tables to be sequential. In M3, tables are merely declarative instances, specifically designed for the purpose of the proof. The prover fills these tables with data relevant to the computation, and these tables serve as a source for interacting with a key component: channels.</p>
<p>Within M3, tables and channels are the fundamental pillars for building and verifying complex computations. <strong>Tables</strong> are the primary means of representing and structuring computation data, functioning as collections of columns where each row represents a step or an instance of an operation. For example, in the context of a Merkle Tree, some tables will have parent and children nodes data.</p>
<p>Complementing tables, <strong>channels</strong> act as communication conduits within the M3 constraint system. They facilitate the flow of data between different tables or between tables and the external world (such as public inputs and outputs). Tables <strong>push</strong> into or <strong>pull</strong> from channels data. This mechanism is crucial for connecting various parts of a complex computation, ensuring that data dependencies are correctly maintained and verifiable. To verify the validity of a proof, the verifier simply needs to check that all channels are <strong>balanced</strong> —meaning that the data pushed into a channel matches the data pulled from it.</p>
<p>While M3 also relies on polynomially-constrained tables, as previous schemes do, it departs from traditional approaches by using these tables solely to support channel balancing, rather than as a vehicle for constructing a global execution trace.</p>
<p>In this post, we’ll explore specific examples of tables and channels within the Binius Merkle Tree constraint system, illustrating how they are used to build a verifiable proof of Merkle Tree inclusion. To see all of that theory in action, the Merkle Tree example wraps the setup in a single helper: <code>MerkleTreeCS</code>. A call to <code>MerkleTreeCS::new</code> sets up five tables, opens three channels, and returns a constraint system that’s ready to be filled with path data. With the plumbing taken care of, we can now look at what each table and channel does.</p>
<h2 id="merkletreecs">MerkleTreeCS</h2>
<p>The <a rel="noopener external" target="_blank" href="https://github.com/IrreducibleOSS/binius/blob/main/crates/m3/src/gadgets/merkle_tree/mod.rs#L45">MerkleTreeCS</a> (Merkle Tree Constraint System) consists of 5 tables and 3 channels that work together to ensure the correctness of Merkle paths verification.</p>
<h3 id="tables">Tables</h3>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * `merkle_path_table_left`: A table of type `NodesTable` that handles Merkle paths where only the left child must be pulled from a channel. We&#39;ll see in detail what this means later on.</span></span>
<span class="giallo-l"><span>    * `merkle_path_table_right`: A table of type NodesTable that handles cases where only the right child is pulled.</span></span>
<span class="giallo-l"><span>    * `merkle_path_table_both`: A table of type `NodesTable` that handles cases where both left and right children are pulled.</span></span>
<span class="giallo-l"><span>    * `root_table`: A table of type `RootTable` that reconciles the final values of Merkle paths with the expected roots.</span></span>
<span class="giallo-l"><span>    * `incr_table`: A table of type `IncrLookup`. A lookup table for increment operations to verify the depth relationships between parent and children nodes.</span></span></code></pre><h3 id="channels">Channels:</h3>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * `nodes_channel` \- Manages intermediate nodes in Merkle paths (format: `[Root ID, Digest, Depth, Index]`)</span></span>
<span class="giallo-l"><span>    * `roots_channel` \- Handles root verification (format: `[Root ID, Digest]`)</span></span>
<span class="giallo-l"><span>    * `lookup_channel` \- Coordinates increment operations to verify that child depth is the parent depth plus one.</span></span></code></pre><h3 id="initialization">Initialization</h3>
<p>The <code>MerkleTreeCS::new()</code> method constructs the entire constraint system. The main goal of this method is to add the tables and channels to <code>cs</code> (the constraint system) and create the <code>MerkleTreeCS</code>.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub fn new(cs: &amp;mut ConstraintSystem) -&gt; Self {</span></span>
<span class="giallo-l"><span>    let nodes_channel = cs.add_channel(&quot;merkle_tree_nodes&quot;);</span></span>
<span class="giallo-l"><span>    let roots_channel = cs.add_channel(&quot;merkle_tree_roots&quot;);</span></span>
<span class="giallo-l"><span>    let lookup_channel = cs.add_channel(&quot;incr_lookup&quot;);</span></span>
<span class="giallo-l"><span>    let permutation_channel = cs.add_channel(&quot;permutation&quot;);  // ← NEW CHANNEL!</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // Create the three Merkle path tables</span></span>
<span class="giallo-l"><span>    let merkle_path_table_left =</span></span>
<span class="giallo-l"><span>        NodesTable::new(cs, MerklePathPullChild::Left, nodes_channel, lookup_channel);</span></span>
<span class="giallo-l"><span>    let merkle_path_table_right =</span></span>
<span class="giallo-l"><span>        NodesTable::new(cs, MerklePathPullChild::Right, nodes_channel, lookup_channel);</span></span>
<span class="giallo-l"><span>    let merkle_path_table_both =</span></span>
<span class="giallo-l"><span>        NodesTable::new(cs, MerklePathPullChild::Both, nodes_channel, lookup_channel);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    let root_table = RootTable::new(cs, nodes_channel, roots_channel);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // Create the increment lookup table with the new permutation channel</span></span>
<span class="giallo-l"><span>    let mut table = cs.add_table(&quot;incr_lookup_table&quot;);</span></span>
<span class="giallo-l"><span>    let incr_table = IncrLookup::new(&amp;mut table, lookup_channel, permutation_channel, 20);</span></span>
<span class="giallo-l"><span>    </span></span>
<span class="giallo-l"><span>    Self { /* ... */ }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>As can be seen, there is an extra channel not mentioned before:</p>
<p>The <code>permutation_channel</code> is a new channel introduced specifically for the <code>IncrLookup</code> table. This channel serves a crucial purpose in the lookup table verification process. It ensures that the two columns in IncrLookup are permutations of each other. These columns are called <code>entries_ordered</code> and <code>entries_sorted</code>, and we will examine them in detail later.</p>
<h2 id="an-example-step-by-step">An Example Step by Step</h2>
<p>We believe that the best way to understand how the constraint system is built and how the tables are created is by looking at an example. For this, we’ll use the example provided by Binius in <a rel="noopener external" target="_blank" href="https://github.com/IrreducibleOSS/binius/blob/main/examples/merkle_tree.rs">merkle_tree.rs</a>, where we’ll be able to construct a tree, some paths, the constraint system, and the proof that validates those paths.</p>
<p>The file begins with some arguments that we’re going to adjust. For simplicity, we want to create a tree with 8 leaves and prove that two of them are part of the tree. In other words, we’ll take <code>default_value_t = 3</code> for the <code>log_leaves</code> (since we want an 8-leaves tree), <code>default_value_t = 1</code> for <code>log_paths</code> (since we want two prove two paths), and <code>default_value_t = 1</code> for <code>log_inv_rate</code></p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>struct Args {</span></span>
<span class="giallo-l"><span>    /// The number of leaves in the merkle tree.</span></span>
<span class="giallo-l"><span>    /// By default 8 leaves.</span></span>
<span class="giallo-l"><span>    #[arg(long, default_value_t = 3, value_parser = value_parser!(u32).range(1..))]</span></span>
<span class="giallo-l"><span>    log_leaves: u32,</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    /// The number of Merkle paths to verify.</span></span>
<span class="giallo-l"><span>    /// By default 2 paths.</span></span>
<span class="giallo-l"><span>    #[arg(short,long, default_value_t = 1, value_parser = value_parser!(u32).range(1..))]</span></span>
<span class="giallo-l"><span>    log_paths: u32,</span></span>
<span class="giallo-l"><span>    </span></span>
<span class="giallo-l"><span>    /// The negative binary logarithm of the Reed–Solomon code rate.</span></span>
<span class="giallo-l"><span>    #[arg(long, default_value_t = 1, value_parser = value_parser!(u32).range(1..))]</span></span>
<span class="giallo-l"><span>    log_inv_rate: u32,</span></span>
<span class="giallo-l"><span>}</span></span></code></pre><h3 id="building-the-tree-and-paths">Building the Tree and paths</h3>
<p>Now that we have the arguments, if you follow the function <a rel="noopener external" target="_blank" href="https://github.com/IrreducibleOSS/binius/blob/main/examples/merkle_tree.rs#L39">main()</a> you’ll see that the tree and the Merkle paths are built there. Let’s add some prints in this part of the code to see their values.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>/* ... */</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>let mut rng = StdRng::seed_from_u64(0);</span></span>
<span class="giallo-l"><span>// Create a Merkle Tree with 8 leaves</span></span>
<span class="giallo-l"><span>let leaves = (0..1 &lt;&lt; args.log_leaves)</span></span>
<span class="giallo-l"><span>    .map(|_| rng.r#gen::&lt;[u8; 32]&gt;())</span></span>
<span class="giallo-l"><span>    .collect::&lt;Vec&lt;_&gt;&gt;();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>let tree = MerkleTree::new(&amp;leaves);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>let roots: [u8; 32] = tree.root();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>println!(&quot;--------- Merkle tree data -------&quot;);</span></span>
<span class="giallo-l"><span>println!(&quot;Leaves: {:?}&quot;, leaves);</span></span>
<span class="giallo-l"><span>println!(&quot;Root: {:?}&quot;, roots);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>let paths = (0..1 &lt;&lt; args.log_paths)</span></span>
<span class="giallo-l"><span>    .map(|_| {</span></span>
<span class="giallo-l"><span>        let index = rng.gen_range(0..1 &lt;&lt; args.log_leaves);</span></span>
<span class="giallo-l"><span>        println!(&quot;------- Path data -------&quot;);</span></span>
<span class="giallo-l"><span>        println!(&quot;Proving leaf index: {:?}&quot;, index);</span></span>
<span class="giallo-l"><span>        println!(&quot;Proving leaf: {:?}&quot;, leaves[index]);</span></span>
<span class="giallo-l"><span>        println!(&quot;Merkle tree path: {:?}&quot;, tree.merkle_path(index));</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        MerklePath {</span></span>
<span class="giallo-l"><span>            root_id: 0,</span></span>
<span class="giallo-l"><span>            index,</span></span>
<span class="giallo-l"><span>            leaf: leaves[index],</span></span>
<span class="giallo-l"><span>            nodes: tree.merkle_path(index),</span></span>
<span class="giallo-l"><span>        }</span></span>
<span class="giallo-l"><span>    })</span></span>
<span class="giallo-l"><span>    .collect::&lt;Vec&lt;_&gt;&gt;();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>/* ... */</span></span></code></pre>
<p>This should print first the eight leaves and the root (each of them is a 32-byte array):</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>--------- Merkle tree data -------</span></span>
<span class="giallo-l"><span>Leaves: [</span></span>
<span class="giallo-l"><span>    [127, 178, 123, 148, 22, 2, 208, 29, 17, 84, 34, 17, 19, 79, 199, 26, 172, 174, 84, 227, 126, 125, 0, 123, 187, 123, 85, 239, 240, 98, 162, 132], </span></span>
<span class="giallo-l"><span>    [154, 99, 40, 60, 186, 240, 253, 188, 235, 31, 100, 121, 177, 151, 243, 168, 141, 208, 216, 9, 47, 231, 42, 124, 86, 40, 21, 56, 115, 139, 7, 226], </span></span>
<span class="giallo-l"><span>    [114, 238, 165, 17, 148, 16, 151, 58, 227, 40, 173, 146, 145, 98, 104, 18, 142, 219, 71, 16, 110, 26, 214, 168, 195, 213, 69, 132, 155, 138, 184, 27], </span></span>
<span class="giallo-l"><span>    [16, 24, 93, 38, 2, 59, 54, 16, 206, 183, 217, 245, 125, 73, 210, 179, 135, 99, 161, 43, 43, 189, 250, 147, 39, 90, 255, 24, 42, 251, 149, 220],</span></span>
<span class="giallo-l"><span>    [118, 35, 234, 226, 120, 82, 64, 185, 61, 18, 177, 106, 102, 216, 22, 16, 124, 220, 140, 137, 199, 16, 143, 255, 32, 149, 225, 141, 223, 239, 137, 134], </span></span>
<span class="giallo-l"><span>    [177, 24, 234, 85, 97, 98, 77, 166, 204, 83, 123, 174, 213, 110, 96, 47, 147, 140, 128, 78, 39, 248, 49, 150, 97, 12, 136, 40, 199, 35, 247, 152], </span></span>
<span class="giallo-l"><span>    [80, 79, 178, 164, 68, 97, 204, 11, 235, 179, 37, 40, 14, 217, 19, 10, 89, 187, 219, 49, 28, 1, 253, 115, 73, 9, 161, 31, 158, 72, 102, 40], </span></span>
<span class="giallo-l"><span>    [180, 59, 54, 61, 129, 174, 139, 104, 153, 70, 236, 229, 198, 130, 205, 89, 138, 101, 234, 191, 246, 58, 53, 114, 223, 228, 95, 181, 173, 229, 139, 220]</span></span>
<span class="giallo-l"><span>]</span></span>
<span class="giallo-l"><span>Root: [193, 178, 67, 64, 61, 105, 200, 119, 129, 200, 250, 91, 108, 49, 178, 161, 234, 142, 150, 145, 206, 128, 43, 153, 216, 191, 196, 183, 198, 179, 118, 122]</span></span></code></pre>
<p>Then the first Merkle path:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>------- Path data -------</span></span>
<span class="giallo-l"><span>Proving leaf index: 3</span></span>
<span class="giallo-l"><span>Proving leaf: [16, 24, 93, 38, 2, 59, 54, 16, 206, 183, 217, 245, 125, 73, 210, 179, 135, 99, 161, 43, 43, 189, 250, 147, 39, 90, 255, 24, 42, 251, 149, 220]</span></span>
<span class="giallo-l"><span>Merkle tree path: [</span></span>
<span class="giallo-l"><span>    [114, 238, 165, 17, 148, 16, 151, 58, 227, 40, 173, 146, 145, 98, 104, 18, 142, 219, 71, 16, 110, 26, 214, 168, 195, 213, 69, 132, 155, 138, 184, 27], </span></span>
<span class="giallo-l"><span>    [246, 247, 101, 36, 57, 192, 24, 48, 162, 208, 160, 30, 187, 154, 180, 176, 208, 104, 135, 216, 175, 8, 0, 249, 96, 50, 194, 72, 102, 219, 184, 27], </span></span>
<span class="giallo-l"><span>    [70, 219, 30, 17, 251, 21, 8, 37, 23, 248, 120, 106, 49, 210, 42, 247, 15, 227, 231, 151, 101, 7, 187, 203, 29, 109, 186, 223, 43, 126, 183, 173]</span></span>
<span class="giallo-l"><span>]</span></span></code></pre>
<p>And finally, the second Merkle path:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>------- Path data -------</span></span>
<span class="giallo-l"><span>Proving leaf index: 4</span></span>
<span class="giallo-l"><span>Proving leaf: [118, 35, 234, 226, 120, 82, 64, 185, 61, 18, 177, 106, 102, 216, 22, 16, 124, 220, 140, 137, 199, 16, 143, 255, 32, 149, 225, 141, 223, 239, 137, 134]</span></span>
<span class="giallo-l"><span>Merkle tree path: [</span></span>
<span class="giallo-l"><span>    [177, 24, 234, 85, 97, 98, 77, 166, 204, 83, 123, 174, 213, 110, 96, 47, 147, 140, 128, 78, 39, 248, 49, 150, 97, 12, 136, 40, 199, 35, 247, 152],</span></span>
<span class="giallo-l"><span>    [44, 37, 79, 124, 156, 84, 213, 102, 239, 101, 1, 89, 211, 73, 117, 58, 143, 41, 102, 47, 67, 32, 248, 100, 29, 138, 44, 204, 232, 177, 216, 54], </span></span>
<span class="giallo-l"><span>    [124, 166, 97, 100, 173, 242, 98, 95, 141, 158, 147, 144, 202, 239, 150, 192, 0, 99, 9, 138, 61, 19, 65, 163, 160, 4, 227, 66, 233, 115, 199, 3]</span></span>
<span class="giallo-l"><span>]</span></span></code></pre>
<p>So, our Merkle tree should look like the one below. To make the graph more readable, we only wrote the first byte of each node, even though we should have written all 32 bytes. The first path is shown in green, and the second one in blue. You may be wondering how we know the content of the middle nodes “181” and “67”, since they are neither the leaves, the root, nor part of the Merkle paths. We got that information from prints we’ll make later.</p>
<p><img src="/images/external/BJe-hoFQlx.png" alt="image" /></p>
<p>In the remainder of this post, we’ll explain the three types of tables used in a <code>MerkleTreeCS</code>: <strong>NodesTable</strong> , <strong>RootTable</strong> and <strong>IncrLookup</strong>.</p>
<p>What are they for? How are they populated? How do they interact with the different channels? We’ll answer these questions using the tree we just built as an illustration.</p>
<h2 id="nodestable">NodesTable</h2>
<h3 id="purpose">Purpose</h3>
<p>This table type is designed to handle the relationships between parent and child nodes. Each row in the table corresponds to a <code>MerklePathEvent</code>, which captures the interaction between three related nodes: two children (left and right) and their parent.</p>
<p>When proving Merkle tree paths, the table is populated by traversing each path and creating one row for every parent-children trio encountered. This systematic approach ensures that all necessary node relationships are properly encoded and can be verified through the constraint system.</p>
<h3 id="content-and-columns">Content and Columns</h3>
<p>The <a rel="noopener external" target="_blank" href="https://github.com/IrreducibleOSS/binius/blob/main/crates/m3/src/gadgets/merkle_tree/mod.rs#L218">NodesTable</a> contains a set of columns that can be categorized into three main groups:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. **MerklePathEvent Data**  </span></span></code></pre>
<p>These columns store the fundamental information about each node relationship:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>       * `root_id`: Identifies which Merkle tree the three nodes belong to.</span></span>
<span class="giallo-l"><span>       * `left_columns`, `right_columns`: Store the digest values of the left and right child nodes.</span></span>
<span class="giallo-l"><span>       * `parent_depth`, `child_depth`: indicate the tree levels where the parent and children nodes are. The levels (or depths) start at 0 in the top (the root) and continues until $\log_2 (\text{leaves}.\text{len()})$, ending at the leaves.</span></span>
<span class="giallo-l"><span>       * `parent_index`, `left_index`, `right_index_packed`: Store the positional indices of nodes.</span></span>
<span class="giallo-l"><span>       * `_pull_child`: Specifies which child node needs to be pulled from the channel.</span></span>
<span class="giallo-l"><span>    2. **Groestl-256 Hash Computation**  </span></span></code></pre>
<p>These columns handle the cryptographic hash operations:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>       * `state_out_shifted`: Contains the concatenated bytes of left and right children organized for the Groestl-256 permutation.</span></span>
<span class="giallo-l"><span>       * `permutation_output_columns`: Store the bytes after the Groestl-256 output transformation.</span></span>
<span class="giallo-l"><span>       * `permutation`: The Groestl-256 permutation gadget.</span></span></code></pre>
<blockquote>
<p>Note: This serves as a clear example of the power of gadgets. In a sense, the gadget responsible for verifying a Merkle path delegates the task of checking the validity of the hash function to another gadget (not detailed in this post, but it operates in an analogous way). This modular approach allows us to build proofs for more complex programs in a clean and scalable manner.</p>
</blockquote>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    3. **Depth Constraint**</span></span></code></pre>
<p><code>increment</code>: A gadget used to ensure the child node depth is exactly one more than the parent node depth.</p>
<h3 id="initialization-1">Initialization</h3>
<p>The <code>NodesTable</code> is created through its <a rel="noopener external" target="_blank" href="https://github.com/IrreducibleOSS/binius/blob/main/crates/m3/src/gadgets/merkle_tree/mod.rs#L249">new()</a> method. This initialization process involves:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * Adding the table to the **constraint system** using `cs.add_table()`.</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    * Adding **committed columns** to the table using `table.add_committed()` or `table.add_committed_multiple()`.</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    * Adding **virtual columns** to the table using `table.add_packed()`, `table.add_shifted()` and `table.add_computed()`. In the [Binius documentation](https://www.binius.xyz/building/pattern/declaring) you can see an explanation of the difference between committed and virtual columns.</span></span></code></pre>
<blockquote>
<p>Note: This is particularly relevant in M3, as it represents one of the key differences compared to other proving systems. Virtual columns play a fundamental role by allowing the prover to commit only to a reduced number of tables (committed columns), while avoiding the need to commit to the virtual ones. The reason this is possible is that all the information required to reconstruct the virtual columns from the committed ones is fully encoded in the constraint system.</p>
</blockquote>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * Establishing a **zero constraint** to ensure that the concatenation of left and right children nodes equals the input of the parent hash. This is implemented using `table.assert_zero()`.</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>for i in 0..8 {</span></span>
<span class="giallo-l"><span>    table.assert_zero(</span></span>
<span class="giallo-l"><span>        format!(&quot;state_in_assert[{i}]&quot;),</span></span>
<span class="giallo-l"><span>        state_in_packed[i]</span></span>
<span class="giallo-l"><span>            - upcast_col(left_packed[i])</span></span>
<span class="giallo-l"><span>            - upcast_col(right_packed[i]) * B64::from(1 &lt;&lt; 32),</span></span>
<span class="giallo-l"><span>    );</span></span>
<span class="giallo-l"><span>}</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    * Setting up **flushing rules** that define how the table interacts with the [NodesChannel](https://github.com/IrreducibleOSS/binius/blob/main/crates/m3/src/gadgets/merkle_tree/mod.rs#L409) using `nodes_channel.push()` and `nodes_channel.pull()`.</span></span></code></pre><h3 id="channel-interaction">Channel interaction</h3>
<p>Let’s explain a bit more the last point mentioned in the table initialization. The <code>NodesTable</code> interacts with the <code>NodesChannel</code> through the following push-pull rule: <em>Push Parent, Pull Child</em>.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * **Push:** Parent node information (root ID, content, depth, and index) should be pushed to the channel.</span></span>
<span class="giallo-l"><span>    * **Pull:** Depending on the `pull_child` input, pull either the left child, right child, or both children from the channel. For each path, only one child should be pulled, left or right depending the path route. But if there is a parent-children trio Merkle event that is used in different paths once pulling left and once pulling right, then both children are pulled.</span></span></code></pre><h3 id="table-population">Table population</h3>
<p>The struct <code>NodesTable</code> implements the <code>TableFiller</code> trait, with the core population logic in the <a rel="noopener external" target="_blank" href="https://github.com/IrreducibleOSS/binius/blob/main/crates/m3/src/gadgets/merkle_tree/mod.rs#L508">fill()</a> function. For each <code>MerklePathEvent</code>, the function:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * Extracts the node relationship data (parent, left child, right child)</span></span>
<span class="giallo-l"><span>    * Computes derived values like child indices and depth increments.</span></span>
<span class="giallo-l"><span>    * Fills the permutation state with the concatenated child node data.</span></span>
<span class="giallo-l"><span>    * Populates all table columns with the appropriate values.</span></span></code></pre>
<p>This filling process transforms the trace data into the constraint system representation needed for proof generation and verification.</p>
<h3 id="our-example">Our Example</h3>
<p>To understand what a <code>MerklePathEvent</code> is and how these tables are populated let’s look at our example.</p>
<p>In the <code>main()</code> function of <code>merkle_tree.rs</code> example, once we have the tree and the paths, the trace is generated and after that the tables are filled using the function <a rel="noopener external" target="_blank" href="https://github.com/IrreducibleOSS/binius/blob/main/crates/m3/src/gadgets/merkle_tree/mod.rs#L100">fill_tables()</a>. Here we can add more prints to see what all this data looks like.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub fn fill_tables(</span></span>
<span class="giallo-l"><span>    &amp;self,</span></span>
<span class="giallo-l"><span>    trace: &amp;MerkleTreeTrace,</span></span>
<span class="giallo-l"><span>    cs: &amp;ConstraintSystem,</span></span>
<span class="giallo-l"><span>    witness: &amp;mut WitnessIndex,</span></span>
<span class="giallo-l"><span>) -&gt; anyhow::Result&lt;()&gt; {</span></span>
<span class="giallo-l"><span>    // Filter the MerklePathEvents into three iterators based on the pull child type.</span></span>
<span class="giallo-l"><span>    let left_events = trace</span></span>
<span class="giallo-l"><span>        .nodes</span></span>
<span class="giallo-l"><span>        .iter()</span></span>
<span class="giallo-l"><span>        .copied()</span></span>
<span class="giallo-l"><span>        .filter(|event| event.flush_left &amp;&amp; !event.flush_right)</span></span>
<span class="giallo-l"><span>        .collect::&lt;Vec&lt;_&gt;&gt;();</span></span>
<span class="giallo-l"><span>    let right_events = trace</span></span>
<span class="giallo-l"><span>        .nodes</span></span>
<span class="giallo-l"><span>        .iter()</span></span>
<span class="giallo-l"><span>        .copied()</span></span>
<span class="giallo-l"><span>        .filter(|event| !event.flush_left &amp;&amp; event.flush_right)</span></span>
<span class="giallo-l"><span>        .collect::&lt;Vec&lt;_&gt;&gt;();</span></span>
<span class="giallo-l"><span>    let both_events = trace</span></span>
<span class="giallo-l"><span>        .nodes</span></span>
<span class="giallo-l"><span>        .iter()</span></span>
<span class="giallo-l"><span>        .copied()</span></span>
<span class="giallo-l"><span>        .filter(|event| event.flush_left &amp;&amp; event.flush_right)</span></span>
<span class="giallo-l"><span>        .collect::&lt;Vec&lt;_&gt;&gt;();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    println!(&quot;------- Merkle Path Events -------&quot;);</span></span>
<span class="giallo-l"><span>    println!(&quot;Left events: {:?}&quot;, &amp;left_events);</span></span>
<span class="giallo-l"><span>    println!(&quot;Right events: {:?}&quot;, &amp;right_events);</span></span>
<span class="giallo-l"><span>    println!(&quot;Both events: {:?}&quot;, &amp;both_events);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    // Fill the nodes tables based on the filtered events.</span></span>
<span class="giallo-l"><span>    witness.fill_table_parallel(&amp;self.merkle_path_table_left, &amp;left_events)?;</span></span>
<span class="giallo-l"><span>    witness.fill_table_parallel(&amp;self.merkle_path_table_right, &amp;right_events)?;</span></span>
<span class="giallo-l"><span>    witness.fill_table_parallel(&amp;self.merkle_path_table_both, &amp;both_events)?;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    /*...*/</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>This should print, first the left events:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>Left events: [</span></span>
<span class="giallo-l"><span>    MerklePathEvent { </span></span>
<span class="giallo-l"><span>        root_id: 0, </span></span>
<span class="giallo-l"><span>        left: [67, 45, 38, 237, 191, 26, 225, 172, 10, 94, 207, 176, 214, 146, 204, 230, 180, 241, 18, 217, 51, 18, 215, 92, 201, 50, 136, 22, 3, 172, 197, 55], </span></span>
<span class="giallo-l"><span>        right: [44, 37, 79, 124, 156, 84, 213, 102, 239, 101, 1, 89, 211, 73, 117, 58, 143, 41, 102, 47, 67, 32, 248, 100, 29, 138, 44, 204, 232, 177, 216, 54], </span></span>
<span class="giallo-l"><span>        parent: [70, 219, 30, 17, 251, 21, 8, 37, 23, 248, 120, 106, 49, 210, 42, 247, 15, 227, 231, 151, 101, 7, 187, 203, 29, 109, 186, 223, 43, 126, 183, 173], </span></span>
<span class="giallo-l"><span>        parent_depth: 1, </span></span>
<span class="giallo-l"><span>        parent_index: 1, </span></span>
<span class="giallo-l"><span>        flush_left: true, </span></span>
<span class="giallo-l"><span>        flush_right: false </span></span>
<span class="giallo-l"><span>    }, </span></span>
<span class="giallo-l"><span>    MerklePathEvent { </span></span>
<span class="giallo-l"><span>        root_id: 0, </span></span>
<span class="giallo-l"><span>        left: [118, 35, 234, 226, 120, 82, 64, 185, 61, 18, 177, 106, 102, 216, 22, 16, 124, 220, 140, 137, 199, 16, 143, 255, 32, 149, 225, 141, 223, 239, 137, 134], </span></span>
<span class="giallo-l"><span>        right: [177, 24, 234, 85, 97, 98, 77, 166, 204, 83, 123, 174, 213, 110, 96, 47, 147, 140, 128, 78, 39, 248, 49, 150, 97, 12, 136, 40, 199, 35, 247, 152], </span></span>
<span class="giallo-l"><span>        parent: [67, 45, 38, 237, 191, 26, 225, 172, 10, 94, 207, 176, 214, 146, 204, 230, 180, 241, 18, 217, 51, 18, 215, 92, 201, 50, 136, 22, 3, 172, 197, 55], </span></span>
<span class="giallo-l"><span>        parent_depth: 2, </span></span>
<span class="giallo-l"><span>        parent_index: 2, </span></span>
<span class="giallo-l"><span>        flush_left: true, </span></span>
<span class="giallo-l"><span>        flush_right: false </span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>]</span></span></code></pre>
<p>This event is a left one because the node that has to be pulled out from the channel is the left child “67”:<br />
<img src="/images/external/r19SajY7ee.png" alt="image" /><br />
The same with the second event. Here, the node that has to be pulled is the left child “118”:<br />
<img src="/images/external/HJF1CjYXee.png" alt="image" /></p>
<p>On the other hand, you should also see the prints of the right events:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>Right events: [</span></span>
<span class="giallo-l"><span>    MerklePathEvent { </span></span>
<span class="giallo-l"><span>        root_id: 0, </span></span>
<span class="giallo-l"><span>        left: [114, 238, 165, 17, 148, 16, 151, 58, 227, 40, 173, 146, 145, 98, 104, 18, 142, 219, 71, 16, 110, 26, 214, 168, 195, 213, 69, 132, 155, 138, 184, 27], </span></span>
<span class="giallo-l"><span>        right: [16, 24, 93, 38, 2, 59, 54, 16, 206, 183, 217, 245, 125, 73, 210, 179, 135, 99, 161, 43, 43, 189, 250, 147, 39, 90, 255, 24, 42, 251, 149, 220], </span></span>
<span class="giallo-l"><span>        parent: [181, 157, 35, 221, 161, 240, 65, 205, 125, 210, 142, 58, 147, 55, 148, 56, 221, 206, 216, 118, 104, 90, 130, 87, 219, 62, 104, 251, 27, 201, 113, 211], </span></span>
<span class="giallo-l"><span>        parent_depth: 2, </span></span>
<span class="giallo-l"><span>        parent_index: 1, </span></span>
<span class="giallo-l"><span>        flush_left: false, </span></span>
<span class="giallo-l"><span>        flush_right: true </span></span>
<span class="giallo-l"><span>    }, </span></span>
<span class="giallo-l"><span>    MerklePathEvent { </span></span>
<span class="giallo-l"><span>        root_id: 0, </span></span>
<span class="giallo-l"><span>        left: [246, 247, 101, 36, 57, 192, 24, 48, 162, 208, 160, 30, 187, 154, 180, 176, 208, 104, 135, 216, 175, 8, 0, 249, 96, 50, 194, 72, 102, 219, 184, 27], </span></span>
<span class="giallo-l"><span>        right: [181, 157, 35, 221, 161, 240, 65, 205, 125, 210, 142, 58, 147, 55, 148, 56, 221, 206, 216, 118, 104, 90, 130, 87, 219, 62, 104, 251, 27, 201, 113, 211], </span></span>
<span class="giallo-l"><span>        parent: [124, 166, 97, 100, 173, 242, 98, 95, 141, 158, 147, 144, 202, 239, 150, 192, 0, 99, 9, 138, 61, 19, 65, 163, 160, 4, 227, 66, 233, 115, 199, 3], </span></span>
<span class="giallo-l"><span>        parent_depth: 1, </span></span>
<span class="giallo-l"><span>        parent_index: 0, </span></span>
<span class="giallo-l"><span>        flush_left: false, </span></span>
<span class="giallo-l"><span>        flush_right: true </span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>]</span></span></code></pre>
<p>In these cases the nodes that have to be pulled are the right children:<br />
<img src="/images/external/S19_AiY7ge.png" alt="image" /></p>
<p><img src="/images/external/ByT3DLk4gg.png" alt="image" /></p>
<p>Finally, you’ll find a print of a both left and right event:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>Both events: [</span></span>
<span class="giallo-l"><span>    MerklePathEvent { </span></span>
<span class="giallo-l"><span>        root_id: 0, </span></span>
<span class="giallo-l"><span>        left: [124, 166, 97, 100, 173, 242, 98, 95, 141, 158, 147, 144, 202, 239, 150, 192, 0, 99, 9, 138, 61, 19, 65, 163, 160, 4, 227, 66, 233, 115, 199, 3], </span></span>
<span class="giallo-l"><span>        right: [70, 219, 30, 17, 251, 21, 8, 37, 23, 248, 120, 106, 49, 210, 42, 247, 15, 227, 231, 151, 101, 7, 187, 203, 29, 109, 186, 223, 43, 126, 183, 173], </span></span>
<span class="giallo-l"><span>        parent: [193, 178, 67, 64, 61, 105, 200, 119, 129, 200, 250, 91, 108, 49, 178, 161, 234, 142, 150, 145, 206, 128, 43, 153, 216, 191, 196, 183, 198, 179, 118, 122], </span></span>
<span class="giallo-l"><span>        parent_depth: 0, </span></span>
<span class="giallo-l"><span>        parent_index: 0, </span></span>
<span class="giallo-l"><span>        flush_left: true, </span></span>
<span class="giallo-l"><span>        flush_right: true </span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>]</span></span></code></pre>
<p>In this case, if you are looking at the blue path, the right child node “70” has to be pulled, but if you are looking at the green path, the left child “124” has to be pulled. That’s why this event is both left and right:<br />
<img src="/images/external/SJV1r2tmxx.png" alt="image" /></p>
<h2 id="roottable">RootTable</h2>
<h3 id="purpose-1">Purpose</h3>
<p><code>RootTable</code> is a table within the Binius Merkle Tree constraint system that is responsible for reconciling the final values of Merkle paths with the declared Merkle roots. While <code>NodesTable</code> verifies the steps along a path, <code>RootTable</code> provides the ultimate cryptographic guarantee that these paths lead to the correct, pre-committed Merkle roots.</p>
<h3 id="content">Content</h3>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub struct RootTable {</span></span>
<span class="giallo-l"><span>    pub id: TableId,</span></span>
<span class="giallo-l"><span>    pub root_id: Col&lt;B8&gt;,</span></span>
<span class="giallo-l"><span>    pub digest: [Col&lt;B32&gt;; 8]</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>This table contains the data -the Id and the digest (or content)- of the root nodes of all the trees we are analyzing, since we can prove different paths for different trees.</p>
<h3 id="initialization-2">Initialization</h3>
<p>RootTable initialization is done by its method <a rel="noopener external" target="_blank" href="https://github.com/IrreducibleOSS/binius/blob/main/crates/m3/src/gadgets/merkle_tree/mod.rs#L469">new()</a>:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>impl RootTable {</span></span>
<span class="giallo-l"><span>    pub fn new(</span></span>
<span class="giallo-l"><span>        cs: &amp;mut ConstraintSystem,</span></span>
<span class="giallo-l"><span>        nodes_channel: ChannelId,</span></span>
<span class="giallo-l"><span>        roots_channel: ChannelId,</span></span>
<span class="giallo-l"><span>    ) -&gt; Self {</span></span>
<span class="giallo-l"><span>        </span></span>
<span class="giallo-l"><span>        /*...*/</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>This function:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. Adds a table to the `cs`:</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>let mut table = cs.add_table(&quot;merkle_tree_roots&quot;);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    2. Defines columns within that table (committed and/or virtual):</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>let root_id = table.add_committed(&quot;root_id&quot;);</span></span>
<span class="giallo-l"><span>let digest = table.add_committed_multiple(&quot;digest&quot;);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>let zero = table.add_constant(&quot;zero&quot;, [B32::ZERO]);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    3. Adds the flushing rules associated with that table and its channels (`nodes_channel` and `roots_channel`).</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>table.pull(roots_channel_id, to_root_flush(root_id_upcasted, digest));</span></span>
<span class="giallo-l"><span>let mut nodes_channel = NodesChannel::new(&amp;mut table, nodes_channel_id);</span></span>
<span class="giallo-l"><span>nodes_channel.pull(root_id_upcasted, digest, zero, zero);</span></span></code></pre><h3 id="flushing-rules">Flushing Rules</h3>
<p><code>RootTable</code> primarily interacts with the <code>nodes_channel</code> and <code>roots_channel</code> to perform its reconciliation. It will <code>pull</code> data from both channels to verify consistency.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * **`nodes_channel`** : This channel carries information about all intermediate and final nodes of the Merkle paths. `RootTable` will `pull` the digest of the final node of a path from this channel.</span></span>
<span class="giallo-l"><span>    * **`roots_channel`** : This channel contains the actual Merkle roots that are being proven against. `RootTable` will `pull` these values to ensure that the path&#39;s end-point matches one of the valid roots.</span></span></code></pre>
<p>The flushing rules would ensure that the necessary data (final path node digests and declared root digests) are available to the <code>RootTable</code> for its internal consistency checks. This comparison forms the core of the zero-knowledge constraint for root verification, ensuring that the Merkle path indeed leads to the claimed root.</p>
<h2 id="incrlookup">IncrLookup</h2>
<h3 id="purpose-2">Purpose</h3>
<p>Beyond <code>NodesTable</code> and <code>RootTable</code>, the Binius Merkle Tree constraint system also utilizes <a rel="noopener external" target="_blank" href="https://github.com/IrreducibleOSS/binius/blob/main/crates/m3/src/gadgets/indexed_lookup/incr.rs#L161">IncrLookup</a>. This is a specialized gadget designed to efficiently verify 8-bit increment operations with a carry bit. Instead of writing complex arithmetic constraints for each instance of an increment operation, <code>IncrLookup</code> allows the prover to simply demonstrate that each operation performed is present in a pre-defined table of all valid increment results. This significantly reduces the computational cost and proof size.</p>
<p>In the specific context of Merkle tree inclusion proofs, <code>IncrLookup</code> is used to ensure that in each <code>MerklePathEvent</code>, the child’s depth is exactly one greater than the parent’s depth.</p>
<h3 id="content-1">Content</h3>
<p>The <a rel="noopener external" target="_blank" href="https://github.com/IrreducibleOSS/binius/blob/main/crates/m3/src/gadgets/indexed_lookup/incr.rs#L161">IncrLookup</a> only has two columns <code>entries_ordered</code> and <code>entries_sorted</code>. Both columns have exactly the same values but sorted in different ways. We’ll see how these columns are filled later on.</p>
<p>The struct <code>IncrLookup</code> has one more field <code>lookup_producer</code>. <a rel="noopener external" target="_blank" href="https://github.com/IrreducibleOSS/binius/blob/main/crates/m3/src/gadgets/lookup.rs#L16">LookupProducer</a> is the gadget in charge of creating the lookup table.</p>
<h3 id="initialization-3">Initialization</h3>
<p>When the <code>MerkleTreeCS</code> is set up, an <code>IncrLookup</code> instance is created (see <a rel="noopener external" target="_blank" href="https://github.com/IrreducibleOSS/binius/blob/main/crates/m3/src/gadgets/merkle_tree/mod.rs#L87">here</a>) through its method <a rel="noopener external" target="_blank" href="https://github.com/IrreducibleOSS/binius/blob/main/crates/m3/src/gadgets/indexed_lookup/incr.rs#L176">new()</a>, which does the following:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. Fixes the size for the columns:</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>table.require_fixed_size(IncrIndexedLookup.log_size());</span></span></code></pre>
<p>Note that <code>IncrIndexedLookup.log_size()</code> is $2^9 = 512$ as you can see <a rel="noopener external" target="_blank" href="https://github.com/IrreducibleOSS/binius/blob/main/crates/m3/src/gadgets/indexed_lookup/incr.rs#L245">here</a>. This is because each index $i \in {0, \ldots, 511}$ of the column will represent an incrementation of some certain input. The 8 less significant bits of $i$ tell us the input and the most significant bit tell us the carry.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    2. Adds the `entries_ordered` and `entries_sorted` columns to the table.</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    3. Adds **flushing rules** for the `permutation_channel` of our constraint system to ensure that one column is the permutation of the other one:</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>// Use flush to check that entries_sorted is a permutation of entries_ordered.</span></span>
<span class="giallo-l"><span>table.push(permutation_chan, [entries_ordered]);</span></span>
<span class="giallo-l"><span>table.pull(permutation_chan, [entries_sorted]);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    4. Configures a `LookupProducer` to manage how entries are queried and to handle their multiplicities (how many times each specific increment operation occurs during the proof).</span></span></code></pre><h3 id="table-population-1">Table population</h3>
<p>As well as the other tables, the <code>incr_table</code> of the <code>MerkleTreeCS</code> is filled inside the function <a rel="noopener external" target="_blank" href="https://github.com/IrreducibleOSS/binius/blob/main/crates/m3/src/gadgets/merkle_tree/mod.rs#L100">fill_tables()</a>, specifically in this part:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>let lookup_counts = tally(cs, witness, &amp;[], self.lookup_channel, &amp;IncrIndexedLookup)?;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>// Fill the lookup table with the sorted counts</span></span>
<span class="giallo-l"><span>let sorted_counts = lookup_counts</span></span>
<span class="giallo-l"><span>    .into_iter()</span></span>
<span class="giallo-l"><span>    .enumerate()</span></span>
<span class="giallo-l"><span>    .sorted_by_key(|(_, count)| Reverse(*count))</span></span>
<span class="giallo-l"><span>    .collect::&lt;Vec&lt;_&gt;&gt;();</span></span>
<span class="giallo-l"><span>witness.fill_table_parallel(&amp;self.incr_table, &amp;sorted_counts)?;</span></span></code></pre>
<p>Let’s break down this code snippet in detail. For that, we have to understand what is the variable <code>lookup_counts</code> and what does the function <code>tally()</code> do.</p>
<h4 id="lookup-counts">Lookup Counts</h4>
<p><code>lookup_counts</code> is a vector of 512 integer elements. This vector is the result of the function <a rel="noopener external" target="_blank" href="https://github.com/IrreducibleOSS/binius/blob/main/crates/m3/src/builder/indexed_lookup.rs#L51">tally()</a>. As its documentation explains, this function “determines the read counts of each entry in an indexed lookup table”. It iterates over every table of our constraint system looking for a specific flushing rule: a pull operation on the input channel. In our case, the input channel is called <code>lookup_channel</code>. Whenever it finds this flushing rule it adds 1 to the result vector at a specific index (that depends on the value being pulled).</p>
<p>To understand how this index is chosen let’s add some prints and see what happens in our example.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub fn tally&lt;P&gt;(</span></span>
<span class="giallo-l"><span>	cs: &amp;ConstraintSystem&lt;B128&gt;,</span></span>
<span class="giallo-l"><span>	// TODO: This doesn&#39;t actually need mutable access. But must of the WitnessIndex methods only</span></span>
<span class="giallo-l"><span>	// allow mutable access.</span></span>
<span class="giallo-l"><span>	witness: &amp;mut WitnessIndex&lt;P&gt;,</span></span>
<span class="giallo-l"><span>	boundaries: &amp;[Boundary&lt;B128&gt;],</span></span>
<span class="giallo-l"><span>	chan: ChannelId,</span></span>
<span class="giallo-l"><span>	indexed_lookup: &amp;impl IndexedLookup&lt;B128&gt;,</span></span>
<span class="giallo-l"><span>) -&gt; Result&lt;Vec&lt;u32&gt;, Error&gt;</span></span>
<span class="giallo-l"><span>where</span></span>
<span class="giallo-l"><span>	P: PackedField&lt;Scalar = B128&gt;</span></span>
<span class="giallo-l"><span>		+ PackedExtension&lt;B1&gt;</span></span>
<span class="giallo-l"><span>		+ PackedExtension&lt;B8&gt;</span></span>
<span class="giallo-l"><span>		+ PackedExtension&lt;B16&gt;</span></span>
<span class="giallo-l"><span>		+ PackedExtension&lt;B32&gt;</span></span>
<span class="giallo-l"><span>		+ PackedExtension&lt;B64&gt;</span></span>
<span class="giallo-l"><span>		+ PackedExtension&lt;B128&gt;,</span></span>
<span class="giallo-l"><span>{</span></span>
<span class="giallo-l"><span>	println!(&quot;------- Look up counts for channel: {chan} -------&quot;);</span></span>
<span class="giallo-l"><span>	let mut counts = vec![0; 1 &lt;&lt; indexed_lookup.log_size()]; // 2^{8+1} </span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>	// Tally counts from the tables</span></span>
<span class="giallo-l"><span>	for table in &amp;cs.tables {</span></span>
<span class="giallo-l"><span>		// In merkle tree example, NodesTable and RootTable</span></span>
<span class="giallo-l"><span>		if let Some(table_index) = witness.get_table(table.id()) {</span></span>
<span class="giallo-l"><span>			println!(&quot;--- Processing table: {} (ID: {}) ---&quot;, table.name, table.id());</span></span>
<span class="giallo-l"><span>			for partition in table.partitions.values() {</span></span>
<span class="giallo-l"><span>				for flush in &amp;partition.flushes {</span></span>
<span class="giallo-l"><span>					if flush.channel_id == chan &amp;&amp; flush.direction == FlushDirection::Pull {</span></span>
<span class="giallo-l"><span>						// In the merkle tree example, this occurs in every NodesTable pull from the</span></span>
<span class="giallo-l"><span>						// lookup_channel.</span></span>
<span class="giallo-l"><span>						println!(</span></span>
<span class="giallo-l"><span>							&quot;Found matching flush: The table has a Pull operation on channel {}&quot;,</span></span>
<span class="giallo-l"><span>							chan</span></span>
<span class="giallo-l"><span>						);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>						let table_size = table_index.size();</span></span>
<span class="giallo-l"><span>						// TODO: This should be parallelized, which is pretty tricky.</span></span>
<span class="giallo-l"><span>						let segment = table_index.full_segment();</span></span>
<span class="giallo-l"><span>						let cols = flush</span></span>
<span class="giallo-l"><span>							.columns</span></span>
<span class="giallo-l"><span>							.iter()</span></span>
<span class="giallo-l"><span>							.map(|&amp;col_index| segment.get_dyn(col_index))</span></span>
<span class="giallo-l"><span>							.collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>						if !flush.selectors.is_empty() {</span></span>
<span class="giallo-l"><span>							// TODO: check flush selectors</span></span>
<span class="giallo-l"><span>							todo!(&quot;tally does not support selected table reads yet&quot;);</span></span>
<span class="giallo-l"><span>						}</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>						let mut elems = vec![B128::ZERO; cols.len()];</span></span>
<span class="giallo-l"><span>						// It&#39;s important that this is only the unpacked table size(rows * values</span></span>
<span class="giallo-l"><span>						// per row in the partition), not the full segment size. The entries</span></span>
<span class="giallo-l"><span>						// after the table size are not flushed.</span></span>
<span class="giallo-l"><span>						for i in 0..table_size * partition.values_per_row {</span></span>
<span class="giallo-l"><span>							for (elem, col) in iter::zip(&amp;mut elems, &amp;cols) {</span></span>
<span class="giallo-l"><span>								*elem = col.get(i);</span></span>
<span class="giallo-l"><span>							}</span></span>
<span class="giallo-l"><span>							let index = indexed_lookup.entry_to_index(&amp;elems);</span></span>
<span class="giallo-l"><span>							println!(&quot;Index {index} corresponds to element: {:?}&quot;, elems);</span></span>
<span class="giallo-l"><span>							counts[index] += 1;</span></span>
<span class="giallo-l"><span>						}</span></span>
<span class="giallo-l"><span>					}</span></span>
<span class="giallo-l"><span>				}</span></span>
<span class="giallo-l"><span>			}</span></span>
<span class="giallo-l"><span>		}</span></span>
<span class="giallo-l"><span>	}</span></span></code></pre>
<p>This should print at first the following:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>------- Look up counts for channel: 2 -------</span></span>
<span class="giallo-l"><span>--- Processing table: merkle_tree_nodes_left (ID: 0) ---</span></span>
<span class="giallo-l"><span>Found matching flush: The table has a Pull operation on channel 2</span></span>
<span class="giallo-l"><span>Index 258 corresponds to element: [BinaryField128b(0x00000000000000000000000000010302)]</span></span>
<span class="giallo-l"><span>Index 257 corresponds to element: [BinaryField128b(0x00000000000000000000000000010201)]</span></span></code></pre>
<p>This tells us this information: We are looking for pull outs on the channel 2 (the <code>lookup_channel</code>), and we analize first the <code>NodesTable</code> that has the <em>left events</em>. In that table it encountered two pull outs from the channel:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. The first pull out is  </span></span></code></pre>
<p><code>BinaryField128b(0x00000000000000000000000000010302)</code>. To understand what this binary field element represent follow this steps:
* convert its hex value to a binary expansion:<br />
$$0\text{x}10302 = 00010000001100000010$$
* Take the 8 less significant bits. The resulting number is called <em>input</em> : $00000010$.
* Take the bit at position 16 (from LSB to MSB and starting in 0). The resulting number is called <em>carry in</em> : $1$
* Concatenate them in the following way: <em>carry in</em> || <em>input</em>. This results in<br />
$$100000010.$$
* The result is the binary expansion of our index:<br />
$$100000010 = 258.$$</p>
<p>Now, what is has to do all of this with our Merkle tree? Well, this index $258$ is representing the parent’s and children’s depths in the following event:<br />
<img src="/images/external/ryf9s5lEgl.png" alt="image" /></p>
<p>Since the parent’s depth is 2, the input will be $00000010$. And since the children depth is the parent’s plus one, the carry is $1$. You can see this better at the initialization of every <code>NodesTable</code> (<a rel="noopener external" target="_blank" href="https://github.com/IrreducibleOSS/binius/blob/main/crates/m3/src/gadgets/merkle_tree/mod.rs#L249">here</a>), in this specific part:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>let parent_depth = table.add_committed(&quot;parent_depth&quot;);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>let one = table.add_constant(&quot;one&quot;, [B1::ONE]);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>let increment = Incr::new(&amp;mut table, lookup_chan, parent_depth, one);</span></span>
<span class="giallo-l"><span>let child_depth = increment.output;</span></span></code></pre>
<p>Here the <code>input</code> is <code>parent_depth</code>and the <code>carry_in</code> is <code>one</code>.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    2. The second pull out is `BinaryField128b(0x00000000000000000000000000010201)`. Let&#39;s do the same thing we did above: </span></span>
<span class="giallo-l"><span>       * Convert to binary: $$0\text{x}10201 = 00010000001000000001$$</span></span>
<span class="giallo-l"><span>       * Then, `input = 00000001`. This means that it represent an event with parent&#39;s depth 1.</span></span>
<span class="giallo-l"><span>       * `carry_in = 1` because children&#39;s depth is parent&#39;s depth plus 1.</span></span>
<span class="giallo-l"><span>       * Concatenate to get the index: $100000001 = 257$.  </span></span></code></pre>
<p>This index corresponds to the following event:<br />
<img src="/images/external/Skm17oe4ll.png" alt="image" /></p>
<p>Now, let’s see what else the function <code>tally()</code> printed. You should also see this:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>--- Processing table: merkle_tree_nodes_right (ID: 1) ---</span></span>
<span class="giallo-l"><span>Found matching flush: The table has a Pull operation on channel 2</span></span>
<span class="giallo-l"><span>Index 257 corresponds to element: [BinaryField128b(0x00000000000000000000000000010201)]</span></span>
<span class="giallo-l"><span>Index 258 corresponds to element: [BinaryField128b(0x00000000000000000000000000010302)]</span></span></code></pre>
<p>Note that we have here the same indeces as before. That’s because the right events have the same parent depths as the left ones:<br />
<img src="/images/external/SkTU7oxNeg.png" alt="image" /></p>
<p>After that you should see in your terminal the following:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>--- Processing table: merkle_tree_nodes_both (ID: 2) ---</span></span>
<span class="giallo-l"><span>Found matching flush: The table has a Pull operation on channel 2</span></span>
<span class="giallo-l"><span>Index 256 corresponds to element: [BinaryField128b(0x00000000000000000000000000010100)]</span></span></code></pre>
<p>Here, note that $$0\text{x}10100 = 00010000000100000000.$$ Then, <code>input = 00000000</code> and that means parent’s depth is 0. The index $256 = 100000000$ is representing this both left and right event:<br />
<img src="/images/external/rkTmBjxElx.png" alt="image" /></p>
<p>Finally, you should see printed the following:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>--- Processing table: merkle_tree_roots (ID: 3) ---</span></span></code></pre>
<p>This means that it processed the roots table but, as expected, it didn’t find any pull out from the lookup channel.</p>
<h4 id="sorted-counts">Sorted counts</h4>
<p>Recall that we were trying to understand how the <code>incr_table</code> is populated. After calculating all the <code>lookup_counts</code>, we sort them in a specific way, store it in <code>sorted_counts</code> and use it to fill the table.</p>
<p>The variable <code>sorted_counts</code> is a vector of 512 tuples. The first element of each tuple is an index and the second element has the count that the variable <code>lookup_counts</code>has at that index. These tuples are sorted according to counts from highest to lowest. One more time let’s add this print at the function <a rel="noopener external" target="_blank" href="https://github.com/IrreducibleOSS/binius/blob/main/crates/m3/src/gadgets/merkle_tree/mod.rs#L100">fill_tables()</a> to understand it better:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>let lookup_counts = tally(cs, witness, &amp;[], self.lookup_channel, &amp;IncrIndexedLookup)?;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>// Fill the lookup table with the sorted counts</span></span>
<span class="giallo-l"><span>let sorted_counts = lookup_counts</span></span>
<span class="giallo-l"><span>    .into_iter()</span></span>
<span class="giallo-l"><span>    .enumerate()</span></span>
<span class="giallo-l"><span>    .sorted_by_key(|(_, count)| Reverse(*count))</span></span>
<span class="giallo-l"><span>    .collect::&lt;Vec&lt;_&gt;&gt;();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>println!(&quot;------- Increment Table -------&quot;);</span></span>
<span class="giallo-l"><span>println!(&quot;Sorted counts: {sorted_counts:?}&quot;);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>witness.fill_table_parallel(&amp;self.incr_table, &amp;sorted_counts)?;</span></span></code></pre>
<p>This should print:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>------- Increment Table -------</span></span>
<span class="giallo-l"><span>Sorted counts: [</span></span>
<span class="giallo-l"><span>    (257, 2), (258, 2), (256, 1), (0, 0), (1, 0), (2, 0), ..., (510, 0), (511, 0)</span></span>
<span class="giallo-l"><span>]</span></span></code></pre>
<p>The <code>IncrLookup</code> instance uses these counts to fill its internal <code>entries_ordered</code> and <code>entries_sorted</code> columns, and its <code>LookupProducer</code> records the exact multiplicity for each valid increment operation that occurred in the Merkle tree paths computation.</p>
<h2 id="summary">Summary</h2>
<p>This post offers an in-depth exploration of Binius’s M3 arithmetization framework, using a Merkle tree inclusion proof as a concrete example. We examined how tables and channels serve as the foundational abstractions in M3, replacing the traditional concept of a sequential execution trace with a declarative, data-driven model. In this paradigm, computation is decomposed into modular tables, while global consistency is maintained through channel balancing.</p>
<p>At the core of the example lies the <code>MerkleTreeCS</code> gadget, which coordinates five specialized tables and multiple channels to verify Merkle path correctness. The <code>NodesTable</code> handles the hashing of parent-child node relationships, the <code>RootTable</code> ties computed paths to expected root values, and the <code>IncrLookup</code> table validates depth transitions using a permutation-checked lookup structure. These components communicate via channels like <code>nodes_channel</code> and <code>lookup_channel</code>, ensuring that every consumed value was properly produced and accounted for.</p>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
