<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GKR protocol implementation: deep dive into the code - LambdaClass Blog</title>
    <meta name="description" content="Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">GKR protocol implementation: deep dive into the code</h1>
        
        <div class="page-meta">
            <time datetime="2025-07-22">July 22, 2025</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <h2 id="introduction">Introduction</h2>
<p>The <strong>GKR</strong> (Goldwasser–Kalai–Rothblum) protocol provides an efficient way to verify computations over arithmetic circuits, avoiding re-execution and reducing the verifier’s work. In our previous post, <a href="/gkr-protocol-a-step-by-step-example/">GKR protocol: a step-by-step example</a>, we explored how the protocol works in detail, focusing on its mathematical structure and walking through a concrete hand-worked example. <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2023/1284">GKR</a> is currently used to improve the performance of lookup arguments, which are crucial for proving the execution of zero-knowledge virtual machines.</p>
<p>The goal of this post is to explain <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks/pull/1011">our implementation</a> of the protocol in Lambdaworks, showing how arithmetic circuits are described and validated, and how the prover and verifier operate in practice. We’ll also see how the <strong>Fiat-Shamir transform</strong> is applied to make the protocol <strong>non-interactive</strong> , and how the <strong>Sumcheck protocol</strong> is adapted and integrated as the core component for verifying each circuit layer.</p>
<p>If you’re not familiar with the protocol or need a refresher, we recommend starting with our previous post linked above.</p>
<p><strong>Warning:</strong> The GKR implementation presented here is for educational purposes only and should not be used in production. Note that for more general circuits, the protocol is vulnerable to practical attacks, as it relies on the Fiat-Shamir transform (see <a rel="noopener external" target="_blank" href="https://eprint.iacr.org/2025/118.pdf">“How to Prove False Statements”</a>).</p>
<h2 id="circuit-structure">Circuit Structure</h2>
<p>A GKR circuit is composed of layers. Each layer contains gates, and each gate operates on outputs from the previous layer. Gates can be either addition or multiplication. For protocol compatibility, each layer must have a power-of-two number of gates.</p>
<p><img src="/images/external/BkLEjCjIlx.png" alt="image" /><br />
<em>The arithmetic circuit used in the previous post as an example</em></p>
<p>In some cases, we can work with more efficient versions if all the gates are, for example, multiplications.</p>
<h3 id="circuit-api">Circuit API</h3>
<p>The main structures for circuit construction are:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * `Circuit` — Consists of a vector of layers (ordered from top to bottom, starting at the output layer and not including the input layer); the number of inputs; and the number of variables needed to index the input layer.</span></span>
<span class="giallo-l"><span>          </span></span>
<span class="giallo-l"><span>          pub struct Circuit {</span></span>
<span class="giallo-l"><span>              /// First layer is the output layer. It doesn&#39;t include the input layer.</span></span>
<span class="giallo-l"><span>              layers: Vec&lt;CircuitLayer&gt;,</span></span>
<span class="giallo-l"><span>          </span></span>
<span class="giallo-l"><span>              /// Number of inputs</span></span>
<span class="giallo-l"><span>              num_inputs: usize,</span></span>
<span class="giallo-l"><span>              input_num_vars: usize, // log2 of number of inputs</span></span>
<span class="giallo-l"><span>          }</span></span>
<span class="giallo-l"><span>          </span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    * `CircuitLayer` — contains a vector of gates and the number of variables needed to index those gates.</span></span>
<span class="giallo-l"><span>          </span></span>
<span class="giallo-l"><span>          pub struct CircuitLayer {</span></span>
<span class="giallo-l"><span>              pub gates: Vec&lt;Gate&gt;,</span></span>
<span class="giallo-l"><span>              pub num_of_vars: usize, // log2 of number of gates in this layer</span></span>
<span class="giallo-l"><span>          }</span></span>
<span class="giallo-l"><span>          </span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    * `Gate` — a single gate, with its type and input indices.</span></span>
<span class="giallo-l"><span>    * `GateType` — either `Add` or `Mul`.</span></span></code></pre><h3 id="circuit-gates">Circuit Gates</h3>
<p>Each gate in the circuit is either an addition (<code>Add</code>) or multiplication (<code>Mul</code>) gate. The gate type determines how the outputs from the previous layer are combined:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * `Add`: The gate outputs the sum of its two input wires.</span></span>
<span class="giallo-l"><span>    * `Mul`: The gate outputs the product of its two input wires.</span></span></code></pre>
<p>For example:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>let gate_1 = Gate::new(GateType::Mul, [0, 1]); //Multiplies outputs at indices 0 and 1 from the previous layer.</span></span>
<span class="giallo-l"><span>let gate_2 = Gate::new(GateType::Add, [2, 3]); // Adds outputs at indices 2 and 3 from the previous layer.</span></span></code></pre>
<p><img src="/images/external/SkRvRAjIlx.png" alt="image" /></p>
<h3 id="example-the-blog-post-circuit">Example: The Blog Post Circuit</h3>
<p>To illustrate this, let’s walk through the construction of the exact circuit used in our <a href="/gkr-protocol-a-step-by-step-example/">step-by-step GKR blog post</a>. This is available as <code>lambda_post_circuit()</code> in the codebase, and you can use it directly or as a template for your circuits.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub fn lambda_post_circuit() -&gt; Result&lt;Circuit, CircuitError&gt; {</span></span>
<span class="giallo-l"><span>    use crate::circuit::{Circuit, CircuitLayer, Gate, GateType};</span></span>
<span class="giallo-l"><span>    Circuit::new(</span></span>
<span class="giallo-l"><span>        vec![</span></span>
<span class="giallo-l"><span>            // Layer 0 (output layer): Two gates</span></span>
<span class="giallo-l"><span>            CircuitLayer::new(vec![</span></span>
<span class="giallo-l"><span>                Gate::new(GateType::Mul, [0, 1]), // Multiplies outputs 0 and 1 from previous layer</span></span>
<span class="giallo-l"><span>                Gate::new(GateType::Add, [2, 3]), // Adds outputs 2 and 3 from previous layer</span></span>
<span class="giallo-l"><span>            ]),</span></span>
<span class="giallo-l"><span>            // Layer 1: Four gates</span></span>
<span class="giallo-l"><span>            CircuitLayer::new(vec![</span></span>
<span class="giallo-l"><span>                Gate::new(GateType::Mul, [0, 1]), // Multiplies the two inputs</span></span>
<span class="giallo-l"><span>                Gate::new(GateType::Add, [0, 0]), // Adds the first input to itself</span></span>
<span class="giallo-l"><span>                Gate::new(GateType::Add, [0, 1]), // Adds both inputs</span></span>
<span class="giallo-l"><span>                Gate::new(GateType::Mul, [0, 1]), // Multiplies the two inputs again</span></span>
<span class="giallo-l"><span>            ]),</span></span>
<span class="giallo-l"><span>        ],</span></span>
<span class="giallo-l"><span>        2, // Two inputs</span></span>
<span class="giallo-l"><span>    )</span></span>
<span class="giallo-l"><span>}</span></span></code></pre><h3 id="how-to-build-your-circuit">How to Build Your Circuit</h3>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. **Decide the number of inputs.** Each input will be referenced by its index (starting from 0).</span></span>
<span class="giallo-l"><span>    2. **Build the first layer:** Each gate in the first layer operates on the inputs. Use `Gate::new(GateType::Add, [i, j])` or `Gate::new(GateType::Mul, [i, j])` to add or multiply input indices `i` and `j`.</span></span>
<span class="giallo-l"><span>    3. **Build subsequent layers:** Each gate operates on outputs from the previous layer. Indices always refer to the order of outputs of the prior layer. Each new layer should be inserted at the beginning of the `layers` vector, since layers are ordered from the top (output layers) to the bottom of the circuit.</span></span>
<span class="giallo-l"><span>    4. **Repeat until you reach the output layer.**</span></span>
<span class="giallo-l"><span>    5. **Wrap your layers in a`Circuit::new(layers, num_inputs)` call.**</span></span></code></pre>
<p><strong>Important:</strong></p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * Each layer must have a power-of-two number of gates.</span></span>
<span class="giallo-l"><span>    * Indices must be valid (i.e., not out of bounds for the previous layer).</span></span></code></pre><h3 id="circuit-automatic-validation">Circuit Automatic Validation</h3>
<p>When you construct a <code>Circuit</code>, several checks are performed automatically to ensure the circuit is well-formed:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * **Power-of-two gates** : Each layer must have a number of gates that is a power of two. This is required for the protocol to work efficiently.</span></span>
<span class="giallo-l"><span>    * **Valid input indices** : Each gate&#39;s input indices must refer to valid outputs from the previous layer. If an index is out of bounds, the construction fails.</span></span>
<span class="giallo-l"><span>    * **Power-of-two inputs** : The number of circuit inputs must also be a power of two.</span></span></code></pre>
<p>If any of these conditions are not met, the constructor returns a descriptive error (as a <code>Result::Err</code>). This prevents invalid circuits from being created and helps catch mistakes early in development.</p>
<h2 id="the-gkr-protocol">The GKR Protocol</h2>
<p>Let’s see how each step of the protocol is implemented in our code. We aim to demonstrate how it leverages the sumcheck protocol to recursively reduce a claim about the correctness of a computation at one layer of a circuit to a claim about the next layer, progressing from the output layer down to the input layer.</p>
<p>Recall that in our implementation, we utilize the Fiat-Shamir transform to render the protocol non-interactive, which results in a slightly different appearance from the version described in the previous post.</p>
<h3 id="prover">Prover</h3>
<h4 id="the-proof-structure">The proof structure</h4>
<p>The prover is responsible for evaluating the circuit and constructing a proof that convinces the verifier of the correctness of this evaluation. The core logic for the prover resides in <code>prover.rs</code>, where you can find the struct <code>GKRProof</code> that consists of:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * The input and the output values of the circuit.</span></span>
<span class="giallo-l"><span>    * A sumcheck proof for each circuit layer having: </span></span>
<span class="giallo-l"><span>      * The round univariate polynomials $g_j$.</span></span>
<span class="giallo-l"><span>      * The composition of the univariate polynomial $q$.</span></span></code></pre>
<p>Let’s recall what the polynomials $g_j$ and $q$ are. In each circuit layer and for each round $j$ of its sumcheck, the prover has to compute the univariate polynomial $g_j$ by fixing the first variable and summing over all the others. For example, in our previous post, in the layer $0$, the sumcheck had four rounds leading to these polynomials:</p>
<p>$$\begin{align}<br />
g_1 (z) &amp;= \sum_{(b_2, c_1, c_2) : \in {0, 1}^3} \tilde f_{ r_0 }^{ (0) } (z, b_2, c_1, c_2), \ \newline<br />
g_2 (z) &amp;= \sum_{(c_1, c_2) : \in {0, 1}^2} \tilde f_{ r_0 }^{ (0) } (s_1, z, c_1, c_2), \ \newline<br />
g_3 (z) &amp;= \sum_{c_2 : \in {0, 1}} \tilde f_{ r_0 }^{ (0) } (s_1, s_2, z, c_2),\ \newline<br />
g_4 (z) &amp;= \tilde f_{ r_0 }^{ (0) } (s_1, s_2, s_3, z),<br />
\end{align}$$</p>
<p>where $s_j$ are random challenges.</p>
<p>On the other hand, for each layer $i$, the polynomial $q$ is the composition $q = \tilde W_{i + 1} \circ \ell$, where $\tilde W_{i + 1}$ is the multilinear polynomial extension of the function that maps a node’s position to its actual value, and $\ell$ is the line that goes from $b^\star$ to $c^\star$. In the previous example, $\ell (0) = (s_1, s_2)$ and $\ell (1) = (s_3, s_4)$.</p>
<p>In the codebase, you’ll see it as:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub struct GKRProof&lt;F: IsField&gt; {</span></span>
<span class="giallo-l"><span>    pub input_values: Vec&lt;FieldElement&lt;F&gt;&gt;,</span></span>
<span class="giallo-l"><span>    pub output_values: Vec&lt;FieldElement&lt;F&gt;&gt;,</span></span>
<span class="giallo-l"><span>    pub layer_proofs: Vec&lt;LayerProof&lt;F&gt;&gt;,</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>The proof for each circuit layer is:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub struct LayerProof&lt;F: IsField&gt; {</span></span>
<span class="giallo-l"><span>    pub sumcheck_proof: GKRSumcheckProof&lt;F&gt;,</span></span>
<span class="giallo-l"><span>    pub poly_q: Polynomial&lt;FieldElement&lt;F&gt;&gt;,</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>Finally, the <code>sumcheck_proof</code> contains the round polynomials $g_j$ and the challenges used in those rounds, so that both prover and verifier can calculate the line $\ell$.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>pub struct GKRSumcheckProof&lt;F: IsField&gt; {</span></span>
<span class="giallo-l"><span>    pub round_polynomials: Vec&lt;Polynomial&lt;FieldElement&lt;F&gt;&gt;&gt;,</span></span>
<span class="giallo-l"><span>    pub challenges: Vec&lt;FieldElement&lt;F&gt;&gt;,</span></span>
<span class="giallo-l"><span>}</span></span></code></pre><h4 id="building-the-proof">Building the proof</h4>
<p>The prover constructs the proof using the <code>Prover::generate_proof()</code> method. This function takes the circuit and its inputs, evaluates the circuit on them, and generates the proof. Let’s break down this function into the following steps:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. **Circuit Evaluation:** The Prover evaluates the whole circuit in the given inputs.</span></span>
<span class="giallo-l"><span>           </span></span>
<span class="giallo-l"><span>           let evaluation = circuit.evaluate(input);</span></span>
<span class="giallo-l"><span>           </span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    2. **Transcript Initialization** :</span></span></code></pre>
<p>Since we implemented the non-interactive version of the protocol, the prover must <strong>commit to the circuit, its inputs, and its outputs</strong>. This is done by defining a <code>DefaultTranscript</code>, from which we can commit to and sample new values. Both prover and verifier append this data to the transcript. To append the circuit, they need to convert it into bytes, and they do so using the function <code>circuit_to_bytes()</code> that you can find in the file <code>lib.rs</code>. We’ll see more about the transcript later on in the Fiat-Shamir subsection.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    3. **Sample $r_0$** :  </span></span></code></pre>
<p>The prover samples the first $r_0$ to fix the variable $a$ and begin the sumcheck. Recall that the variable $a$ could have more than one bit, so $r_0$ has the same size as $a$ called $k_0$</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>           let k_0 = circuit.num_vars_at(0).ok_or(ProverError::CircuitError)?;</span></span>
<span class="giallo-l"><span>           let mut r_i: Vec&lt;FieldElement&lt;F&gt;&gt; = (0..k_0)</span></span>
<span class="giallo-l"><span>               .map(|_| transcript.sample_field_element())</span></span>
<span class="giallo-l"><span>               .collect();</span></span>
<span class="giallo-l"><span>           </span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    4. **Sumcheck layer iteration:** For each layer, the prover applies the sumcheck protocol following these steps:</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>       * **Building the function** :  </span></span></code></pre>
<p>The prover builds the function to which he wants to apply the sumcheck,<br />
$$\tilde f_{ r_i } (b, c) = \widetilde{\text{add_i}} (r_i, b, c) \cdot (\widetilde W_{i + 1}(b) + \widetilde W_{i + 1}(c)) + \widetilde{\text{mul_i}} (r_i, b, c) \cdot (\widetilde{W_{i + 1}} (b) \cdot \widetilde{W_{i + 1}} (c)),$$<br />
using the method <code>Prover::build_gkr_polynomial()</code>. Note that this method returns two terms instead of just one. More specifically, it returns a 2-item vector whose elements are themselves vectors of two multilinear polynomials:<br />
First term or vector:<br />
$$[\widetilde{\text{add_i}} (r_i, b, c), \widetilde{W_{i + 1}} (b) + \widetilde{W_{i + 1}} (c)]$$<br />
Second term or vector:<br />
$$[\widetilde{\text{mul_i}} (r_i, b, c), \widetilde{W_{i + 1}} (b) \cdot \widetilde{W_{i + 1}} (c)]$$</p>
<p>This is necessary because the sumcheck implementation at lambdaworks only accepts a product of multilinear polynomials. That is why we separate our polynomial $\tilde f_{r_i}$ into two terms of products of multilinear polynomials.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>             let gkr_poly_terms =</span></span>
<span class="giallo-l"><span>                     Prover::build_gkr_polynomial(circuit, &amp;r_i, w_next_evals, layer_idx)?;</span></span>
<span class="giallo-l"><span>             </span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>       * **Apply the GKR Sumcheck Prover:**  </span></span></code></pre>
<p>We use a sumcheck implementation specifically designed for the GKR protocol. We’ll go into more detail about this new sumcheck later, but there are three <strong>key changes</strong> to keep in mind:<br />
<strong>I)</strong> We need a sumcheck prover that <strong>takes a transcript as input</strong> , so we can maintain the same transcript for both the prover and the verifier, which is created at the start.<br />
<strong>II)</strong> This new sumcheck also <strong>returns the random values sampled during execution</strong>. This allows both the prover and verifier to compute the function $\ell$ later, which depends on those values.<br />
<strong>III)</strong> The GKR sumcheck allows us to <strong>work with both terms</strong> of $\tilde f_{ r_i } (b,c)$ at the same time.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>             let sumcheck_proof = gkr_sumcheck_prove(gkr_poly_terms, &amp;mut transcript)?;</span></span>
<span class="giallo-l"><span>             </span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>       * **Sumcheck final claim:**  </span></span></code></pre>
<p>The prover samples a new field element $r^\star$ (called <code>r_new</code>in the code), evaluates the line $\ell$ at it, and calculates the composition polynomial $q$. The evaluation of $\ell$ is computed using the function <code>line()</code> that you can find in <code>lib.rs</code> (since it is used by both prover and verifier). On the other hand, the polynomial $q$ is calculated using the method <code>Prover::build_polynomial_q()</code>. To calculate this polynomial, the prover needs to interpolate three points, since $q$ has degree 2 (as $\ell$ is linear and $\tilde W_{i + 1}$ multilinear in each variable).</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>             // r* in our blog post &lt;https://blog.lambdaclass.com/gkr-protocol-a-step-by-step-example/&gt;</span></span>
<span class="giallo-l"><span>             let r_new = transcript.sample_field_element();</span></span>
<span class="giallo-l"><span>             </span></span>
<span class="giallo-l"><span>             // Construct the next round&#39;s random point using line function</span></span>
<span class="giallo-l"><span>             //  l(x) = b + x * (c - b)</span></span>
<span class="giallo-l"><span>             let (b, c) = sumcheck_challenges.split_at(num_vars_next);</span></span>
<span class="giallo-l"><span>             // r_i = l(r_new)</span></span>
<span class="giallo-l"><span>             r_i = crate::line(b, c, &amp;r_new);</span></span>
<span class="giallo-l"><span>             </span></span>
<span class="giallo-l"><span>             let poly_q = Prover::build_polynomial_q(b, c, w_next_evals.clone())?;</span></span>
<span class="giallo-l"><span>             </span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    5. **Make the proof:** Finally, the prover has all the ingredients to make the proof.</span></span>
<span class="giallo-l"><span>           </span></span>
<span class="giallo-l"><span>           let proof = GKRProof {</span></span>
<span class="giallo-l"><span>               input_values: input.to_vec(),</span></span>
<span class="giallo-l"><span>               output_values,</span></span>
<span class="giallo-l"><span>               layer_proofs,</span></span>
<span class="giallo-l"><span>           };</span></span></code></pre><h3 id="verifier">Verifier</h3>
<p>Once we understand what the prover does, it’s easy to see what the verifier needs to do. It simply follows the same steps as the prover, using the elements of the proof and performing the necessary checks at each step. She verifies the proof using the method <code>Verifier::verify()</code> following these steps:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. **Transcript Initialization:**  </span></span></code></pre>
<p>Just as the prover, start by creating a transcript and appending the <strong>circuit</strong> (which is known to both parties), the <strong>inputs</strong> , and the <strong>outputs</strong> sent in the proof by the prover.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    2. **Initial Sum Calculation:**  </span></span></code></pre>
<p>Sample field elements for $r_0$ to fix the variable $a$ and set the initial sum as $m_0 = \tilde D (r_0)$, where $\tilde D$ is the multilinear polynomial extension of the function that maps the output gates to the evaluation values. The prover sent these values as part of the proof.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>           let output_poly_ext = DenseMultilinearPolynomial::new(proof.output_values.clone());</span></span>
<span class="giallo-l"><span>           let mut claimed_sum = output_poly_ext</span></span>
<span class="giallo-l"><span>               .evaluate(r_i.clone())</span></span>
<span class="giallo-l"><span>               .map_err(|_e| VerifierError::MultilinearPolynomialEvaluationError)?;</span></span>
<span class="giallo-l"><span>           </span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    3. **Layer-by-Layer Verification:** For each layer $i$, the verifier performs the following:</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>       * **Verify the sumcheck proof:**  </span></span></code></pre>
<p>The verifier checks the sumcheck proof for the current layer using the function <code>gkr_sumcheck_verify</code>. This function ensures that the sequence of univariate polynomials $g_j$ provided by the prover has degree 2 and is consistent with the claimed sum in each sumcheck round $j$; that is,<br />
$$ deg(g_j) \leq 2,$$$$g_j (0) + g_j (1) == g_{j - 1} (s_{ j - 1 }).$$</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>             let (sumcheck_verified, sumcheck_challenges) = gkr_sumcheck_verify(</span></span>
<span class="giallo-l"><span>                 claimed_sum.clone(),</span></span>
<span class="giallo-l"><span>                 &amp;layer_proof.sumcheck_proof,</span></span>
<span class="giallo-l"><span>                 &amp;mut transcript,</span></span>
<span class="giallo-l"><span>             )?;</span></span>
<span class="giallo-l"><span>             if !sumcheck_verified {</span></span>
<span class="giallo-l"><span>                 return Ok(false);</span></span>
<span class="giallo-l"><span>             }</span></span>
<span class="giallo-l"><span>             </span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>       * **Check the final round $n$ using the composition polynomial $q$:**  </span></span></code></pre>
<p>To verify the final claim of the sumcheck in the last round, the verifier needs the values $\tilde W_{ i + 1}(b^\star)$ and $\tilde W_{i + 1}(c^\star)$. However, the polynomial $\tilde W_{ i + 1}$ is unknown to her: the verifier doesn’t have the circuit evaluations. That is why she performs this final check using the composition polynomial $q$ provided by the prover. Recall that if the prover didn’t cheat, $q(0) = \tilde W_{ i + 1}(b^\star)$ and $q(1) = \tilde W_{ i + 1}(c^\star)$. Therefore, the verifier must check that<br />
$$g_n (s_n) = \widetilde{\text{add_i}} (r_i, b^\star, c^\star) \cdot (q(0) + q(1)) + \widetilde{\text{mul_i}} (r_i, b^\star, c^\star) \cdot (q(0) \cdot q(1))$$</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>             let last_poly = layer_proof.sumcheck_proof.round_polynomials.last().unwrap();</span></span>
<span class="giallo-l"><span>             let last_challenge = sumcheck_challenges.last().unwrap();</span></span>
<span class="giallo-l"><span>             let expected_final_eval = last_poly.evaluate::&lt;F&gt;(last_challenge);</span></span>
<span class="giallo-l"><span>             </span></span>
<span class="giallo-l"><span>             let q_at_0 = layer_proof.poly_q.evaluate(&amp;FieldElement::zero());</span></span>
<span class="giallo-l"><span>             let q_at_1 = layer_proof.poly_q.evaluate(&amp;FieldElement::one());</span></span>
<span class="giallo-l"><span>             </span></span>
<span class="giallo-l"><span>             let add_eval = circuit.add_i_ext(&amp;r_i, layer_idx).evaluate(sumcheck_challenges.clone())?;</span></span>
<span class="giallo-l"><span>             let mul_eval = circuit.mul_i_ext(&amp;r_i, layer_idx).evaluate(sumcheck_challenges.clone())?;</span></span>
<span class="giallo-l"><span>             </span></span>
<span class="giallo-l"><span>             let final_eval = add_eval * (&amp;q_at_0 + &amp;q_at_1) + mul_eval * q_at_0 * q_at_1;</span></span>
<span class="giallo-l"><span>             if final_eval != expected_final_eval {</span></span>
<span class="giallo-l"><span>                 return Ok(false);</span></span>
<span class="giallo-l"><span>             }</span></span>
<span class="giallo-l"><span>             </span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>       * **Sample a new challenge and update the evaluation point:**  </span></span></code></pre>
<p>The verifier samples a new field element $r^\star$ from the transcript, then uses the line function to compute the next evaluation point $r_{ i + 1} = \ell (r^\star)$ for the following layer. The claimed sum is updated by evaluating the composition polynomial $q$ at the new challenge: $q(r^\star)$.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>             let r_new = transcript.sample_field_element();</span></span>
<span class="giallo-l"><span>             let num_vars_next = circuit.num_vars_at(layer_idx + 1).ok_or(VerifierError::CircuitError)?;</span></span>
<span class="giallo-l"><span>             let (b, c) = sumcheck_challenges.split_at(num_vars_next);</span></span>
<span class="giallo-l"><span>             r_i = crate::line(b, c, &amp;r_new);</span></span>
<span class="giallo-l"><span>             claimed_sum = layer_proof.poly_q.evaluate(&amp;r_new);</span></span>
<span class="giallo-l"><span>             </span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    4. **Final Input Check:**  </span></span></code></pre>
<p>After all layers have been processed, the verifier checks that the final claimed sum matches the evaluation of the multilinear extension of the input values at the final evaluation point $r_i$. In the previous post example, that would be $$q(r^\star) == \tilde W_2 (r_2).$$ This ensures that the entire computation, from outputs down to the inputs, is consistent.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>           let input_poly_ext = DenseMultilinearPolynomial::new(proof.input_values.clone());</span></span>
<span class="giallo-l"><span>           if claimed_sum</span></span>
<span class="giallo-l"><span>               != input_poly_ext</span></span>
<span class="giallo-l"><span>                   .evaluate(r_i)</span></span>
<span class="giallo-l"><span>                   .map_err(|_| VerifierError::MultilinearPolynomialEvaluationError)?</span></span>
<span class="giallo-l"><span>           {</span></span>
<span class="giallo-l"><span>               return Ok(false);</span></span>
<span class="giallo-l"><span>           }</span></span></code></pre>
<p>If all checks pass, the verifier accepts the proof as valid. Otherwise, the proof is rejected at the first failed check. This process allows the verifier to efficiently confirm the correctness of the computation without re-executing the entire circuit.</p>
<h2 id="the-sumcheck-protocol">The Sumcheck Protocol</h2>
<p>The Sumcheck protocol is a central component of the GKR protocol. Its role is to allow the prover to convince the verifier that a sum over a product of multilinear polynomials is correct, without requiring the verifier to compute the sum directly. This is achieved by reducing the original sum to a sequence of univariate polynomial checks, one for each variable.</p>
<h3 id="quick-recap-what-is-the-sum-being-checked">Quick Recap: What is the sum being checked?</h3>
<p>At each layer $i$ of the GKR protocol, the prover and verifier need to check a sum of the form:</p>
<p>$$<br />
S = \sum_{x_1, \ldots, x_n \in {0,1}} \tilde f_{ r_i }(x_1, \ldots, x_n)<br />
$$</p>
<p>where $\tilde f_{ r_i } (x_1, \ldots, x_n)$ is a multilinear polynomial that encodes the wiring and values of the circuit at that layer, and $n$ is the number of variables for that layer (which depends on the number of bits needed to index the gates of the next layer).</p>
<p>The sumcheck protocol allows the prover to convince the verifier that the claimed value $S$ is correct, by sending a sequence of univariate polynomials $g_1, g_2, \ldots, g_n$ such that, in round $j$:</p>
<p>$$<br />
g_j(z) = \sum_{x_{j + 1}, \ldots, x_n} f_{r} (s_1, \ldots, s_{j - 1}, z, x_{j + 1}, \ldots, x_n)<br />
$$</p>
<p>where $s_1, \ldots, s_{j - 1}$ are the challenges sampled in previous rounds, $z$ is the variable for the current round, and the remaining variables are summed over. The number of rounds (and thus the number of $g_j$ polynomials) is always equal to the number of variables of $\tilde f_{ r_i }$ for the layer being checked.</p>
<p>At each round, the verifier checks the key sumcheck property:</p>
<p>$$deg(g_j) \leq 2$$</p>
<p>$$<br />
g_j(0) + g_j(1) = \text{previous sum}<br />
$$</p>
<p>and then samples a new challenge $s_j$ for the next round. After all rounds, the verifier is left with a claim about $f_{r} (s_1, \ldots, s_n)$, which is checked against the next layer.</p>
<h3 id="splitting-the-gkr-polynomial-for-sumcheck">Splitting the GKR Polynomial for Sumcheck</h3>
<p>The GKR polynomial $\tilde f_{ r_i } (b, c)$, which encodes the relationship between two adjacent layers, is given by:</p>
<p>$$<br />
\tilde f_{r_i}(b, c) = \widetilde{\text{add_i}} (r_i, b, c) \cdot \left( W_{ i + 1} (b) + W_{ i + 1} (c) \right) + \widetilde{\text{mul_i}} (r_i, b, c) \cdot \left( W_{ i + 1 }(b) \cdot W_{ i + 1}(c) \right)<br />
$$</p>
<p>To apply the sumcheck protocol, this polynomial is split into two terms, each being a product of two multilinear polynomials:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * The first term:  </span></span></code></pre>
<p>$$<br />
\widetilde{\text{add_i}} (r_i, b, c) \cdot \left( W_{ i + 1}(b) + W_{ i + 1}(c) \right)<br />
$$
* The second term:<br />
$$<br />
\widetilde{\text{mul_i}} (r_i, b, c) \cdot \left( W_{ i + 1 }(b) \cdot W_{ i + 1}(c) \right)<br />
$$</p>
<p>This splitting is necessary because the sumcheck implementation expects a product of multilinear polynomials. In the code, this is handled by the function <code>Prover::build_gkr_polynomial</code> (see the Prover section), which returns a vector with two entries, each being a vector of two multilinear polynomials (the factors of each term). These are then passed to the sumcheck prover, which processes both terms together in each round.</p>
<h3 id="implementation-in-the-codebase">Implementation in the Codebase</h3>
<p>The logic for the sumcheck protocol is implemented in <a href="https://blog.lambdaclass.com/posts/gkr-protocol-implementation-deep-dive-into-the-code/./src/sumcheck.rs"><code>sumcheck.rs</code></a>. This file contains the functions used by both the prover and the verifier to perform the sumcheck rounds for each circuit layer.</p>
<h4 id="prover-step-by-step-sumcheck-proof-generation">Prover: Step-by-step sumcheck proof generation:</h4>
<p>At each layer, the prover constructs the sumcheck proof as follows:</p>
<p><strong>1. Build the GKR polynomial terms</strong></p>
<p>For the current layer, construct the GKR polynomial and split it into two terms as required by the protocol:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>let factors_term_1 = terms[0].clone();</span></span>
<span class="giallo-l"><span>let factors_term_2 = terms[1].clone();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>let mut prover_term_1 = Prover::new(factors_term_1)?;</span></span>
<span class="giallo-l"><span>let mut prover_term_2 = Prover::new(factors_term_2)?;</span></span></code></pre>
<p><strong>2. Compute the initial claimed sum</strong></p>
<p>The prover computes the initial sum for both terms and adds them:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>let claimed_sum_term_1 = prover_term_1.compute_initial_sum()?;</span></span>
<span class="giallo-l"><span>let claimed_sum_term_2 = prover_term_2.compute_initial_sum()?;</span></span>
<span class="giallo-l"><span>let claimed_sum = claimed_sum_term_1 + claimed_sum_term_2;</span></span></code></pre>
<p><strong>3. Apply the sumcheck protocol round by round</strong></p>
<p>For each round, the prover computes the univariate polynomial for each term, sums them, and appends the result to the transcript. Each resulting polynomial $g_j$ is collected in a vector:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>let mut proof_polys = Vec::with_capacity(num_vars);</span></span>
<span class="giallo-l"><span>for j in 0..num_vars {</span></span>
<span class="giallo-l"><span>    let g_j_term_1 = prover_term_1.round(current_challenge.as_ref())?;</span></span>
<span class="giallo-l"><span>    let g_j_term_2 = prover_term_2.round(current_challenge.as_ref())?;</span></span>
<span class="giallo-l"><span>    let g_j = g_j_term_1 + g_j_term_2;</span></span>
<span class="giallo-l"><span>    // ...append g_j to transcript...</span></span>
<span class="giallo-l"><span>    proof_polys.push(g_j);</span></span>
<span class="giallo-l"><span>    // ...sample challenge, update current_challenge...</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p><strong>4. Collect the proof data</strong></p>
<p>After all rounds, the vector of polynomials and the challenges are used to construct the sumcheck proof object:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>let sumcheck_proof = GKRSumcheckProof {</span></span>
<span class="giallo-l"><span>    round_polynomials: proof_polys,</span></span>
<span class="giallo-l"><span>    challenges,</span></span>
<span class="giallo-l"><span>};</span></span></code></pre>
<p><strong>5. Send to verifier</strong></p>
<p>Include the sumcheck proof as part of the overall GKR proof, which the verifier will check in the next phase.</p>
<h4 id="verifier-step-by-step-sumcheck-verification">Verifier: Step-by-step sumcheck verification:</h4>
<p>At each layer, the verifier processes the sumcheck proof as follows:</p>
<p><strong>1. For each round, check the degree and sum property</strong></p>
<p>For each univariate polynomial $g_j$ received, check that the degree is at most two and that the sum of its evaluations at 0 and 1 matches the expected value (either the initial claim or the previous polynomial evaluated at the previous challenge):</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>// Check that the degree of g_j does not exceed the theoretical bound</span></span>
<span class="giallo-l"><span>if g_j.degree() &gt; 2 {</span></span>
<span class="giallo-l"><span>    return Err(crate::verifier::VerifierError::InvalidDegree);</span></span>
<span class="giallo-l"><span>}</span></span>
<span class="giallo-l"><span>let g_j_0 = g_j.evaluate::&lt;F&gt;(&amp;FieldElement::zero());</span></span>
<span class="giallo-l"><span>let g_j_1 = g_j.evaluate::&lt;F&gt;(&amp;FieldElement::one());</span></span>
<span class="giallo-l"><span>let sum_evals = &amp;g_j_0 + &amp;g_j_1;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>let expected_sum = if j == 0 {</span></span>
<span class="giallo-l"><span>    claimed_sum.clone()</span></span>
<span class="giallo-l"><span>} else {</span></span>
<span class="giallo-l"><span>    let prev_poly = &amp;proof_polys[j - 1];</span></span>
<span class="giallo-l"><span>    let prev_challenge = &amp;challenges[j - 1];</span></span>
<span class="giallo-l"><span>    prev_poly.evaluate::&lt;F&gt;(prev_challenge)</span></span>
<span class="giallo-l"><span>};</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>if sum_evals != expected_sum {</span></span>
<span class="giallo-l"><span>    return Ok((false, challenges));</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p><strong>2. Update the transcript and sample the next challenge</strong></p>
<p>After each round, the verifier appends the polynomial to the transcript and samples the next challenge:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>let r_j = transcript.sample_field_element();</span></span>
<span class="giallo-l"><span>challenges.push(r_j.clone());</span></span></code></pre>
<p><strong>3. Accept or reject</strong></p>
<p>If all rounds pass the checks, accept the sum as correct, without needing to evaluate the full sum directly. If any check fails, reject the proof immediately.</p>
<p>Each round of the sumcheck protocol reduces the number of variables by one, transforming a multivariate sum into a sequence of univariate checks. The prover performs the main computations, while the verifier only needs to check a small number of polynomial evaluations and field operations. The use of the Fiat-Shamir transform ensures that the protocol is non-interactive, with all challenges derived from the transcript.</p>
<h2 id="fiat-shamir-transform-making-it-non-interactive">Fiat-Shamir Transform: Making it Non-Interactive</h2>
<p>The original GKR protocol is interactive, meaning it requires a series of back-and-forth communications between the prover and the verifier. While interactive proofs are theoretically sound, they can be impractical for many real-world applications due to latency and communication overhead. The Fiat-Shamir transform is a cryptographic technique used to convert interactive proof systems into non-interactive ones.</p>
<h3 id="how-fiat-shamir-is-applied">How Fiat-Shamir is Applied</h3>
<p>In our implementation, the Fiat-Shamir transform replaces the verifier’s random challenges with outputs from a cryptographic hash function, specifically a <code>DefaultTranscript</code> from the <code>lambdaworks_crypto</code> crate. This allows the prover to generate all necessary challenges deterministically, without any interaction with the verifier.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. **Transcript Initialization** : A transcript is created and seeded with public information relevant to the proof. This includes:</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>       * The circuit structure (serialized via `circuit_to_bytes(circuit)`).</span></span>
<span class="giallo-l"><span>       * The public input values.</span></span>
<span class="giallo-l"><span>       * The claimed output values.</span></span></code></pre>
<p>By including this information, any party can reconstruct the same transcript and verify the challenges generated.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    2. **Challenge Generation** : At each step where the interactive protocol would require a random challenge from the verifier, the implementation instead:</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>       * Appends the current state of the proof (e.g., the coefficients of a polynomial sent by the prover) to the transcript.</span></span>
<span class="giallo-l"><span>       * Samples a random field element from the transcript using `transcript.sample_field_element()`. This element is cryptographically derived from all previous information in the transcript, making it unpredictable to the prover before the relevant information is committed.</span></span></code></pre><h3 id="key-challenge-points">Key Challenge Points</h3>
<p>The Fiat-Shamir transform is applied at several critical junctures in the GKR protocol:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * **Initial Random Values** ($r_0$): For the output layer, initial random challenges are sampled to begin the layer-by-layer reduction.</span></span>
<span class="giallo-l"><span>    * **Sumcheck Challenges** ($s_j$): In each round of the Sumcheck protocol, challenges are generated from the transcript. These challenges are essential for the verifier to check the consistency of the prover&#39;s univariate polynomials.</span></span>
<span class="giallo-l"><span>    * **Line Function Parameter** ($r^\star$ or `r_new`): After each layer&#39;s sumcheck, a new challenge `r_new` is sampled. This challenge is used in the `line` function to derive the evaluation point for the next layer&#39;s claimed sum, effectively linking the layers in the proof.</span></span></code></pre>
<p>By leveraging the Fiat-Shamir transform, our GKR implementation achieves non-interactivity, making it more practical for real-world applications where continuous communication between prover and verifier might be infeasible or introduce undesirable latency. This transformation is a cornerstone of many modern zero-knowledge proof systems, enabling efficient and verifiable computation in a wide range of scenarios.</p>
<h2 id="summary">Summary</h2>
<p>In this post, we showed how we implemented the GKR protocol. Starting from a circuit description, the prover evaluates each layer, constructs the corresponding polynomial, and runs a tailored Sumcheck protocol whose challenges are generated through a Fiat–Shamir transcript. The verifier, working with the same transcript, replays the Sumcheck rounds, checks the final claim with the composition polynomial $q$, and ultimately confirms that the computation is correct all the way down to the public inputs. In this way, a potentially expensive re-execution of the circuit is reduced to a series of lightweight algebraic checks.<br />
Although this implementation is intended for educational use, it captures every essential step of the protocol.</p>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
