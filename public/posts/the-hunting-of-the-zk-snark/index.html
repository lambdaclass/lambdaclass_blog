<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The hunting of the (zk)-SNARK - LambdaClass Blog</title>
    <meta name="description" content="Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">The hunting of the (zk)-SNARK</h1>
        
        <div class="page-meta">
            <time datetime="2023-01-11">January 11, 2023</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <h2 id="introduction">Introduction</h2>
<p>Succinct Non-Interactive Arguments of Knowledge (SNARKs) are powerful cryptographic primitives with decentralized finances, governance, and computation applications. There are many different SNARKs, such as Marlin (the one Aleo uses), Plonk, STARKs, Groth16, etc., depending on the tools they are built on and with differences in performance, proof sizes, verification times, etc. However, they are all based on some common principles and properties. Among SNARKs, the most important ones for private applications are zero-knowledge SNARKs (zk-SNARKs, for short). They allow us to prove that we know certain variables, called witness, $w$, such that the output of a function $F$, evaluated at the witness and instance (public variables), $x$, is $F(x,w)=y$, without revealing anything about $w$.</p>
<p>We can convert computer programs to functions receiving input (some of which we may want to conceal) and prove their correct execution with SNARKs. For example, we can transform the program into an arithmetic circuit, $C$, and, given the public input and output, $x$, and confidential data, $w$, we can prove that the program was correctly executed by showing the satisfiability of the circuit, $C(x,w)=0$. Since arithmetic circuit satisfiability is an NP-complete problem, we can reduce any NP problem to an arithmetic circuit (this is not the only alternative, though, and several constructions rely on different techniques).</p>
<p>Before jumping into the details, let us first explain the main properties of a SNARK and the precise meaning of each term in the name. A zk-SNARK involves two parties, the prover and the verifier, where the first one tries to convince the latter of a given statement, such as the prover knows $w$ such that $C(w,x)=0$. The SNARK must fulfill the following:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. Completeness: If the prover knows $w$, he will always be able to convince an honest verifier of the statement&#39;s validity.</span></span>
<span class="giallo-l"><span>    2. Soundness: if the statement is false, then no cheating prover could convince the verifier to accept, except with very low probability.</span></span>
<span class="giallo-l"><span>    3. Zero-knowledge: the proof does not reveal anything about the witness.</span></span></code></pre>
<p>As for the name, we have the following:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. Succinctness: the proofs must be short and quick to verify. This property would enable us to delegate expensive computations to untrusted parties and check their validity without running the program ourselves.</span></span>
<span class="giallo-l"><span>    2. Non-interactive: does not require interaction between prover and verifier, nor to generate the proof or verify it. We will see that the construction will rely first on interactive proofs, but we can turn it into non-interactive by employing the [Fiat-Shamir](https://en.wikipedia.org/wiki/Fiat%E2%80%93Shamir_heuristic) transform.</span></span>
<span class="giallo-l"><span>    3. Argument of knowledge: we can prove with a high probability that we know the witness.</span></span></code></pre><h2 id="setup">Setup</h2>
<p>SNARKs require trusted setups. Among them, we can distinguish:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * Uniform reference string or transparent setups (URS).</span></span>
<span class="giallo-l"><span>    * Structured reference string or private setup (SRS).</span></span></code></pre>
<p>In the case of SRS, we can find two instances:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * Universal (for example, MARLIN)</span></span>
<span class="giallo-l"><span>    * Specific (Groth 16)</span></span></code></pre>
<p>In practice, the trusted setup is carried out as a multiparty computation; the construction will be secure if there is at least one honest party. The problem with specific SRS is that the string depends on the program, and we must carry out a new setup for each one (this is an undesirable property).</p>
<h2 id="probabilistic-proofs-and-capabilities-of-the-verifier">Probabilistic proofs and capabilities of the verifier</h2>
<p>The conciseness of the argument relies on probabilistic proofs. To do that, we first have to establish the things that the “powers” or capabilities of the verifier. We have:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * Interaction: the verifier can interact with the prover, sending challenges and receiving responses.</span></span>
<span class="giallo-l"><span>    * Multiprover: there are several provers, but they are isolated.</span></span>
<span class="giallo-l"><span>    * Randomness: the verifier can select random elements or queries.</span></span>
<span class="giallo-l"><span>    * Ability to perform queries to an oracle: the verifier may query the prover&#39;s messages.</span></span></code></pre>
<p>When the verifier has access to more than one of these powers, we get different types of proofs:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * Interactivity + Randomness: Interactive proofs (IP).</span></span>
<span class="giallo-l"><span>    * Randomness + Oracle: Probabilistically checkable proofs (PCP).</span></span>
<span class="giallo-l"><span>    * Interactivity + Randomness + Oracle: Interactive Oracle Proofs (IOP)</span></span></code></pre>
<p>There are other possibilities, such as MIOP, but we will focus on the previous 3. IOPs give the most efficient constructions for SNARKs: quasilinear time verification, linear size proof lengths, linear time prover, and efficient implementations. PCP are interesting from an educational point of view but are inefficient in practice (it does not result in succinct proofs, except with linear queries). Finally, IP give some powerful building blocks in the form of subroutines.</p>
<p>In an IOP, the prover and verifier exchange messages. The prover sends arbitrary messages (in a polynomial IOP, the prover sends commitments - see next section- to polynomials), and the verifier sends random challenges. After some rounds, the verifier queries some values and decides whether to accept or reject the proof.</p>
<h2 id="commitment-schemes">Commitment schemes</h2>
<p>The performance of SNARKs depends on the type of commitment used; there have been many advances over the last years to improve them.</p>
<p>We can think of a commitment as a safe box. We make some choice for a bet, store it in a secure container, and hand it to someone else. Once the result is known, we can reveal our selection by opening the safe box.</p>
<p>A commitment has to verify two properties:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * Binding: we cannot produce two valid openings for the same commitment. In other words, if we committed to some value $a$, it should be impossible to find $b$ such that the $cm(a)=cm(b)$.</span></span>
<span class="giallo-l"><span>    * Hiding: the commitment reveals nothing about the committed data.</span></span></code></pre>
<p>One way to commit to a message is by using a <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">collision-resistant hash function</a>. If we have a message $m$ and some random value $r$,<br />
$\mathrm{cm}(m,r)=hash(m\mid r)$<br />
Given that it is collision-resistant, we have the binding property.<br />
We can afterward open the commitment and verify the following:<br />
$\mathrm{Verify}(m,r,\mathrm{cm})\rightarrow$ accept or reject<br />
One advantage of commitments is that they tend to be short. For example, if we use SHA-256, the digest length will be 32 bytes.</p>
<p>One relevant group of commitments is the polynomial schemes. Here are some constructions and the math that they rely on:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * Basic elliptic curves: bulletproofs</span></span>
<span class="giallo-l"><span>    * Bilinear groups: Kate-Zaverucha-Goldberg (KZG) polynomial commitments (pairings, trusted setup) DORY (no trusted setup)</span></span>
<span class="giallo-l"><span>    * Groups of unknown order: DARK</span></span>
<span class="giallo-l"><span>    * Hash functions only: FRI</span></span></code></pre><h2 id="anatomy-of-a-snark">Anatomy of a SNARK</h2>
<p>A SNARK can be constructed by selecting the following two elements:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. A type of probabilistic proof: for example, probabilistically checkable proof (PCP) or interactive oracle proof (IOP). A particular kind of IOP is polynomial IOP (PIOP).</span></span>
<span class="giallo-l"><span>    2. A commitment scheme (cryptography). For example, polynomial/functional commitments, vector commitments, and linear encoding.</span></span></code></pre>
<p>The probabilistic proof determines the type of computation. It can be either a machine computation (such as vmTinyRam) or a circuit.</p>
<p>The cryptographic element determines the cost to generate the proofs, whether it will be postquantum secure, and the type of setup (transparent or structured). The math tools we need to work with each of them are:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * Linear encoding: Elliptic curve pairings (ECP) + Lattices</span></span>
<span class="giallo-l"><span>    * Vector commitment: Collision resistant hash (CRH) functions + ECP.</span></span>
<span class="giallo-l"><span>    * Polynomial commitment: CRH, ECP, PO groups, UO groups</span></span></code></pre>
<p>Some SNARK recipes are:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. Linear PCP + Linear encoding: Groth16, Groth-Maller 17</span></span>
<span class="giallo-l"><span>    2. PCP/IOP + vector commitment: STARKs</span></span>
<span class="giallo-l"><span>    3. Polynomial PCP/IOP + polynomial commitment: MARLIN, SONIC, Plonk, Spartan.</span></span></code></pre>
<p>Bulletproofs take different combinations of the elements above and are based on cryptographic sum checks.</p>
<p>The proof’s size depends strongly on the type of construction. For example, for PIOP with KZG polynomial commitments, proofs take less than one kB (two elliptic curve elements). In contrast, IOP with <a rel="noopener external" target="_blank" href="https://vitalik.ca/general/2017/11/22/starks_part_2.html">FRI</a> (Fast Reed-Solomon Interactive Oracle Proofs of Proximity) needs around 100 kB, more than two orders of magnitude more! This difference is because FRI uses Merkle trees; the verification requires an authentication path, needing several hashes.</p>
<p>One problem we face with circuits is that the verifier should read it, resulting in a linear verification time that depends linearly on the size (which would make it non-succinct). To avoid this, we can preprocess it and attain sublinear verification times.</p>
<p>We will now focus on the KZG polynomial commitment, which is the basis of Marlin and Plonk.</p>
<h2 id="kzg-commitment-scheme">KZG commitment scheme</h2>
<p>The polynomial commitment scheme has the following algorithms:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    1. Setup.</span></span>
<span class="giallo-l"><span>    2. Commit.</span></span>
<span class="giallo-l"><span>    3. Open.</span></span></code></pre>
<p>To commit to a polynomial, we will evaluate the polynomial at a given but unknown point $\alpha$.</p>
<p>The setup takes the maximum degree of the polynomial (which depends on the number of gates of the arithmetic circuit) and outputs the public parameters: proving key and verifying key. To be able to evaluate polynomials, we will use an elliptic curve (we will need it to be <a href="/multiscalar-multiplication-strategies-and-challenges/">pairing friendly</a>, such as BLS 12-377) to hide $\alpha$ and its powers ($\alpha$ is chosen during the setup ceremony and discarded as toxic waste!). To do that, we pick a generator of a group of large prime order $d+1$, $g$ and calculate<br />
$H={g,\alpha g, \alpha^2 g, \alpha^3 g,…, \alpha^{d} g}={h_0,h_1,h_2,…h_{d}}$<br />
This calculation will give us a vast collection of elliptic curve points (we will save them as a string), which will work as the proving key. In the case of a universal setup, the number of elements will coincide with the maximum size of the circuit. Since elliptic curve points take in the order of $100$ B, if we want to deal with $10^{8}$ gates, we will need more than 1 GB to store it. For a given circuit, which could be much smaller than the maximum, MARLIN trims the key so that it is much simpler and faster to work. The setup also depends on a security parameter $\lambda$, but we will consider it to be fixed in our analysis.<br />
We therefore have $\mathrm{setup}(\lambda,N)\rightarrow \mathrm{pp(pk,vk)}$.</p>
<p>The prover generates the polynomial $P(x)=p_0+p_1x+…p_dx^d$ and commits to it by evaluating it at $\alpha$. Since we do not know $\alpha$, only the scalar multiples of group elements of powers of $\alpha$,<br />
$\mathrm{cm}(P)=p_0g+p_1\alpha g+…+p_d\alpha^d g=p_0h_0+p_1h_1+…p_dh_d$<br />
This calculation is the problem of multiscalar multiplication (<a href="/multiscalar-multiplication-strategies-and-challenges/">MSM</a>). We see that the polynomial commitment corresponds to one group element of the elliptic curve.</p>
<p>We could also use a <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle tree</a> to commit to a polynomial. The problem with Merkle trees is that the size of the tree would be dependent on the degree of the polynomial. In the case of KZG, the commitment is just one group element independent of the size. Besides, when we want to evaluate the polynomial in a proof, we need to send all the coefficients in the clear (revealing the polynomial), with the verifier having to do linear work on the size of the polynomial. On the other hand, we will see that KZG mostly hides the polynomial (unless there are lots of queries), and the verification is independent of the degree of the polynomial. Additionally, KZG allows for batch proofs: if we have several commitments $\mathrm{cm}_1$, $\mathrm{cm}_2$, …, $\mathrm{cm}_k$, we can generate a single proof showing that all commitments are valid.</p>
<p>Once the prover commits to the polynomial, the verifier (in an interactive scheme) can send random points $r_k$ to the prover, and the latter gives the polynomial evaluated at $r_k$, $P(r_k)$. To make it non-interactive, we use the Fiat-Shamir transform to generate random challenges from a cryptographic hash function.</p>
<p>Suppose the prover wants to convince the verifier that $P(u)=v$. He can transform that equation into a polynomial, $g(x)=P(x)-v$, which has a root at $x=u$. This fact means that $g(x)$ is divisible by $x-u$, which we can write as $g(x)=P(x)-v=Q(x)(x-u)$, where $Q$ is the quotient polynomial. The prover can commit to $Q(x)$ doing the same as before, that is<br />
$\mathrm{cm}(Q)=q_0g+q_1\alpha d+…+q_{d-1}\alpha^{d-1} g=q_0h_0+q_1h_1+…q_{d-1}h_{d-1}$<br />
which is another MSM. The proof $\pi$ contains this group element: constant size! The proof will show that $P(u)=v$ and $P$ is indeed a polynomial of at most degree $d$ and that the commitment of $P$ is $\mathrm{cm}(P)$.</p>
<p>The verifier accepts the proof if $(\alpha-u)\mathrm{cm}(Q)=\mathrm{cm}(P)-vg$. The problem is that we do not know $\alpha$. This is where <a rel="noopener external" target="_blank" href="https://vitalik.ca/general/2017/01/14/exploring_ecp.html">pairings</a> come to our aid, and we only need the elements $h_0$ and $h_1$ to be able to compute. Roughly speaking, an elliptic curve pairing is a function<br />
$f: \mathcal{G}_1 \times \mathcal{G}_2\rightarrow \mathcal{G}_t$<br />
which takes two elements, $P$ from $\mathcal{G}_1$ and $Q$ from $\mathcal{G}_2$ and outputs an element $R$ from $\mathcal{G}_t$. All the groups have the same order $r$ and correspond to groups in pairing-friendly elliptic curves. In the case of MARLIN, we use the <a href="/multiscalar-multiplication-strategies-and-challenges/">curve BLS 12-377</a>. The pairing satisfies the following:<br />
$f(P,Q)=f(g,g_2)^{pq}$<br />
where $g$ and $g_2$ are generators for the groups $\mathcal{G}_1$ and $\mathcal{G}_2$ (and $P=pg$ and $Q=qg_2$). The form of the verification equation in terms of pairings is<br />
$f(\mathrm{cm}(Q),(\alpha-u)g_2)=f(\mathrm{cm}(P)-vg,g_2)$<br />
We do the check over $\mathcal{G}_t$. We only need to know $\alpha g_2$ from the trusted setup.</p>
<p>How can we be convinced that if we evaluated the polynomials at a single point and they coincide, then it is likely that the argument is true? The answer lies with the <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Schwartz%E2%80%93Zippel_lemma">Schwartz-Zippel lemma</a> (we will state it for finite fields): for a polynomial $P$ of degree $d$ over a finite field of order $p$, the probability that the polynomial is zero at a point sampled at random $r$ is<br />
$\mathrm{Pr}(P(r)=0)=d/p$<br />
Given that the maximum size of circuits (which gives the maximum degree of a polynomial) is around $2^{26}\approx 10^8$ and the size of the field is larger than $2^{256}$, the probability is around $2^{-230}\approx 10^{-70}$. If we say $P_1$ and $P_2$ coincide at one point $r$, we can construct the polynomial $P(x)=P_1(x)-P_2(x)$ (since polynomial addition is closed) and $P(r)=0$. Given how unlikely it is to hit a zero at random, we are confident that $P(x)$ is the zero polynomial.</p>
<h2 id="summary">Summary</h2>
<p>Zk-SNARKs have started gaining attention due to their use in developing fully private applications. They provide succinct proofs that a specific computation was carried out correctly without revealing sensitive information. There are many possible constructions, most based on probabilistic proofs and a commitment scheme. Depending on the different choices, more efficient versions are possible and determine the type of computation (machine or circuit computation). We explored the KZG commitment scheme, which shows the idea behind systems such as MARLIN and Plonk and the calculations we need to generate and verify the proofs.</p>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
