<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deep dive into Cairo&#x27;s AIR and the changes we had to do in Lambdaworks to be compatible with Starknet Stone Prover - LambdaClass Blog</title>
    <meta name="description" content="Deep technical insights on cryptography, distributed systems, zero-knowledge proofs, and cutting-edge software engineering from the LambdaClass team.">

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.lambdaclass.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.lambdaclass.com/atom.xml">

    <!-- Styles -->
    <link rel="stylesheet" href="https://blog.lambdaclass.com/style.css">

    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <nav class="nav-container">
                <a href="https://blog.lambdaclass.com" class="site-logo">
                    <span class="logo-text">LambdaClass</span>
                </a>
                <div class="nav-links">
                    <a href="https://blog.lambdaclass.com" >Home</a>
                    <a href="https://blog.lambdaclass.com/tags" >Topics</a>
                    <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                </div>
            </nav>
        </header>

        <main class="site-main">
            
<article class="page-article">
    <header class="page-header">
        <h1 class="page-title">Deep dive into Cairo&#x27;s AIR and the changes we had to do in Lambdaworks to be compatible with Starknet Stone Prover</h1>
        
        <div class="page-meta">
            <time datetime="2024-01-25">January 25, 2024</time>
        </div>
        
    </header>

    <div class="page-content prose">
        <h2 id="introduction">Introduction</h2>
<p>During the last months, we have been working to make <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks">Lambdaworks</a> STARK Platinum prover with Starknet’s Stone prover. We also want STARK Platinum to be flexible enough to be used as a drop-in replacement for other STARK provers, such as Winterfell (employed as the default prover in Miden). One of the main difficulties is related to how we provide the algebraic intermediate representation (AIR) and constraints in a simple yet expressible way and be able to try and test several trace configuration layouts. In a <a href="/comparing-stark-provers/">previous post</a>, we discussed different design choices for STARK provers, such as using virtual columns, built-ins, and chiplets and their tradeoffs. We would like the prover to be as modular as possible so that we can try different design options, incorporate new tools or fields, and assess performance. One inconvenience with previous approaches was that changes in the AIR or selecting a new layout needed extensive rewriting. Moreover, when using virtual columns, the prover must supply the zerofiers for each constraint, which depends on how the columns are interleaved, making it difficult and error-prone.</p>
<p>In this post, we will cover the new way of implementing transition constraints and AIRs in STARK Platinum, which should give us more freedom to test and move things around, making it more straightforward to add new layouts. We also provide tools to evaluate the zerofiers without the user giving the exact expression. If you are unfamiliar with some of the concepts, you can take a look at our posts on STARKs <a href="/diving-deep-fri/">1</a> and <a href="/comparing-stark-provers/">2</a>.</p>
<h2 id="transition-constraints">Transition constraints</h2>
<p>We define the public trait <code>pub trait TransitionConstraint&lt;F, E&gt;: Send + Sync where F: IsSubFieldOf&lt;E&gt; + IsFFTField + Send + Sync, E: IsField + Send + Sync,</code>, which contains all the methods we need to deal with transition constraints. It is generic over two fields, <code>F</code>, the base field, and <code>E</code>, which could be a field extension of <code>F</code>. If we do not need an extension field, we will simply have <code>E</code> equal to <code>F</code>. The base field should also be an FFT-friendly field, that is, it should contain a multiplicative subgroup of size $2^m$ (for example, $p = 2^{64} - 2^{32} +1$ has a multiplicative group of size $2^{64} - 2^{32}$, which is divisible by $2^{32}$). Below, we list the main methods:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * `fn degree` gives the degree of the transition constraint. All the constraints for the Cairo vm are at most degree 3. The higher the degree of the constraint, the larger the evaluation domain needed to calculate the transition constraints.</span></span>
<span class="giallo-l"><span>    * `fn constraint_idx` gives the constraint identifier, a unique integer between 0 and the total number of transition constraints.</span></span>
<span class="giallo-l"><span>    * `fn evaluate` provides how to evaluate the constraint over the trace&#39;s low-degree extension (LDE). Depending on the constraint, `periodic_values` or `rap_challenges` may be needed. The values are stored in the `transition_evaluations` vector, in the position corresponding to the`constraint_idx`.</span></span>
<span class="giallo-l"><span>    * `fn period` indicates how often a constraint is applied. If the constraint is applied at each step, it is set to $1$. Some constraints may apply every several steps (for example, 16 or 256), which is necessary to evaluate the zerofier correctly.</span></span>
<span class="giallo-l"><span>    * `fn offset` indicates where we start applying the constraint, beginning from the first step. If the constraint applies from the first step, we set it to $0$. If a constraint starts at $1$ and has a period of $16$, this means that the constraint is valid for steps 1, 17, 33, 49, etc. We need this to evaluate the zerofier correctly.</span></span>
<span class="giallo-l"><span>    * `fn end_exemptions` indicates whether the constraint applies to the trace&#39;s last $n$ steps. If it applies to every step, it is set to $0$. If the last two steps do not enforce the constraint, we put it to $2$.</span></span>
<span class="giallo-l"><span>    * `fn exemptions_period` and `fn periodic_exemptions_offset` are necessary to remove several intermediate steps from a constraint. All the exemptions are needed to evaluate the zerofier correctly.</span></span>
<span class="giallo-l"><span>    * Several methods to evaluate the zerofier for the constraint `fn end_exemptions_poly`, `fn zerofier_evaluations_on_extended_domain` and `fn evaluate_zerofier`. The second function is needed to evaluate the composition polynomial, while the third one is required to evaluate at the out-of-domain point, $z$.</span></span></code></pre><h2 id="understanding-exemptions-and-zerofiers">Understanding exemptions and zerofiers</h2>
<h3 id="fibonacci-sequence">Fibonacci sequence</h3>
<p>To fix how exemptions work, let us look at some examples. The easiest to grasp is <code>end_exemptions</code>. These appear, for example, in the case of the calculation of the Fibonacci sequence:<br />
$a_0 = a_1 = 1$<br />
$a_{n + 2} = a_{n + 1} + a_n$<br />
A single trace column can represent this and can be expressed by the following polynomial relationship:<br />
$t(g^2 x) - t(g x) - t(x) = 0$<br />
This constraint is valid for all computation steps except the last two. Remember that we represent each step by a power of $g$, an $n$-th primitive root of unity ($n$ is equal to the trace length). Thus, the zerofier would look like<br />
$$Z_C (x) = \prod_{i = 0}^{ n - 3} (x - g^i ) = \frac{\prod_{i = 0}^{ n - 1} (x - g^i )}{(x - g^{n - 2} )( x - g^{n - 1} )}$$<br />
The zerofier is<br />
$Z (x) = \prod_{i = 0}^{ n - 1} (x - g^i ) = x^n - 1$<br />
while the exemptions are just<br />
$E (x) = (x - g^{n - 2} )( x - g^{n - 1} )$<br />
The combination of both gives the zerofier for the constraint. To represent these constraints, we will have <code>fn end_exemptions</code> return $2$, <code>fn period</code> return $1$, and <code>fn offset</code> yield $0$.</p>
<h3 id="cairo-flags-example">Cairo Flags example</h3>
<p>This example follows the constraints in the virtual column containing all the flags in the Cairo vm. The AIR is provided <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks/blob/87915f06dab3a899d6e967766c0097a89d8d633b/provers/stark/src/examples/bit_flags.rs#L18">here</a>. The column consists of repetitions of 15 binary values, followed by a zero value. There are two transition constraints:<br />
$t (1 - t) = 0$<br />
$t = 0$</p>
<p>The first constraint holds for all values except every 16th value. On the other hand, the second constraint holds only every 16 rows, starting from row 15. Let’s compute the zerofier for the second constraint first:<br />
$Z_C (x) = (x - g^{15} )(x - g^{31} )(x - g^{47} )…$<br />
The number of terms is $n/16$. We can take the $g^{15}$ as common factor and call $y = x/g^{15}$. Thus,<br />
$Z_C (x) = g^{15 n/16} \prod_{j = 0}^{ n/16 - 1} (y - g^{ 16j} )$<br />
Remember that, if $g$ is an $n$-th root of unity, $g^{16}$ is an $n/16$-th root of unity. Since we are multiplying all the $n/16$ roots of unity, we get<br />
$Z_C (y) = g^{15 n/16} (y^{n/16} - 1)$<br />
Distributing and remembering the relationship between $x$ and $y$<br />
$Z_C (x) = x^{n/16} - g^{ 15n/16 }$<br />
This zerofier is compatible with <code>fn offset</code> equal to $15$ and <code>fn period</code> equal to $16$, with no exemptions present.</p>
<p>The zerofier for the first constraint can be calculated by knowing the zerofiers for the whole trace and the zerofier for the zero flag constraint. This is,<br />
$$Z_F (x) = \frac{x^n - 1}{x^{n/16} - g^{ 15n/16 }}$$</p>
<p>The first constraint has <code>fn periodic_exemptions_offset</code> equal to $15$ and <code>fn exemptions_period</code> equal to $16$, essentially computing the same zerofier as the zero flag and taking it from the full trace zerofier.</p>
<h2 id="algebraic-intermediate-representation">Algebraic Intermediate Representation</h2>
<p>We established an AIR trait, which contains all the methods we need to represent the trace, the constraints, and their evaluation.</p>
<p>The method <code>fn trace_layout(&amp;self) -&gt; (usize, usize)</code> provides the number of columns of the main and auxiliary traces (if it exists). The main trace contains elements in the base field (for example, Stark252 or Mini-Goldilocks). In contrast, if needed, the auxiliary trace may have elements from an extension field to achieve cryptographic security.</p>
<p>To evaluate transition constraints, we have the methods <code>fn compute_transition_prover</code>, <code>fn compute_transition_verifier</code>, <code>fn transition_constraints</code> and <code>fn transition_zerofier_evaluations</code>.</p>
<p>The <code>fn transition_zerofier_evaluations</code> has a default implementation. Given that some constraints might share the same zerofier (because they apply at the same steps of the execution trace), we avoid recomputing zerofiers by checking with a <code>zerofier_group_key</code>.</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>fn transition_zerofier_evaluations(</span></span>
<span class="giallo-l"><span>        &amp;self,</span></span>
<span class="giallo-l"><span>        domain: &amp;Domain&lt;Self::Field&gt;,</span></span>
<span class="giallo-l"><span>    ) -&gt; Vec&lt;Vec&lt;FieldElement&lt;Self::Field&gt;&gt;&gt; {</span></span>
<span class="giallo-l"><span>        let mut evals = vec![Vec::new(); self.num_transition_constraints()];</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        let mut zerofier_groups: HashMap&lt;ZerofierGroupKey, Vec&lt;FieldElement&lt;Self::Field&gt;&gt;&gt; =</span></span>
<span class="giallo-l"><span>            HashMap::new();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        self.transition_constraints().iter().for_each(|c| {</span></span>
<span class="giallo-l"><span>            let period = c.period();</span></span>
<span class="giallo-l"><span>            let offset = c.offset();</span></span>
<span class="giallo-l"><span>            let exemptions_period = c.exemptions_period();</span></span>
<span class="giallo-l"><span>            let periodic_exemptions_offset = c.periodic_exemptions_offset();</span></span>
<span class="giallo-l"><span>            let end_exemptions = c.end_exemptions();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>            // This hashmap is used to avoid recomputing with an fft the same zerofier evaluation</span></span>
<span class="giallo-l"><span>            // If there are multiple domains and subdomains they can be further optimized</span></span>
<span class="giallo-l"><span>            // as to share computation between them</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>            let zerofier_group_key = (</span></span>
<span class="giallo-l"><span>                period,</span></span>
<span class="giallo-l"><span>                offset,</span></span>
<span class="giallo-l"><span>                exemptions_period,</span></span>
<span class="giallo-l"><span>                periodic_exemptions_offset,</span></span>
<span class="giallo-l"><span>                end_exemptions,</span></span>
<span class="giallo-l"><span>            );</span></span>
<span class="giallo-l"><span>            zerofier_groups</span></span>
<span class="giallo-l"><span>                .entry(zerofier_group_key)</span></span>
<span class="giallo-l"><span>                .or_insert_with(|| c.zerofier_evaluations_on_extended_domain(domain));</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>            let zerofier_evaluations = zerofier_groups.get(&amp;zerofier_group_key).unwrap();</span></span>
<span class="giallo-l"><span>            evals[c.constraint_idx()] = zerofier_evaluations.clone();</span></span>
<span class="giallo-l"><span>        });</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        evals</span></span>
<span class="giallo-l"><span>    }</span></span></code></pre><h2 id="implementing-the-cairoair">Implementing the CairoAIR</h2>
<p>The implementation of the CairoAIR starts <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks/blob/f271ed876cfa3aa58e36a29e22430eef3703fdc8/provers/cairo/src/air.rs#L535">here</a>. We begin by defining the <code>fn new</code>, which contains the 64 constraints, the transition exemptions and the AIRContext. Since the Stone Prover uses virtual columns, the final number of constraints (counting transition and boundary constraints) will be 46. The main trace has six columns, and the auxiliary trace has 2. The plain layout for one step can be found in the <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks/blob/main/docs/src/starks/stone_prover/trace_plain_layout.md">documentation of our prover</a>.</p>
<p>The implementation of the <code>TransitionConstraint</code> trait for each of the constraints is done <a rel="noopener external" target="_blank" href="https://github.com/lambdaclass/lambdaworks/blob/main/provers/cairo/src/transition_constraints.rs#L8">here</a>. This is the list of transition constraints for the CairoAIR using the plain layout:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>    * BitPrefixFlag0</span></span>
<span class="giallo-l"><span>    * BitPrefixFlag1</span></span>
<span class="giallo-l"><span>    * BitPrefixFlag2</span></span>
<span class="giallo-l"><span>    * BitPrefixFlag3</span></span>
<span class="giallo-l"><span>    * BitPrefixFlag4</span></span>
<span class="giallo-l"><span>    * BitPrefixFlag5</span></span>
<span class="giallo-l"><span>    * BitPrefixFlag6</span></span>
<span class="giallo-l"><span>    * BitPrefixFlag7</span></span>
<span class="giallo-l"><span>    * BitPrefixFlag8</span></span>
<span class="giallo-l"><span>    * BitPrefixFlag9</span></span>
<span class="giallo-l"><span>    * BitPrefixFlag10</span></span>
<span class="giallo-l"><span>    * BitPrefixFlag11</span></span>
<span class="giallo-l"><span>    * BitPrefixFlag12</span></span>
<span class="giallo-l"><span>    * BitPrefixFlag13</span></span>
<span class="giallo-l"><span>    * BitPrefixFlag14</span></span>
<span class="giallo-l"><span>    * ZeroFlagConstraint</span></span>
<span class="giallo-l"><span>    * InstructionUnpacking</span></span>
<span class="giallo-l"><span>    * CpuOperandsMemDstAddr</span></span>
<span class="giallo-l"><span>    * CpuOperandsMem0Addr</span></span>
<span class="giallo-l"><span>    * CpuOperandsMem1Addr</span></span>
<span class="giallo-l"><span>    * CpuUpdateRegistersApUpdate</span></span>
<span class="giallo-l"><span>    * CpuUpdateRegistersFpUpdate</span></span>
<span class="giallo-l"><span>    * CpuUpdateRegistersPcCondPositive</span></span>
<span class="giallo-l"><span>    * CpuUpdateRegistersPcCondNegative</span></span>
<span class="giallo-l"><span>    * CpuUpdateRegistersUpdatePcTmp0</span></span>
<span class="giallo-l"><span>    * CpuUpdateRegistersUpdatePcTmp1</span></span>
<span class="giallo-l"><span>    * CpuOperandsOpsMul</span></span>
<span class="giallo-l"><span>    * CpuOperandsRes</span></span>
<span class="giallo-l"><span>    * CpuOpcodesCallPushFp</span></span>
<span class="giallo-l"><span>    * CpuOpcodesCallPushPc</span></span>
<span class="giallo-l"><span>    * CpuOpcodesAssertEq</span></span>
<span class="giallo-l"><span>    * MemoryDiffIsBit0</span></span>
<span class="giallo-l"><span>    * MemoryDiffIsBit1</span></span>
<span class="giallo-l"><span>    * MemoryDiffIsBit2</span></span>
<span class="giallo-l"><span>    * MemoryDiffIsBit3</span></span>
<span class="giallo-l"><span>    * MemoryDiffIsBit4</span></span>
<span class="giallo-l"><span>    * MemoryIsFunc0</span></span>
<span class="giallo-l"><span>    * MemoryIsFunc1</span></span>
<span class="giallo-l"><span>    * MemoryIsFunc2</span></span>
<span class="giallo-l"><span>    * MemoryIsFunc3</span></span>
<span class="giallo-l"><span>    * MemoryIsFunc4</span></span>
<span class="giallo-l"><span>    * MemoryMultiColumnPermStep0_0</span></span>
<span class="giallo-l"><span>    * MemoryMultiColumnPermStep0_1</span></span>
<span class="giallo-l"><span>    * MemoryMultiColumnPermStep0_2</span></span>
<span class="giallo-l"><span>    * MemoryMultiColumnPermStep0_3</span></span>
<span class="giallo-l"><span>    * MemoryMultiColumnPermStep0_4</span></span>
<span class="giallo-l"><span>    * Rc16DiffIsBit0</span></span>
<span class="giallo-l"><span>    * Rc16DiffIsBit1</span></span>
<span class="giallo-l"><span>    * Rc16DiffIsBit2</span></span>
<span class="giallo-l"><span>    * Rc16DiffIsBit3</span></span>
<span class="giallo-l"><span>    * Rc16PermStep0_0</span></span>
<span class="giallo-l"><span>    * Rc16PermStep0_1</span></span>
<span class="giallo-l"><span>    * Rc16PermStep0_2</span></span>
<span class="giallo-l"><span>    * Rc16PermStep0_3</span></span>
<span class="giallo-l"><span>    * FlagOp1BaseOp0BitConstraint</span></span>
<span class="giallo-l"><span>    * FlagResOp1BitConstraint</span></span>
<span class="giallo-l"><span>    * FlagPcUpdateRegularBit</span></span>
<span class="giallo-l"><span>    * FlagFpUpdateRegularBit</span></span>
<span class="giallo-l"><span>    * CpuOpcodesCallOff0</span></span>
<span class="giallo-l"><span>    * CpuOpcodesCallOff1</span></span>
<span class="giallo-l"><span>    * CpuOpcodesCallFlags</span></span>
<span class="giallo-l"><span>    * CpuOpcodesRetOff0</span></span>
<span class="giallo-l"><span>    * CpuOpcodesRetOff2</span></span>
<span class="giallo-l"><span>    * CpuOpcodesRetFlags</span></span></code></pre>
<p>We will take a look at the implementation for <code>BitPrefixFlag0</code> constraint, which we reproduce below:</p>
<pre class="giallo" style="color: #E1E4E8; background-color: #24292E;"><code data-lang="plain"><span class="giallo-l"><span>impl TransitionConstraint&lt;Stark252PrimeField, Stark252PrimeField&gt; for BitPrefixFlag0 {</span></span>
<span class="giallo-l"><span>    fn degree(&amp;self) -&gt; usize {</span></span>
<span class="giallo-l"><span>        2</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    fn constraint_idx(&amp;self) -&gt; usize {</span></span>
<span class="giallo-l"><span>        0</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    fn evaluate(</span></span>
<span class="giallo-l"><span>        &amp;self,</span></span>
<span class="giallo-l"><span>        frame: &amp;stark_platinum_prover::frame::Frame&lt;Stark252PrimeField, Stark252PrimeField&gt;,</span></span>
<span class="giallo-l"><span>        transition_evaluations: &amp;mut [Felt252],</span></span>
<span class="giallo-l"><span>        _periodic_values: &amp;[Felt252],</span></span>
<span class="giallo-l"><span>        _rap_challenges: &amp;[Felt252],</span></span>
<span class="giallo-l"><span>    ) {</span></span>
<span class="giallo-l"><span>        let current_step = frame.get_evaluation_step(0);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        let constraint_idx = self.constraint_idx();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        let current_flag = current_step.get_main_evaluation_element(0, constraint_idx);</span></span>
<span class="giallo-l"><span>        let next_flag = current_step.get_main_evaluation_element(0, constraint_idx + 1);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        let one = Felt252::one();</span></span>
<span class="giallo-l"><span>        let two = Felt252::from(2);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        let bit = current_flag - two * next_flag;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        let res = bit * (bit - one);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        transition_evaluations[constraint_idx] = res;</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    fn end_exemptions(&amp;self) -&gt; usize {</span></span>
<span class="giallo-l"><span>        0</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>This constraint shows that the variable corresponding to Flag0 is binary, that is, $b \in {0 , 1}$. Mathematically, this condition is expressed as $b (1 - b) = 0$.</p>
<p>First, we define the degree of the constraint. Since the polynomial defining the constraint $b (1 - b) = 0$ is quadratic, the degree function will return $2$. Next, we define the constraint index or identifier, which has to be between 0 and 63. We choose 0 for this constraint (but we could change it if we want the constraints to be in another order, which is convenient if we have to rearrange the constraints for compatibility). In this case, since the variable has to be binary at every execution step, the <code>end_exemptions</code> is simply 0.</p>
<p>We can now jump to the <code>evaluate</code> function for the constraint. To evaluate the constraint, we need the <code>frame</code> (containing the elements from the LDE of the main and auxiliary traces) and <code>transition_evaluations</code>, which we will modify to add the value corresponding to the constraint. Line 17 gets the evaluation frame for the current step, and with the constraint index, we search for the current and next flags (this is an optimization used in the Stone Prover). We get the bit for the flag in line 27 and compute the constraint expression in line 29 (this should be zero if we evaluate it using the values of a valid trace). Finally, we store the value in <code>transition_evaluations</code> at position <code>constraint_idx</code>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this post, we covered the changes introduced in STARK Platinum to deal with transition constraints and AIR definition. This will help us play more easily with different layouts and avoid having the user define the zerofiers by providing explicit expressions. We covered how zerofiers are defined and how constraint evaluations are carried out. We also think the changes will help test other features, such as using smaller fields in Starknet (though this may need further changes).</p>

    </div>
</article>

        </main>

        <footer class="site-footer">
            <div class="footer-container">
                <div class="footer-content">
                    <p class="footer-copyright">&copy; 2026 LambdaClass. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="https://github.com/lambdaclass" target="_blank" rel="noopener">GitHub</a>
                        <a href="https://x.com/class_lambda" target="_blank" rel="noopener">X</a>
                        <a href="https://blog.lambdaclass.com/rss.xml">RSS</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Check for saved preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme) {
            html.setAttribute('data-theme', savedTheme);
        } else if (systemPrefersDark) {
            html.setAttribute('data-theme', 'dark');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });
    </script>
</body>
</html>
